# k倍区间

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240119222621407-17056743842691-17167371817571.png)

 算法核心：该 O(n) 算法的精髓在于，对于前缀和对k取余结果相同的 n 个连续子区间，必定存在 n-1 个余数为0，也就是k的倍数区间。



比如说样例输入5个数，12345.

|   1   |  2   |  3   |  4   |  5   |
| :---: | :--: | :--: | :--: | :--: |
|  12   |  23  |  34  |  45  |      |
|  123  |  24  |  35  |      |      |
| 1234  |  25  |      |      |      |
| 12345 |      |      |      |      |
|   5   |  4   |  3   |  2   |  1   |

一共有15种序列，每一个序列都相加和2取余，如果余数为0（该序列是2的倍数），说明本次操作的序列是一个2的倍数区间。

```c
#include<iostream>
using namespace std;


int main()
{
    long long n, k, ans = 0, son[100000], sum[100000], b[100000] = { 0 };
    cin >> n >> k;
    for (int i = 0; i < n; i++)
    {
        cin >> son[i];
        if (i != 0)
        {
            //计算前缀和 = （上一个前缀和 + 当前处理的数字）% 2（K） 取余结果
            sum[i] = (sum[i - 1] + son[i]) % k;
        }
        else
        {
            //默认，首次求前缀和
            sum[i] = son[i] % k;
        }

        //记录该前缀和出现的次数
        b[sum[i]]++;
        
        //相同的K倍区间 等价于 相同前缀和出现的次数-1 
        ans += b[sum[i]] - 1;

        //有可能说，本次的前缀和 和2（K）取余完事 等于 0，那么它也算一个K倍区间
        if (sum[i] == 0)
        {
            ans++;
        }
   
    }
    cout << ans;
    return 0;
}
```

