# 项目开发框架

什么是开发框架？

- 开发框架可以简单的理解为已封装好的函数和类，是工具的集合。
- 拥有合适的开发框架，可以极大的提升开发效率。
- 在实际项目开发中，程序员都会使用开发框架。

- 在项目开始之前，熟悉开发框架（士兵-武器装备)。

- 重点是掌握开发框架的功能和使用方法，能写出源代码更棒。

- 不完全理解开发框架的功能没有关系，项目开发时将融汇贯通





## 开发框架介绍

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240324113844474-17112515258981.png)



有统一的开发框架吗？

- boost、POCO是底层框架，不能满足应用开发的需求。
- 不同的行业、公司、大佬有不同的开发框架，一人一风格。
- 开发框架是各家的秘笈，不外传，百度不到。

## 字符串操作

:::details 字符串操作函数定义

```c
namespace idc
{
    #pragma region 字符串操作的若干函数 
/*===========删除字符串左边指定的字符==========
      char* str                     //<I/O> 待处理的字符串。
      const int cc=' '              //需要删除的字符，缺省删除空格。
      bool                          //<return> 便于操作返回处理好之后的字符串
*/
char*     deletelchr(char* str, const int cc=' ');
string& deletelchr(string &str, const int cc=' ');
/*===========删除字符串右边指定的字符==========
      char* str                     //<I/O> 待处理的字符串。
      const int cc=' '              // <I> 需要删除的字符，缺省删除空格。
      char*                         //<return> 便于操作返回处理好之后的字符串
*/
char*     deleterchr(char *str,const int cc=' ');
string& deleterchr(string &str,const int cc=' ');
/*===========删除字符串左右两边指定的字符==========
      char* str                     //<I/O> 待处理的字符串。
      const int cc=' '              // <I> 需要删除的字符，缺省删除空格。
      char*                         //<return> 便于操作 返回处理好之后的字符串
*/
char*     deletelrchr(char *str,const int cc=' ');
string& deletelrchr(string &str,const int cc=' ');
/*===========把字符串中的小写字母转换成大写，忽略不是字母的字符。==========
      char *str                 //<I/O> 待转换的字符串。
      char*                     //<O> 便于操作 返回处理好之后的字符串
*/
char*     toupper(char *str);
string& toupper(string &str);
/*===========把字符串中的大写字母转换成小写，忽略不是字母的字符。==========
      char *str                 //<I/O> 待转换的字符串。
      char*                     //<O> 便于操作 返回处理好之后的字符串
*/
char*     tolower(char *str);
string& tolower(string &str);
/*===========在字符串str中，如果存在字符串str1，就替换为字符串str2。==========
    注意：
        1、如果str2比str1要长，替换后str会变长，所以必须保证str有足够的空间，否则内存会溢出（C++风格字符串不存在这个问题）。
        2、如果str2中包含了str1的内容，且bloop为true，这种做法存在逻辑错误，replacestr将什么也不做。
        3、如果str2为空，表示删除str中str1的内容。
      char *str                //<I/O> 待处理的字符串
      const string &str1       //<I>   旧的内容
      const string &str2       //<I>   新的内容
      const bool bloop=false   //<I>   是否循环执行替换
*/
bool replacestr(char *str,const string &str1,const string &str2,const bool bloop=false);
bool replacestr(string &str,const string &str1,const string &str2,const bool bloop=false);
/*===========从一个字符串中提取出数字、符号和小数点，存放到另一个字符串中。==========
    const string &src           //<I> 原字符串。
    char *dest                  //<I> 目标字符串。
    const bool bsigned=false    //<I> 是否提取符号（+和-），true-包括；false-不包括。
    注意：src和dest可以是同一个变量。
*/
char*   picknumber(const string &src,char *dest,const bool bsigned=false,const bool bdot=false);
string& picknumber(const string &src,string &dest,const bool bsigned=false,const bool bdot=false);
string  picknumber(const string &src,const bool bsigned=false,const bool bdot=false);
/*===========正则表达式，判断一个字符串是否匹配另一个字符串。==========
    const string &str       //<I> str：需要判断的字符串，是精确表示的，如文件名"_public.cpp"。
    const string &rules     //<I> rules：匹配规则的表达式，用星号"*"代表任意字符，多个表达式之间用半角的逗号分隔，如"*.h,*.cpp"。
    注意：
        1）str参数不需要支持"*"，rules参数支持"*"；
        2）函数在判断str是否匹配rules的时候，会忽略字母的大小写。
*/
bool matchstr(const string &str,const string &rules);
#pragma endregion
}
```

:::



:::details 字符串操作函数实现

```c
#include "_public.h"  
namespace idc
{	

char *deletelchr(char* str, const int cc)
{
    if (str == nullptr) return nullptr;		
    // 遍历字符串，p将指向左边第一个不是cc的字符  
    char* p = str;				  
    while (*p == cc)			
        p++;		
    memmove(str, p, strlen(str) - (p - str)+1);  //把结尾标志0也拷过来  
    return str;
}
string& deletelchr(string &str, const int cc)
{
     // 从字符串的左边查找第一个不是cc的字符的位置。
    auto pos=str.find_first_not_of(cc); 
    // 把0-pos之间的字符串替换成空。
    if (pos!= 0) str.replace(0,pos,"");       
    return str;
}
char* deleterchr(char *str,const int cc)
{
    if (str == nullptr) return nullptr;	
    char* p = str;			   //指向字符串的首地址。
    char* piscc = 0;		  //右边全是字符cc的第一个位置。
     // 遍历字符串
    while (*p != 0)			  
    {
         // 记下字符cc的第一个位置。
        if (*p == cc && piscc == 0) piscc = p;		 
         // 只要当前字符不是cc，清空piscc。
        if (*p != cc) piscc = 0;						
        p++;		
	  }
	// 把piscc位置的字符置为0，表示字符串已结束。
	if (piscc != 0) *piscc = 0;	
    return str;
}
string& deleterchr(string &str,const int cc)
{
    // 从字符串的右边查找第一个不是cc的字符的位置
    auto pos=str.find_last_not_of(cc);     
    if (pos!= 0) str.erase(pos+1); 	// 把pos之后的字符删掉     
    return str;
}
char* deletelrchr(char *str,const int cc)
{
    deletelchr(str,cc);
    deleterchr(str,cc);
    return str;
}
string& deletelrchr(string &str,const int cc)
{
    deletelchr(str,cc);
    deleterchr(str,cc);
    return str;
}
char* toupper(char *str)
{
    if (str == nullptr) return nullptr;
    char* p = str;	// 指向字符串的首地址,并遍历字符串
    while (*p != 0)			
    {
        if ( (*p >= 'a') && (*p <= 'z') ) *p=*p - 32;
        p++;
    }
    return str;
}
string& toupper(string &str)
{
    for (auto &cc:str)
    {
        if ( (cc >= 'a') && (cc <= 'z') ) cc=cc - 32;
    }
    return str;
}
char* tolower(char *str)
{
    if (str == nullptr) return nullptr;
    char* p = str;	// 指向字符串的首地址，并遍历字符串
    while (*p != 0)		
    {
        if ( (*p >= 'A') && (*p <= 'Z') ) *p=*p + 32;
        p++;
    }
    return str;
}
string& tolower(string &str)
{
    for (auto &cc:str)
    {
        if ( (cc >= 'A') && (cc <= 'Z') ) cc=cc + 32;
    }
    return str;
}
bool replacestr(string &str,const string &str1,const string &str2,bool bloop)
{
    // 如果原字符串str或旧的内容str1为空，没有意义，不执行替换。
    if ((str.length() == 0) || (str1.length() == 0)) 			return false;

    // 如果bloop为true并且str2中包含了str1的内容，直接返回
    //因为会进入死循环，最终导致内存溢出。
    if ( (bloop==true) && (str2.find(str1)!=string::npos) ) 		return false;
    
    int pstart=0;//如果bloop==false，存下一次执行替换的开始位置
    int ppos=0; //存本次需要替换的位置。
    while (true)
    {
        if (bloop == true)
            //每次从字符串的最左边开始查找子串str1。             
            ppos=str.find(str1);
        else
            //从上次执行替换的位置后开始查找子串str1。
            ppos=str.find(str1,pstart);  
        
         // 如果没有找到子串str1。
        if (ppos == string::npos) break;      
		
        // 把str1替换成str2。
        str.replace(ppos,str1.length(),str2);  
 		
        //下一次执行替换的开始位置往右移动。
        if (bloop == false) pstart=ppos+str2.length();   
    }
    return true;
}
bool replacestr(char *str,const string &str1,const string &str2,bool bloop)
{
    if (str == nullptr) return false;
    string strtemp(str);
    replacestr(strtemp,str1,str2,bloop);
   //string的copy函数不会给C风格字符串的结尾加0。
    strtemp.copy(str,strtemp.length());
    str[strtemp.length()]=0;   
    return true;
}
char* picknumber(const string &src,char *dest,const bool bsigned,const bool bdot)
{
    if (dest==nullptr) return nullptr;    
    
    string strtemp=picknumber(src,bsigned,bdot);
    
    // string的copy函数不会给C风格字符串的结尾加0。
    strtemp.copy(dest,strtemp.length());
    dest[strtemp.length()]=0;    
    return dest;
}

string& picknumber(const string &src,string &dest,const bool bsigned,const bool bdot)
{
    // 为了支持src和dest是同一变量的情况，定义str临时变量。
    string str;
    for (char cc:src)
    {
       // 判断是否提取符号。
      if ((bsigned==true) && ((cc == '+') || (cc == '-')))
      {
           str.append(1,cc); continue;
       }
       // 判断是否提取小数点。
       if ( (bdot==true) && (cc == '.') )
       {
           str.append(1,cc); continue;
       }
        // 提取数字。
        if (isdigit(cc)) str.append(1,cc);
    }
    dest=str;
    return dest;
}
string picknumber(const string &src,const bool bsigned,const bool bdot)
{
    string dest;
    picknumber(src,dest,bsigned,bdot);
    return dest;
}

bool matchstr(const string &str,const string &rules)
{
    // 如果匹配规则表达式的内容是空的，返回false。
    if (rules.length() == 0) return false;

    // 如果如果匹配规则表达式的内容是"*"，直接返回true。
    if (rules == "*") return true;

    int ii = 0;
    int jj = 0;
    int pos1 = 0;
    int pos2 = 0;
    ccmdstr cmdstr;
    ccmdstr cmdsubstr;
    string filename=str;
    string matchstr=rules;

    // 把字符串都转换成大写后再来比较
    toupper(filename);
    toupper(matchstr);

    cmdstr.splittocmd(matchstr,",");
    for (ii=0;ii<cmdstr.size();ii++)
    {
        // 如果为空，就一定要跳过，否则就会被匹配上。
        if (cmdstr[ii].empty() == true) continue;

        pos1=pos2=0;
        cmdsubstr.splittocmd(cmdstr[ii],"*");
        for (jj=0;jj<cmdsubstr.size();jj++)
        {
            // 如果是文件名的首部
            if (jj == 0)
                if (filename.substr(0,cmdsubstr[jj].length())!=cmdsubstr[jj]) break;

            // 如果是文件名的尾部
            if (jj == cmdsubstr.size()-1)
                if (filename.find(cmdsubstr[jj],filename.length()-cmdsubstr[jj].length()) == string::npos) break;

            pos2=filename.find(cmdsubstr[jj],pos1);

            if (pos2 == string::npos) break;

            pos1=pos2+cmdsubstr[jj].length();
        }

        if (jj==cmdsubstr.size()) return true;
    }
    return false;
}
}
```

:::



:::details 验证删除字符

```c
/*
 *  程序名：demo10.cpp，此程序演示开发框架中删除字符串左、右、两边指定字符的使用方法。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    char str1[31];        // C风格的字符串
    string str2;          // C++风格的字符串

    if(1) // 删除str1左边的空格
    {
    	strcpy(str1,"  西施  ");
    	deletelchr(str1,' ');  
         // 输出结果是str1=西施  =    
    	printf("str1=%s=\n",str1);  
        
        str2="  西施  ";
    	deletelchr(str2,' ');
   		cout << "str2=" << str2 << "=\n";   
    }
    
    if(1) // 删除str1左边的空格
    {	
        strcpy(str1,"  西施  ");
        deleterchr(str1,' ');        
   		// 输出结果是str1=西施  =
        printf("str1=%s=\n",str1);   
        
        str2="  西施  ";
        deleterchr(str2,' ');
        cout << "str2=" << str2 << "=\n";
    }
    
    if(1)  // 删除str1两边的空格
    {
        strcpy(str1,"  西施  ");
        deletelrchr(str1,' ');       
        // 输出结果是str1=西施=
        printf("str1=%s=\n",str1);  
        
        str2="  西施  ";
        deletelrchr(str2,' ');
        cout << "str2=" << str2 << "=\n";
    }
}
```

```shell
[root@localhost demo]# g++ -o demo10 demo10.cpp ../_public.cpp  
[root@localhost demo]# ./demo10
str1=西施  =
str2=西施  =
str1=  西施=
str2=  西施=
str1=西施=
str2=西施=
[root@localhost demo]# 
```

:::



:::details 验证替换字符串中字符

```c
/*
 *  程序名：demo14.cpp，此程序演示开发框架中字符串替换replacestr函数的使用。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    char str1[301] = {0};

    if(1)      // 把冒号替换成等号
    {
    	strcpy(str1,"name:messi,no:10,job:striker.");
    	replacestr(str1,":","=");     
    	// 输出结果是 str1=name=messi,no=10,job=striker.=
    	printf("str1=%s=\n",str1);      
    }
     
    if(1)  // 把"name:"替换成""，相当于删除内容"name:"
    {
   	 	strcpy(str1,"name:messi,no:10,job:striker.");     
		replacestr(str1,"name:",""); 
        //输出结果是str1=messi,no:10,job:striker.=
    	printf("str1=%s=\n",str1);   
    }
   	
    if(1)  //把两个"--"替换成一个"-"，bloop参数为false
    {
     
      strcpy(str1,"messi----10----striker");  
      replacestr(str1,"--","-",false);
      //输出结果是:str1=messi--10--striker=
      printf("str1=%s=\n",str1);
    }
    
    if(1) //把两个"--"替换成一个"-"，bloop参数为true。 
    {
      strcpy(str1,"messi----10----striker"); 
      replacestr(str1,"--","-",true);
      //输出结果是str1=messi-10-striker=
      printf("str1=%s=\n",str1);   
    }
    
    if(1) // 把一个"-"替换成两个"--"，bLoop参数为false。
    {
       strcpy(str1,"messi-10-striker");        
       replacestr(str1,"-","--",false);  
       // 输出结果是str1=messi--10--striker=
       printf("str1=%s=\n",str1);        
     }  
    
     if(1) // 以下代码把"-"替换成"--"，bloop参数为true，存在逻辑错误，replacestr将不执行替换。
     {
        strcpy(str1,"messi-10-striker");   
        replacestr(str1,"-","--",true);
         // 输出结果是str1=messi-10-striker=
        printf("str1=%s=\n",str1); 
     }
    
    if(1)
    {
        string str2;
        str2="name:messi,no:10,job:striker.";
        replacestr(str2,":","=");  // 把冒号替换成等号。
        // 输出结果是str2=name=messi,no=10,job=striker.=
        cout << "str2=" << str2 << "=\n";  
    }
    
    if(1) // 把冒号替换成等号。
    {
        string str2;
        str2="name:messi,no:10,job:striker.";
        replacestr(str2,":","="); 
        // 输出结果是str2=name=messi,no=10,job=striker.=
        cout << "str2=" << str2 << "=\n";    
    }
	
  	if(1)
    {
    	str2="name:messi,no:10,job:striker.";  
        replacestr(str2,"name:","");  
        // 输出结果是str2=messi,no:10,job:striker.=
        cout << "str2=" << str2 << "=\n";     
    }
 	
    if(1)    // 把两个"--"替换成一个"-"，bLoop参数为false。
    {
       str2="messi----10----striker"; 
       replacestr(str2,"--","-",false); 
       // 输出结果是str2=messi--10--striker=
       cout << "str2=" << str2 << "=\n";     
    }
   
	if(1)  // 把两个"--"替换成一个"-"，bLoop参数为true。
    {
       str2="messi----10----striker";
       replacestr(str2,"--","-",true);
       //输出结果是str2=messi-10-striker=
       cout << "str2=" << str2 << "=\n";     
    }
    
    if(1)
    {
        str2="messi----10----striker"; 
        replacestr(str2,"--","-",true);
        // 输出结果是str2=messi-10-striker=
        cout << "str2=" << str2 << "=\n";     
    }
    
    if(1) // 把两个"--"替换成一个"-"，bLoop参数为true。
    {
    	str2="messi----10----striker";   
        replacestr(str2,"--","-",true); 
        //输出结果是str2=messi-10-striker=
        cout << "str2=" << str2 << "=\n";
    }
 
	if(1) // 把一个"-"替换成两个"--"，bLoop参数为false。
    {
    	str2="messi-10-striker"; 
        replacestr(str2,"-","--",false);
        // 输出结果是str2=messi--10--striker=
        cout << "str2=" << str2 << "=\n";     
    }
	
    if(1)// 以下代码把"-"替换成"--"，bloop参数为true，存在逻辑错误，replacestr将不执行替换。
    { 
        str2="messi-10-striker";  
        replacestr(str2,"-","--",true);  
        // 输出结果是str2=messi-10-striker=
        cout << "str2=" << str2 << "=\n";  
    }  
}
```

:::



:::details 验证解析出字符串的数字

```cpp
/*
 *  程序名：demo16.cpp，此程序演示开发框架中picknumber函数的使用。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    char str1[30] = {0};   
    string str2;
    
    if(1)
    {
    	strcpy(str1,"iab+12.3xy");    
    	picknumber(str1,str1,false,false);
         // 输出结果是str1=123= 
    	printf("str1=%s=\n",str1); 
        
        str2="iab+12.3xy"; 
        picknumber(str2,str2,false,false);
        // 输出结果是str2=123=
        cout << "str2=" << str2 << "=\n"; 
    }  
    if(1)
    {
    	strcpy(str1,"iab+12.3xy");
    	picknumber(str1,str1,true,false);
        // 输出结果是str1=+123=
        printf("str1=%s=\n",str1); 
        
        str2="iab+12.3xy";
        picknumber(str2,str2,true,false);
        // 输出结果是str2=+123=
        cout << "str2=" << str2 << "=\n";  
    } 
    if(1)
    {
        strcpy(str1,"iab+12.3xy");
        picknumber(str1,str1,true,true);
         // 输出结果是str1=+12.3=
        printf("str1=%s=\n",str1);
        
        str2="iab+12.3xy";
    	picknumber(str2,str2,true,true);
        // 输出结果是str2=+12.3=
    	cout << "str2=" << str2 << "=\n";  
    }
}
```

:::



:::details 验证正则匹配函数

```cpp
/*
 *  程序名：demo18.cpp，此程序演示开发框架正则表达示MatchStr函数的使用。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;
int main()
{
    if(1)   // 以下代码将输出yes。
     {
        if (matchstr("_public.h","*.h,*.cpp")) 				 		printf("yes\n");
        else 
           printf("no\n");  
    }
    if(1)   // 以下代码将输出yes。
    {
        if (matchstr("_public.h","*.H")) 
            printf("yes\n");
        else
            printf("no\n");     
    }  
    if(1)   // 以下代码将输出no。
    {
        if (matchstr("_public.h","*p*k*.h"))
            printf("yes\n");
        else
            printf("no\n");
    }
}
```

:::



提升代码能力

- 用demo程序测试函数的功能，掌握使用方法。
- 除了matchstr函数，把其它的函数写出来。
- 如果这些函数的代码写不出来，代码能力达不到实战要求。



## 字符串转数组

:::details ccmdstr类抽象定义

```c
#pragma region ccmdstr类用于拆分有分隔符的字符串

/*================= ccmdstr类用于拆分有分隔符的字符串================
    字符串的格式为：字段内容1+分隔符+字段内容2+分隔符+字段内容3+分隔符+...+字段内容n。
    例如："messi,10,striker,30,1.72,68.5,Barcelona"，这是足球运动员梅西的资料。
    包括：姓名、球衣号码、场上位置、年龄、身高、体重和效力的俱乐部，字段之间用半角的逗号分隔的格式字符串，
    针对这种字符串，提供了一个ccmdstr类，完成解析分割值的工作。
*/
class ccmdstr; 
class ccmdstr
{
private:
    vector<string> m_cmdstr;  // 存放拆分后的字段内容
    //构造/析构
public:
    ccmdstr()  { } 
     ~ccmdstr(); 
    ccmdstr(const string &buffer,const string &sepstr,const bool bdelspace=false);
private:   
    //禁用拷贝构造函数和赋值函数
    ccmdstr(const ccmdstr &) = delete; 
    ccmdstr &operator=(const ccmdstr &) = delete;
    //行为方法
 public:   
    /*===========重载[]运算符，可以像访问数组一样访问m_cmdstr成员==========
        int ii        // <I> 访问的下标索引
    */ 
    const string& operator[](int ii) const    
    {
        return m_cmdstr[ii];
    }
    /*===========把字符串拆分到m_cmdstr容器中==========
        const string &buffer        // <I> 待拆分的字符串
        const string &sepstr        // <I> buffer中采用的分隔符，注意，sepstr参数的数据类型不是字符，是字符串，如","、" "、"|"、"~!~"。
        ,const bool bdelspace=false // <I> 拆分后是否删除字段内容前后的空格，true-删除；false-不删除，缺省不删除。
    */
    void splittocmd(const string &buffer,const string &sepstr,const bool bdelspace=false);
    /*===========获取拆分后字段的个数，即m_cmdstr容器的大小==========
     
    */
    int size() const { return m_cmdstr.size(); }
    /*===========兼容以前的项目==========
    */
    int cmdcount() const { return m_cmdstr.size(); }     
    /*===========从m_cmdstr容器获取字段内容==========
        int ii         //<I> 访问的下标索引
        T &value        //<I> 传入变量的地址，用于存放字段内容。 
        const int ilen=0 //<I> 预计字符串长度,缺省值为0-全部长度。
        返回值：true-成功；如果ii的取值超出了m_cmdstr容器的大小，返回失败。
    */ 
    bool getvalue(const int ii,string &value,const int ilen=0) const;      // C++风格字符串。视频中没有第三个参数，加上第三个参数更好。
    bool getvalue(const int ii,char *value,const int ilen=0) const;          // C风格字符串，ilen缺省值为0-全部长度。 
    bool getvalue(const int ii,int  &value) const;                                    // int整数。
    bool getvalue(const int ii,unsigned int &value) const;                     // unsigned int整数。
    bool getvalue(const int ii,long &value) const;                                  // long整数。
    bool getvalue(const int ii,unsigned long &value) const;                  // unsigned long整数。
    bool getvalue(const int ii,double &value) const;                              // 双精度double。
    bool getvalue(const int ii,float &value) const;                                  // 单精度float。
    bool getvalue(const int ii,bool &value) const;                                  // bool型。  
};

// 重载<<运算符，输出ccmdstr::m_cmdstr中的内容，方便调试。
ostream& operator<<(ostream& out, const ccmdstr& cc);
#pragma endregion
```

::: 



:::details `ccmdstr` 类实现

```c
ccmdstr::ccmdstr(const string &buffer,const string &sepstr,const bool bdelspace)
{
    splittocmd(buffer,sepstr,bdelspace);
}
void ccmdstr::splittocmd(const string &buffer,const string &sepstr,const bool bdelspace)
{
    // 清除所有的旧数据
    m_cmdstr.clear();
    int pos=0;        // 每次从buffer中查找分隔符的起始位置。
    int pos1=0;      // 从pos的位置开始，查找下一个分隔符的位置。
    string substr;   // 存放每次拆分出来的子串。

    // 从pos的位置开始，查找下一个分隔符的位置。 
    while ( (pos1=buffer.find(sepstr,pos)) != string::npos)   
    {
         // 从buffer中截取子串
        substr=buffer.substr(pos,pos1-pos);           
        if (bdelspace == true) deletelrchr(substr);   // 删除子串前后的空格

        // 把子串放入m_cmdstr容器中，调用string类的移动构造函数
        m_cmdstr.push_back(std::move(substr));     

        // 下次从buffer中查找分隔符的起始位置后移
        pos=pos1+sepstr.length();                         
    }
    // 处理最后一个字段（最后一个分隔符之后的内容）
    substr=buffer.substr(pos);
    if (bdelspace == true) deletelrchr(substr);
    m_cmdstr.push_back(std::move(substr));
    return;
}
bool ccmdstr::getvalue(const int ii,string &value,const int ilen) const
{
    if(ii < 0) return false;
    if (ii>=m_cmdstr.size()) return false;
	
    //实现截取读取到字符拆分字符串内容子串的效果
    int itmplen=m_cmdstr[ii].length();
    if ((ilen>0)&&(ilen<itmplen) ) itmplen=ilen;
    value=m_cmdstr[ii].substr(0,itmplen);
    return true;
}
bool ccmdstr::getvalue(const int ii,char *value,const int len) const
{
      if(ii<0) return false; 
      if((ii>=m_cmdstr.size())) return false;
      if (value==nullptr) return false;

    //调用者必须保证value的空间足够，否则这里会内存溢出
    if (len>0) memset(value,0,len+1);   

    if ( (m_cmdstr[ii].length()<=(unsigned int)len) || (len==0) )
    {
        m_cmdstr[ii].copy(value,m_cmdstr[ii].length());
        value[m_cmdstr[ii].length()]=0;    // string的copy函数不会给C风格字符串的结尾加0,这里手动加上
    }
    else
    {
        m_cmdstr[ii].copy(value,len);
        value[len]=0;
    }
    return true;
}
bool ccmdstr::getvalue(const int ii,int &value) const
{
    if(ii < 0) return false; 
    if (ii>=m_cmdstr.size()) return false;
    try
    {
        value = stoi(picknumber(m_cmdstr[ii],true)); 
    }
    catch(const std::exception& e)
    {
         // stoi有异常，需要处理异常。
        return false;
    }
    return true;
}
bool ccmdstr::getvalue(const int ii,unsigned int &value) const
{
    if (ii>=m_cmdstr.size()) return false;
    try
    {
       value = stoi(picknumber(m_cmdstr[ii]));  
    }
    catch(const std::exception& e)
    {
        // stoi有异常，需要处理异常。不提取符号 + -
        return false;
    }

    return true;
}
bool ccmdstr::getvalue(const int ii,long &value) const
{
    if (ii>=m_cmdstr.size()) return false;

    try
    {
        value = stol(picknumber(m_cmdstr[ii],true)); 
    }
    catch(const std::exception& e)
    {
        // stol有异常，需要处理异常。
        return false;
    }

    return true;
}
bool ccmdstr::getvalue(const int ii,unsigned long &value) const
{
    if (ii>=m_cmdstr.size()) return false;

    try
    {
        value = stoul(picknumber(m_cmdstr[ii])); 
    }
    catch(const std::exception& e)
    {
         // stoul有异常，需要处理异常。不提取符号 + -
        return false;
    }

    return true;
}
bool ccmdstr::getvalue(const int ii,double &value) const
{
    if (ii>=m_cmdstr.size()) return false;

    try
    {
        value = stod(picknumber(m_cmdstr[ii],true,true)); 
    }
    catch(const std::exception& e)
    {
        // stod有异常，需要处理异常。提取符号和小数点。
        return false;
    }

    return true;
}
bool ccmdstr::getvalue(const int ii,float &value) const
{
    if (ii>=m_cmdstr.size()) return false;

    try
    {
        value = stof(picknumber(m_cmdstr[ii],true,true)); 
    }
    catch(const std::exception& e)
    {
        // stof有异常，需要处理异常。提取符号和小数点。
        return false;
    }

    return true;
}
bool ccmdstr::getvalue(const int ii,bool &value) const
{
    if (ii>=m_cmdstr.size()) return false;

    string str=m_cmdstr[ii];
    toupper(str);     // 转换为大写来判断。

    if (str=="TRUE") value=true; 
    else value=false;
    return true;
}
ccmdstr::~ccmdstr()
{
    m_cmdstr.clear();
}
ostream& operator<<(ostream& out, const ccmdstr& cmdstr)
{
    for (int ii=0;ii<cmdstr.size();ii++)
        out << "[" << ii << "]=" << cmdstr[ii] << endl;
    return out;
}
```

:::



:::details 拆分字符串`ccmdstr`类的使用

```c
/*
 *  程序名：demo20.cpp，此程序演示开发框架拆分字符串ccmdstr类的使用。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;
struct st_player
{
    char name[51];    // 姓名
    char no[6];      // 球衣号码
    bool striker;    // 场上位置是否是前锋，true-是；false-不是。
    int  age;        // 年龄
    double weight;   // 体重，kg。
    long sal;        // 年薪，欧元。
    char club[51];   // 效力的俱乐部
}stplayer; // 用于存放足球运动员资料的结构体
int main()
{
    memset(&stplayer,0,sizeof(struct st_player));
    string buffer="messi~!~10~!~true~!~a30~!~68.5~!~2100000~!~Barc,elona";   
    //定义拆分字符串的对象并拆分字符串   
    //方法1：有参构造 
    ccmdstr cmdstr(buffer,"~!~"); 
    //方法2:无参构造+splittocmd方法
    //ccmdstr cmdstr;   
    //cmdstr.splittocmd(buffer,"~!~");  
    //像访问数组一样访问拆分后的元素
    for (int ii=0;ii<cmdstr.size();ii++)
    {
        cout << "cmdstr["<<ii<<"]=" << cmdstr[ii] << endl;
    }
    // 输出拆分后的元素，一般用于调试
    cout << cmdstr;
    // 获取拆分后元素的内容
    cmdstr.getvalue(0, stplayer.name,50); // 获取姓名
    cmdstr.getvalue(1, stplayer.no,5); // 获取球衣号码
    cmdstr.getvalue(2, stplayer.striker); // 场上位置
    cmdstr.getvalue(3, stplayer.age); // 获取年龄
    cmdstr.getvalue(4, stplayer.weight); // 获取体重
    cmdstr.getvalue(5, stplayer.sal); // 获取年薪，欧元。
    cmdstr.getvalue(6, stplayer.club,50); // 获取效力的俱乐部
   printf("name=%s,no=%s,striker=%d,age=%d,weight=%.1f,sal=%ld,club=%s\n",\       stplayer.name,stplayer.no,stplayer.striker,stplayer.age,\
               stplayer.weight,stplayer.sal,stplayer.club);
    // 输出结果:name=messi,no=10,striker=1,age=30,weight=68.5,sal=21000000,club=Barcelona
}

```

:::

## 解析XML

:::details 解析xml格式字符串的函数族抽象 `getxmlbuffer()`

```c
#pragma region 解析xml格式字符串的函数族
/*===========解析xml格式字符串的函数==========
    xml格式的字符串的内容如下：
        <filename>/tmp/_public.h</filename><mtime>2020-01-01 12:20:35</mtime><size>18348</size>
        <filename>/tmp/_public.cpp</filename><mtime>2020-01-01 10:10:15</mtime><size>50945</size> 
    const string &xmlbuffer  //<I> 待解析的xml格式字符串
    const string &fieldname  //<I> 字段的标签名
    T  value                 //<I> 传入变量的地址，用于存放字段内容，支持bool、int、insigned int、long、unsigned long、double和char[]。
    const int ilen=0         //<I> 注意：当value参数的数据类型为char []时，必须保证value数组的内存足够，否则可能发生内存溢出的问题.
    bool                     //<I> true-成功；如果fieldname参数指定的标签名不存在，返回失败。
*/
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,string &value,const int ilen=0);   
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,char *value,const int ilen=0);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,bool &value);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,int  &value);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,unsigned int &value);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,long &value);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,unsigned long &value);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,double &value);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,float &value);
#pragma endregion 
```

:::



::: details `getxmlbuffer()` 实现

```c
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,string  &value,const int ilen)
{
    string start="<"+fieldname+">";            // 数据项开始的标签
    string end="</"+fieldname+">";            // 数据项结束的标签

    // 在xml中查找数据项开始的标签的位置。  
    int startp=xmlbuffer.find(start);               
    if (startp==string::npos) return false;

    // 在xml中查找数据项结束的标签的位置。
    int endp=xmlbuffer.find(end);             
    if (endp==string::npos) return false;

    // 从xml中截取数据项的内容
    int itmplen=endp-startp-start.length();
    if ( (ilen>0) && (ilen<itmplen) ) itmplen=ilen;
    value=xmlbuffer.substr(startp+start.length(),itmplen);
    return true;
}
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,char *value,const int len)
{
    if (value==nullptr) return false;
    // 调用者必须保证value的空间足够，否则这里会内存溢出。
    if (len>0) memset(value,0,len+1);   
    string str;
    getxmlbuffer(xmlbuffer,fieldname,str);
    if ((str.length()<=(unsigned int)len) || (len==0) )
    {
        str.copy(value,str.length());
        value[str.length()]=0;    // string的copy函数不会给C风格字符串的结尾加0。
    }
    else
    {
        str.copy(value,len);
        value[len]=0;
    }
    return true;
}
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,bool &value)
{
    string str;
    if (getxmlbuffer(xmlbuffer,fieldname,str)==false) return false;
    toupper(str);    // 转换为大写来判断（也可以转换为小写，效果相同）。
    if (str=="TRUE") value=true; 
    else value=false;
    return true;
}
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,int &value)
{
    string str;
    if (getxmlbuffer(xmlbuffer,fieldname,str)==false) return false;
    try
    {
       value = stoi(picknumber(str,true));  
    }
    catch(const std::exception& e)
    {
        return false; // stoi有异常，需要处理异常。
    }
    return true;
}
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,unsigned int &value)
{
    string str;
    if (getxmlbuffer(xmlbuffer,fieldname,str)==false) return false;
    try
    {
       value = stoi(picknumber(str));  
    }
    catch(const std::exception& e)
    {
        return false; // stoi有异常，需要处理异常。不提取符号 + -
    }
    return true;
}
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,long &value)
{
    string str;
    if (getxmlbuffer(xmlbuffer,fieldname,str)==false) return false;
    try
    {
        value = stol(picknumber(str,true));  // stol有异常，需要处理异常。
    }
    catch(const std::exception& e)
    {
        return false;
    }
    return true;
}
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,unsigned long &value)
{
    string str;
    if (getxmlbuffer(xmlbuffer,fieldname,str)==false) return false;
    try
    {
        value = stoul(picknumber(str));  // stoul有异常，需要处理异常。不提取符号 + -
    }
    catch(const std::exception& e)
    {
        return false;
    }
    return true;
}
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,double &value)
{
    string str;
    if (getxmlbuffer(xmlbuffer,fieldname,str)==false) return false;
    try
    {
        value = stod(picknumber(str,true,true)); 
    }
    catch(const std::exception& e)
    {
        return false; // stod有异常，需要处理异常。提取符号和小数点。
    }

    return true;
}
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,float &value)
{
    string str;
    if (getxmlbuffer(xmlbuffer,fieldname,str)==false) return false;
    try
    {
        value = stof(picknumber(str,true,true));  
    }
    catch(const std::exception& e)
    {
        return false;// stof有异常，需要处理异常。提取符号和小数点。
    }
    return true;
}
```



:::





:::details getxmlbuffer函数解析xml字符串

```c
/*
 *  程序名：demo22.cpp，此程序演示调用开发框架的getxmlbuffer函数解析xml字符串。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;
int main()
{
    // 球员梅西的资料存放在xml中。
    string buffer="<name>梅西</name><no>10</no><striker>true</striker><age>30</age><weight>68.5</weight><sal>21000000</sal><club>Barcelona</club>";

    // 用于存放足球运动员资料的结构体。
    struct st_player
    {
        string name;      // 姓名
        char no[6];       // 球衣号码
        bool striker;     // 场上位置是否是前锋，true-是；false-不是。
        int  age;         // 年龄
        double weight;    // 体重，kg。
        long sal;         // 年薪，欧元。
        char club[51];    // 效力的俱乐部
    }stplayer;

    getxmlbuffer(buffer,"name",stplayer.name);
    cout << "name=" << stplayer.name << endl;
    getxmlbuffer(buffer,"no",stplayer.no,5);
    cout << "no=" << stplayer.no << endl;
    getxmlbuffer(buffer,"striker",stplayer.striker);
    cout << "striker=" << stplayer.striker << endl;
    getxmlbuffer(buffer,"age",stplayer.age);
    cout << "age=" << stplayer.age << endl;
    getxmlbuffer(buffer,"weight",stplayer.weight);
    cout << "weight=" << stplayer.weight << endl;
    getxmlbuffer(buffer,"sal",stplayer.sal);
    cout << "sal=" << stplayer.sal << endl;
    getxmlbuffer(buffer,"club",stplayer.club,50);
    cout << "club=" << stplayer.club << endl;
}
```

```shell
[root@localhost demo]# ./demo22
name=梅西
no=10
striker=1
age=30
weight=68.5
sal=21000000
club=Barcelona
```

:::

## 格式输出C++字符串

:::details  格式输出C++字符串 模板抽象

```c
#pragma region C++格式化输出函数模板
template< typename... Args >
bool sformat(string &str,const char* fmt, Args... args ) 
{
     // 得到格式化输出后字符串的总长度。
    int len = snprintf( nullptr, 0, fmt, args... );     
    if (len < 0) return false;                                  // 如果调用snprintf失败，返回-1。

    if (len == 0) { str.clear(); return true; }            // 如果调用snprintf返回0，表示格式化输出的内容为空。
    str.resize(len);                                                 // 为string分配内存。
    snprintf(&str[0], len + 1, fmt, args... );           // linux平台第二个参数是len+1，windows平台是len。
    return true;
}

template< typename... Args >
string sformat(const char* fmt, Args... args ) 
{
    string str;

    int len = snprintf( nullptr, 0, fmt, args... );      // 得到格式化后字符串的长度。
    if (len < 0) return str;              // 如果调用snprintf失败，返回-1。
    if (len == 0) return str;           // 如果调用snprintf返回0，表示格式化输出的内容为空。;

    str.resize(len);                                                // 为string分配内存。
    snprintf(&str[0], len + 1, fmt, args... );          // linux平台第二个参数是len+1，windows平台是len。
    return str;
}
#pragma endregion 
```

:::



:::details 格式化输出sformat函数使用

```c
/*
 *  程序名：demo23.cpp，此程序演示调用开发框架的格式化输出sformat函数。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;
int main()
{
    int bh=1;
    char name[31]; strcpy(name,"西施");
    double weight=48.2;
    string yz="漂亮";

    char s1[100];
    int len=snprintf(s1,100,"编号=%02d,姓名=%s,体重=%.2f,颜值=%s",bh,name,weight,yz.c_str());
    cout << "s1=" << s1 << endl;
    printf("len=%d\n",len);
    printf("strlen(s1)=%d\n",strlen(s1));

    string s2;
    s2="编号="+to_string(bh)+",姓名="+name+",体重="+to_string(weight)+",颜值="+yz;
    cout << "s2=" << s2 << endl;

    s2=sformat("编号=%02d,姓名=%s,体重=%.2f,颜值=%s",bh,name,weight,yz.c_str());
    cout << "s2=" << s2 << endl;

    sformat(s2,"编号=%02d,姓名=%s,体重=%.2f,颜值=%s",bh,name,weight,yz.c_str());
    cout << "s2=" << s2 << endl;
}
```

```shell
[root@localhost demo]# ./demo23
s1=编号=01,姓名=西施,体重=48.20,颜值=漂亮
len=50
strlen(s1)=50
s2=编号=1,姓名=西施,体重=48.200000,颜值=漂亮
s2=编号=01,姓名=西施,体重=48.20,颜值=漂亮
s2=编号=01,姓名=西施,体重=48.20,颜值=漂亮
[root@localhost demo]# 
```

:::

## 时间操作

- C++11提供了chrono模版库，实现了时间相关的操作。
- chrono模版库不够方便，不能满足开发的需求，还需要封装。
- 对原生的时间操作函数进行了封装。



:::details 时间操作的若干函数和类抽象定义

```c
#pragma region 时间操作的若干函数

/*================= 取操作系统的时间（用字符串表示）==========================
         string &strtime //<O> 用于存放获取到的时间
         const string &fmt="" //<I> 输出时间的格式 fmt每部分的含义：yyyy-年份；mm-月份；dd-日期；hh24-小时；mi-分钟；ss-秒
                                    缺省是"yyyy-mm-dd hh24:mi:ss"，目前支持以下格式：
                                    "yyyy-mm-dd hh24:mi:ss"
                                    "yyyymmddhh24miss"
                                    "yyyy-mm-dd"
                                    "yyyymmdd"
                                    "hh24:mi:ss"
                                    "hh24miss"
                                    "hh24:mi"
                                    "hh24mi"
                                    "hh24"
                                    "mi"
        注意：
             1）小时的表示方法是hh24，不是hh，这么做的目的是为了保持与数据库的时间表示方法一致；
             2）以上列出了常用的时间格式，如果不能满足你应用开发的需求，请修改源代码timetostr()函数增加更多的格式支持；
             3）调用函数的时候，如果fmt与上述格式都匹配，strtime的内容将为空。
              4）时间的年份是四位，其它的可能是一位和两位，如果不足两位，在前面补0。
        const int timetvl=0     //<I>  时间的偏移量，单位：秒，0是缺省值，表示当前时间，30表示当前时间30秒之后的时间点，-30表示当前时间30秒之前的时间点。
*/
string& ltime(string &strtime,const string &fmt="",const int timetvl=0);
char *  ltime(char *strtime   ,const string &fmt="",const int timetvl=0);
string  ltime1(const string &fmt="",const int timetvl=0); // 为了避免重载的岐义，增加ltime1()函数。
/*================= 把整数表示的时间转换为字符串表示的时间）==========================
        const time_t ttime      //<I> 整数表示的时间
        string &strtime         //<I> 字符串表示的时间
        const string &fmt=""    //<I>  输出字符串时间strtime的格式，与ltime()函数的fmt参数相同，如果fmt的格式不正确，strtime将为空。
*/
string& timetostr(const time_t ttime,string &strtime,const string &fmt="");
char*   timetostr(const time_t ttime,char *strtime   ,const string &fmt="");
string  timetostr1(const time_t ttime,const string &fmt=""); // 为了避免重载的岐义，增加timetostr1()函数。
/*================= 把字符串表示的时间转换为整数表示的时间==========================
       const string &strtime       //<I> 字符串表示的时间，格式不限，但一定要包括yyyymmddhh24miss，一个都不能少，顺序也不能变。
       time_t                      //<O> 返回值：整数表示的时间，如果strtime的格式不正确，返回-1。
*/
time_t strtotime(const string &strtime);
/*================= 把字符串表示的时间加上一个偏移的秒数后得到一个新的字符串表示的时间==========================
        const string &in_stime      //<I> 输入的字符串格式的时间，格式不限，但一定要包括yyyymmddhh24miss，一个都不能少，顺序也不能变。
        char *out_stime             //<I> 输出的字符串格式的时间。
        const int timetvl           //<I> 需要偏移的秒数，正数往后偏移，负数往前偏移。
        const string &fmt=""        //<I> 输出字符串时间out_stime的格式，与ltime()函数的fmt参数相同。
        注意：in_stime和out_stime参数可以是同一个变量的地址，如果调用失败，out_stime的内容会清空。
        bool                        //<return> true-成功，false-失败，如果返回失败，可以认为是in_stime的格式不正确。
*/
bool addtime(const string &in_stime,char *out_stime,const int timetvl,const string &fmt="");
bool addtime(const string &in_stime,string &out_stime,const int timetvl,const string &fmt="");


class ctimer;// 这是一个精确到微秒的计时器。

class ctimer
{
private:
    struct timeval m_start;    // 计时开始的时间点。
    struct timeval m_end;     // 计时结束的时间点。

public:
// 构造函数中会调用start方法。
    ctimer();          
 public:
    
    //开始计时。
    void start();     

    // 计算已逝去的时间，单位：秒，小数点后面是微秒。
    // 每调用一次本方法之后，自动调用start方法重新开始计时。
    double elapsed();

};
#pragma endregion
```

:::



:::details 时间操作的若干函数和类实现

```c
string& timetostr(const time_t ttime,string &strtime,const string &fmt)
{
    //struct tm sttm = *localtime ( &ttime );        // 非线程安全。
    struct tm sttm; localtime_r (&ttime,&sttm);   // 线程安全。
    sttm.tm_year=sttm.tm_year+1900;   // tm.tm_year成员要加上1900。
    sttm.tm_mon++; // sttm.tm_mon成员是从0开始的，要加1。

    // 缺省的时间格式。
    if ( (fmt=="") || (fmt=="yyyy-mm-dd hh24:mi:ss") )
    {
        strtime=sformat("%04u-%02u-%02u %02u:%02u:%02u",sttm.tm_year,sttm.tm_mon,sttm.tm_mday,\
                   sttm.tm_hour,sttm.tm_min,sttm.tm_sec);
        return strtime;
    }

    if (fmt=="yyyy-mm-dd hh24:mi")
    {
        strtime=sformat("%04u-%02u-%02u %02u:%02u",sttm.tm_year,sttm.tm_mon,sttm.tm_mday,\
                   sttm.tm_hour,sttm.tm_min);
        return strtime;
    }

    if (fmt=="yyyy-mm-dd hh24")
    {
        strtime=sformat("%04u-%02u-%02u %02u",sttm.tm_year,sttm.tm_mon,sttm.tm_mday,sttm.tm_hour);
        return strtime;
    }

    if (fmt=="yyyy-mm-dd")
    {
        strtime=sformat("%04u-%02u-%02u",sttm.tm_year,sttm.tm_mon,sttm.tm_mday); 
        return strtime;
    }

    if (fmt=="yyyy-mm")
    {
        strtime=sformat("%04u-%02u",sttm.tm_year,sttm.tm_mon); 
        return strtime;
    }

    if (fmt=="yyyymmddhh24miss") 
    {
        strtime=sformat("%04u%02u%02u%02u%02u%02u",sttm.tm_year,sttm.tm_mon,sttm.tm_mday,\
                   sttm.tm_hour,sttm.tm_min,sttm.tm_sec);
        return strtime;
    }

    if (fmt=="yyyymmddhh24mi")
    {
        strtime=sformat("%04u%02u%02u%02u%02u",sttm.tm_year,sttm.tm_mon,sttm.tm_mday,\
                   sttm.tm_hour,sttm.tm_min);
        return strtime;
    }

    if (fmt=="yyyymmddhh24")
    {
        strtime=sformat("%04u%02u%02u%02u",sttm.tm_year,sttm.tm_mon,sttm.tm_mday,sttm.tm_hour);
        return strtime;
    }

    if (fmt=="yyyymmdd")
    {
        strtime=sformat("%04u%02u%02u",sttm.tm_year,sttm.tm_mon,sttm.tm_mday); 
        return strtime;
    }

    if (fmt=="hh24miss")
    {
        strtime=sformat("%02u%02u%02u",sttm.tm_hour,sttm.tm_min,sttm.tm_sec); 
        return strtime;
    }

    if (fmt=="hh24mi") 
    {
        strtime=sformat("%02u%02u",sttm.tm_hour,sttm.tm_min); 
        return strtime;
    }

    if (fmt=="hh24")
    {
        strtime=sformat("%02u",sttm.tm_hour); 
        return strtime;
    }

    if (fmt=="mi")
    {
        strtime=sformat("%02u",sttm.tm_min); 
        return strtime;
    }
    return strtime;
}
char* timetostr(const time_t ttime,char *strtime,const string &fmt)
{
    if (strtime==nullptr) return nullptr;   

    string str;
    timetostr(ttime,str,fmt);         
    //string 内容拷贝到 strtime中
    str.copy(strtime,str.length());
    strtime[str.length()]=0;           // string的copy函数不会给C风格字符串的结尾加0。
    return strtime;
}
string timetostr1(const time_t ttime,const string &fmt)
{
    string str;
    timetostr(ttime,str,fmt);           
    return str;
}
string& ltime(string &strtime,const string &fmt,const int timetvl)
{
    time_t  timer;
    time(&timer); // 获取系统当前时间。
    timer=timer+timetvl;              // 加上时间的偏移量。
    timetostr(timer,strtime,fmt);   // 把整数表示的时间转换为字符串表示的时间。
    return strtime;
}
char* ltime(char *strtime,const string &fmt,const int timetvl)
{
    if (strtime==nullptr) return nullptr;  

    time_t  timer;
    time(&timer );  // 获取系统当前时间。
    timer=timer+timetvl;              // 加上时间的偏移量。
    timetostr(timer,strtime,fmt);   // 把整数表示的时间转换为字符串表示的时间。
    return strtime;
}
string ltime1(const string &fmt,const int timetvl)
{
    string strtime;
    ltime(strtime,fmt,timetvl);   
    return strtime;
}

time_t strtotime(const string &strtime)
{
    string strtmp,yyyy,mm,dd,hh,mi,ss;

    picknumber(strtime,strtmp,false,false);    // 把字符串中的数字全部提取出来。
    // 2021-12-05 08:30:45
    // 2021/12/05 08:30:45
    // 20211205083045

    if (strtmp.length() != 14) return -1;           // 如果时间格式不是yyyymmddhh24miss，说明时间格式不正确。

    yyyy=strtmp.substr(0,4);
    mm=strtmp.substr(4,2);
    dd=strtmp.substr(6,2);
    hh=strtmp.substr(8,2);
    mi=strtmp.substr(10,2);
    ss=strtmp.substr(12,2);

    struct tm sttm;

    try
    {
        sttm.tm_year = stoi(yyyy) - 1900;
        sttm.tm_mon = stoi(mm) - 1;
        sttm.tm_mday = stoi(dd);
        sttm.tm_hour = stoi(hh);
        sttm.tm_min = stoi(mi);
        sttm.tm_sec = stoi(ss);
        sttm.tm_isdst = 0;
    }
    catch(const std::exception& e)
    {
        return -1;
    }

    return mktime(&sttm);
}
bool addtime(const string &in_stime,string &out_stime,const int timetvl,const string &fmt)
{
    time_t  timer;
    // 把字符串表示的时间转换为整数表示的时间，方便运算。
    if ( (timer=strtotime(in_stime))==-1) { out_stime=""; return false; }

    timer=timer+timetvl;  // 时间运算。

    // 把整数表示的时间转换为字符串表示的时间。
    timetostr(timer,out_stime,fmt);

    return true;
}
bool addtime(const string &in_stime,char *out_stime,const int timetvl,const string &fmt)
{
    if (out_stime==nullptr) return false;    // 判断空指针。
    time_t  timer;

    // 把字符串表示的时间转换为整数表示的时间，方便运算。
    if ( (timer=strtotime(in_stime))==-1) { strcpy(out_stime,""); return false; }
    timer=timer+timetvl;  // 时间运算。

    // 把整数表示的时间转换为字符串表示的时间。
    timetostr(timer,out_stime,fmt);
    return true;
}


ctimer::ctimer()
{
    start();   // 计时开始。
}

// 计时开始。
void ctimer::start()
{
    memset(&m_start,0,sizeof(struct timeval));
    memset(&m_end,0,sizeof(struct timeval));
    gettimeofday(&m_start, 0);    // 获取当前时间，精确到微秒。
}

// 计算已逝去的时间，单位：秒，小数点后面是微秒
// 每调用一次本方法之后，自动调用Start方法重新开始计时。
double ctimer::elapsed()
{
    gettimeofday(&m_end,0);     // 获取当前时间作为计时结束的时间，精确到微秒。

    string str;
    str=sformat("%ld.%06ld",m_start.tv_sec,m_start.tv_usec);
    double dstart=stod(str);      // 把计时开始的时间点转换为double。

    str=sformat("%ld.%06ld",m_end.tv_sec,m_end.tv_usec);
    double dend=stod(str);       // 把计时结束的时间点转换为double。

    start();                                  // 重新开始计时。

    return dend-dstart;
}

```

:::



:::details 时间操作的若干函数使用演示



`ltime()`时间函数的使用（获取操作系统时间）。

```c
/*
 *  程序名：demo24.cpp，此程序演示开发框架中ltime时间函数的使用（获取操作系统时间）。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;
int main()
{

    char strtime1[20];   // C风格的字符串。
    string strtime2;    // C++风格的字符串。
    memset(strtime1,0,sizeof(strtime1));
    
    if(1)          // 获取当前时间
    {     
    	ltime(strtime1,"yyyy-mm-dd hh24:mi:ss");   
        printf("strtime1=%s\n",strtime1);
        
        ltime(strtime2,"yyyy-mm-dd hh24:mi:ss");        
    	cout << "strtime2=" << strtime2 << "\n";
    }
    
    if(1)     // 获取30秒前的时间
    {
    	ltime(strtime1,"yyyy-mm-dd hh24:mi:ss",-30);     
    	printf("strtime1=%s\n",strtime1);
        
        ltime(strtime2,"yyyy-mm-dd hh24:mi:ss",-30);  
    	cout << "strtime2=" << strtime2 << "\n";
    }
    
    if(1) // 获取30秒后的时间。
    {
		
    	ltime(strtime1,"yyyy-mm-dd hh24:mi:ss",30);   
    	printf("strtime1=%s\n",strtime1);     
        
        ltime(strtime2,"yyyy-mm-dd hh24:mi:ss",30); 
        cout << "strtime2=" << strtime2 << "\n";
    }
}
```

`addtime()`函数进行时间的运算

```c
/*
 *  程序名：demo28.cpp，此程序演示开发框架中采用addtime函数进行时间的运算。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    char strtime[20];
    memset(strtime,0,sizeof(strtime));
    strcpy(strtime,"2020-01-20 12:35:22");

    char s1[20];         // C风格的字符串。
    string s2;            // C++风格的字符串。
    
    if(1)
    {
        // 减一天
 		addtime(strtime,s1,0-1*24*60*60);        
        // 输出s1=2020-01-19 12:35:22
        printf("s1=%s\n",s1);
    }
	
    if(1)  // 加两天。 
    {
        addtime(strtime,s2,2*24*60*60);         // 172800
    	// 输出s2=2020-01-22 12:35:22
        cout << "s2=" << s2 << endl;              
    }                
}
```

`ctimer` 计时器的演示

```c
/*
 *  程序名：demo29.cpp，此程序演示开发框架中的ctimer类（计时器）的用法。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    ctimer timer;
    printf("elapsed=%lf\n",timer.elapsed());
    sleep(1);
    printf("elapsed=%lf\n",timer.elapsed());
    sleep(1);
    printf("elapsed=%lf\n",timer.elapsed());
    usleep(1000);
    printf("elapsed=%lf\n",timer.elapsed());
    usleep(100);
    printf("elapsed=%lf\n",timer.elapsed());
    sleep(10);
    printf("elapsed=%lf\n",timer.elapsed());
}
```

:::



## 目录和文件操作

:::details 目录和文件操作方法和类抽象

```c
#pragma region 目录和文件操作
/*===========根据绝对路径的文件名或目录名逐级的创建目录==========
      const string &pathorfilename  //<I> 绝对路径的文件名或目录名
      bool bisfilename=true         //<I> 指定pathorfilename的类型，true-pathorfilename是文件名，否则是目录名，缺省值为true。
      bool                          //<return>  返回值：true-成功，false-失败
      注意：如果返回失败，原因有大概有三种情况： 1）权限不足；2）pathorfilename参数不是合法的文件名或目录名；3）磁盘空间不足。
*/
bool newdir(const string &pathorfilename,bool bisfilename=true);
/*===========重命名文件，类似Linux系统的mv命令==========
    const string &srcfilename   // <I> 原文件名，建议采用绝对路径的文件名。
    const string &dstfilename   // <I> 目标文件名，建议采用绝对路径的文件名
    bool                        // <O> 返回值：true-成功；false-失败，失败的主要原因是权限不足或磁盘空间不够，如果原文件和目标文件不在同一个磁盘分区，重命名也可能失败。
    注意，在重命名文件之前，会自动创建dstfilename参数中包含的目录。在应用开发中，可以用renamefile()函数代替rename()库函数
*/
bool renamefile(const string &srcfilename,const string &dstfilename);
/*===========复制文件，类似Linux系统的cp命令==========
   const string &srcfilename    //<I> 原文件名，建议采用绝对路径的文件名。
   const string &dstfilename    //<I> 目标文件名，建议采用绝对路径的文件名。
   bool                         //<return>  返回值：true-成功；false-失败，失败的主要原因是权限不足或磁盘空间不够。
   注意
        1）在复制文件之前，会自动创建dstfilename参数中的目录名。
        2）复制文件的过程中，采用临时文件命名的方法，复制完成后再改名为dstfilename，避免中间状态的文件被读取。
        3）复制后的文件的时间与原文件相同，这一点与Linux系统cp命令不同。
*/
bool copyfile(const string &srcfilename,const string &dstfilename);
/*===========获取文件的大小==========
   const string &filename)     //<I> 待获取的文件名，建议采用绝对路径的文件名。
   int                         //<O> 返回值：如果文件不存在或没有访问权限，返回-1，成功返回文件的大小，单位是字节。
*/
int filesize(const string &filename);
/*===========获取文件的时间==========
    const string &filename,char *mtime      //<I> 待获取的文件名，建议采用绝对路径的文件名。
    char *mtime                             //<I> 用于存放文件的时间，即stat结构体的st_mtime。
    const string &fmt="yyyymmddhh24miss"    //<I> fmt：设置时间的输出格式，与ltime()函数相同，但缺省是"yyyymmddhh24miss"。
    bool                                    //<return> 返回值：如果文件不存在或没有访问权限，返回false，成功返回true。
*/
bool filemtime(const string &filename,char *mtime ,const string &fmt="yyyymmddhh24miss");
bool filemtime(const string &filename,string &mtime,const string &fmt="yyyymmddhh24miss");
/*===========重置文件的修改时间属性==========
    const string &filename  //<I> 待重置的文件名，建议采用绝对路径的文件名。
    const string &mtime     //<I> 字符串表示的时间，格式不限，但一定要包括yyyymmddhh24miss，一个都不能少，顺序也不能变。
    bool                    //<return> 返回值：true-成功；false-失败，失败的原因保存在errno中。
*/
bool setmtime(const string &filename,const string &mtime);

class cdir; //获取某目录及其子目录中的文件列表的类

class cdir
{
    //构造析构
private:
     // 禁用拷贝构造函数和赋值函数
    cdir(const cdir &) = delete;                     
    cdir &operator=(const cdir &) = delete; 
    ~cdir(); 
public:
    cdir():m_pos(0),m_fmt("yyyymmddhh24miss") {}  
    //成员属性
private:
    vector<string> m_filelist;  // 存放文件列表的容器（绝对路径的文件名）。
    int m_pos; // 从文件列表m_filelist中已读取文件的位置。
    string m_fmt; // 文件时间格式，缺省"yyyymmddhh24miss"。    
public:
    //举例: /project/public/_public.h
    string m_dirname;        // 目录名，例如：/project/public
    string m_filename;       // 文件名，不包括目录名，例如：_public.h
    string m_ffilename;      // 绝对路径的文件，例如：/project/public/_public.h
    int      m_filesize;     // 文件的大小，单位：字节。
    string m_mtime;          // 文件最后一次被修改的时间，即stat结构体的st_mtime成员。
    string m_ctime;          // 文件生成的时间，即stat结构体的st_ctime成员。
    string m_atime;          // 文件最后一次被访问的时间，即stat结构体的st_atime成员。

public:
    /*=========== 设置文件时间的格式，支持"yyyy-mm-dd hh24:mi:ss"和"yyyymmddhh24miss"两种，缺省是后者。==========

    */
    void setfmt(const string &fmt);
    /*===========打开目录，获取目录中文件的列表，存放在m_filelist容器中。==========
        const string &dirname       //<I> 目录名，采用绝对路径，如/tmp/root。
        const string &rules         //<I> 文件名的匹配规则，不匹配的文件将被忽略。
        const int maxfiles=10000    //<I> 本次获取文件的最大数量，缺省值为10000个，如果文件太多，可能消耗太多的内存。
        const bool bandchild=false  //<I> 是否打开各级子目录，缺省值为false-不打开子目录。
        bool bsort=false            //<I> bsort，是否按文件名排序，缺省值为false-不排序。
        bool                        //<return>  返回值：true-成功，false-失败。

    */
    bool opendir(const string &dirname,const string &rules,const int maxfiles=10000,const bool bandchild=false,bool bsort=false);
private:
    //这是一个递归函数，被opendir()的调用，在cdir类的外部不需要调用它
    bool _opendir(const string &dirname,const string &rules,const int maxfiles,const bool bandchild);

public:
    // 从m_filelist容器中获取一条记录（文件名），同时获取该文件的大小、修改时间等信息。
    // 调用opendir方法时，m_filelist容器被清空，m_pos归零，每调用一次readdir方法m_pos加1。
    // 当m_pos小于m_filelist.size()，返回true，否则返回false。
    bool readdir();
    unsigned int size() { return m_filelist.size(); }
};
#pragma endregion
```

:::



:::details 目录和文件操作方法和类实现

```c
bool newdir(const string &pathorfilename,bool bisfilename)
{
    // /tmp/aaa/bbb/ccc/ddd =>   /tmp    /tmp/aaa    /tmp/aaa/bbb    /tmp/aaa/bbb/ccc 
     
    // 检查目录是否存在，如果不存在，逐级创建子目录
    int pos=1;          // 不要从0开始，0是根目录/。

    while (true)
    {
        int pos1=pathorfilename.find('/',pos);
        if (pos1==string::npos) break;
        // 截取目录
        string strpathname=pathorfilename.substr(0,pos1);     
        // 位置后移
        pos=pos1+1;
        // 如果目录不存在，创建它
        if (access(strpathname.c_str(),F_OK) != 0)
        {
            // 0755是八进制，不要写成755。
            if (mkdir(strpathname.c_str(),0755) != 0) return false; 
        }
    }

    // 如果pathorfilename不是文件，是目录，还需要创建最后一级子目录。
    if (bisfilename==false)
    {
        if (access(pathorfilename.c_str(),F_OK) != 0)
        {
            if (mkdir(pathorfilename.c_str(),0755) != 0) return false;
        }
    }
    return true;
}
int filesize(const string &filename)
{
    struct stat st_filestat;      // 存放文件信息的结构体。

    // 获取文件信息，存放在结构体中。
    if (stat(filename.c_str(),&st_filestat) < 0) return -1;

    return st_filestat.st_size;   // 返回结构体的文件大小成员。
}
bool filemtime(const string &filename,string &mtime,const string &fmt)
{
    struct stat st_filestat;      // 存放文件信息的结构体。

    // 获取文件信息，存放在结构体中。
    if (stat(filename.c_str(),&st_filestat) < 0) return false;

    // 把整数表示的时间转换成字符串表示的时间。
    timetostr(st_filestat.st_mtime,mtime,fmt);

    return true;
}
bool filemtime(const string &filename,char *mtime,const string &fmt)
{
    struct stat st_filestat;      // 存放文件信息的结构体。

    // 获取文件信息，存放在结构体中。
    if (stat(filename.c_str(),&st_filestat) < 0) return false;

    // 把整数表示的时间转换成字符串表示的时间。
    timetostr(st_filestat.st_mtime,mtime,fmt);

    return true;
}
void cdir::setfmt(const string &fmt)
{
    m_fmt=fmt;
}
bool cdir::opendir(const string &dirname,const string &rules,const int maxfiles,const bool bandchild,bool bsort)
{
    m_filelist.clear();    // 清空文件列表容器。
    m_pos=0;              // 从文件列表中已读取文件的位置归0。

    // 如果目录不存在，创建它。
    if (newdir(dirname,false) == false) return false;

    // 打开目录，获取目录中的文件列表，存放在m_filelist容器中。
    bool ret=_opendir(dirname,rules,maxfiles,bandchild);

    if (bsort==true)    // 对文件列表排序。
    {
      sort(m_filelist.begin(), m_filelist.end());
    }

    return ret;
}
bool cdir::_opendir(const string &dirname,const string &rules,const int maxfiles,const bool bandchild)
{
    DIR *dir;   // 目录指针。

    // 打开目录。
    if ( (dir=::opendir(dirname.c_str())) == nullptr ) return false; // opendir与库函数重名，需要加::

    string strffilename;            // 全路径的文件名。
    struct dirent *stdir;            // 存放从目录中读取的内容。

    // 用循环读取目录的内容，将得到目录中的文件名和子目录。
    while ((stdir=::readdir(dir)) != 0) // readdir与库函数重名，需要加::
    {
        // 判断容器中的文件数量是否超出maxfiles参数。
        if ( m_filelist.size()>=maxfiles ) break;

        // 文件名以"."打头的文件不处理。.是当前目录，..是上一级目录，其它以.打头的都是特殊目录和文件。
        if (stdir->d_name[0]=='.') continue;
        
        // 拼接全路径的文件名。
        strffilename=dirname+'/'+stdir->d_name;  

        // 如果是目录，处理各级子目录。
        if (stdir->d_type==4)
        {
            if (bandchild == true)      // 打开各级子目录。
            {
                if (_opendir(strffilename,rules,maxfiles,bandchild) == false)   // 递归调用_opendir函数。
                {
                    closedir(dir); return false;
                }
            }
        }
        
        // 如果是普通文件，放入容器中。
        if (stdir->d_type==8)
        {
            // 把能匹配上的文件放入m_filelist容器中。
            if (matchstr(stdir->d_name,rules) == false) continue;

            m_filelist.push_back(std::move(strffilename));
        }
    }

    closedir(dir);   // 关闭目录。

    return true;
}
bool cdir::readdir()
{
    // 如果已读完，清空容器
    if (m_pos >= m_filelist.size()) 
    {
      m_pos=0; m_filelist.clear(); return false;
    }

    // 文件全名，包括路径
    m_ffilename=m_filelist[m_pos];

    // 从绝对路径的文件名中解析出目录名和文件名。
    int pp=m_ffilename.find_last_of("/");
    m_dirname=m_ffilename.substr(0,pp);
    m_filename=m_ffilename.substr(pp+1);

    // 获取文件的信息。
    struct stat st_filestat;
    stat(m_ffilename.c_str(),&st_filestat);
    m_filesize=st_filestat.st_size;                                     // 文件大小。
    m_mtime=timetostr1(st_filestat.st_mtime,m_fmt);   // 文件最后一次被修改的时间。
    m_ctime=timetostr1(st_filestat.st_ctime,m_fmt);      // 文件生成的时间。
    m_atime=timetostr1(st_filestat.st_atime,m_fmt);      // 文件最后一次被访问的时间。

    m_pos++;       // 已读取文件的位置后移。

    return true;
}
cdir::~cdir()
{
    m_filelist.clear();
}
bool renamefile(const string &srcfilename,const string &dstfilename)
{
    // 如果原文件不存在，直接返回失败。
    if (access(srcfilename.c_str(),R_OK) != 0) return false;

    // 创建目标文件的目录。
    if (newdir(dstfilename,true) == false) return false;

    // 调用操作系统的库函数rename重命名文件。 mv
    if (rename(srcfilename.c_str(),dstfilename.c_str()) == 0) return true;

    return false;
}
bool copyfile(const string &srcfilename,const string &dstfilename)
{
    // 创建目标文件的目录。
    if (newdir(dstfilename,true) == false) return false;

    cifile ifile;
    cofile ofile;
    int ifilesize=filesize(srcfilename);

    int  total_bytes=0;
    int  onread=0;
    char buffer[5000];

    if (ifile.open(srcfilename,ios::in|ios::binary)==false) return false;

    if (ofile.open(dstfilename,ios::out|ios::binary)==false) return false;

    while (true)
    {
        if ((ifilesize-total_bytes) > 5000) onread=5000;
        else onread=ifilesize-total_bytes;

        memset(buffer,0,sizeof(buffer));
        ifile.read(buffer,onread);
        ofile.write(buffer,onread);

        total_bytes = total_bytes + onread;

        if (total_bytes == ifilesize) break;
    }

    ifile.close();
    ofile.closeandrename();

    // 更改文件的修改时间属性
    string strmtime;
    filemtime(srcfilename,strmtime);
    setmtime(dstfilename,strmtime);

    return true;
}

```

:::





:::details 目录和文件操作的使用



采用`newdir`函数根据绝对路径的文件名或目录名逐级的创建目录。

```cpp
/*
 *  程序名：demo30.cpp，此程序演示开发框架中采用newdir函数根据绝对路径的文件名或目录名逐级的创建目录。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;
int main()
{	
    if(1) // 创建"/tmp/aaa/bbb/ccc/ddd"目录。
    {
        //针对这个目录  /tmp/aaa/bbb/ccc/ddd 
        //底层先查验父目录是否存在？不存在会先创建。查验顺序如下
        // /tmp
        // /tmp/aaa   
        // /tmp/aaa/bbb
        // /tmp/aaa/bbb/ccc
        // /tmp/aaa/bbb/ccc/ddd
      	newdir("/tmp/aaa/bbb/ccc/ddd",false); 
    }
	if(1)// 创建"/tmp/111/222/333/444/data.xml"文件
    {	
        // 创建逻辑同理，先确保父目录存在，再创建到具体data.xml文件
        // 创建"/tmp/111/222/333/444"目录。
    	newdir("/tmp/111/222/333/444/data.xml",true);     
    }
}
```

演示文件操作函数的用法

```c
/*
 *  程序名：demo32.cpp，此程序演示开发框架的文件操作函数的用法
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;
int main()
{
    if(1)   // 重命名文件
    {
		if(renamefile("/project/public/lib_public.so",                     "/tmp/aaa/bbb/ccc/lib_public.so")==false)
        {
          printf("renamefile(/project/public/lib_public.so) %d:%s\n",errno,strerror(errno));
        }        
    }
    
    if(1)     // 复制文件
    {
    	if(copyfile("/project/public/libftp.a",
                    "/tmp/aaa/ddd/ccc/libftp.a")==false)
    	{
        printf("copyfile(/project/public/libftp.a) %d:%s\n",errno,strerror(errno));
        } 
    }
    
    if(1)     // 获取文件的大小
    {  
        printf("size=%d\n",
               filesize("/project/public/_public.h"));     
    }
    
    if(1)     // 重置文件的时间
    {
        setmtime("/project/public/_public.h",
                 "2020-01-05 13:37:29"); 
    }
  	
    if(1)    // 获取文件的时间
    {
        string mtime;
    	filemtime("/project/public/_public.h",
              mtime,"yyyy-mm-dd hh24:mi:ss");
    	// 输出mtime=2020-01-05 13:37:29
    	cout << "mtime=" << mtime << endl;  
        
    	filemtime("/project/public/_public.h",mtime);
    	// 输出mtime=20200105133729
    	cout << "mtime=" << mtime << endl;  
    }
}
```

`cdir`类获取某目录及其子目录中的文件列表信息。

```c
/*
 *  程序名：demo34.cpp，此程序演示开发框架中采用cdir类获取某目录及其子目录中的文件列表信息。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main(int argc,char *argv[])
{
    if (argc != 3) 
    { 
        printf("Using:./demo34 pathname matchstr\n");
        printf("Sample:./demo34 /project \"*.h,*.cpp\"\n");
        return -1;
    }

    cdir dir;       // 创建读取目录的对象。

    if (dir.opendir(argv[1],argv[2],100,false,true)==false)             // 打开目录，获取目录中文件的列表。
    {   
        printf("dir.opendir(%s) failed.\n",argv[1]); return -1; 
    }
     //遍历文件列表
    while(dir.readdir()==true)       
    {
        cout << "filename=" << dir.m_ffilename << ",mtime=" << dir.m_mtime << ",size=" << dir.m_filesize << endl;
    }
}
```

:::

## 写文件和读文件

C＋+提供了ofstream类，实现了文件的读和写。

不支持格式化输出。

还有其它的小细节需要处理。



向文件中写数据的步骤（初工的想法）

- 打开文件。
- 向文件中写入数据。
- 关闭文件。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240324143306576.png)



文件操作没有锁机制，生成文件需要时间，如果在进程A生成文件的过程中，进程B就读到了文件，那么，进程B读到的内容可能是不完整的。



向文件中写数据的步骤-优化 （中工的做法）

- 打开临时文件。
- 向临时文件中写入数据。
- 关闭临时文件。
- 把临时文件名改名为正式的文件名。



:::details 写文件读文件类抽象

```c
#pragma region 写文件和读文件
class cofile;//写文件的类
class cifile;//读取文件的类
class cofile  
{
private:
    ofstream fout;                  // 写入文件的对象。
    string   m_filename;         // 文件名，建议采用绝对路径。
    string   m_filenametmp;  // 临时文件名，在m_filename后面加".tmp"。
public:
    cofile() {}
    ~cofile() { close(); };
public:
    // 文件是否已打开
    bool isopen() const { return fout.is_open(); }   
    /*===========打开文件==========
        const string &filename              //<I> 待打开的文件名。
        const bool btmp=true                //<I> 是否采用临时文件的方案。
        const ios::openmode mode=ios::out   //<I> 打开文件的模式。
        const bool benbuffer=true           //<I> 是否启用文件缓冲区。
    */
    bool open(const string &filename,const bool btmp=true,const ios::openmode mode=ios::out,const bool benbuffer=true);
    /*===========把数据以文本的方式格式化输出到文件==========
            const char* fmt     //<I>含有占位符的格式化字符串
             Args... args       //<I>可变参数列表
    */
    template< typename... Args >
    bool writeline(const char* fmt, Args... args) 
    {
        if (fout.is_open()==false) return false;
        fout << sformat(fmt,args...);
        return fout.good();
    }
    /*===========重载<<运算符，把数据以文本的方式输出到文件==========
                 注意：换行只能用\n，不能用endl
         const T &value 写入的内容
    */
    template<typename T>
    cofile& operator<<(const T &value)
    {
        fout << value; return *this;
    }

    /*===========把二进制数据写入文件==========
        void *buf      //<I> 指向二进制数据的内存 
        int bufsize    //<I> 二进制数据在内存中占用的字节
    */
    bool write(void *buf,int bufsize);
    // 关闭文件，并且把临时文件名改为正式文件名
    bool closeandrename();
    // 关闭文件，如果有临时文件，则删除它
    void close();
};
class cifile   
{
private:
    ifstream fin;                // 读取文件的对象
    string   m_filename;         // 文件名，建议采用绝对路径
public:
    cifile() {}
    ~cifile() { close(); }
public:
    // 判断文件是否已打开
    bool isopen() const { return fin.is_open(); }
    /*===========打开文件==========
       const string &filename           //<I> 待打开的文件名
       const ios::openmode mode=ios::in //<I> 打开文件的模式
    */
    bool open(const string &filename,const ios::openmode mode=ios::in);
     /*===========以行的方式读取文本文件==========
        string &buf             //<I> 读取到的一行文本
        const string& endbz=""  //<I> endbz指定行的结尾标志，缺省为空，没有结尾标志
    */
    bool readline(string &buf,const string& endbz="");
    /*===========读取二进制文件，返回实际读取到的字节数==========
        void *buf       //<I> 读取到的二进制数据载入这个地址指向的内存区域
        int bufsize     //<I> 这个地址指向的内存区域的大小 字节为单位
    */
    int read(void *buf,const int bufsize);
    // 关闭并删除文件
    bool closeandremove();
    // 只关闭文件
    void close();
};
#pragma endregion
```

:::



:::details 写文件读文件类实现

```c
bool cifile::open(const string &filename,const ios::openmode mode)
{
    // 如果文件是打开的状态，先关闭它。
    if (fin.is_open()) fin.close();

    m_filename=filename;

    fin.open(m_filename,mode);

    return fin.is_open();
}
int cifile::read(void *buf,const int bufsize)
{
    // fin.read((char *)buf,bufsize);
    fin.read(static_cast<char *>(buf),bufsize);

    return fin.gcount();          // 返回读取的字节数。
}
bool cifile::closeandremove()
{
    if (fin.is_open()==false) return false;

    fin.close(); 

    if (remove(m_filename.c_str())!=0) return false;

    return true;
}
void cifile::close() 
{ 
    if (fin.is_open()==false) return;

    fin.close(); 
}
bool cifile::readline(string &buf,const string& endbz)
{
    buf.clear();            // 清空buf。

    string strline;        // 存放从文件中读取的一行。

    while (true)
    {
        getline(fin,strline);    // 从文件中读取一行。
      
        if (fin.eof()) break;    // 如果文件已读完。

        buf=buf+strline;      // 把读取的内容拼接到buf中。

        if (endbz=="")
            return true;          // 如果行没有结尾标志。
        else 
        {
            // 如果行有结尾标志，判断本次是否读到了结尾标志，如果没有，继续读，如果有，返回。
            if (buf.find(endbz,buf.length()-endbz.length()) != string::npos) return true;
        }

        buf=buf+"\n";        // getline从文件中读取一行的时候，会删除\n，所以，这里要补上\n，因为这个\n不应该被删除。
    }

    return false;
}
bool cofile::open(const string &filename,const bool btmp,const ios::openmode mode,const bool benbuffer)
{
    // 如果文件是打开的状态，先关闭它。
    if (fout.is_open()) fout.close();

    m_filename=filename;

    newdir(m_filename,true);     // 如果文件的目录不存在，创建目录。

    if (btmp==true) 
    {   // 采用临时文件的方案。
        m_filenametmp=m_filename+".tmp";
        fout.open(m_filenametmp,mode);
    }
    else
    {   // 不采用临时文件的方案。
        m_filenametmp.clear();
        fout.open(m_filename,mode);
    }

    // 不启用文件缓冲区。
    if (benbuffer==false) fout << unitbuf;

    return fout.is_open();
}
bool cofile::write(void *buf,int bufsize)
{
    if (fout.is_open()==false) return false;

    // fout.write((char *)buf,bufsize);
    fout.write(static_cast<char *>(buf),bufsize);

    return fout.good();
}
bool cofile::closeandrename()
{
    if (fout.is_open()==false) return false;

    fout.close();

    //  如果采用了临时文件的方案。
    if (m_filenametmp.empty()==false) 
        if (rename(m_filenametmp.c_str(),m_filename.c_str())!=0) return false;

    return true;
}
void cofile::close() 
{ 
    if (fout.is_open()==false) return;

    fout.close(); 

    //  如果采用了临时文件的方案。
    if (m_filenametmp.empty()==false) 
        remove(m_filenametmp.c_str());
}
```

:::



:::details 写文件读文件使用



`cofile`类向文件中写入文本数据

```c
/*
 *  程序名：demo36.cpp，此程序演示开发框架中采用cofile类向文件中写入文本数据。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;  
int main()
{
    cofile ofile;      
     // 1、创建文件，实际创建的是临时文件
     //例如/tmp/data/girl.xml.tmp。
     if (ofile.open("/tmp/data/girl.xml")==false)
     {
        printf("ofile.open(/tmp/data/girl.xml) failed.\n");
        return -1;
     }
    // 2、用<<输出到文件，与cout的用法相同。
    ofile << "<data>" << "\n";         // 换行只能用\n，不能用endl。

    // 3、格式化输出到文件
    ofile.writeline("<name>%s</name><age>%d</age><sc>%s</sc><yz>%s</yz><memo>%s</memo><endl/>\n",\
                           "妲已",28,"火辣","漂亮","商要亡，关我什么事。");
    ofile.writeline("<name>%s</name><age>25</age><sc>火辣</sc><yz>漂亮</yz><memo>1、中国排名第一的美女；\n"\
         "2、男朋友是范蠡；\n"\
         "3、老公是夫差，被勾践弄死了。</memo><endl/>\n","西施");
    ofile << "</data>\n"; // 换行只能用\n，不能用endl

    // sleep(10);  
    // 此时用ls /tmp/data/*.tmp可以看到生成的临时文件

    // 4、关闭文件，并把临时文件名改为正式的文件名
    ofile.closeandrename();
}
```

`cifile`类从文本文件中读取数据。

```c
/*
 *  程序名：demo37.cpp，此程序演示开发框架中采用cifile类从文本文件中读取数据。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    cifile ifile;
    string strline;   // 存放从文本文件中读取的一行
    
    // 打开文件
    if (ifile.open("/tmp/data/girl.xml")==false)
    {
        printf("ofile.open(/tmp/data/girl.xml) failed.\n"); return -1;
    }
	
    while (true)
    {
        // 从文件中读取一行。
        if (ifile.readline(strline,"<endl/>")==false) 				break;
        cout << "=" << strline << "=\n";
    }

    // ifile.closeandremove();     // 关闭并删除文件。
    ifile.close();                       // 关闭文件。
}
```

`cofile`类向文件中写入二进制数据。

```c
/*
 *  程序名：demo38.cpp，此程序演示开发框架中采用cofile类向文件中写入二进制数据。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    cofile ofile;

    // 1、创建文件，实际创建的是临时文件
    // 例如/tmp/data/girl.dat.tmp。
    if (ofile.open("/tmp/data/girl.dat",true,ios::binary)==false)
    {
        printf("ofile.open(/tmp/data/girl.dat) failed.\n"); return -1;
    }

    struct st_girl
    {
        int bh;
        char name[21];
    }girl;

    memset(&girl,0,sizeof(girl));
    girl.bh=8;
    strcpy(girl.name,"西施");
    ofile.write(&girl,sizeof(girl));

    // sleep(30);  
    // 用ls /tmp/data/*.tmp可以看到生成的临时文件。

    // 关闭文件，并把临时文件名改为正式的文件名。
    ofile.closeandrename();
}
```

:::

## 日志文件操作

简单的小程序，把东西显示在屏幕上就可以了。

服务程序运行在后台，无人守值，不会在屏幕上显示东西。

日志文件的内容:程序运行的状态、处理数据的情况........



:::details 日志文件操作`clogfile` 类抽象

```c
#pragma region 日志模块

class spinlock_mutex;// 自旋锁
class clogfile;//日志文件
class spinlock_mutex
{
private:
    atomic_flag flag;

    spinlock_mutex(const spinlock_mutex&) = delete;
    spinlock_mutex& operator=(const spinlock_mutex) = delete;
public:
    spinlock_mutex() 
    {
        flag.clear();
    }
    void lock()           // 加锁。
    {
        while (flag.test_and_set())
            ;
    }
    void unlock()      // 解锁。
    {
        flag.clear();
    }
};
class clogfile
{
    ofstream fout;              // 日志文件对象。
    string   m_filename;        // 日志文件名，建议采用绝对路径。
    ios::openmode m_mode;       // 日志文件的打开模式。
    bool     m_backup;          // 是否自动切换日志。
    int        m_maxsize;       // 当日志文件的大小超过本参数时，自动切换日志。
    bool     m_enbuffer;        // 是否启用文件缓冲区。
    spinlock_mutex m_splock;    // 自旋锁，用于多线程程序中给写日志的操作加锁。

//构造和析构
public:
    clogfile(int maxsize=100):m_maxsize(maxsize){}// 日志文件的大小缺省100M。
    void close() { fout.close(); }
    ~clogfile() { close(); };

public:    
    /*===========打开日志文件==========
        注意，在多进程的程序中，多个进程往同一日志文件写入大量的日志时，可能会出现小混乱，但是，多线程不会。
            1）多个进程往同一日志文件写入大量的日志时，可能会出现小混乱，这个问题并不严重，可以容忍；
            2）只有同时写大量日志时才会出现混乱，在实际开发中，这种情况不多见。
             3）如果业务无法容忍，可以用信号量加锁。

        const string &filename   //<I> 日志文件名，建议采用绝对路径，如果文件名中的目录不存在，就先创建目录。
        const ios::openmode mode=ios::app   //<I> 日志文件的打开模式，缺省值是ios::app。
        const bool bbackup=true             //<I> 是否自动切换（备份），true-切换，false-不切换，在多进程的服务程序中，如果多个进程共用一个日志文件，bbackup必须为false。
        const bool benbuffer=false          //<I> 是否启用文件缓冲机制，true-启用，false-不启用，如果启用缓冲区，那么写进日志文件中的内容不会立即写入文件，缺省是不启用。
    */
    bool open(const string &filename,const ios::openmode mode=ios::app,const bool bbackup=true,const bool benbuffer=false);

    // 把日志内容以文本的方式格式化输出到日志文件，并且，在日志内容前面写入时间。
    template< typename... Args >
    bool write(const char* fmt, Args... args) 
    {
        if (fout.is_open()==false) return false;
        
         // 判断是否需要切换日志文件。
        backup();                 

        m_splock.lock();        // 加锁。
        fout << ltime1() << " " << sformat(fmt,args...);      // 把当前时间和日志内容写入日志文件。
        m_splock.unlock();    // 解锁。

        return fout.good();
    }

    // 重载<<运算符，把日志内容以文本的方式输出到日志文件，不会在日志内容前面写时间。
    // 注意：内容换行用\n，不能用endl。
    template<typename T>
    clogfile& operator<<(const T &value)
    {
        m_splock.lock();
        fout << value; 
        m_splock.unlock();
        return *this;
    }
  
private:
    // 如果日志文件的大小超过m_maxsize的值，就把当前的日志文件名改为历史日志文件名，再创建新的当前日志文件。
    // 备份后的文件会在日志文件名后加上日期时间，如/tmp/log/filetodb.log.20200101123025。
    // 注意，在多进程的程序中，日志文件不可切换，多线程的程序中，日志文件可以切换。
    bool backup();
};
#pragma endregion
```

:::



:::details 日志文件操作`clogfile` 类实现

```c



bool clogfile::open(const string &filename,const ios::openmode mode,const bool bbackup,const bool benbuffer)
{
    // 如果日志文件是打开的状态，先关闭它。
    if (fout.is_open()) fout.close();

    m_filename=filename;        // 日志文件名。
    m_mode=mode;                 // 打开模式。
    m_backup=bbackup;          // 是否自动备份。
    m_enbuffer=benbuffer;      // 是否启用文件缓冲区。

    newdir(m_filename,true);                              // 如果日志文件的目录不存在，创建它。

    fout.open(m_filename,m_mode);                  // 打开日志文件。

    if (m_enbuffer==false) fout << unitbuf;       // 是否启用文件缓冲区。

    return fout.is_open();
}
bool clogfile::backup()
{
    // 不备份
    if (m_backup == false) return true;

    if (fout.is_open() == false) return false;

    // 如果当前日志文件的大小超过m_maxsize，备份日志。
    if (fout.tellp() > m_maxsize*1024*1024)
    {
        m_splock.lock();       // 加锁。

        fout.close();              // 关闭当前日志文件。

        // 拼接备份日志文件名。
        string bak_filename=m_filename+"."+ltime1("yyyymmddhh24miss");

        rename(m_filename.c_str(),bak_filename.c_str());   // 把当前日志文件改名为备份日志文件。

        fout.open(m_filename,m_mode);              // 重新打开当前日志文件。

        if (m_enbuffer==false) fout << unitbuf;   // 判断是否启动文件缓冲区。

        m_splock.unlock();   // 解锁。

        return fout.is_open();
    }

    return true;
}
```



:::





:::details 采用开发框架的`clogfile`类记录程序的运行日志

```c
/*
 *  程序名：demo42.cpp，此程序演示采用开发框架的clogfile类记录程序的运行日志。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    clogfile logfile;      // 创建日志对象。

    // 打开日志文件。
    if (logfile.open("/tmp/log/demo42.log",ios::out,false)==false)
    {
        printf("logfile.open(/tmp/log/demo42.log) failed.\n");  return -1;
    }

    logfile.write("程序开始运行。\n");

    for (int ii=0;ii<5000000;ii++)
    {
        logfile.write("这是第%d个%s...ok.\n",ii,"超级女生");
        //logfile.write("第%d个超女开始表演...",ii);     // 表演前，写一行日志，...表示正在表演中。
        //sleep(2);                                                          // 超女在表演中。
        //logfile << "ok.\n";                                          // 表演完成后，写入ok。
    }

    logfile.write("程序运行结束。\n");
}
```

:::



## 网络通信

:::details 网络通信类和函数抽象

```c
#pragma region 网络通信

class ctcpclient;// socket通讯的客户端类
class ctcpserver;// socket通讯的服务端类
template <class TT, int MaxLength>
class squeue;   //循环队列
class csemp;    // 信号量
class ctcpclient
{
private:
    int  m_connfd;      // 客户端的socket.
    string m_ip;        // 服务端的ip地址。
    int  m_port;        // 服务端通讯的端口。
public:
    ctcpclient(): m_connfd(-1),m_port(0) { } 
    ~ctcpclient();  // 析构函数自动关闭socket，释放资源。
public:
    /*===========向服务端发起连接请求==========
        const string &ip        //<I> 服务端的ip地址
        const int port          //<I> 服务端通讯的端口        
        bool                    //<return> 返回值：true-成功；false-失败。
    */
    bool connect(const string &ip,const int port);
     /*===========向接收对端发送过来的文本数据==========
        string &buffer          //<O> 存放接收数据缓冲区,接收文本内容
        const int itimeout=0    //<I> 等待数据的超时时间（秒）：-1-不等待；0-无限等待；>0-等待的秒数。
        bool                    //<return> 返回值：true-成功；false-失败，失败有两种情况：1）等待超时；2）socket连接已不可用。
    */
    bool read(string &buffer,const int itimeout=0);                         
    /*===========向接收对端发送过来的二进制数据==========
        string &buffer          //<O> 存放接收数据缓冲区,接收二进制数据
        const int ibuflen       //<I> 打算接收数据的大小
        const int itimeout=0    //<I> 等待数据的超时时间（秒）：-1-不等待；0-无限等待；>0-等待的秒数。
        bool                    //<return> 返回值：true-成功；false-失败，失败有两种情况：1）等待超时；2）socket连接已不可用。
    */
    bool read(void *buffer,const int ibuflen,const int itimeout=0);  
    /*=========== 向对端发送文本数据==========
       const string &buffer  //<I> 待发送数据缓冲区
    */
    bool write(const string &buffer);  
    /*=========== 向对端发送二进制数据==========
       const void *buffe    //<I> 待发送数据缓冲区
       const int ibuflen    //<I> 待发送数据的大小
       bool                 //<return>  返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。
    */                   
    bool write(const void *buffer,const int ibuflen);  
    // 断开与服务端的连接
    void close();
};
class ctcpserver
{
private:
    int m_socklen;                     // 结构体struct sockaddr_in的大小。
    struct sockaddr_in m_clientaddr;   // 客户端的地址信息。
    struct sockaddr_in m_servaddr;     // 服务端的地址信息。
    int  m_listenfd;                   // 服务端用于监听的socket。
    int  m_connfd;                     // 客户端连接上来的socket。
public:
    ctcpserver():m_listenfd(-1),m_connfd(-1) {}  // 构造函数。
    ~ctcpserver();  // 析构函数自动关闭socket，释放资源。
public:
     /*=========== 服务端初始化==========
       const unsigned int port  //<I> 指定服务端用于监听的端口
       const int backlog=5      //<I> 已连接队列长度，默认为5个
       bool                     //<return> 返回值：true-成功；false-失败，一般情况下，只要port设置正确，没有被占用，初始化都会成功。
    */    
    bool initserver(const unsigned int port,const int backlog=5); 
    /*=========== 从已连接队列中获取一个客户端连接，如果已连接队列为空，将阻塞等待==========
        //<return> 返回值：true-成功的获取了一个客户端连接，false-失败，如果accept失败，可以重新accept。
    */
    bool accept();
    /*=========== 获取客户端的ip地址==========
        //<return> 返回值：客户端的ip地址，如"192.168.1.100"。
    */
    char *getip();
    /*=========== 接收对端发送过来的文本数据==========
        string &buffer           //<I> 存放接收数据的缓冲区
        const int itimeout=0     //<I>  等待数据的超时时间（秒）：-1-不等待；0-无限等待；>0-等待的秒数。
        bool                    //<return> true-成功；false-失败，失败有两种情况：1）等待超时；2）socket连接已不可用。
    */
    bool read(string &buffer,const int itimeout=0);                         
    /*=========== 接收对端发送过来的二进制数据==========
        void *buffer            //<I> 存放接收数据的缓冲区
        const int ibuflen       //<I> 打算接收数据的大小。
        const int itimeout=0    //<I> 等待数据的超时时间（秒）：-1-不等待；0-无限等待；>0-等待的秒数。
        bool                    //<I> 返回值：true-成功；false-失败，失败有两种情况：1）等待超时；2）socket连接已不可用。
    */
    bool read(void *buffer,const int ibuflen,const int itimeout=0); 
    /*=========== 向对端发送文本数据==========
        const string &buffer    //<I> 发送数据缓冲区
        bool                    //<return> 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。
    */
    bool write(const string &buffer);                   
     /*=========== 向对端发送二进制数据==========
        const void *buffer      //<I> 发送数据缓冲区
        const int ibuflen       //<I> 待发送数据的大小
        bool                    //<return> 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。
    */
    bool write(const void *buffer,const int ibuflen);   
    // 关闭监听的socket，即m_listenfd，常用于多进程服务程序的子进程代码中。
    void closelisten();
    // 关闭客户端的socket，即m_connfd，常用于多进程服务程序的父进程代码中。
    void closeclient();
};



/*===========接收socket的对端发送过来的文本数据==========
    const int sockfd        //<I> 可用的socket连接
    string &buffer          //<I> 接收数据缓冲区的地址
    const int itimeout=0    //<I> 读取数据超时的时间，单位：秒，-1-不等待；0-无限等待；>0-等待的秒数。
    bool                    //<return> 返回值：true-成功；false-失败，失败有两种情况：1）等待超时；2）socket连接已不可用。
*/
bool tcpread(const int sockfd,string &buffer,const int itimeout=0);        
/*===========接收socket的对端发送过来的二进制数据==========
    const int sockfd     //<I> 可用的socket连接
    void *buffer         //<I> 接收数据缓冲区的地址
    const int ibuflen    //<I> 本次成功接收数据的字节数
    const int itimeout=0 //<I>  读取数据超时的时间，单位：秒，-1-不等待；0-无限等待；>0-等待的秒数
    bool                 //<return> 返回值：true-成功；false-失败，失败有两种情况：1）等待超时；2）socket连接已不可用。
*/
bool tcpread(const int sockfd,void *buffer,const int ibuflen,const int itimeout=0);    
/*===========接收socket的对端发送过来的文本数据==========
    const int sockfd        //<I> 可用的socket连接
    const string &buffer    //<I> 待发送数据缓冲区的地址
    bool                    //<return> 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。
*/
bool tcpwrite(const int sockfd,const string &buffer);                          
/*===========接收socket的对端发送过来的二进制数据==========
    const int sockfd       //<I> 可用的socket连接
    const void *buffer     //<I> 待发送数据缓冲区的地址
    const int ibuflen      //<I> 待发送数据的字节数
    bool                   //<return> 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。
*/
bool tcpwrite(const int sockfd,const void *buffer,const int ibuflen);      
/*===========从已经准备好的socket中读取数据==========
   const int sockfd     //<I> 已经准备好的socket连接
   char *buffer         //<I> 存放数据的地址
   const size_t n       //<I> 本次打算读取数据的字节数。
   bool                 //<return> 返回值：成功接收到n字节的数据后返回true，socket连接不可用返回false。
*/
bool readn(const int sockfd,char *buffer,const size_t n);
/*===========向已经准备好的socket中写入数据==========
    const int sockfd    //<I> 已经准备好的socket连接
    const char *buffer  //<I> 待写入数据的地址
    const size_t n      //<I> 待写入数据的字节数
    bool                //<return>  返回值：成功写入完n字节的数据后返回true，socket连接不可用返回false。
*/
bool writen(const int sockfd,const char *buffer,const size_t n);
/*=========== 忽略关闭全部的信号、关闭全部的IO，缺省只忽略信号，不关IO。==========
   bool bcloseio=false  //<I> 是否也关闭IO,缺省不关闭IO
*/
void closeioandsignal(bool bcloseio=false);


template <class TT, int MaxLength>
class squeue
{
private:
    bool m_inited;              // 队列被初始化标志，true-已初始化；false-未初始化。
    TT   m_data[MaxLength];     // 用数组存储循环队列中的元素。
    int  m_head;                // 队列的头指针。
    int  m_tail;                // 队列的尾指针，指向队尾元素。
    int  m_length;              // 队列的实际长度。    
public:
    squeue() { init(); }  
    squeue(const squeue &) = delete;          
    squeue &operator=(const squeue &) = delete; 
public:
    /*===========循环队列的初始化操作。==========
         注意：如果用于共享内存的队列，不会调用构造函数，必须调用此函数初始化。
    */
    void init()  
    { 
        if (m_inited!=true)               // 循环队列的初始化只能执行一次。
        { 
            m_head=0;                      // 头指针。
            m_tail=MaxLength-1;     // 为了方便写代码，初始化时，尾指针指向队列的最后一个位置。
            m_length=0;                   // 队列的实际长度。
            memset(m_data,0,sizeof(m_data));  // 数组元素清零。
            m_inited=true; 
        }
    }
     /*===========元素入队==========
         const TT &ee   //<I> 入队元素
         bool           //<return> 返回值：false-失败；true-成功。
    */
    bool push(const TT &ee)
    {
        if (full() == true)
        {
            cout << "循环队列已满，入队失败。\n"; return false;
        }

        // 先移动队尾指针，然后再拷贝数据。
        m_tail=(m_tail+1)%MaxLength;  // 队尾指针后移。
        m_data[m_tail]=ee;
        m_length++;    

      return true;
    }

    // 求循环队列的长度，返回值：>=0-队列中元素的个数
    int  size()                   
    {
        return m_length;    
    }

    // 判断循环队列是否为空，返回值：true-空，false-非空。
    bool empty()                    
    {
      if (m_length == 0) return true;    

      return false;
    }

    // 判断循环队列是否已满，返回值：true-已满，false-未满。
    bool full()
    {
        if (m_length == MaxLength) return true;    

      return false;
    }

    // 查看队头元素的值，元素不出队。
    TT& front()
    {
        return m_data[m_head];
    }

    // 元素出队，返回值：false-失败；true-成功。
    bool pop()
    {
        if (empty() == true) return false;

        m_head=(m_head+1)%MaxLength;  // 队列头指针后移。
        m_length--;    

        return true;
    }

    // 显示循环队列中全部的元素。
    // 这是一个临时的用于调试的函数，队列中元素的数据类型支持cout输出才可用。
    void printqueue()                    
    {
        for (int ii = 0; ii < size(); ii++)
        {
            cout << "m_data[" << (m_head+ii)%MaxLength << "],value=" \
                 << m_data[(m_head+ii)%MaxLength] << endl;
        }
    }
};
class csemp
{
private:
    union semun  // 用于信号量操作的共同体。
    {
      int val;
      struct semid_ds *buf;
      unsigned short  *arry;
    };

    int   m_semid;         // 信号量id（描述符）。

    // 如果把sem_flg设置为SEM_UNDO，操作系统将跟踪进程对信号量的修改情况，
    // 在全部修改过信号量的进程（正常或异常）终止后，操作系统将把信号量恢复为初始值。
    // 如果信号量用于互斥锁，设置为SEM_UNDO。
    // 如果信号量用于生产消费者模型，设置为0。
    short m_sem_flg;

public:
    csemp(const csemp &) = delete;                     
    csemp &operator=(const csemp &) = delete;  
    csemp():m_semid(-1){}
    ~csemp();
public:
    // 如果信号量已存在，获取信号量；如果信号量不存在，则创建它并初始化为value。
    // 如果用于互斥锁，value填1，sem_flg填SEM_UNDO。
    // 如果用于生产消费者模型，value填0，sem_flg填0。
    bool init(key_t key,unsigned short value=1,short sem_flg=SEM_UNDO);
    // 信号量的P操作，如果信号量的值是0，将阻塞等待，直到信号量的值大于0。
    bool wait(short value=-1);    
    // 信号量的V操作。
    bool post(short value=1);    
    // 获取信号量的值，成功返回信号量的值，失败返回-1。
    int  getvalue();                     
     // 销毁信号量
    bool destroy();                      
};




#pragma endregion
```

:::





:::details 网络通信类和函数实现

```c

void closeioandsignal(bool bcloseio)
{
    int ii=0;

    for (ii=0;ii<64;ii++)
    {
        if (bcloseio==true) close(ii);

        signal(ii,SIG_IGN); 
    }
}
bool ctcpclient::connect(const string &ip,const int port)
{
    // 如果已连接到服务端，则断开，这种处理方法没有特别的原因，不要纠结。
    if (m_connfd!=-1) { ::close(m_connfd); m_connfd=-1; }
 
    // 忽略SIGPIPE信号，防止程序异常退出。
    // 如果send到一个disconnected socket上，内核就会发出SIGPIPE信号。这个信号
    // 的缺省处理方法是终止进程，大多数时候这都不是我们期望的。我们重新定义这
    // 个信号的处理方法，大多数情况是直接屏蔽它。
    signal(SIGPIPE,SIG_IGN);   

    m_ip=ip;
    m_port=port;

    struct hostent* h;
    struct sockaddr_in servaddr;

    if ( (m_connfd = socket(AF_INET,SOCK_STREAM,0) ) < 0) return false;

    if ( !(h = gethostbyname(m_ip.c_str())) )
    {
        ::close(m_connfd);  m_connfd=-1; return false;
    }

    memset(&servaddr,0,sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(m_port);  // 指定服务端的通讯端口
    memcpy(&servaddr.sin_addr,h->h_addr,h->h_length);

    if (::connect(m_connfd, (struct sockaddr *)&servaddr,sizeof(servaddr)) != 0)
    {
        ::close(m_connfd);  m_connfd=-1; return false;
    }

    return true;
}
void ctcpclient::close()
{
    if (m_connfd >= 0) ::close(m_connfd); 

    m_connfd=-1;
    m_port=0;
}
ctcpclient::~ctcpclient()
{
    close();
}

bool ctcpserver::initserver(const unsigned int port,const int backlog)
{
    // 如果服务端的socket>0，关掉它，这种处理方法没有特别的原因，不要纠结。
    if (m_listenfd > 0) { ::close(m_listenfd); m_listenfd=-1; }

    if ( (m_listenfd = socket(AF_INET,SOCK_STREAM,0))<=0) return false;

    // 忽略SIGPIPE信号，防止程序异常退出。
    // 如果往已关闭的socket继续写数据，会产生SIGPIPE信号，它的缺省行为是终止程序，所以要忽略它。
    signal(SIGPIPE,SIG_IGN);   

    // 打开SO_REUSEADDR选项，当服务端连接处于TIME_WAIT状态时可以再次启动服务器，
    // 否则bind()可能会不成功，报：Address already in use。
    int opt = 1; 
    setsockopt(m_listenfd,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(opt));    

    memset(&m_servaddr,0,sizeof(m_servaddr));
    m_servaddr.sin_family = AF_INET;
    m_servaddr.sin_addr.s_addr = htonl(INADDR_ANY);   // 任意ip地址。
    m_servaddr.sin_port = htons(port);
    if (bind(m_listenfd,(struct sockaddr *)&m_servaddr,sizeof(m_servaddr)) != 0 )
    {
        closelisten(); return false;
    }

    if (listen(m_listenfd,backlog) != 0 )
    {
        closelisten(); return false;
    }

    return true;
}

bool ctcpserver::accept()
{
    if (m_listenfd==-1) return false;

    int m_socklen = sizeof(struct sockaddr_in);
    if ((m_connfd=::accept(m_listenfd,(struct sockaddr *)&m_clientaddr,(socklen_t*)&m_socklen)) < 0)
        return false;

    return true;
}

char *ctcpserver::getip()
{
    return(inet_ntoa(m_clientaddr.sin_addr));
}
bool ctcpserver::read(void *buffer,const int ibuflen,const int itimeout) 
{
    if (m_connfd==-1) return false;

    return(tcpread(m_connfd,buffer,ibuflen,itimeout));
}

bool ctcpserver::read(string &buffer,const int itimeout)  
{
    if (m_connfd==-1) return false;

    return(tcpread(m_connfd,buffer,itimeout));
}

bool ctcpclient::read(void *buffer,const int ibuflen,const int itimeout)   
{
    if (m_connfd==-1) return false;

    return(tcpread(m_connfd,buffer,ibuflen,itimeout));
}

bool ctcpclient::read(string &buffer,const int itimeout)  
{
    if (m_connfd==-1) return false;

    return(tcpread(m_connfd,buffer,itimeout));
}

bool ctcpserver::write(const void *buffer,const int ibuflen) 
{
    if (m_connfd==-1) return false;

    return(tcpwrite(m_connfd,(char*)buffer,ibuflen));
}

bool ctcpserver::write(const string &buffer)
{
    if (m_connfd==-1) return false;

    return(tcpwrite(m_connfd,buffer));
}
bool ctcpclient::write(const void *buffer,const int ibuflen)
{
    if (m_connfd==-1) return false;

    return(tcpwrite(m_connfd,(char*)buffer,ibuflen));
}
bool ctcpclient::write(const string &buffer)
{
    if (m_connfd==-1) return false;

    return(tcpwrite(m_connfd,buffer));
}
void ctcpserver::closelisten()
{
    if (m_listenfd >= 0)
    {
        ::close(m_listenfd); m_listenfd=-1;
    }
}
void ctcpserver::closeclient()
{
    if (m_connfd >= 0)
    {
        ::close(m_connfd); m_connfd=-1; 
    }
}
ctcpserver::~ctcpserver()
{
    closelisten(); closeclient();
}
bool tcpread(const int sockfd,void *buffer,const int ibuflen,const int itimeout)   
{
    if (sockfd==-1) return false;

    // 如果itimeout>0，表示需要等待itimeout秒，如果itimeout秒后还没有数据到达，返回false。
    if (itimeout>0)
    {
        struct pollfd fds;
        fds.fd=sockfd;
        fds.events=POLLIN;
        if ( poll(&fds,1,itimeout*1000) <= 0 ) return false;
    }

    // 如果itimeout==-1，表示不等待，立即判断socket的缓冲区中是否有数据，如果没有，返回false。
    if (itimeout==-1)
    {
        struct pollfd fds;
        fds.fd=sockfd;
        fds.events=POLLIN;
        if ( poll(&fds,1,0) <= 0 ) return false;
    }

    // 读取报文内容。
    if (readn(sockfd,(char*)buffer,ibuflen) == false) return false;

    return true;
}
bool tcpread(const int sockfd,string &buffer,const int itimeout)   
{
    if (sockfd==-1) return false;

    // 如果itimeout>0，表示等待itimeout秒，如果itimeout秒后接收缓冲区中还没有数据，返回false。
    if (itimeout>0)
    {
        struct pollfd fds;
        fds.fd=sockfd;
        fds.events=POLLIN;
        if ( poll(&fds,1,itimeout*1000) <= 0 ) return false;
    }

    // 如果itimeout==-1，表示不等待，立即判断socket的接收缓冲区中是否有数据，如果没有，返回false。
    if (itimeout==-1)
    {
        struct pollfd fds;
        fds.fd=sockfd;
        fds.events=POLLIN;
        if ( poll(&fds,1,0) <= 0 ) return false;
    }

    int buflen=0;

    // 先读取报文长度，4个字节。
    if (readn(sockfd,(char*)&buflen,4) == false) return false;

    buffer.resize(buflen);   // 设置buffer的大小。

    // 再读取报文内容。
    if (readn(sockfd,&buffer[0],buflen) == false) return false;

    return true;
}
bool tcpwrite(const int sockfd,const void *buffer,const int ibuflen)     
{
    if (sockfd==-1) return false;

    if (writen(sockfd,(char*)buffer,ibuflen) == false) return false;

    return true;
}
bool tcpwrite(const int sockfd,const string &buffer)     
{
    if (sockfd==-1) return false;

    int buflen=buffer.size();

    // 先发送报头。
    if (writen(sockfd,(char*)&buflen,4) == false) return false;

    // 再发送报文体。
    if (writen(sockfd,buffer.c_str(),buflen) == false) return false;

    return true;
}
bool readn(const int sockfd,char *buffer,const size_t n)
{
    int nleft=n;    // 剩余需要读取的字节数。
    int idx=0;       // 已成功读取的字节数。
    int nread;       // 每次调用recv()函数读到的字节数。

    while(nleft > 0)
    {
        if ( (nread=recv(sockfd,buffer+idx,nleft,0)) <= 0) return false;

        idx=idx+nread;
        nleft=nleft-nread;
    }

    return true;
}
bool writen(const int sockfd,const char *buffer,const size_t n)
{
    int nleft=n;       // 剩余需要写入的字节数。
    int idx=0;          // 已成功写入的字节数。
    int nwritten;      // 每次调用send()函数写入的字节数。
  
    while(nleft > 0 )
    {    
      if ( (nwritten=send(sockfd,buffer+idx,nleft,0)) <= 0) return false;      
    
      nleft=nleft-nwritten;
      idx=idx+nwritten;
    }

    return true;
}
bool csemp::init(key_t key,unsigned short value,short sem_flg)
{
    if (m_semid!=-1) return false; // 如果已经初始化了，不必再次初始化。

    m_sem_flg=sem_flg;

    // 信号量的初始化不能直接用semget(key,1,0666|IPC_CREAT)
    // 因为信号量创建后，初始值是0，如果用于互斥锁，需要把它的初始值设置为1，
    // 而获取信号量则不需要设置初始值，所以，创建信号量和获取信号量的流程不同。

    // 信号量的初始化分三个步骤：
    // 1）获取信号量，如果成功，函数返回。
    // 2）如果失败，则创建信号量。
    // 3) 设置信号量的初始值。

    // 获取信号量。
    if ( (m_semid=semget(key,1,0666)) == -1)
    {
        // 如果信号量不存在，创建它。
        if (errno==ENOENT)
        {
            // 用IPC_EXCL标志确保只有一个进程创建并初始化信号量，其它进程只能获取。
            if ( (m_semid=semget(key,1,0666|IPC_CREAT|IPC_EXCL)) == -1)
            {
                if (errno==EEXIST) // 如果错误代码是信号量已存在，则再次获取信号量。
                {
                    if ( (m_semid=semget(key,1,0666)) == -1)
                    { 
                        perror("init 1 semget()"); return false; 
                    }
                    return true;
                }
                else  // 如果是其它错误，返回失败。
                {
                    perror("init 2 semget()"); return false;
                }
            }

            // 信号量创建成功后，还需要把它初始化成value。
            union semun sem_union;
            sem_union.val = value;   // 设置信号量的初始值。
            if (semctl(m_semid,0,SETVAL,sem_union) <  0) 
            { 
                perror("init semctl()"); return false; 
            }
        }
        else
        { perror("init 3 semget()"); return false; }
    }

    return true;
}
bool csemp::wait(short value)
{
    if (m_semid==-1) return false;

    struct sembuf sem_b;
    sem_b.sem_num = 0;      // 信号量编号，0代表第一个信号量。
    sem_b.sem_op = value;   // P操作的value必须小于0。
    sem_b.sem_flg = m_sem_flg;
    if (semop(m_semid,&sem_b,1) == -1) { perror("p semop()"); return false; }

    return true;
}
bool csemp::post(short value)
{
    if (m_semid==-1) return false;

    struct sembuf sem_b;
    sem_b.sem_num = 0;     // 信号量编号，0代表第一个信号量。
    sem_b.sem_op = value;  // V操作的value必须大于0。
    sem_b.sem_flg = m_sem_flg;
    if (semop(m_semid,&sem_b,1) == -1) { perror("V semop()"); return false; }

    return true;
}
int csemp::getvalue()
{
    return semctl(m_semid,0,GETVAL);
}
bool csemp::destroy()
{
    if (m_semid==-1) return false;

    if (semctl(m_semid,0,IPC_RMID) == -1) { perror("destroy semctl()"); return false; }

    return true;
}
csemp::~csemp()
{
}

```

:::



:::details 网络通信的使用

`ctcpclient`类传输文本数据

```cpp
/*
 *  程序名：demo44.cpp，此程序演示采用开发框架的ctcpclient类传输文本数据（网络通讯的客户端） 
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main(int argc,char *argv[])
{
    if (argc!=3)
    {
        printf("Using:./demo44 ip port\n");
        printf("Sample:./demo44 192.168.150.128 5005\n");
        return -1;
    }

    ctcpclient tcpclient;
    if (tcpclient.connect(argv[1],atoi(argv[2]))==false)     // 向服务端发起连接请求。
    {
        printf("tcpclient.connect(%s,%s) failed.\n",argv[1],argv[2]); return -1;
    }

    string sendbuf,recvbuf;

    for (int ii=0;ii<10;ii++)
    {
        sendbuf=sformat("这是第%d个超级女生。",ii);

        if (tcpclient.write(sendbuf)==false)        // 向服务端发送请求报文。
        {
            printf("tcpclient.write() failed.\n"); break;
        }
        cout << "发送：" << sendbuf << endl;

        sleep(1);

        if (tcpclient.read(recvbuf)==false)         // 接收服务端的回应报文。
        {
            printf("tcpclient.read() failed.\n"); break;
        }
        cout << "接收：" << recvbuf << endl;
    }
}
```

`ctcpserver`类传输文本数据。（网络通讯的服务端） 

```cpp
/*
 *  程序名：demo45.cpp，此程序演示采用开发框架的ctcpserver类传输文本数据。（网络通讯的服务端） 
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main(int argc,char *argv[])
{
    if (argc!=2)
    {
        printf("Using:./demo45 port\n");
        printf("Sample:./demo45 5005\n");
        return -1;
    }

    ctcpserver tcpserver;
    if (tcpserver.initserver(atoi(argv[1]))==false)        // 服务端初始化。
    {
        printf("tcpserver.initserver(%s) failed.\n",argv[1]); return -1;
    }

    if (tcpserver.accept()==false)                                // 等待客户端的连接。
    {
        printf("accept() failed.\n"); return -1;
    }
    cout << "客户端已连接(" << tcpserver.getip() << ")。\n";

    string sendbuf,recvbuf;

    while (true)
    {
        if (tcpserver.read(recvbuf)==false)          // 接收客户端的请求报文。
        {
            printf("tcpserver.read() failed.\n"); break;
        }
        cout << "接收：" << recvbuf << endl;

        sendbuf="ok";
        if (tcpserver.write(sendbuf)==false)        // 向客户端发送回应报文。
        {
            printf("tcpserver.write() failed.\n"); break;
        }
        cout << "发送：" << sendbuf << endl;
    }
}
```

`ctcpclient`类传输二进制数据（网络通讯的客户端）

```cpp
/*
 *  程序名：demo46.cpp，此程序演示采用开发框架的ctcpclient类传输二进制数据（网络通讯的客户端） 
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main(int argc,char *argv[])
{
    if (argc!=3)
    {
        printf("Using:./demo46 ip port\n");
        printf("Sample./demo46 192.168.150.128 5005\n");
        return -1;
    }

    ctcpclient tcpclient;
    if (tcpclient.connect(argv[1],atoi(argv[2]))==false)     // 向服务端发起连接请求。
    {
        printf("tcpclient.connect(%s,%s) failed.\n",argv[1],argv[2]); return -1;
    }

    struct st_girl   // 超女结构体。
    {
        int bh;
        char name[31];
    }stgirl;

    string recvbuf;

    for (int ii=0;ii<10;ii++)
    {
        memset(&stgirl,0,sizeof(stgirl));
        stgirl.bh=ii;
        sprintf(stgirl.name,"西施%d",ii);

        if (tcpclient.write(&stgirl,sizeof(stgirl))==false)        // 向服务端发送请求数据。
        {
            printf("tcpclient.write() failed.\n"); break;
        }
        cout << sformat("发送：bh=%d,name=%s\n",stgirl.bh,stgirl.name);

        sleep(1);

        if (tcpclient.read(recvbuf)==false)         // 接收服务端的回应报文。
        {
            printf("tcpclient.read() failed.\n"); break;
        }
        cout << "接收：" << recvbuf << endl;
    }
}
```

`ctcpserver`类传输二进制数据。（网络通讯的服务端）

```cpp
/*
 *  程序名：demo47.cpp，此程序演示采用开发框架的ctcpserver类传输二进制数据。（网络通讯的服务端）
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main(int argc,char *argv[])
{
    if (argc!=2)
    {
        printf("Using:./demo47 port\n");
        printf("Sample:./demo47 5005\n");
        return -1;
    }

    ctcpserver tcpserver;
    if (tcpserver.initserver(atoi(argv[1]))==false)        // 服务端初始化。
    {
        printf("tcpserver.initserver(%s) failed.\n",argv[1]); return -1;
    }

    if (tcpserver.accept()==false)                                // 等待客户端的连接。
    {
        printf("accept() failed.\n"); return -1;
    }
    cout << "客户端已连接(" << tcpserver.getip() << ")。\n";

    struct st_girl
    {
        int bh;
        char name[31];
    }stgirl;

    string sendbuf;

    while (true)
    {
        if (tcpserver.read(&stgirl,sizeof(stgirl))==false)          // 接收客户端的请求数据。
        {
            printf("tcpserver.read() failed.\n"); break;
        }
        cout << sformat("接收：bh=%d,name=%s\n",stgirl.bh,stgirl.name);

        sendbuf="ok";
        if (tcpserver.write("ok")==false)        // 向客户端发送回应报文。
        {
            printf("tcpserver.write() failed.\n"); break;
        }
        cout << "发送：" << sendbuf << endl;
    }
}
```

:::







tcp的发送和接收

- 发送:把数据放入tcp的发送缓冲区。

- 接收:从tcp的接收缓冲区中取数据。



分包和粘包



分包: tcp报文的大小缺省是1460字节，如果发送缓冲区中的数据超过1460字节，tcp将拆分成多个包发送，如果接收方及时的从接收缓冲区中取走了数据，看上去像就接收到了多个报文。



粘包: tcp接收到数据之后，有序放在接收缓冲区中，数据之间不存在分隔符的说法，如果接收方没有及时的从缓冲区中取走数据看上去就象粘在了一起。



如何区分报文

报文长度(4字节的整数）+报文内容



发送报文的方法

- 先发送报文长度，再发送报文内容。
- 例如:Hello world，先发送11，再发送Hello world。



该封装的`tcpwrite()` `tcpread()` 可以解决分包和粘包的问题。



send函数

- send函数的功能是把待发送的数据拷贝到发送缓冲区。
- 返回值是已拷贝的字节数，正常情况下，与待发送数据的字节数相同。
- 如果发送缓冲区的空间不足，则返回本次已拷贝的字节数。

- 为了保证全部的数据被发送，应该循环调用send函数，直到全部的数据被发送完成。

## 学习要求

- 用demo程序测试开发框架中函数和类的功能，掌握使用方法。
- 除了matchstr函数，把其它函数和类的代码写出来。
- 如果有些写不出来，不要强求。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240324145658342-17112634198342.png)



