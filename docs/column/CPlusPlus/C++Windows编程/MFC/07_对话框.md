# 对话框

## 模态对话框的创建

模态框就是调用了对话框类的`DoModal()` 方法，此时会阻塞在`DoModal()` 方法这里，效果就是父对话框的任何地方都不能点击了，必须关闭了这个模态对话框才可以。

```c{43}

// MyboleView.h: CMyboleView 类的接口
//

#pragma once


class CMyboleView : public CView
{
protected: // 仅从序列化创建
	CMyboleView() noexcept;
	DECLARE_DYNCREATE(CMyboleView)

// 特性
public:
	CMyboleDoc* GetDocument() const;

// 操作
public:

// 重写
public:
	virtual void OnDraw(CDC* pDC);  // 重写以绘制该视图
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

// 实现
public:
	virtual ~CMyboleView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// 生成的消息映射函数
protected:
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnDialog();
};

#ifndef _DEBUG  // MyboleView.cpp 中的调试版本
inline CMyboleDoc* CMyboleView::GetDocument() const
   { return reinterpret_cast<CMyboleDoc*>(m_pDocument); }
#endif


```

```c{6,11-13}
BEGIN_MESSAGE_MAP(CMyboleView, CView)
	// 标准打印命令
	ON_COMMAND(ID_FILE_PRINT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, &CView::OnFilePrintPreview)
	ON_COMMAND(IDM_DIALOG, &CMyboleView::OnDialog)
END_MESSAGE_MAP()
    
void CMyboleView::OnDialog()
{
	CTestDlg dlg;
	dlg.DoModal();

}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412204643421.png)



## 非模态对话框的创建

非模态对话框更好，实际开发我们更期望使用非模态对话框。这样他不会阻塞到夫对话库的操作。非模态对话框，需要我们去放大他的变量作用域，要么放在堆区管理，要么定义为类成员。

```c{46}

// MyboleView.h: CMyboleView 类的接口
//

#pragma once
#include "TestDlg.h"

class CMyboleView : public CView
{
protected: // 仅从序列化创建
	CMyboleView() noexcept;
	DECLARE_DYNCREATE(CMyboleView)

// 特性
public:
	CMyboleDoc* GetDocument() const;

// 操作
public:

// 重写
public:
	virtual void OnDraw(CDC* pDC);  // 重写以绘制该视图
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

// 实现
public:
	virtual ~CMyboleView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// 生成的消息映射函数
protected:
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnDialog();

public:
	CTestDlg dlg;
};

#ifndef _DEBUG  // MyboleView.cpp 中的调试版本
inline CMyboleDoc* CMyboleView::GetDocument() const
   { return reinterpret_cast<CMyboleDoc*>(m_pDocument); }
#endif
```

```c{3-10}
void CMyboleView::OnDialog()
{
	//方法1：定义成类属性
	//dlg.Create(IDD_DIALOG1, this);
	//dlg.ShowWindow(SW_SHOW);

   //方法2:定义成指针，将对话框资源内存放在堆区管理(有内存泄漏BUG)
	CTestDlg *pDlg = new CTestDlg;
	pDlg->Create(IDD_DIALOG1, this);
	pDlg->ShowWindow(SW_SHOW);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412205840642.png)

方法2有设计缺陷，因为说没有把指向CTestDlg内存的指针保存起来，我们后续无法释放内存。



:::details 释放内存方案

解决方案1：定义为父类的成员变量，delete时进行释放内存。

```c{46}

// MyboleView.h: CMyboleView 类的接口
//

#pragma once
#include "TestDlg.h"

class CMyboleView : public CView
{
protected: // 仅从序列化创建
	CMyboleView() noexcept;
	DECLARE_DYNCREATE(CMyboleView)

// 特性
public:
	CMyboleDoc* GetDocument() const;

// 操作
public:

// 重写
public:
	virtual void OnDraw(CDC* pDC);  // 重写以绘制该视图
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

// 实现
public:
	virtual ~CMyboleView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// 生成的消息映射函数
protected:
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnDialog();

public:
	CTestDlg* pDlg;
};

#ifndef _DEBUG  // MyboleView.cpp 中的调试版本
inline CMyboleDoc* CMyboleView::GetDocument() const
   { return reinterpret_cast<CMyboleDoc*>(m_pDocument); }
#endif

```

```c
CMyboleView::~CMyboleView()
{
	if (pDlg)
	{
		delete pDlg;
		pDlg = nullptr;
	}
}
void CMyboleView::OnDialog()
{
	
	pDlg = new CTestDlg;
	pDlg->Create(IDD_DIALOG1, this);
	pDlg->ShowWindow(SW_SHOW);

}
```

解决方案2：重写CTestDlg中的`PostNcDestroy()`

```c{23}
#pragma once


// CTestDlg 对话框

class CTestDlg : public CDialog
{
	DECLARE_DYNAMIC(CTestDlg)

public:
	CTestDlg(CWnd* pParent = nullptr);   // 标准构造函数
	virtual ~CTestDlg();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_DIALOG1 };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
	virtual void PostNcDestroy();
public:
	afx_msg void OnBnClickedBtnAdd();
private:
	CButton m_btn;
	BOOL m_bIsCreated;
public:
	afx_msg void OnStnClickedNumber1();
private:
//	int m_num1;
//	int m_num2;
	int m_num3;
	int m_num1;
	int m_num2;
	CEdit m_edit1;
	CEdit m_edit2;
	CEdit m_edit3;
public:
	afx_msg void OnBnClickedButton2();
//	afx_msg void OnBnClickedButton3();
	//afx_msg void OnBnClickedOk();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
};

```

加入`delete this` 用于删除this指向的内存

```c{3}
void CTestDlg::PostNcDestroy()
{
	delete this;
	CDialog::PostNcDestroy();
}
```

这样指针定义成局部也可以。

```c

	void CMyboleView::OnDialog()
	{
		CTestDlg* pDlg;
		pDlg = new CTestDlg;
		pDlg->Create(IDD_DIALOG1, this);
		pDlg->ShowWindow(SW_SHOW);

	}
```



:::



## 动态创建按钮

下面，我们要实现这样的功能:当单击对话框中某个按钮时，就在对话框中动态创建一个新按钮。



当再次单击Add按钮时，它又重复创建一个窗口并试图与`m_btn`这个对象相关联，但因为此时m_btn这个对象已经和一个窗口绑定在--起了，因此就会出现非法操作。

```c{}
void CTestDlg::OnBnClickedBtnAdd()
{
	m_btn.Create(L"New", BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD,
		CRect(0, 0, 100, 100), this, 123);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412211637098.png)



:::details 处理重复创建窗口引发报错

解决方案1：维护一个创建标识，如果创建了则销毁。已解除CButton对象和窗口句柄之间的关联。这个标识量可以是类全局，也可以是静态全局。

```c{27,28}
#pragma once


// CTestDlg 对话框

class CTestDlg : public CDialog
{
	DECLARE_DYNAMIC(CTestDlg)

public:
	CTestDlg(CWnd* pParent = nullptr);   // 标准构造函数
	virtual ~CTestDlg();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_DIALOG1 };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
	virtual void PostNcDestroy();
public:
	afx_msg void OnBnClickedBtnAdd();
private:
	CButton m_btn;
	BOOL m_bIsCreated;
public:
	afx_msg void OnStnClickedNumber1();
private:
	int m_num3;
	int m_num1;
	int m_num2;
	CEdit m_edit1;
	CEdit m_edit2;
	CEdit m_edit3;
public:
	afx_msg void OnBnClickedButton2();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
};
```

```c{2,10}
BEGIN_MESSAGE_MAP(CTestDlg, CDialog)
	ON_BN_CLICKED(IDC_BTN_ADD, &CTestDlg::OnBnClickedBtnAdd)
END_MESSAGE_MAP()
CTestDlg::CTestDlg(CWnd* pParent /*=nullptr*/)
	: CDialog(IDD_DIALOG1, pParent)
	, m_num1(0)
	, m_num2(0)
	, m_num3(0)
{
	m_bIsCreated = FALSE;
}
 
void CTestDlg::OnBnClickedBtnAdd()
{
		if (m_bIsCreated == FALSE)
		{
			m_btn.Create(L"New", BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD,
				CRect(0, 0, 100, 100), this, 123);
			m_bIsCreated = TRUE;
		}
		else
		{
			m_btn.DestroyWindow();
			m_bIsCreated = FALSE;
		}
}	
```

静态局部全局：

```c
void CTestDlg::OnBnClickedBtnAdd()
{
	static BOOL m_bIsCreated = FALSE;
		if (m_bIsCreated == FALSE)
		{
			m_btn.Create(L"New", BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD,
				CRect(0, 0, 100, 100), this, 123);
			m_bIsCreated = TRUE;
		}
		else
		{
			m_btn.DestroyWindow();
			m_bIsCreated = FALSE;
		}
}	
```

解决方案2：下面利用一种更直接的方法来实现这种判断。根据前面的知识，我们知道CWnd对象都有一个成员变量:m_hWnd，用来保存与窗口对象相关联的窗口句柄。如果窗口对象没有与任一个窗口相关联，这个句柄就为NUILL。因此，代码也可以这样书写

```c

void CTestDlg::OnBnClickedBtnAdd()
{
	if (!m_btn.m_hWnd)
	{
		m_btn.Create(L"New", BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD,
			CRect(0, 0, 100, 100), this, 123);
	}
	else
	{
		m_btn.DestroyWindow();
	}
}
```

:::



## 控件的访问

```c{25}
#pragma once


// CTestDlg 对话框

class CTestDlg : public CDialog
{
	DECLARE_DYNAMIC(CTestDlg)

public:
	CTestDlg(CWnd* pParent = nullptr);   // 标准构造函数
	virtual ~CTestDlg();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_DIALOG1 };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
	virtual void PostNcDestroy();
public:
	afx_msg void OnBnClickedBtnAdd();
private:
	CButton m_btn;
	BOOL m_bIsCreated;
public:
	afx_msg void OnStnClickedNumber1();
private:
	int m_num3;
	int m_num1;
	int m_num2;
	CEdit m_edit1;
	CEdit m_edit2;
	CEdit m_edit3;
public:
	afx_msg void OnBnClickedButton2();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
};
```



```c{2,7-8}
BEGIN_MESSAGE_MAP(CTestDlg, CDialog)
	ON_STN_CLICKED(IDC_NUMBER1, &CTestDlg::OnStnClickedNumber1)
END_MESSAGE_MAP()
void CTestDlg::OnStnClickedNumber1()
{
	CString str; 
	//通过ID查CTestDlg中的子窗口控件  GetDlgItem
	//GetWindowText SetWindowText 设置窗口名
	if (GetDlgItem(IDC_NUMBER1)->GetWindowText(str), str == L"Number1：")
	{
		GetDlgItem(IDC_NUMBER1)->SetWindowText(L"数值1：");
	}
	else
	{
		GetDlgItem(IDC_NUMBER1)->SetWindowText(L"Number1：");
	}

}
```

有一点需要注意: if 语句中使用了一条**逗号表达式**。逗号表达式的结果是最后一个表达式的返回值，这里就是指判断字符串是否相等的那条语句的返回值。





IDC_NUMBER1静态文本控件上单击鼠标左键，即可实现文本的改变。因此，为了使一个静态文本控件能够响应鼠标单击消息，那么需要进行两个特殊的步骤:第一步，改变它的ID;第二步，在它的属性对话框中选中Notify选项。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412214145940.png)





## 编辑框控件

为了对前两个编辑框中的数字求和，那么首先就要获得这两个编辑框中的内容。同时，可以利用`SetWindowText`函数将求和结果显示在第三个编辑框中。

```c{5-7,12-13}
void CTestDlg::OnBnClickedBtnAdd()
{
	int num1, num2, num3 =0;
	TCHAR ch1[10], ch2[10], ch3[10] = {0};
	//查编辑框文本值
	GetDlgItem(IDC_EDIT1)->GetWindowText(ch1, 10);
	GetDlgItem(IDC_EDIT2)->GetWindowText(ch2, 10);
	num1 = _tstoi(ch1);
	num2 = _tstoi(ch2);
	num3 = num1 + num2;
	_itot_s(num3, ch3, 10);
	//设置编辑框文本值
	GetDlgItem(IDC_EDIT3)->SetWindowText(ch3);
}
```

利用`GetDlgltemText`和`SetDlgltemText`函数

```c{5-7,12-13}

void CTestDlg::OnBnClickedBtnAdd()
{
	int num1, num2, num3 = 0;
	TCHAR ch1[10], ch2[10], ch3[10] = TEXT("\0");
	//查编辑框文本值
	GetDlgItemText(IDC_EDIT1, ch1, 10);
	GetDlgItemText(IDC_EDIT2, ch2, 10);
	num1 = _tstoi(ch1);
	num2 = _tstoi(ch2);
	num3 = num1 + num2;
	_itot_s(num3, ch3, 10);
	//设置编辑框文本值
	SetDlgItemText(IDC_EDIT3, ch3);
}	
```

`GetDlgItemInt`和 `SetDlgItemInt`来实现上述功能。

```c{4-5,7}
void CTestDlg::OnBnClickedBtnAdd()
{
	int num1, num2, num3 = 0;
	num1 = GetDlgItemInt(IDC_EDIT1);
	num2 = GetDlgItemInt(IDC_EDIT2);
	num3 = num1 + num2;
	SetDlgItemInt(IDC_EDIT3, num3);
}
```

将这三个编辑框分别与对话框类的三个成员变量相关联，然后通过这些成员变量来检索和设置编辑框的文本，这是最简单的访问控件的方式。



我们通过添加变量的方式，来建立控件和类成员变量的绑定。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412215722522.png)

MFC框架底层会自动帮我们生成关联代码。

```c{29-31}
#pragma once


// CTestDlg 对话框

class CTestDlg : public CDialog
{
	DECLARE_DYNAMIC(CTestDlg)

public:
	CTestDlg(CWnd* pParent = nullptr);   // 标准构造函数
	virtual ~CTestDlg();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_DIALOG1 };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
	virtual void PostNcDestroy();
public:
	afx_msg void OnBnClickedBtnAdd();
public:
	afx_msg void OnStnClickedNumber1();
private:
	int m_num1;
	int m_num2;
	int m_num3;
public:
	afx_msg void OnBnClickedButton2();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
};
```

```c{3-5,12-14,19-21}
CTestDlg::CTestDlg(CWnd* pParent /*=nullptr*/)
	: CDialog(IDD_DIALOG1, pParent)
	, m_num1(0)
	, m_num2(0)
	, m_num3(0)
{
}

void CTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_EDIT1, m_num1);
	DDX_Text(pDX, IDC_EDIT2, m_num2);
	DDX_Text(pDX, IDC_EDIT3, m_num3);
}

void CTestDlg::OnBnClickedBtnAdd()
{
	UpdateData(); //获取控件值注入到关联的类变量
	m_num3 = m_num1 + m_num2;
	UpdateData(FALSE); //将类变量数据更新到UI
}
```

这时，如果在前两个编辑框的任一个中输入一个非数值型的字符，程序会弹出一个对话框，提示:"请键入一个整数".

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412220543493-17129307455941.png)



可是我们并没有编写过这个提示功能，这里为什么会出现这样一个提示对话框?实际上，这是因为我们把编辑框控件与一个int型的变量相关联了，这样，当输入的内容不是数值时，程序就会弹出这样的提示信息框。



另外，还可以对编辑框控件中输入的数值设定一个范围。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412220744228.png)



ClassWizard又在程序的 DoDataExchange函数中添加了几行代码。

```c{7-9}
void CTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_EDIT1, m_num1);
	DDX_Text(pDX, IDC_EDIT2, m_num2);
	DDX_Text(pDX, IDC_EDIT3, m_num3);
	//编辑框控件中输入的数值设定一个范围
	DDV_MinMaxInt(pDX, m_num1, 0, 100);
	DDV_MinMaxInt(pDX, m_num2, 0, 100);	
}
```

下面，我们把编辑框控件再与一个变量相关联，但与上面不同的是，此次关联的是一个控件变量，即代表**控件本身**。

```c{32-34}
#pragma once


// CTestDlg 对话框

class CTestDlg : public CDialog
{
	DECLARE_DYNAMIC(CTestDlg)

public:
	CTestDlg(CWnd* pParent = nullptr);   // 标准构造函数
	virtual ~CTestDlg();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_DIALOG1 };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
	virtual void PostNcDestroy();
public:
	afx_msg void OnBnClickedBtnAdd();
private:
	CButton m_btn;
	BOOL m_bIsCreated;
public:
	afx_msg void OnStnClickedNumber1();
private:
	CEdit m_edit1;
	CEdit m_edit2;
	CEdit m_edit3;
public:
	afx_msg void OnBnClickedButton2();
//	afx_msg void OnBnClickedButton3();
	//afx_msg void OnBnClickedOk();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
};
```

```c
void CTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);

	DDX_Control(pDX, IDC_EDIT1, m_edit1);
	DDX_Control(pDX, IDC_EDIT2, m_edit2);
	DDX_Control(pDX, IDC_EDIT3, m_edit3);
}
```

因为这些控件变量代表的就是控件本身，并且CEdit类派生于CWnd类，因此，可以利用这些控件变量调用`GetWindowText`和`SetWindowText`这两个函数来获取和设置编辑框的文本。

```c
void CTestDlg::OnBnClickedBtnAdd()
{
	int num1, num2, num3 = 0;
	TCHAR ch1[10], ch2[10], ch3[10] = {0};
	m_edit1.GetWindowText(ch1, 10);
	m_edit2.GetWindowText(ch2, 10);
	num1 = _tstoi(ch1);
	num2 = _tstoi(ch2);
	num3 = num1 + num2;
	_itot_s(num3, ch3, 10);
	m_edit3.SetWindowText(ch3);
}	
```

Windows程序都是基于消息的系统，因此，为了获取或设置窗口的