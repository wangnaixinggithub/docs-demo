# 对话框

## 模态对话框的创建

模态框就是调用了对话框类的`DoModal()` 方法，此时会阻塞在`DoModal()` 方法这里，效果就是父对话框的任何地方都不能点击了，必须关闭了这个模态对话框才可以。

```c{43}

// MyboleView.h: CMyboleView 类的接口
//

#pragma once


class CMyboleView : public CView
{
protected: // 仅从序列化创建
	CMyboleView() noexcept;
	DECLARE_DYNCREATE(CMyboleView)

// 特性
public:
	CMyboleDoc* GetDocument() const;

// 操作
public:

// 重写
public:
	virtual void OnDraw(CDC* pDC);  // 重写以绘制该视图
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

// 实现
public:
	virtual ~CMyboleView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// 生成的消息映射函数
protected:
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnDialog();
};

#ifndef _DEBUG  // MyboleView.cpp 中的调试版本
inline CMyboleDoc* CMyboleView::GetDocument() const
   { return reinterpret_cast<CMyboleDoc*>(m_pDocument); }
#endif


```

```c{6,11-13}
BEGIN_MESSAGE_MAP(CMyboleView, CView)
	// 标准打印命令
	ON_COMMAND(ID_FILE_PRINT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, &CView::OnFilePrintPreview)
	ON_COMMAND(IDM_DIALOG, &CMyboleView::OnDialog)
END_MESSAGE_MAP()
    
void CMyboleView::OnDialog()
{
	CTestDlg dlg;
	dlg.DoModal();

}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412204643421.png)



## 非模态对话框的创建

非模态对话框更好，实际开发我们更期望使用非模态对话框。这样他不会阻塞到夫对话库的操作。非模态对话框，需要我们去放大他的变量作用域，要么放在堆区管理，要么定义为类成员。

```c{46}

// MyboleView.h: CMyboleView 类的接口
//

#pragma once
#include "TestDlg.h"

class CMyboleView : public CView
{
protected: // 仅从序列化创建
	CMyboleView() noexcept;
	DECLARE_DYNCREATE(CMyboleView)

// 特性
public:
	CMyboleDoc* GetDocument() const;

// 操作
public:

// 重写
public:
	virtual void OnDraw(CDC* pDC);  // 重写以绘制该视图
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

// 实现
public:
	virtual ~CMyboleView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// 生成的消息映射函数
protected:
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnDialog();

public:
	CTestDlg dlg;
};

#ifndef _DEBUG  // MyboleView.cpp 中的调试版本
inline CMyboleDoc* CMyboleView::GetDocument() const
   { return reinterpret_cast<CMyboleDoc*>(m_pDocument); }
#endif
```

```c{3-10}
void CMyboleView::OnDialog()
{
	//方法1：定义成类属性
	//dlg.Create(IDD_DIALOG1, this);
	//dlg.ShowWindow(SW_SHOW);

   //方法2:定义成指针，将对话框资源内存放在堆区管理(有内存泄漏BUG)
	CTestDlg *pDlg = new CTestDlg;
	pDlg->Create(IDD_DIALOG1, this);
	pDlg->ShowWindow(SW_SHOW);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412205840642.png)

方法2有设计缺陷，因为说没有把指向CTestDlg内存的指针保存起来，我们后续无法释放内存。



:::details 释放内存方案

解决方案1：定义为父类的成员变量，delete时进行释放内存。

```c{46}

// MyboleView.h: CMyboleView 类的接口
//

#pragma once
#include "TestDlg.h"

class CMyboleView : public CView
{
protected: // 仅从序列化创建
	CMyboleView() noexcept;
	DECLARE_DYNCREATE(CMyboleView)

// 特性
public:
	CMyboleDoc* GetDocument() const;

// 操作
public:

// 重写
public:
	virtual void OnDraw(CDC* pDC);  // 重写以绘制该视图
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

// 实现
public:
	virtual ~CMyboleView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// 生成的消息映射函数
protected:
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnDialog();

public:
	CTestDlg* pDlg;
};

#ifndef _DEBUG  // MyboleView.cpp 中的调试版本
inline CMyboleDoc* CMyboleView::GetDocument() const
   { return reinterpret_cast<CMyboleDoc*>(m_pDocument); }
#endif

```

在析构函数，释放掉内存。

```c{3-7,12}
CMyboleView::~CMyboleView()
{
	if (pDlg)
	{
		delete pDlg;
		pDlg = nullptr;
	}
}
void CMyboleView::OnDialog()
{
	
	pDlg = new CTestDlg;
	pDlg->Create(IDD_DIALOG1, this);
	pDlg->ShowWindow(SW_SHOW);

}
```

解决方案2：重写CTestDlg中的`PostNcDestroy()`

```c{23}
#pragma once


// CTestDlg 对话框

class CTestDlg : public CDialog
{
	DECLARE_DYNAMIC(CTestDlg)

public:
	CTestDlg(CWnd* pParent = nullptr);   // 标准构造函数
	virtual ~CTestDlg();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_DIALOG1 };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
	virtual void PostNcDestroy();
public:
	afx_msg void OnBnClickedBtnAdd();
private:
	CButton m_btn;
	BOOL m_bIsCreated;
public:
	afx_msg void OnStnClickedNumber1();
private:
//	int m_num1;
//	int m_num2;
	int m_num3;
	int m_num1;
	int m_num2;
	CEdit m_edit1;
	CEdit m_edit2;
	CEdit m_edit3;
public:
	afx_msg void OnBnClickedButton2();
//	afx_msg void OnBnClickedButton3();
	//afx_msg void OnBnClickedOk();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
};

```

加入`delete this` 用于删除this指向的内存

```c{3}
void CTestDlg::PostNcDestroy()
{
	delete this;
	CDialog::PostNcDestroy();
}
```

这样指针定义成局部也可以。

```c

	void CMyboleView::OnDialog()
	{
		CTestDlg* pDlg;
		pDlg = new CTestDlg;
		pDlg->Create(IDD_DIALOG1, this);
		pDlg->ShowWindow(SW_SHOW);

	}
```



:::



## 动态创建按钮

下面，我们要实现这样的功能:当单击对话框中某个按钮时，就在对话框中动态创建一个新按钮。



当再次单击Add按钮时，它又重复创建一个窗口并试图与`m_btn`这个对象相关联，但因为此时m_btn这个对象已经和一个窗口绑定在--起了，因此就会出现非法操作。

```c{}
void CTestDlg::OnBnClickedBtnAdd()
{
	m_btn.Create(L"New", BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD,
		CRect(0, 0, 100, 100), this, 123);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412211637098.png)



:::details 处理重复创建窗口引发报错

解决方案1：维护一个创建标识，如果创建了则销毁。已解除CButton对象和窗口句柄之间的关联。这个标识量可以是类全局，也可以是静态全局。

```c{27,28}
#pragma once


// CTestDlg 对话框

class CTestDlg : public CDialog
{
	DECLARE_DYNAMIC(CTestDlg)

public:
	CTestDlg(CWnd* pParent = nullptr);   // 标准构造函数
	virtual ~CTestDlg();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_DIALOG1 };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
	virtual void PostNcDestroy();
public:
	afx_msg void OnBnClickedBtnAdd();
private:
	CButton m_btn;
	BOOL m_bIsCreated;
public:
	afx_msg void OnStnClickedNumber1();
private:
	int m_num3;
	int m_num1;
	int m_num2;
	CEdit m_edit1;
	CEdit m_edit2;
	CEdit m_edit3;
public:
	afx_msg void OnBnClickedButton2();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
};
```

```c{2,10}
BEGIN_MESSAGE_MAP(CTestDlg, CDialog)
	ON_BN_CLICKED(IDC_BTN_ADD, &CTestDlg::OnBnClickedBtnAdd)
END_MESSAGE_MAP()
CTestDlg::CTestDlg(CWnd* pParent /*=nullptr*/)
	: CDialog(IDD_DIALOG1, pParent)
	, m_num1(0)
	, m_num2(0)
	, m_num3(0)
{
	m_bIsCreated = FALSE;
}
 
void CTestDlg::OnBnClickedBtnAdd()
{
		if (m_bIsCreated == FALSE)
		{
			m_btn.Create(L"New", BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD,
				CRect(0, 0, 100, 100), this, 123);
			m_bIsCreated = TRUE;
		}
		else
		{
			m_btn.DestroyWindow();
			m_bIsCreated = FALSE;
		}
}	
```

静态局部全局：

```c
void CTestDlg::OnBnClickedBtnAdd()
{
	static BOOL m_bIsCreated = FALSE;
		if (m_bIsCreated == FALSE)
		{
			m_btn.Create(L"New", BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD,
				CRect(0, 0, 100, 100), this, 123);
			m_bIsCreated = TRUE;
		}
		else
		{
			m_btn.DestroyWindow();
			m_bIsCreated = FALSE;
		}
}	
```

解决方案2：下面利用一种更直接的方法来实现这种判断。根据前面的知识，我们知道CWnd对象都有一个成员变量:m_hWnd，用来保存与窗口对象相关联的窗口句柄。如果窗口对象没有与任一个窗口相关联，这个句柄就为NUILL。因此，代码也可以这样书写

```c

void CTestDlg::OnBnClickedBtnAdd()
{
	if (!m_btn.m_hWnd)
	{
		m_btn.Create(L"New", BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD,
			CRect(0, 0, 100, 100), this, 123);
	}
	else
	{
		m_btn.DestroyWindow();
	}
}
```

:::



## 控件的访问

```c{25}
#pragma once


// CTestDlg 对话框

class CTestDlg : public CDialog
{
	DECLARE_DYNAMIC(CTestDlg)

public:
	CTestDlg(CWnd* pParent = nullptr);   // 标准构造函数
	virtual ~CTestDlg();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_DIALOG1 };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
	virtual void PostNcDestroy();
public:
	afx_msg void OnBnClickedBtnAdd();
private:
	CButton m_btn;
	BOOL m_bIsCreated;
public:
	afx_msg void OnStnClickedNumber1();
private:
	int m_num3;
	int m_num1;
	int m_num2;
	CEdit m_edit1;
	CEdit m_edit2;
	CEdit m_edit3;
public:
	afx_msg void OnBnClickedButton2();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
};
```



```c{2,7-8}
BEGIN_MESSAGE_MAP(CTestDlg, CDialog)
	ON_STN_CLICKED(IDC_NUMBER1, &CTestDlg::OnStnClickedNumber1)
END_MESSAGE_MAP()
void CTestDlg::OnStnClickedNumber1()
{
	CString str; 
	//通过ID查CTestDlg中的子窗口控件  GetDlgItem
	//GetWindowText SetWindowText 设置窗口名
	if (GetDlgItem(IDC_NUMBER1)->GetWindowText(str), str == L"Number1：")
	{
		GetDlgItem(IDC_NUMBER1)->SetWindowText(L"数值1：");
	}
	else
	{
		GetDlgItem(IDC_NUMBER1)->SetWindowText(L"Number1：");
	}

}
```

有一点需要注意: if 语句中使用了一条**逗号表达式**。逗号表达式的结果是最后一个表达式的返回值，这里就是指判断字符串是否相等的那条语句的返回值。





IDC_NUMBER1静态文本控件上单击鼠标左键，即可实现文本的改变。因此，为了使一个静态文本控件能够响应鼠标单击消息，那么需要进行两个特殊的步骤:第一步，改变它的ID;第二步，在它的属性对话框中选中Notify选项。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412214145940.png)





## 编辑框控件

为了对前两个编辑框中的数字求和，那么首先就要获得这两个编辑框中的内容。同时，可以利用`SetWindowText`函数将求和结果显示在第三个编辑框中。

```c{5-7,12-13}
void CTestDlg::OnBnClickedBtnAdd()
{
	int num1, num2, num3 =0;
	TCHAR ch1[10], ch2[10], ch3[10] = {0};
	//查编辑框文本值
	GetDlgItem(IDC_EDIT1)->GetWindowText(ch1, 10);
	GetDlgItem(IDC_EDIT2)->GetWindowText(ch2, 10);
	num1 = _tstoi(ch1);
	num2 = _tstoi(ch2);
	num3 = num1 + num2;
	_itot_s(num3, ch3, 10);
	//设置编辑框文本值
	GetDlgItem(IDC_EDIT3)->SetWindowText(ch3);
}
```

利用`GetDlgltemText`和`SetDlgltemText`函数

```c{5-7,12-13}

void CTestDlg::OnBnClickedBtnAdd()
{
	int num1, num2, num3 = 0;
	TCHAR ch1[10], ch2[10], ch3[10] = TEXT("\0");
	//查编辑框文本值
	GetDlgItemText(IDC_EDIT1, ch1, 10);
	GetDlgItemText(IDC_EDIT2, ch2, 10);
	num1 = _tstoi(ch1);
	num2 = _tstoi(ch2);
	num3 = num1 + num2;
	_itot_s(num3, ch3, 10);
	//设置编辑框文本值
	SetDlgItemText(IDC_EDIT3, ch3);
}	
```

`GetDlgItemInt`和 `SetDlgItemInt`来实现上述功能。

```c{4-5,7}
void CTestDlg::OnBnClickedBtnAdd()
{
	int num1, num2, num3 = 0;
	num1 = GetDlgItemInt(IDC_EDIT1);
	num2 = GetDlgItemInt(IDC_EDIT2);
	num3 = num1 + num2;
	SetDlgItemInt(IDC_EDIT3, num3);
}
```

将这三个编辑框分别与对话框类的三个成员变量相关联，然后通过这些成员变量来检索和设置编辑框的文本，这是最简单的访问控件的方式。



我们通过添加变量的方式，来建立控件和类成员变量的绑定。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412215722522.png)

MFC框架底层会自动帮我们生成关联代码。

```c{29-31}
#pragma once


// CTestDlg 对话框

class CTestDlg : public CDialog
{
	DECLARE_DYNAMIC(CTestDlg)

public:
	CTestDlg(CWnd* pParent = nullptr);   // 标准构造函数
	virtual ~CTestDlg();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_DIALOG1 };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
	virtual void PostNcDestroy();
public:
	afx_msg void OnBnClickedBtnAdd();
public:
	afx_msg void OnStnClickedNumber1();
private:
	int m_num1;
	int m_num2;
	int m_num3;
public:
	afx_msg void OnBnClickedButton2();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
};
```

```c{3-5,12-14,19-21}
CTestDlg::CTestDlg(CWnd* pParent /*=nullptr*/)
	: CDialog(IDD_DIALOG1, pParent)
	, m_num1(0)
	, m_num2(0)
	, m_num3(0)
{
}

void CTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_EDIT1, m_num1);
	DDX_Text(pDX, IDC_EDIT2, m_num2);
	DDX_Text(pDX, IDC_EDIT3, m_num3);
}

void CTestDlg::OnBnClickedBtnAdd()
{
	UpdateData(); //获取控件值注入到关联的类变量
	m_num3 = m_num1 + m_num2;
	UpdateData(FALSE); //将类变量数据更新到UI
}
```

这时，如果在前两个编辑框的任一个中输入一个非数值型的字符，程序会弹出一个对话框，提示:"请键入一个整数".

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412220543493-17129307455941.png)



可是我们并没有编写过这个提示功能，这里为什么会出现这样一个提示对话框?实际上，这是因为我们把编辑框控件与一个int型的变量相关联了，这样，当输入的内容不是数值时，程序就会弹出这样的提示信息框。



另外，还可以对编辑框控件中输入的数值设定一个范围。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240412220744228.png)



ClassWizard又在程序的 DoDataExchange函数中添加了几行代码。

```c{7-9}
void CTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_EDIT1, m_num1);
	DDX_Text(pDX, IDC_EDIT2, m_num2);
	DDX_Text(pDX, IDC_EDIT3, m_num3);
	//编辑框控件中输入的数值设定一个范围
	DDV_MinMaxInt(pDX, m_num1, 0, 100);
	DDV_MinMaxInt(pDX, m_num2, 0, 100);	
}
```

下面，我们把编辑框控件再与一个变量相关联，但与上面不同的是，此次关联的是一个控件变量，即代表**控件本身**。

```c{32-34}
#pragma once


// CTestDlg 对话框

class CTestDlg : public CDialog
{
	DECLARE_DYNAMIC(CTestDlg)

public:
	CTestDlg(CWnd* pParent = nullptr);   // 标准构造函数
	virtual ~CTestDlg();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_DIALOG1 };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
	virtual void PostNcDestroy();
public:
	afx_msg void OnBnClickedBtnAdd();
private:
	CButton m_btn;
	BOOL m_bIsCreated;
public:
	afx_msg void OnStnClickedNumber1();
private:
	CEdit m_edit1;
	CEdit m_edit2;
	CEdit m_edit3;
public:
	afx_msg void OnBnClickedButton2();
//	afx_msg void OnBnClickedButton3();
	//afx_msg void OnBnClickedOk();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
};
```

```c
void CTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);

	DDX_Control(pDX, IDC_EDIT1, m_edit1);
	DDX_Control(pDX, IDC_EDIT2, m_edit2);
	DDX_Control(pDX, IDC_EDIT3, m_edit3);
}
```

因为这些控件变量代表的就是控件本身，并且CEdit类派生于CWnd类，因此，可以利用这些控件变量调用`GetWindowText`和`SetWindowText`这两个函数来获取和设置编辑框的文本。

```c
void CTestDlg::OnBnClickedBtnAdd()
{
	int num1, num2, num3 = 0;
	TCHAR ch1[10], ch2[10], ch3[10] = {0};
	m_edit1.GetWindowText(ch1, 10);
	m_edit2.GetWindowText(ch2, 10);
	num1 = _tstoi(ch1);
	num2 = _tstoi(ch2);
	num3 = num1 + num2;
	_itot_s(num3, ch3, 10);
	m_edit3.SetWindowText(ch3);
}	
```

Windows程序都是基于消息的系统，因此，为了获取或设置窗口的文本，就可以通过`SendMessage`来发送这条消息，从而获取或设置窗口的文本。

```c
void CTestDlg::OnBnClickedBtnAdd()
{	
	int num1, num2, num3;
	TCHAR ch1[10], ch2[10], ch3[10];

	::SendMessage(GetDlgItem(IDC_EDIT1)->m_hWnd, WM_GETTEXT, 10, (LPARAM)ch1);
	::SendMessage(m_edit2.m_hWnd, WM_GETTEXT, 10, (LPARAM)ch2);

	num1 = _tstoi(ch1);
	num2 = _tstoi(ch2);
	num3 = num1 + num2;

	_itot_s(num3, ch3, 10);
	m_edit3.SendMessage(WM_SETTEXT, 0, (LPARAM)ch3);
}
```

这种方式也是通过发送消息来完成对控件的访问，但这时是直接给对话框的子控件发送消息，使用的函数是SendDIgltemMessage。

```c
void CTestDlg::OnBnClickedBtnAdd()
{	
	int num1, num2, num3;
	TCHAR ch1[10], ch2[10], ch3[10];
	SendDlgItemMessage(IDC_EDIT1, WM_GETTEXT, 10, (LPARAM)ch1);
	SendDlgItemMessage(IDC_EDIT2, WM_GETTEXT, 10, (LPARAM)ch2);

	num1 = _tstoi(ch1);
	num2 = _tstoi(ch2);
	num3 = num1 + num2;
	_itot_s(num3, ch3, 10);
	SendDlgItemMessage(IDC_EDIT3, WM_SETTEXT, 0, (LPARAM)ch3);
    //编辑框内所有内容被选中
	SendDlgItemMessage(IDC_EDIT3, EM_SETSEL, 0, -1);
	m_edit3.SetFocus();
}
```

## 实现窗口区域收缩

```c
void CTestDlg::OnBnClickedButton2()
{
	CString str;
	if (GetDlgItemText(IDC_BUTTON2, str), str == L"收缩<<")
	{
		SetDlgItemText(IDC_BUTTON2, L"扩展>>");
	}
	else
	{
		SetDlgItemText(IDC_BUTTON2, L"收缩<<");
	}
	static CRect rectLarge;
	static CRect rectSmall;

	//矩形静态全局初始化
	if (rectLarge.IsRectNull())
	{
		CRect rectSeparator;
		
		GetWindowRect(&rectLarge);//查当前窗口的矩形
		GetDlgItem(IDC_SEPARATOR)->GetWindowRect(&rectSeparator); //查分割线的矩形

		rectSmall.left = rectLarge.left;
		rectSmall.top = rectLarge.top;
		rectSmall.right = rectLarge.right;//赋值给rectSmall
		rectSmall.bottom = rectSeparator.bottom; //把当前窗口的矩形，底部赋值的是分割线的低
	}
	if (str == "收缩<<")
	{
		//显示当前窗口的矩形
		SetWindowPos(NULL, 0, 0, rectSmall.Width(), rectSmall.Height(),
			SWP_NOMOVE | SWP_NOZORDER);
	}
	else
	{
		SetWindowPos(NULL, 0, 0, rectLarge.Width(), rectLarge.Height(),
			SWP_NOMOVE | SWP_NOZORDER);
	}

}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E5%AE%9E%E7%8E%B0%E7%AA%97%E5%8F%A3%E5%8C%BA%E5%9F%9F%E7%9A%84%E6%94%B6%E7%BC%A9.gif)



## 覆盖OnOk会关闭对话框



覆盖OnOk会关闭对话框的行为，来实现按下回车切换控件。

```c
void CTestDlg::OnOK()
{
	//注释基类的实现，这样回车就没有反应了。不会关闭对话框。
	//CDialog::OnOK();
}

WNDPROC	prevProc;
LRESULT CALLBACK NewEditProc(
	HWND hwnd,      // handle to window
	UINT uMsg,      // message identifier
	WPARAM wParam,  // first message parameter
	LPARAM lParam   // second message parameter
)
{
	MessageBox(NULL, L"1", L"", MB_OK);
	//如果这个消息ID = WM_CHAR 并且按下的键是回车键
	if (uMsg == WM_CHAR && wParam == 0x0d)
	{
        //下面三种方式，都可以让下一个窗口聚焦
		::SetFocus(GetNextWindow(hwnd, GW_HWNDNEXT));
        SetFocus(::GetWindow(hwnd, GW_HWNDNEXT));
		SetFocus(::GetNextDlgTabItem(::GetParent(hwnd), hwnd, FALSE));
		return 0;
	}
	else
		return prevProc(hwnd, uMsg, wParam, lParam);
}
BOOL CTestDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	//为ID为 IDC_EDIT1 的编译框 绑定消息处理函数
	prevProc = (WNDPROC)SetWindowLong(GetDlgItem(IDC_EDIT1)->m_hcWnd, /*GWL_WNDPROC*/(-4), (LONG)NewEditProc);
	return TRUE; 
}
```

如果没有没有实现从编辑框按下回车后，切换到下一个控件，请排查该编辑框控件有没有选中Multiline选项,如果没有，即这个编辑框不支持多行，因此就无接收回车键按下这一消息。所以,我们应该选中这个选项后，就可以切换了。

```c
void CTestDlg::OnOK()
{
	MessageBox(L"11");
    //方法2：查这个ID=IDC_EDIT1 下一个窗口进行聚焦
	GetDlgItem(IDC_EDIT1)->GetNextWindow()->SetFocus();
    //方法3:获取当前对话框得到焦点的控件的下一个窗口进行聚焦
	GetFocus()->GetNextWindow()->SetFocus();
	GetNextDlgTabItem(GetFocus())->SetFocus();
	CDialog::OnOK();
}
```

## tap键顺序

我们可以在设计对话框的时候，通过`ctrl+D` 调用出来tab键的顺序，来实现对shift切换控件进行一个顺序设置。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240418204019953.png)



## 默认按钮

如果把测试对话框中的收缩按钮设置为默认按钮，即在其属性对话框中选中 defaultbutton选项，那么当在测试对话框中按下回车键时，就不会再由CTestDlg类的OnOK函数来响应，而是由收缩按钮的响应函数（OnButton1）来响应这一事件了。读者可以试着运行这时的Mybole程序，会发现当按下回车键后，对话框会发生收缩，再次按下回车键时，对话框又还原了。也就是说，这时，回车键按下这一操作由收缩按钮的响应函数来响应了。



现在，我们取消收缩按钮的默认设置，并删除OK按钮，再次运行Mybole程序，打开测试对话框，按下回车键，会发现焦点仍是在各控件间依次转移。也就是说，当用户按下回车键时，Windows将查看对话框中是否存在指定的默认按钮，如果有，就调用该默认按钮单击消息的响应函数。如果没有，就会调用虚拟的OnOK函数，即使对话框没有包含默认的OK按钮。但是读者一定要注意，这个默认OK按钮的ID是:IDOK。



## 逃跑按钮实现

:::details CNewButton类扩展CButton 定义和实现。

```c
#pragma once
class CNewButton : public CButton
{
	DECLARE_DYNAMIC(CNewButton)
public:
	CNewButton();
	virtual ~CNewButton();
protected:
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
public:
	CNewButton* m_pBtn;
};
```

把自己窗口隐藏起来，让对方显示。

```c
#include "stdafx.h"
#include "Test.h"
#include "NewButton.h"
IMPLEMENT_DYNAMIC(CNewButton, CButton)
CNewButton::CNewButton()
{
}
CNewButton::~CNewButton()
{
}
//绑定鼠标移动到按钮时的事件由OnMouseMove处理
BEGIN_MESSAGE_MAP(CNewButton, CButton)
	ON_WM_MOUSEMOVE()
END_MESSAGE_MAP()
void CNewButton::OnMouseMove(UINT nFlags, CPoint point)
{
	ShowWindow(SW_HIDE);
	m_pBtn->ShowWindow(SW_SHOW);

	CButton::OnMouseMove(nFlags, point);
}
```

:::

```c
#pragma once
#include "NewButton.h"
class CTestDlg : public CDialogEx
{
public:
	CTestDlg(CWnd* pParent = nullptr);	
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_TEST_DIALOG };
#endif
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	
protected:
	HICON m_hIcon;
	// 生成的消息映射函数
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnBnClickedButton2();
private:
	CNewButton m_btn1;
	CNewButton m_btn2;
};
//在对话框，WM_CREATE 时初始化所有的控件的时候，进行绑定。
BOOL CTestDlg::OnInitDialog()
{
    //你指向我，我指向你。
	m_btn1.m_pBtn = &m_btn2;
	m_btn2.m_pBtn = &m_btn1;
}
```

**两个按钮对象互相保存对方的首地址**

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240418205430245.png)

初始化状态下应该隐藏掉一个按钮，可以利用按钮属性对话框把第一个按钮的 Visible属性置为FALSE,另一个置为TRUE

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240418205636670.png)



## 属性表单和向导的创建

为了创建一个属性表单，首先需要创建一个CPropertySheet对象，接下来，在此对象中为每一个属性页创建一个对象(CPropertyPage类型)，并调用AddPage函数添加每一个属性页，然后调用DoModal函数显示一个模态属性表单，或者调用Create函数创建一个非模态属性表单。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240418210525933.png)





:::details 属性页 extends  ` CMFCPropertyPage`

`CProp1.hpp`

```c
class CProp1 : public CMFCPropertyPage
{
	DECLARE_DYNAMIC(CProp1)

public:
	CProp1();
	virtual ~CProp1();
	enum { IDD = IDD_PROP1 };

protected:
	DECLARE_MESSAGE_MAP()
public:
	virtual BOOL OnSetActive();
	virtual void DoDataExchange(CDataExchange* pDX);
	int m_occupation;
	virtual LRESULT OnWizardNext();
	virtual BOOL OnInitDialog();
	CString m_workAddr;
};
```

`CProp1.cpp`

```c
#include "stdafx.h"
#include "Prop.h"
#include "Prop1.h"
IMPLEMENT_DYNAMIC(CProp1, CMFCPropertyPage)

CProp1::CProp1() : CMFCPropertyPage(CProp1::IDD)
, m_occupation(-1)
, m_workAddr(_T(""))
{

}
CProp1::~CProp1()
{
}
BEGIN_MESSAGE_MAP(CProp1, CMFCPropertyPage)
END_MESSAGE_MAP()
BOOL CProp1::OnSetActive()
{
	((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_NEXT);

	return CMFCPropertyPage::OnSetActive();
}
void CProp1::DoDataExchange(CDataExchange* pDX)
{
	CMFCPropertyPage::DoDataExchange(pDX);
	DDX_Radio(pDX, IDC_RADIO1, m_occupation);
	DDX_LBString(pDX, IDC_LIST1, m_workAddr);
}
LRESULT CProp1::OnWizardNext()
{
	UpdateData();
	if (m_occupation == -1)
	{
		MessageBox(L"请选择你的职业！");
		return -1;
	}
	if (m_workAddr == "")
	{
		MessageBox(L"请选择你的工作地点！");
		return -1;
	}


	return CMFCPropertyPage::OnWizardNext();
}
BOOL CProp1::OnInitDialog()
{
	CMFCPropertyPage::OnInitDialog();
	((CListBox*)GetDlgItem(IDC_LIST1))->AddString(L"北京");
	((CListBox*)GetDlgItem(IDC_LIST1))->AddString(L"天津");
	((CListBox*)GetDlgItem(IDC_LIST1))->AddString(L"上海");
	return TRUE; 
}

```

`Prop2.hpp`

```c
class CProp2 : public CMFCPropertyPage
{
	DECLARE_DYNAMIC(CProp2)

public:
	CProp2();
	virtual ~CProp2();
	enum { IDD = IDD_PROP2 };

protected:
	DECLARE_MESSAGE_MAP()
public:
	virtual BOOL OnSetActive();
	virtual void DoDataExchange(CDataExchange* pDX);
	BOOL m_football;
	BOOL m_basketball;
	BOOL m_volleyball;
	BOOL m_swim;
	virtual LRESULT OnWizardNext();
};
```

```c
#include "stdafx.h"
#include "Prop.h"
#include "Prop2.h"
IMPLEMENT_DYNAMIC(CProp2, CMFCPropertyPage)

CProp2::CProp2() : CMFCPropertyPage(CProp2::IDD)
, m_football(FALSE)
, m_basketball(FALSE)
, m_volleyball(FALSE)
, m_swim(FALSE)
{

}

CProp2::~CProp2()
{
}

BEGIN_MESSAGE_MAP(CProp2, CMFCPropertyPage)
END_MESSAGE_MAP()

BOOL CProp2::OnSetActive()
{
	((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

	return CMFCPropertyPage::OnSetActive();
}
void CProp2::DoDataExchange(CDataExchange* pDX)
{
	// TODO: 在此添加专用代码和/或调用基类

	CMFCPropertyPage::DoDataExchange(pDX);
	DDX_Check(pDX, IDC_CHECK1, m_football);
	DDX_Check(pDX, IDC_CHECK2, m_basketball);
	DDX_Check(pDX, IDC_CHECK3, m_volleyball);
	DDX_Check(pDX, IDC_CHECK4, m_swim);
}
LRESULT CProp2::OnWizardNext()
{
	// TODO: 在此添加专用代码和/或调用基类
	UpdateData();
	if (m_football || m_basketball || m_volleyball || m_swim)
		return CPropertyPage::OnWizardNext();
	else
	{
		MessageBox(L"请选择你的兴趣爱好！");
		return -1;
	}

	return CMFCPropertyPage::OnWizardNext();
}

```



`Prop3.hpp`

```c
class CProp3 : public CMFCPropertyPage
{
	DECLARE_DYNAMIC(CProp3)

public:
	CProp3();
	virtual ~CProp3();
	enum { IDD = IDD_PROP3 };

protected:
	DECLARE_MESSAGE_MAP()
public:
	virtual BOOL OnSetActive();
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual BOOL OnInitDialog();
	virtual BOOL OnWizardFinish();
	CString m_strSalary;
};
```

`Prop3.cpp`

```cpp
#include "stdafx.h"
#include "Prop.h"
#include "Prop3.h"
IMPLEMENT_DYNAMIC(CProp3, CMFCPropertyPage)
CProp3::CProp3() : CMFCPropertyPage(CProp3::IDD)
{

}

CProp3::~CProp3()
{
}


BEGIN_MESSAGE_MAP(CProp3, CMFCPropertyPage)
END_MESSAGE_MAP()
BOOL CProp3::OnSetActive()
{
	((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);

	return CMFCPropertyPage::OnSetActive();
}

void CProp3::DoDataExchange(CDataExchange* pDX)
{
	// TODO: 在此添加专用代码和/或调用基类

	CMFCPropertyPage::DoDataExchange(pDX);
}

BOOL CProp3::OnInitDialog()
{
	CMFCPropertyPage::OnInitDialog();

	((CComboBox*)GetDlgItem(IDC_COMBO1))->AddString(L"3000元以下");
	((CComboBox*)GetDlgItem(IDC_COMBO1))->AddString(L"3000-5000元");
	((CComboBox*)GetDlgItem(IDC_COMBO1))->AddString(L"5000-8000元");
	((CComboBox*)GetDlgItem(IDC_COMBO1))->AddString(L"8000元以上");

	((CComboBox*)GetDlgItem(IDC_COMBO1))->SetCurSel(0);

	return TRUE;
}

BOOL CProp3::OnWizardFinish()
{
	int index;
	index = ((CComboBox*)GetDlgItem(IDC_COMBO1))->GetCurSel();
	((CComboBox*)GetDlgItem(IDC_COMBO1))->GetLBText(index, m_strSalary);

	return CMFCPropertyPage::OnWizardFinish();
}

```

:::



:::details 属性表 extends CMFCPropertySheet 

```cpp
#pragma once

#include "Prop1.h"
#include "Prop2.h"
#include "Prop3.h"

// CPropSheet

class CPropSheet : public CMFCPropertySheet
{
	DECLARE_DYNAMIC(CPropSheet)

public:
	CPropSheet();
	virtual ~CPropSheet();

protected:
	DECLARE_MESSAGE_MAP()
public:
	CProp1 m_prop1;
	CProp2 m_prop2;
	CProp3 m_prop3;
};
```

```cpp
#include "stdafx.h"
#include "Prop.h"
#include "PropSheet.h"
IMPLEMENT_DYNAMIC(CPropSheet, CMFCPropertySheet)
CPropSheet::CPropSheet()
{
    //调用AddPage方法，将属性页交与属性表管理。
	AddPage(&m_prop1);
	AddPage(&m_prop2);
	AddPage(&m_prop3);
}
CPropSheet::~CPropSheet()
{
}
BEGIN_MESSAGE_MAP(CPropSheet, CMFCPropertySheet)
END_MESSAGE_MAP()

```

:::



:::details CPropView 视类使用属性表



`PropView.h`

```c
class CPropView : public CView
{
protected: // 仅从序列化创建
	CPropView() noexcept;
	DECLARE_DYNCREATE(CPropView)

// 特性
public:
	CPropDoc* GetDocument() const;

// 操作
public:

// 重写
public:
	virtual void OnDraw(CDC* pDC);  // 重写以绘制该视图
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:

// 实现
public:
	virtual ~CPropView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// 生成的消息映射函数
protected:
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnPropertysheet();
private:
	int m_iOccupation;
	CString m_strWorkAddr;
	BOOL m_bLike[4];
	CString m_strSalary;
};

#ifndef _DEBUG  // PropView.cpp 中的调试版本
inline CPropDoc* CPropView::GetDocument() const
   { return reinterpret_cast<CPropDoc*>(m_pDocument); }
#endif
```

`PropView.cpp`

```c
IMPLEMENT_DYNCREATE(CPropView, CView)
BEGIN_MESSAGE_MAP(CPropView, CView)
	ON_COMMAND(IDM_PROPERTYSHEET, &CPropView::OnPropertysheet)
END_MESSAGE_MAP()

CPropView::CPropView() noexcept
{
	m_iOccupation = -1;
	m_strWorkAddr = "";
	memset(m_bLike, 0, sizeof(m_bLike));
	m_strSalary = "";

}  
void CPropView::OnPropertysheet()
{
	CPropSheet propSheet;
	propSheet.SetWizardMode();

	if (ID_WIZFINISH == propSheet.DoModal())
	{
		m_iOccupation = propSheet.m_prop1.m_occupation;
		m_strWorkAddr = propSheet.m_prop1.m_workAddr;
		m_bLike[0] = propSheet.m_prop2.m_football;
		m_bLike[1] = propSheet.m_prop2.m_basketball;
		m_bLike[2] = propSheet.m_prop2.m_volleyball;
		m_bLike[3] = propSheet.m_prop2.m_swim;
		m_strSalary = propSheet.m_prop3.m_strSalary;
		Invalidate();
	}
}
void CPropView::OnDraw(CDC* pDC)
{
	CPropDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	if (!pDoc)
		return;

	CFont font;
	font.CreatePointFont(300, L"华文行楷");

	CFont *pOldFont;
	pOldFont = pDC->SelectObject(&font);

	CString strTemp;
	strTemp = L"你的职业：";

	switch (m_iOccupation)
	{
	case 0:
		strTemp += L"程序员";
		break;
	case 1:
		strTemp += L"系统工程师";
		break;
	case 2:
		strTemp += L"项目经理";
		break;
	default:
		break;
	}
	pDC->TextOut(0, 0, strTemp);

	strTemp = L"你的工作地点：";
	strTemp += m_strWorkAddr;

	TEXTMETRIC tm;
	pDC->GetTextMetrics(&tm);

	pDC->TextOut(0, tm.tmHeight, strTemp);

	strTemp = L"你的兴趣爱好：";
	if (m_bLike[0])
	{
		strTemp += L"足球 ";
	}
	if (m_bLike[1])
	{
		strTemp += L"篮球 ";
	}
	if (m_bLike[2])
	{
		strTemp += L"排球 ";
	}
	if (m_bLike[3])
	{
		strTemp += L"游泳 ";
	}
	pDC->TextOut(0, tm.tmAveCharWidth * 2, strTemp);

	strTemp = L"你的薪资水平：";
	strTemp += m_strSalary;
	pDC->TextOut(0, tm.tmHeight * 3, strTemp);
	pDC->SelectObject(pOldFont);

}

```

:::

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240418211650549.png) 