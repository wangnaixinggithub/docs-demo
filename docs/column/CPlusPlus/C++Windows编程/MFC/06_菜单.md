# 菜单

## 菜单命令响应函数

这里我们先需学习，如何新增菜单项，并且该菜单项被点击的事件进行处理。



首先，通过点击菜单资源，可以进行配置菜单的菜单项。我们新增一个菜单项为Test,指定他的ID为`IDM_TEST`



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401212850973-17119781324801.png)

然后，在`MainFrm.h` 中添加消息处理函数`onTest()`的声明。

并在`MainFrm.cpp` 添加其实现逻辑，这里是去进行弹窗。

接着，把`OnTest()` 函数和`ON_COMMAND`消息进行一个消息绑定。

```c{42}

// MainFrm.h: CMainFrame 类的接口
//

#pragma once

class CMainFrame : public CFrameWnd
{
	
protected: // 仅从序列化创建
	CMainFrame() noexcept;
	DECLARE_DYNCREATE(CMainFrame)

// 特性
public:

// 操作
public:

// 重写
public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// 实现
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // 控件条嵌入成员
	CToolBar          m_wndToolBar;
	CStatusBar        m_wndStatusBar;

// 生成的消息映射函数
protected:
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	DECLARE_MESSAGE_MAP()

public:
	//1、声明一个消息处理函数，afx_msg 代表他是一个消息处理函数。
	afx_msg void OnTest();
private:
	CBitmap m_bitmap;
public:
	afx_msg void OnUpdateEditCut(CCmdUI *pCmdUI);
	afx_msg void OnUpdateFileNew(CCmdUI *pCmdUI);
	afx_msg void OnShow();
};



```

```c{21,123,124,125,126}

// MainFrm.cpp: CMainFrame 类的实现
//

#include "stdafx.h"
#include "Menu.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#include "Resource.h"
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	ON_WM_CREATE()
//2、消息处理函数和要处理的消息进行消息映射	
ON_COMMAND(IDM_TEST, &CMainFrame::OnTest)
ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, &CMainFrame::OnUpdateEditCut)
ON_UPDATE_COMMAND_UI(ID_FILE_NEW, &CMainFrame::OnUpdateFileNew)
//ON_COMMAND(IDM_SHOW, &CMainFrame::OnShow)
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // 状态行指示器
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

// CMainFrame 构造/析构

CMainFrame::CMainFrame() noexcept
{
	//m_bAutoMenuEnable = FALSE;
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	/*
	//GetMenu()->GetSubMenu(0)->CheckMenuItem(0, MF_BYPOSITION | MF_CHECKED);
	GetMenu()->GetSubMenu(0)->CheckMenuItem(ID_FILE_NEW, MF_BYCOMMAND | MF_CHECKED);
	GetMenu()->GetSubMenu(0)->SetDefaultItem(1, TRUE);
	GetMenu()->GetSubMenu(0)->SetDefaultItem(5, TRUE);

	CString str;
	str.Format(L"x=%d, y=%d", GetSystemMetrics(SM_CXMENUCHECK), GetSystemMetrics(SM_CYMENUCHECK));
	MessageBox(str);

	m_bitmap.LoadBitmap(IDB_BITMAP1);
	GetMenu()->GetSubMenu(0)->SetMenuItemBitmaps(0, MF_BYPOSITION, &m_bitmap, &m_bitmap);
	*/

	GetMenu()->GetSubMenu(0)->EnableMenuItem(1, MF_BYPOSITION | MF_DISABLED);
	SetMenu(NULL);
	CMenu menu;
	menu.LoadMenu(IDR_MAINFRAME);
	SetMenu(&menu);
	menu.Detach();

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	// TODO: 在此处通过修改
	//  CREATESTRUCT cs 来修改窗口类或样式

	return TRUE;
}

// CMainFrame 诊断

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}
#endif //_DEBUG


// CMainFrame 消息处理程序


//3、由我们对这个菜单项被点击的消息，来写处理逻辑，这里是弹窗。
void CMainFrame::OnTest()
{
	MessageBox(L"MainFrame Clicked");
}


void CMainFrame::OnUpdateEditCut(CCmdUI *pCmdUI)
{
	if (2 == pCmdUI->m_nIndex)
		pCmdUI->Enable();
}


void CMainFrame::OnUpdateFileNew(CCmdUI *pCmdUI)
{
	if (ID_FILE_NEW == pCmdUI->m_nID)
		pCmdUI->Enable(FALSE);

}


void CMainFrame::OnShow()
{
	MessageBox(L"Main show");
}

```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401214739296-17119792609001.png)



可以看到，当我们点击了Test菜单项时，成功触发了我们的处理逻辑，弹框。





## 菜单命令的路由

### 程序类对菜单命令的响应顺序

如果一个菜单项被点击的消息处理函数，被写在多个程序类中，比如说主框架类`CMainFrame`  视图类 `CMenuView ` 文档类 `CMenuDoc` 。理论上，他们都会处理这个Test菜单项，被点击的消息，那么三者之间，必然存在一个优先级。即响应顺序，下面我们实验一下，他们之间的优先级（响应顺序） 是什么样的。

```c{44}

// MenuView.h: CMenuView 类的接口
//

#pragma once


class CMenuView : public CView
{
protected: // 仅从序列化创建
	CMenuView() noexcept;
	DECLARE_DYNCREATE(CMenuView)

// 特性
public:
	CMenuDoc* GetDocument() const;

// 操作
public:

// 重写
public:
	virtual void OnDraw(CDC* pDC);  // 重写以绘制该视图
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

// 实现
public:
	virtual ~CMenuView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// 生成的消息映射函数
protected:
	DECLARE_MESSAGE_MAP()
public:
	//1、视图类同样添加消息处理函数 OnTest() 方法
	afx_msg void OnTest();
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
//	afx_msg void OnShow();
};

#ifndef _DEBUG  // MenuView.cpp 中的调试版本
inline CMenuDoc* CMenuView::GetDocument() const
   { return reinterpret_cast<CMenuDoc*>(m_pDocument); }
#endif


```

```c{29,109,110,111,112,113}

// MenuView.cpp: CMenuView 类的实现
//

#include "stdafx.h"
// SHARED_HANDLERS 可以在实现预览、缩略图和搜索筛选器句柄的
// ATL 项目中进行定义，并允许与该项目共享文档代码。
#ifndef SHARED_HANDLERS
#include "Menu.h"
#endif

#include "MenuDoc.h"
#include "MenuView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CMenuView

IMPLEMENT_DYNCREATE(CMenuView, CView)

BEGIN_MESSAGE_MAP(CMenuView, CView)
	// 标准打印命令
	ON_COMMAND(ID_FILE_PRINT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, &CView::OnFilePrintPreview)
	//2、让视图类也处理IDM_TEST菜单项被点击的事件
	ON_COMMAND(IDM_TEST, &CMenuView::OnTest)
	ON_WM_RBUTTONDOWN()
//	ON_COMMAND(IDM_SHOW, &CMenuView::OnShow)
END_MESSAGE_MAP()

// CMenuView 构造/析构

CMenuView::CMenuView() noexcept
{
	// TODO: 在此处添加构造代码

}

CMenuView::~CMenuView()
{
}

BOOL CMenuView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: 在此处通过修改
	//  CREATESTRUCT cs 来修改窗口类或样式

	return CView::PreCreateWindow(cs);
}

// CMenuView 绘图

void CMenuView::OnDraw(CDC* /*pDC*/)
{
	CMenuDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	if (!pDoc)
		return;

	// TODO: 在此处为本机数据添加绘制代码
}


// CMenuView 打印

BOOL CMenuView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// 默认准备
	return DoPreparePrinting(pInfo);
}

void CMenuView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: 添加额外的打印前进行的初始化过程
}

void CMenuView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: 添加打印后进行的清理过程
}


// CMenuView 诊断

#ifdef _DEBUG
void CMenuView::AssertValid() const
{
	CView::AssertValid();
}

void CMenuView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CMenuDoc* CMenuView::GetDocument() const // 非调试版本是内联的
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMenuDoc)));
	return (CMenuDoc*)m_pDocument;
}
#endif //_DEBUG


// CMenuView 消息处理程序
//3、处理的逻辑为 弹窗一句话  View show
void CMenuView::OnTest()
{
	// TODO: 在此添加命令处理程序代码
	MessageBox(L"View show");
}


void CMenuView::OnRButtonDown(UINT nFlags, CPoint point)
{
	CMenu menu;
	menu.LoadMenu(IDR_MENU1);
	CMenu* pPopup = menu.GetSubMenu(0);

	ClientToScreen(&point);

	//pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
	pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, GetParent());

	CView::OnRButtonDown(nFlags, point);


	CView::OnRButtonDown(nFlags, point);
}


//void CMenuView::OnShow()
//{
//	MessageBox(L"View show");
//}

```

```c{49}

// MenuDoc.h: CMenuDoc 类的接口
//


#pragma once


class CMenuDoc : public CDocument
{
protected: // 仅从序列化创建
	CMenuDoc() noexcept;
	DECLARE_DYNCREATE(CMenuDoc)

// 特性
public:

// 操作
public:

// 重写
public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
#ifdef SHARED_HANDLERS
	virtual void InitializeSearchContent();
	virtual void OnDrawThumbnail(CDC& dc, LPRECT lprcBounds);
#endif // SHARED_HANDLERS

// 实现
public:
	virtual ~CMenuDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// 生成的消息映射函数
protected:
	DECLARE_MESSAGE_MAP()

#ifdef SHARED_HANDLERS
	// 用于为搜索处理程序设置搜索内容的 Helper 函数
	void SetSearchContent(const CString& value);
#endif // SHARED_HANDLERS
public:
	//1、新增CMenuDoc 的消息处理函数 OnTest
  afx_msg void OnTest();
};

```

```c{142-147,25}

// MenuDoc.cpp: CMenuDoc 类的实现
//

#include "stdafx.h"
// SHARED_HANDLERS 可以在实现预览、缩略图和搜索筛选器句柄的
// ATL 项目中进行定义，并允许与该项目共享文档代码。
#ifndef SHARED_HANDLERS
#include "Menu.h"
#endif

#include "MenuDoc.h"

#include <propkey.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

// CMenuDoc

IMPLEMENT_DYNCREATE(CMenuDoc, CDocument)

BEGIN_MESSAGE_MAP(CMenuDoc, CDocument)
	//2、为消息处理函数绑定消息为 IDM_TEST 菜单命令被点击的消息
ON_COMMAND(IDM_TEST, &CMenuDoc::OnTest)
END_MESSAGE_MAP()


// CMenuDoc 构造/析构

CMenuDoc::CMenuDoc() noexcept
{
	// TODO: 在此添加一次性构造代码

}

CMenuDoc::~CMenuDoc()
{
}

BOOL CMenuDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: 在此添加重新初始化代码
	// (SDI 文档将重用该文档)

	return TRUE;
}




// CMenuDoc 序列化

void CMenuDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: 在此添加存储代码
	}
	else
	{
		// TODO: 在此添加加载代码
	}
}

#ifdef SHARED_HANDLERS

// 缩略图的支持
void CMenuDoc::OnDrawThumbnail(CDC& dc, LPRECT lprcBounds)
{
	// 修改此代码以绘制文档数据
	dc.FillSolidRect(lprcBounds, RGB(255, 255, 255));

	CString strText = _T("TODO: implement thumbnail drawing here");
	LOGFONT lf;

	CFont* pDefaultGUIFont = CFont::FromHandle((HFONT) GetStockObject(DEFAULT_GUI_FONT));
	pDefaultGUIFont->GetLogFont(&lf);
	lf.lfHeight = 36;

	CFont fontDraw;
	fontDraw.CreateFontIndirect(&lf);

	CFont* pOldFont = dc.SelectObject(&fontDraw);
	dc.DrawText(strText, lprcBounds, DT_CENTER | DT_WORDBREAK);
	dc.SelectObject(pOldFont);
}

// 搜索处理程序的支持
void CMenuDoc::InitializeSearchContent()
{
	CString strSearchContent;
	// 从文档数据设置搜索内容。
	// 内容部分应由“;”分隔

	// 例如:     strSearchContent = _T("point;rectangle;circle;ole object;")；
	SetSearchContent(strSearchContent);
}

void CMenuDoc::SetSearchContent(const CString& value)
{
	if (value.IsEmpty())
	{
		RemoveChunk(PKEY_Search_Contents.fmtid, PKEY_Search_Contents.pid);
	}
	else
	{
		CMFCFilterChunkValueImpl *pChunk = nullptr;
		ATLTRY(pChunk = new CMFCFilterChunkValueImpl);
		if (pChunk != nullptr)
		{
			pChunk->SetTextValue(PKEY_Search_Contents, value, CHUNK_TEXT);
			SetChunkValue(pChunk);
		}
	}
}

#endif // SHARED_HANDLERS

// CMenuDoc 诊断

#ifdef _DEBUG
void CMenuDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CMenuDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG


// CMenuDoc 命令


//3、实现OnTest消息的处理逻辑，当菜单项IDM_TEST 被点击时触发响应。
void CMenuDoc::OnTest()
{
	AfxMessageBox(L"Doc Clicked!");
}

```

如果三者都有处理，则只执行视图类的消息处理逻辑。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401220822716-17119805039912.png)

如果视图类没有写处理逻辑，则只剩下文档类和框架类。则最终运行文档类的消息处理逻辑。





![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401220945735-17119805873723.png)

根据上述试验，可以得知，响应【Test】菜单项命令的顺序依次是:视类、文档类、框架类，最后才是应用程序类。





![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401222157273.png)



- 如果是命令消息，它就会交由OnCommand这个函数来处理，在这个函数将完成命令消息的路由;

- 如果是通告消息，那么它将交由OnNotify这个函数来处理，该丙数将完成通告消息的路由。

- 二者最后都会调用OnCmdMsg 函数。





 **总结**

下面，我们以Menu这个程序为例，来看看菜单命令消息路由的具体过程:当点击某个菜单项时，最先接收到这个菜单命令消息的是框架类。框架类将把接收到的这个消息交给它的子窗口，即视类，由视类首先进行处理。视类首先根据命令消息映射机制查找自身是否对此消息进行了响应，如果响应了，就调用相应响应函数对这个消息进行处理，消息路由过程结束;如果视类没有对此命令消息做出响应，就交由文档类，文档类同样查找自身是否对这个菜单命令进行了响应，如果响应了，就由文档类的命令消息响应函数进行处理，路由过程结束。如果文档类也未做出响应，就把这个命令消息交还给视类，后者又把该消息交还给框架类。框架类查看自己是否对这个命令消息进行了响应，如果它也没有做出响应，就把这个菜单命令消息交给应用程序类，由后者来进行处理。这就是菜单命令的路由过程。

### Windows消息的分类

- 标准消息

除`WM_COMMAND`之外，所有以WM_开头的消息都是标准消息。从CWnd派生的类，都可以接收到这类消息。

- 命令消息

来自菜单、加速键或工具栏按钮的消息。这类消息都以WM_COMMAND形式呈现。在MFC中，通过菜单项的标识(ID）来区分不同的命令消息:在SDK中，通过消息的wParam参数识别。从 CCmdTarget派生的类，都可以接收到这类消息。

- 通告消息



### 基本菜单操作

菜单可以和房间楼层进行类比。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401222536695-17119815380694.png)

房间也可以通过位置索引来访问，例如三楼第一个房间。同样，对于菜单来说，如果要访问某个菜单项，既可以通过该菜单项的标识ID，也可以通过其位置索引来实现访问。



但对于子菜单来说，只能通过索引号进行访问，因为子菜单是没有标识号的。





#### 标记菜单

带有一个对号(√)(如下图所示)，我们称这种类型的菜单为标记菜单。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401222613475-17119815746795.png)

```c{25-33}
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
	
	//获取到框架类 指向菜单栏A的指针
	CMenu* menuA =  GetMenu();
	//获取菜单栏A的第一个子菜单B
	CMenu* menuB = menuA->GetSubMenu(0);

	//设置 第0号索引位置的菜单项为 标记菜单
	menuB->CheckMenuItem(0, MF_BYPOSITION | MF_CHECKED);
	//设置 菜单项ID为ID_FILE_OPEN为标记菜单 
	menuB->CheckMenuItem(ID_FILE_OPEN, MF_BYCOMMAND|MF_CHECKED);


	return 0;
}

```



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401223939400-17119823816916.png)

#### 默认菜单项

有些应用程序的子菜单下有一个菜单项是以粗体形式显示的，以这种形式显示的就是该子菜单的默认菜单项。

```c{34}
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
	
	
	//设置默认菜单项，黑体加粗显示。
	//1、分割线也会占用菜单项索引
	//2、不支持设置多个默认菜单项，默认菜单项有且只有一个。取代码最后一次SetDefaultItem的时候指定的菜单项
	GetMenu()->GetSubMenu(0)->SetDefaultItem(1,TRUE);
	GetMenu()->GetSubMenu(0)->SetDefaultItem(5, TRUE);


	return 0;
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401224802914-17127562561301.png)

#### 图形标记菜单

菜单项可以配置复选位图。

```c{44}

// MainFrm.h: CMainFrame 类的接口
//

#pragma once

class CMainFrame : public CFrameWnd
{
	
protected: // 仅从序列化创建
	CMainFrame() noexcept;
	DECLARE_DYNCREATE(CMainFrame)

// 特性
public:

// 操作
public:

// 重写
public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// 实现
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // 控件条嵌入成员
	CToolBar          m_wndToolBar;
	CStatusBar        m_wndStatusBar;

// 生成的消息映射函数
protected:
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	DECLARE_MESSAGE_MAP()

public:
	afx_msg void OnTest();
private:
	//1、定义位图对象
	CBitmap m_bitmap;
public:
	afx_msg void OnUpdateEditCut(CCmdUI *pCmdUI);
	afx_msg void OnUpdateFileNew(CCmdUI *pCmdUI);
	afx_msg void OnShow();
};
```



```c{24-31}
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}
	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
	

	//查菜单位图的宽高指标 19 * 19
	CString str;
	str.Format(L"x=%d, y=%d", GetSystemMetrics(SM_CXMENUCHECK), GetSystemMetrics(SM_CYMENUCHECK));
	MessageBox(str);
	//把位图ID和位图对象进行关联
	m_bitmap.LoadBitmap(IDB_BITMAP1);
	//给菜单设置位图
	GetMenu()->GetSubMenu(0)->SetMenuItemBitmaps(0, MF_BYPOSITION, &m_bitmap, &m_bitmap);
	return 0;
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240410215313670.png)



#### 禁用菜单项

我们可以对一些菜单项进行置灰处理，来表示该菜单项不予使用。默认MFC框架的命令菜单处理机制会自动管理好菜单的显示，如果我们要代码控制，则需要在其构造函数中将`m_bAutoMenuEnable` 置为 `FALSE`



> 详见MSDN: [CMenu 类 | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/mfc/reference/cmenu-class?view=msvc-170&devlangs=cpp&f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(AFXWIN%2FCMenu%3A%3AEnableMenuItem)%3Bk(CMenu%3A%3AEnableMenuItem)%3Bk(EnableMenuItem)%3Bk(DevLang-C%2B%2B)%3Bk(TargetOS-Windows)%26rd%3Dtrue#enablemenuitem)
>
> ```c
> // The code fragment below shows how to disable (and gray out) the
> // File\New menu item.
> // NOTE: m_bAutoMenuEnable is set to FALSE in the constructor of
> // CMainFrame so no ON_UPDATE_COMMAND_UI or ON_COMMAND handlers are
> // needed, and CMenu::EnableMenuItem() will work as expected.
> 
> CMenu *mmenu = GetMenu();
> CMenu *submenu = mmenu->GetSubMenu(0);
> submenu->EnableMenuItem(ID_FILE_NEW, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
> ```
>
> 



```c{4,30}
CMainFrame::CMainFrame() noexcept
{
    //1、由程序自行管理菜单的状态。
	m_bAutoMenuEnable = FALSE;
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));
	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);	
	//2、设置第一个子菜单的第二个菜单项变灰
	GetMenu()->GetSubMenu(0)->EnableMenuItem(1, MF_BYPOSITION | MF_GRAYED);
	return 0;
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240410220848900.png)

#### 移除和装载菜单

**菜单的移除**

```c
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
	 
	SetMenu(NULL); //不设置程序的菜单

	return 0;
}
```

**装载自定义菜单**

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240410221449311-17127584905703.png)





```c
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
	

	 
	//SetMenu(NULL); 不设置程序的菜单

	//设置菜单
	CMenu menu;
	menu.LoadMenu(IDR_MENU1);
	SetMenu(&menu);

	//菜单句柄和菜单对象分离，避免CMenu对象在离开函数被析构后，菜单资源被回收
	menu.Detach();

	return 0;
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240410221653564.png)

#### 命令菜单的更新机制

当要显示菜单时，操作系统发出 WM_INITMENUPOPUP消息，然后由程序窗口的基类如CFrameWnd接管。它会创建一个CCmdUI对象，并与程序的第一个菜单项相关联，调用该对象的一个成员函数 DoUpdate()。这个函数发出 CN_UPDATE_COMMAND_UI消息，这条消息带有一个指向CCmdUI对象的指针。这时，系统会判断是否存在一ON_UPDATE_COMMAND_UI宏去捕获这个菜单项消息。如果找到这样一个宏，就调用相应的消息响应函数进行处理，在这个函数中，可以利用传递过来的CCmdUI对象去调用相应的函数，使该菜单项可以使用,或禁用该菜单项。当更新完第一个菜单项后，同一个 CCmdUI对象就设置为与第二个菜单项相关联，依此顺序进行，直到完成所有菜单项的处理。这就是MFC采用的**命令更新机制**。



所以我们可以对这个消息`CN_UPDATE_COMMAND_UI` 指定的菜单命令进行处理，来设置菜单项可用或禁用、设置标记菜单，或者设置菜单项的文本这些功能。

```c{46-47}

// MainFrm.h: CMainFrame 类的接口
//

#pragma once

class CMainFrame : public CFrameWnd
{
	
protected: // 仅从序列化创建
	CMainFrame() noexcept;
	DECLARE_DYNCREATE(CMainFrame)

// 特性
public:

// 操作
public:

// 重写
public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// 实现
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // 控件条嵌入成员
	CToolBar          m_wndToolBar;
	CStatusBar        m_wndStatusBar;

// 生成的消息映射函数
protected:
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	DECLARE_MESSAGE_MAP()

public:
	afx_msg void OnTest();
private:
	CBitmap m_bitmap;
public:
	//1、新建菜单命令更新的消息处理函数
	afx_msg void OnUpdateEditCut(CCmdUI *pCmdUI);
	afx_msg void OnUpdateFileNew(CCmdUI *pCmdUI);
	afx_msg void OnShow();
};
```

```c
BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	ON_WM_CREATE()
ON_COMMAND(IDM_TEST, &CMainFrame::OnTest)
//绑定ID_EDIT_CUT中的菜单项更新时由消息函数OnUpdateEditCut处理
ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, &CMainFrame::OnUpdateEditCut)
//绑定ID_FILE_NEW中的菜单项更新时由消息函数OnUpdateFileNew处理
ON_UPDATE_COMMAND_UI(ID_FILE_NEW, &CMainFrame::OnUpdateFileNew)
END_MESSAGE_MAP()

void CMainFrame::OnUpdateEditCut(CCmdUI *pCmdUI)
{
	//激活剪切菜单项 通过position匹配
	if (2 == pCmdUI->m_nIndex)
		pCmdUI->Enable();
}
void CMainFrame::OnUpdateFileNew(CCmdUI *pCmdUI)
{
	//禁用新建菜单项 通过菜单ID匹配
	if (ID_FILE_NEW == pCmdUI->m_nID)
		pCmdUI->Enable(FALSE);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240410223424437.png)

#### 快捷菜单

快捷菜单就是指鼠标右键可以出现一个菜单。

- 在资源视图中新建菜单 IDR_MENU1
- 对鼠标右键点击的消息进行处理

```c{38}
#pragma once
class CMenuView : public CView
{
protected: // 仅从序列化创建
	CMenuView() noexcept;
	DECLARE_DYNCREATE(CMenuView)

// 特性
public:
	CMenuDoc* GetDocument() const;

// 操作
public:

// 重写
public:
	virtual void OnDraw(CDC* pDC);  // 重写以绘制该视图
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

// 实现
public:
	virtual ~CMenuView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// 生成的消息映射函数
protected:
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
};
#ifndef _DEBUG  // MenuView.cpp 中的调试版本
inline CMenuDoc* CMenuView::GetDocument() const
   { return reinterpret_cast<CMenuDoc*>(m_pDocument); }
#endif

```

```c{6}
BEGIN_MESSAGE_MAP(CMenuView, CView)
	// 标准打印命令
	ON_COMMAND(ID_FILE_PRINT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, &CView::OnFilePrintPreview)
	ON_WM_RBUTTONDOWN()
END_MESSAGE_MAP()

void CMenuView::OnRButtonDown(UINT nFlags, CPoint point)
{
	CMenu menu;
	menu.LoadMenu(IDR_MENU1);
	CMenu* pPopup = menu.GetSubMenu(0);

	ClientToScreen(&point);
		
	// 最后一个参数绝对可以让谁来处理快捷菜单项被点击的消息
    // 如果最后一个参数是 this，则只能由CMenuView类来处理这个消息。
    // 如果最后一个参数是 GetParent() 如果CMenuView类没有提供处理函数，则看框架类有处理函数就用框架类，如果两个都有优先CMenuView类的。遵循菜单路由响应顺序
	//pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
	pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, GetParent());

	CView::OnRButtonDown(nFlags, point);
	CView::OnRButtonDown(nFlags, point);
}
```

### 动态菜单操作

在程序运行的过程中，可以根据需要对程序的菜单进行添加、插入和删除操作，这些动态操作包括两种情况，一种是针对弹出菜单的动态操作，一种是针对菜单项的动态操作。



#### 添加菜单项目

```c{25-29}
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
	
    //添加弹出菜单Test
	CMenu menu;
	menu.CreatePopupMenu();
	GetMenu()->AppendMenu(MF_POPUP, (UINT)menu.m_hMenu, L"Jackson");
	menu.Detach();
	return 0;
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240410230200441.png)

#### 插入菜单项目

```c{26-33}
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);


	CMenu menu;
	menu.CreatePopupMenu();
	GetMenu()->InsertMenu(2, MF_POPUP | MF_BYPOSITION, (UINT)menu.m_hMenu, L"广东省");	//插入到第二个菜单项中
	//给menu弹出式菜单添加三个菜单项
	menu.AppendMenu(MF_STRING, 111, L"东莞市");
	menu.AppendMenu(MF_STRING, 112, L"广州市");
	menu.AppendMenu(MF_STRING, 113, L"深圳市");
	menu.Detach();

	return 0;
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240410230816297.png)



```c{26-28}
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);


	//也可以直接对已有的菜单做新增或插入
	GetMenu()->GetSubMenu(0)->AppendMenu(MF_STRING, 114, L"Welcome");
	GetMenu()->GetSubMenu(0)->InsertMenu(ID_FILE_OPEN, MF_BYCOMMAND | MF_STRING, 115, L"VC编程");

	return 0;
}

```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240410231324020.png)

#### 删除菜单

```c{25-28}
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	//删编译弹出式菜单
	GetMenu()->DeleteMenu(1, MF_BYPOSITION);
	//删新建弹出式菜单下的保存菜单项
	GetMenu()->GetSubMenu(0)->DeleteMenu(2, MF_BYPOSITION);
	return 0;
}

```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240410231851916.png)



#### 动态添加的菜单项的命令响应

前面静态的菜单项的命令怎么处理的，这里也是用一样的步骤思想。



`Resource.h`

先定义好预先的动态他添加的菜单ID宏。

```c{7}
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 Menu2.rc 使用
//
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define IDM_HELLO                       111
#define IDR_MAINFRAME                   128
#define IDR_Menu2TYPE                   130

#define IDM_PHONE1                      32771
#define IDM_PHONE2                      32772
#define IDM_PHONE3                      32773
#define IDM_PHONE4                      32774

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        310
#define _APS_NEXT_COMMAND_VALUE         32778
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           310
#endif
#endif

```



`MainFrm.h`

```c{39}

// MainFrm.h: CMainFrame 类的接口
//

#pragma once

class CMainFrame : public CFrameWnd
{
	
protected: // 仅从序列化创建
	CMainFrame() noexcept;
	DECLARE_DYNCREATE(CMainFrame)

// 特性
public:

// 操作
public:

// 重写
public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// 实现
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // 控件条嵌入成员
	CToolBar          m_wndToolBar;
	CStatusBar        m_wndStatusBar;

// 生成的消息映射函数
protected:
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    //2、定义消息处理函数
	afx_msg void OnHello();
	DECLARE_MESSAGE_MAP()
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
};

```

`Menu2View.cpp`

```c
BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	ON_WM_CREATE()
    //3、建立IDM_HELLO菜单被点击时由OnHello函数进行处理。
	ON_COMMAND(IDM_HELLO, &CMainFrame::OnHello)
END_MESSAGE_MAP()


int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
	
    //4、构建你的动态菜单
	CMenu menu;
	menu.CreatePopupMenu();
	GetMenu()->AppendMenu(MF_POPUP, (UINT)menu.m_hMenu, L"Test");
	menu.AppendMenu(MF_STRING, IDM_HELLO, L"Hello");
	menu.AppendMenu(MF_STRING, 112, L"Bye");
	menu.AppendMenu(MF_STRING, 113, L"Mybole");

	menu.Detach();

	return 0;
}

void CMainFrame::OnHello()
{
    //5、开始写你的业务逻辑
	MessageBox(L"Hello");
}
```

