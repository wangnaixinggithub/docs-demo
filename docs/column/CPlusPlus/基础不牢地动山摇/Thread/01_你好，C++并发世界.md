# 第1章 你好，并发世界!

主要内容

- 定义并发和多线程
- 使用并发和多线程
- C++的并发史
- 简单的C++多线程

距初始C++标准(1998年)发布后的13年后，标准委员对C++进行了重大的修改。新标准(也称C++11或C++0x)在2011年发布，一系列的修改让C++编程更加简单和高效。同时，委员会也确立了标准更新模式——每三年发布一个新标准。从模式确立至今，委员会已经发布了两个标准：2014年的C++14标准和2017的C++17标准，以及若干个C++技术规范标准扩展。

其中最重要的特性就是对多线程的支持。C++标准第一次包含了多线程，并在标准库中提供了多线程组件，这让使用C++编写与平台无关的多线程程序成为可能，也为可移植性提供了强有力的保证。与此同时，开发者们为提高应用的性能，对并发的关注也是与日俱增，特别在多线程方面。在C++11的基础上，C++14、C++17标准，以及一些技术规范标准，都在为C++的多线程和并发添砖加瓦。

本书会使用C++11多线程来编写并发程序，并介绍相关的语言特性和工具。本章以“为什么要使用并发”作为起始点，会对“什么情况下不使用并发”进行阐述，并且对C++的并发方式进行总结。最后，以一个简单的并发实例结束这一章。后面的章节中，会有更多的例子，以便大家对线程库进行更加深入的了解。



# 1.1 何谓并发

并发，指两个或两个以上的独立活动同时发生。

并发在生活中随处可见，我们可以一边走路一边说话，也可以两只手同时做不同的动作，还有每个人都过着相互独立的生活——当我在游泳的时候，你可以看球赛等等。

## 1.1.1 计算机的并发

计算机的并发，指在单个系统里同时执行多个独立的任务。

并发在计算机领域不是一个新鲜事物。很多年前，一台计算机就能通过多任务操作系统的切换功能，同时运行多个应用，并且多处理器服务器很早就实现了并行计算。那并发为什么在计算机领域越来越流行呢？——真正的并行。



以前，大多数计算机只有一个处理器，具有单个处理单元或核芯。这种机器只能在某一时刻执行一个任务，不过可以在单位时间内对任务进行多次切换。通过“这个任务做一会，另一个任务再做一会儿”的方式，让任务看起来是并行的，这种方式称为任务切换。如今，这样的方式仍称为“并发“，因为任务切换得太快，以至于无法感觉到任务会暂时挂起。任务切换会给用户造成一种“并发的假象”，任务切换和真正并发执行相比，行为上还是有着微妙的不同。



多核计算机用于高性能计算已有多年。基于单芯多核处理器(多核处理器)的台式机，也越来越大众化。无论有多少个处理器，这些机器都能够真正的并行多个任务，我们称其为"硬件并发"。





下图显示了处理两个任务时的理想情景，每个任务被分为10个相等大小的子任务块。在一个双核机器上，每个任务可以在各自的处理核心上执行。在单核机器上做任务切换时，每个任务的块交替进行，但中间有一小段分隔(图中所示灰色分隔条)，这表示切换任务的开销。进行任务切换时，操作系统必须保存当前任务CPU的状态和指令指针，并计算要切换到哪个任务，再将切换到的任务加载处理器中。CPU可能要将新任务的指令和数据载入到缓存，这会让CPU停止执行指令，从而造成的更多的延迟。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240218202430676-17082590721501-17167194882171.png)



​												 **并发的两种方式：真正并行 vs. 任务切换**



有些处理器可以在一个核心上执行多个线程，但硬件并发在多处理器上效果更加显著。硬件线程最重要的是数量，也就是可以并发运行独立任务的数量。即便是硬件并发的系统，也有比硬件“可并行最大任务数”还要多的任务需要执行，所以任务切换在这些情况下仍然适用。例如，一个台计算机上可能会有成百上千个的任务在运行，即便是在计算机处于空闲时，还是会有后台任务在运行。正是任务切换使得这些后台任务可以运行，这样系统使用者就可以同时运行文字处理器、编译器、编辑器和Web浏览器了。



下图显示了四个任务在双核处理器上的任务切换，仍是将任务整齐地划分为同等大小子任务块的理想情况。实际上，许多因素会使得任务分割不均或调度不规则。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240218202509800-17082591108082-17167195014012.png)



**四个任务在两个核心之间的切换**

无论应用是在单核处理器，还是多核处理器上运行，不论是任务切换，还是硬件并发，这里提到的技术、功能和类都会涉及。如何使用并发，很大程度上取决于可用的硬件并发。



## 1.1.2 并发的方式

试想当两个程序员在两个独立的办公室一起做一个软件项目，他们可以安静地工作、互不干扰，并且人手一套参考手册。但沟通起来就有些困难，比起可以直接交谈，他们必须使用电话、电子邮件或到对方的办公室进行面对面交流。并且，管理两个办公室需要有一定的经费支出，还需要购买多份参考手册。

假设，让开发人员同在一间办公室办公，他们可以自由的对某个程序设计进行讨论，也可以在纸或白板上绘制图表，对设计观点进行辅助性阐释。现在，只需要管理一个办公室和一套参考资料就够了。遗憾的是，开发人员可能难以集中注意力，并且还可能存在资源共享的问题(比如，"参考手册哪去了?")

以上两种方法，描绘了并发的两种基本途径。开发人员代表线程，办公室代表进程。第一种方式是每个进程只要一个线程，这就类似让每个开发人员拥有自己的办公室。而第二种方式是每个进程有多个线程，如同一个办公室里有两个开发人员。让我们在一个应用中，简单的分析一下这两种方式。



##### 多进程并发

使用并发的第一种方式，是将应用程序分为多个独立的进程同时运行，就像同时进行网页浏览和文字处理一样。如下图所示，独立的进程可以通过进程间的通信渠道传递讯息(信号、套接字、文件、管道等等)。不过，这种进程间的通信通常非常复杂，或是速度很慢。这是因为操作系统会对进程进行保护，以避免一个进程去修改另一个进程的数据。还有一个缺点是运行多个进程的固定开销：需要时间启动进程，操作系统需要资源来管理进程等等

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240218202735928-17082592570663-17167195123343.png)



​														**一对并发运行的进程之间的通信**



当然，以上的机制也不是一无是处：操作系统在进程间提供了保护和更高级别的通信机制，可以更容易编写安全的并发代码。实际上，在类似于[Erlang](https://github.com/xiaoweiChen/CPP-Concurrency-In-Action-2ed-2019/blob/master/content/chapter1/www.erlang.org)的编程环境中，会将进程作为并发的基础块。

使用多进程实现并发还有一个优势——可以使用远程连接(可能需要联网)的方式，在不同的机器上运行独立的进程。虽然，这增加了通信成本，但在设计精良的系统中，这种低成本方案可提高程序的并行可用性和性能。

##### 多线程并发

并发的另一个方式，在单进程中运行多个线程。线程很像轻量级的进程：每个线程相互独立运行，并且可以在不同的指令序列中运行。不过，进程中的所有线程都共享地址空间，并且能访问到大部分数据———全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。虽然，进程之间通常共享内存，但同一数据的内存地址在不同的进程中不相同，所以这种共享难以建立和管理。下图展示了一个进程中的两个线程，正在通过共享内存进行通信。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240218202858096-17082593392944-17167195424714.png)



​															**同一进程中，一对并发线程间的通信**

地址空间共享，以及缺少线程间的数据保护，使得操作系统记录的工作量减小，所以使用多线程的开销远远小于多进程。不过，共享内存的灵活性是有代价的：如果多个线程访问数据，那么必须确保每个线程所访问到的数据一致，这就需要对线程通信做大量的工作。

多个单线程/进程间的通信，要比单一进程中多线程通信的开销大，若不考虑共享内存可能带来的问题，多线程将会成为主流语言(包括C++)更青睐的并发方式。此外，C++标准并未对进程通信提供原生支持，所以实现会依赖于平台相关的API。因此，这里只关注多线程的并发，之后所提到"并发"，均为多线程实现。

多线程应用中，还有一种方式：并行。



## 1.3 并发与并行

对多线程来说，这两个概念大部分是重叠的。对于很多人来说，它们没有什么区别。这两个词是用来描述硬件同时执行多个任务的方式，而“并行”更加注重性能。使用硬件提高数据处理速度时，会讨论程序的并行性。当关注重点在于任务分离或任务响应时，会讨论程序的并发性。这两个术语存在的目的，就是为了区别多线程中不同的关注点。

了解了并发后，来看看为什么要使用并发。



# 1.2 为什么使用并发

原因有二：分离关注点(SOC)和性能(或者可能是两个都有。当然，除了“我乐意”这样的原因)。

## 1.2.1 分离关注点

编写软件时，分离关注点是个好办法。通过将相关的代码与无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能。即使一些操作需要同时进行，依旧可以使用并发，分离不同的功能区域。若不显式地使用并发，就得编写一个任务切换机制，或者在操作中主动地调用一段不相关的代码。



假设有一个用户界面的处理密集型应用——DVD播放程序。这样的应用程序，应具备这两种功能：一，要从光盘中读出数据，对图像和声音进行解码，之后把解码出的信号输出至视频和音频硬件中进行处理，从而实现DVD的播放；二，接收来自用户的输入，当用户单击“暂停”、“返回菜单”或“退出”按键的时候执行对应的操作。



当应用是单个线程时，应用需要在回放期间定期检查用户的输入，这就需要把“DVD播放”代码和“用户界面”代码放在一起。



如果使用多线程方式来分离这些关注点，“用户界面”代码和“播放DVD”代码不需要放在一起：一个线程可以处理“用户界面”，另一个进行“播放DVD”。它们之间会有交互(用户点击“暂停”)，不过任务需要人为的进行关联。



这会带来响应上的错觉，因为用户界面线程通常可以立即响应用户的请求，尽管当请求传递给工作中的线程时，其响应可能只是显示“忙碌中”的光标或“请等待”的消息。同理，独立的线程通常用来执行那些必须在后台持续运行的任务，例如：桌面搜索程序中监视文件系统变化的任务。因为交互清晰可辨，所以会使每个线程变的更加简单。



这种情况下，对线程的划分是基于概念上的设计，所以线程数不再依赖CPU核芯数。

## 1.2.2 性能

重核系统已经存在了几十年，直至现今，它们也只在超级计算机、大型机和大型服务器系统中才能看到。然而，芯片制造商越来越倾向于芯片的多核设计，即在单芯片上集成2、4、16或更多的处理器，从而获取更好的性能。因此，多核计算机、多核嵌入式设备，现在越来越普遍。它们计算能力的提高不是使单一任务运行的更快，而是并行多个任务。曾今，开发者无需做任何事，可以看着程序随着处理器的更新换代而变得更快。但是现在，如Herb Sutter所说的，“没有免费的午餐了。” *如果想要利用日益增长的计算能力，那就必须设计多任务并发式软件*，那些迄今都忽略并发的开发者们要上心了。



有两种利用并发来提高性能的方式：

- 第一，将一个单个任务分成几部分并行运行，从而降低总运行时间，这就是任务并行(task parallelism)。虽然，这听起来很直观，但是一个相当复杂的过程，因为各个部分之间可能存在着依赖。区别可能是在过程方面,一个线程执行算法的一部分，而另一个线程执行算法的另一个部分（第一种方式）

- 第二，或是在处理数据时，每个线程在不同的数据块上执行相同的操作(第二种方式)。第二种方式被称为数据并行(data parallelism)。



容易并行的算法称为是“易并行的”(embarrassingly parallel)。易并行算法具有良好的可扩展特性——当可用硬件线程的数量增加时，算法的并行性也会随之增加，这种算法很好的体现了“人多力量大”。如果算法中有不易并行的部分，可以把算法划分成固定(不可扩展)数量的并行任务。



并发提升性能的第二种方式，是利用并行来解决更大的问题：每次只处理一个文件，不如处理2个、10个或20个。虽然，这是数据并行的一种应用(通过对多组数据同时执行相同的操作)，但着重点不同。处理等量数据仍然需要同样的时间，但现在在相同的时间内处理了更多的数据。这种方法也有限制，并非所有情况下都是有效的。不过，这种方法所带来的吞吐量提升，可以让某些功能成为可能——如果图片的不同区域能被并行地处理，程序就可以处理更高分辨率的视频。



## 2.3 什么时候不使用并发



知道何时不使用并发与知道何时使用一样重要。

不使用并发的唯一原因就是收益比不上成本。使用并发的代码在很多情况下难以理解，因此编写和维护多线程代码会产生脑力成本，而增加的复杂性也可能会引起更多的错误。除非潜在的性能增益足够大或关注点分离地足够清晰，能抵消为确保正确开发所需的额外时间，以及维护代码的额外成本；否则，勿用并发。



同样地，性能增益可能会小于预期。启动线程时存在固有开销，因为操作系统需要分配内核资源和堆栈空间，才能把新线程加入调度器中。如果在线程上的任务完成得很快，那么实际执行任务的时间要比启动线程的时间小很多，这会导致应用的整体性能不如直接使用单线程。



此外，线程的资源有限。如果太多的线程同时运行，则会消耗很多操作系统资源，从而使得操作系统整体上运行得更加缓慢。不仅如此，因为每个线程都需要一个独立的堆栈，所以运行太多的线程也会耗尽进程的可用内存或地址空间。对于一个可用地址空间为4GB(32bit)的架构来说，这的确是个问题：如果每个线程都有一个1MB的堆栈(很多系统都会这样分配)，那么4096个线程将会用尽所有地址空间(不会给代码、静态数据或者堆数据留有任何空间)。即便是64位(或者更大)的系统，不存在这种地址空间限制，但其他资源也是有限的：如果你运行了太多的线程，也会出问题。尽管线程池可以用来限制线程的数量，但也并不是什么灵丹妙药。



当客户端/服务器(C/S)应用在服务端为每一个链接启动一个独立的线程时，对于少量链接没有问题，但当用于需要处理大量链接的高需求服务器时，就会因为线程太多而耗尽系统资源。这种场景下，使用线程池可以对性能进行优化。



最后，运行越多的线程，操作系统就需要越多的上下文切换，每一次切换都需要耗费时间。所以在某些时候，增加线程实际上会降低应用的整体性能。如果试图得到系统的最佳性能，可以考虑使用硬件并发(或不用)，并调整运行线程的数量。



和所有其他优化策略一样，我们为了性能而使用并发：它可以大幅度提高应用的性能，但也可能让代码更加复杂，难以理解，并且更容易出错。因此，应用中只有性能关键部分，才值得并发化。当然，如果性能收益仅次于设计清晰或分离关注点，也可以使用多线程。



既然已经看到了这里，那无论是为了性能、关注点分离，亦或是因为多线程星期一(multithreading Monday)(译者：可能是学习多线程的意思)，你应该确定要在应用中使用并发了。

好！那对于C++开发者来说，多线程意味着什么呢？

# 1.3 并发和多线程

使用C++11标准，可以编写不依赖平台扩展的多线程代码。了解C++线程库前，我们需要先来了解一下C++多线程的发展史。

## 1.3.1 C++多线程历史

C++98(1998)标准不承认线程的存在，并且各种语义以顺序抽象的形式编写。不仅如此，也没有内存模型，所以C++98标准在缺少编译器扩展的情况下，没办法编写多线程应用。



当然，编译器供应商可以自由地向语言添加扩展，C语言中流行的多线程API——POSIX标准中的C标准和Microsoft Windows API——很多C++编译器供应商，通过各种平台相关的扩展来支持多线程。这种支持受限于平台，并且需要相应平台的运行库(例如，异常处理机制的代码)能在多线程情况下正常工作。因为编译器和处理器的实际表现很不错，所以在少数编译器供应商提供正式的多线程内存模型之前，开发者们已经写了很多的C++多线程程序了。



由于不满足于使用平台相关的API来处理多线程，C++开发者们希望使用面向对象的多线程工具。像MFC这样的应用框架，和Boost和ACE这样的通用库，这些库提供了很多简化任务的多线程工具。各种库在细节方面差异很大，但在启动线程的方面，却大同小异。其使用一种便利的设计，也就是使用带锁的获取资源即初始化(RAII, Resource Acquisition Is Initialization)的方式。



编写多线程代码需要扎实的编程基础，当前的很多C++编译器为多线程编程者提供了对应的API，还有一些与平台无关的C++库。这样，开发者们就可以通过这些API来实现多线程。不过，由于缺乏统一的标准，以及内存模型，就会产生一些问题，这些问题在跨平台的多线程应用上表现得尤为明显。



## 1.3.2 支持并发

这些随着C++11标准的发布而改变，新标准中不仅有了全新的内存模型，C++标准库也扩展了：管理线程、保护共享数据、线程间同步操作，以及原子操作。



标准线程库很大程度上，基于之前C++库的经验积累。特别是Boost线程库，作为新标准库的很多类与Boost库中的相关类有着相同名称和结构。随着C++标准的进步，Boost线程库也随着C++标准在许多方面做出改变，这样之前使用Boost的用户会发现自己非常熟悉C++11的线程库。



支持并发仅是C++11标准的变化之一，为了让开发者们的工作变得更加轻松。



## 1.3.3 C++14和C++17对并发和并行的更多支持

C++14中为并发和并行添加了一个新的互斥量类型，用于保护共享数据。C++17考虑的更多：添加了一整套的并行算法。两个标准将整个标准库进行了补强，这让书写多线程代码变得更加容易。



之前还提到了一个并发技术标准，其描述C++标准对于函数和类的扩展，尤其是对线程同步方面。

C++新标准直接支持原子操作，允许开发者通过指定语义的方式编写代码，从而无需了解与平台相关的汇编指令。这对于编写高效、可移植的代码来说，无疑是一个好消息。编译器不仅可以搞定具体平台，还可以编写优化器来解释操作语义，从而让程序得到更好的优化。

## 1.3.4 C++线程库的效率



这是高性能计算开发者的担忧之一。为了效率，C++整合了一些底层工具。这样就需要了解使用高级工具和使用低级工具的开销差，这个开销差就是抽象代价(abstraction penalty)。



C++标准委员会在设计标准库时，特别是线程库，就注意到了这点。目的就是在实现相同功能的前提下，确保使用高级API和使用底层API带来的性能收益相当。这样，标准库在主流平台上都能有高效实现(带有非常低的抽象代价)。



为了达到终极性能，需要给与硬件打交道的开发者提供足够多的底层工具。为了这个目的，形成了原子操作库，可直接控制单个位、字节、内部线程间的同步，以及对所有变化的可见性。原子类型可以在很多地方使用，使用新标准的代码会有更好的可移植性，并且容易维护。



标准库也提供了更高级别工具，使得编写多线程代码更加简单。因为有额外的代码需要执行，这些工具确实会带来性能开销。总的来说，性能开销和手工编写的函数差不多，并且编译器会内联大部分代码。



某些情况下，高级工具会提供一些额外的功能。极少的情况下，一些未使用的功能会影响其他代码的性能。如果很看重程序的性能，并且高级工具带来的开销过高，最好是通过较低层工具来实现功能。绝大多数情况下，用过高的复杂性和过大的出错率，来交换小幅度的性能收益是不划算的。即便是瓶颈出现在C++标准库的工具中，也可能由低劣的程序设计造成。例如，如果过多的线程竞争一个互斥单元，将会很明显的影响性能。与其在互斥操作上耗费时间，不如重新设计，减少互斥单元上的竞争。



C++标准库没有提供所需的性能或行为时，就需要使用与平台相关的工具了。



## 1.3.5 平台相关的工具

虽然C++线程库为多线程和并发处理提供了较全面的工具，但某些平台会提供额外的工具。为了方便地使用这些工具，又使用标准C++线程库，在C++线程库中提供一个`native_handle()`的成员函数，允许通过使用平台相关API直接操作底层实现。就其本质而言，任何使用`native_handle()`执行的操作都是完全依赖于平台。



所以，使用平台相关的工具之前，先了解一下标准库能够做些什么吧。



# 1.4 开始入门

OK！准备一个能与C++11/C++14/C++17标准兼容的编译器。C++多线程程序是什么样子呢？其实，和其他C++程序差不多。唯一的区别在于某些函数可以并发运行，所以需要确保共享数据在并发访问时是安全的。当然，为了并发地运行，必须使用特定函数以及对象来管理各个线程。



## 1.4.1 欢迎来到并发世界

从一个经典的例子开始：一个打印“Hello World”的程序。一个非常简单的在单线程中运行的Hello World程序如下所示，当我们谈到多线程时，可以作为一个基准。

```c
#include <iostream>
int main()
{
  std::cout << "Hello World\n";
}
```

这个程序所做的就是将“Hello World”写进标准输出流。让我们将它与下面清单所示的简单的“Hello, Concurrent World”程序做个比较，它启动了一个独立的线程来显示这个信息。



**代码 1.1 一个简单的Hello, Concurrent World程序：**

```c
#include <iostream>
#include <thread>  // 1
void hello()  // 2
{
  std::cout << "Hello Concurrent World\n";
}
int main()
{
  std::thread t(hello);  // 3
  t.join();  // 4
}
```

- 第一个区别是增加了`#include <thread>`①，包括标准库中对多线程支持的声明，管理线程的函数和类在`<thread>`中声明(保护共享数据的函数和类在其他头文件中声明)。

其次，打印信息移到了一个独立的函数中②。因为每个线程都必须一个执行单元，新线程的执行从这里开始。对于应用程序来说，初始线程是main()，但是对于其他线程，可以在`std::thread`对象的构造函数中指定——本例中命名为`t`③的`std::thread`对象拥有新函数hello()作为其执行函数。



下一个区别：与直接写入标准输出或是从main()调用hello()不同，该程序启动了一个全新的线程来实现，将线程数量一分为二——初始线程始于main()，而新线程始于hello()。



新的线程启动之后③，初始线程继续执行。如果它不等待新线程结束，就运行到main()函数结束——有可能发生在新线程运行之前。这就是为什么在④这里调用`join()`的原因——这会让创建线程等待`std::thread`对象创建的线程。

这看起来仅是为了将一条信息写入标准输出，确实如此——正如上文所描述的，一般来说并不值得为了如此简单的任务而使用多线程，尤其是在这期间初始线程并没做什么。后面的章节中，将通过更加复杂的实例来展示，在哪些情景下使用多线程更有意义。

# 1.5 本章总结

本章中，提及了并发与多线程的含义，以及在应用中为什么使用(或不使用)并发。还提及了多线程在C++中的发展历程，从1998标准中完全缺乏支持，经历了各种平台相关的扩展，再到C++11/C++14/C++17标准和并发技术规范对多线程的支持。芯片制造商选择了以多核芯的形式，使得更多任务可以同时执行的方式来增加处理能力，而不是增加单个核心的执行速度。在这个趋势下，C++多线程来的正是时候，它使得开发者们可以利用CPU带来的更加强大的硬件并发。



HelloWorld中例子，展示C++标准库中的类和函数有多么的简单。C++中使用多线程并不复杂，复杂的是如何设计代码以实现预期的行为。尝试了HelloWorld的示例后，可以了解更多实质性的内容。

在后面，我们将了解用于管理线程的类和函数。