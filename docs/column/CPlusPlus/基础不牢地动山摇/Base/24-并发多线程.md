# 并发多线程



:::details `什么是线程？`

程序：（静态的概念）源代码，指令。

进程：运行着的程序，一个程序可以创建多个进程

线程：线程从属于进程，一个进程可以有多个线程，线程之间共享进程的资源



在C++中，线程被抽象成了`thread` 类。

头文件：`#include <thread>`

线程类：`std::thread`

:::



## 线程状态

|                 thread类成员函数                  | 作用                                                         |
| :-----------------------------------------------: | ------------------------------------------------------------ |
| `explicit thread(Function&& fx, Args&&... args )` | 创建线程                                                     |
|                     `join()`                      | 回收线程的资源，阻塞函数。                                   |
|                    `detach()`                     | 分离子线程，可自动回收线程资源，但是需要确保主线程不提前关闭 |

`thread`类的构造方法如下所示，在开发中我们通常是用第二个构造方法来创建thread线程对象的，注意的是thread类不支持拷贝构造（故而删除了= 运算符的重载）。但是他支持移动构造。



:::details `构造函数`

```c++
class thread{
	public:
		//无参构造一个线程对象，不执行任何任务（不会创建/启动子线程）
    	thread() noexcept;
    
   		//创建线程对象，在线程中执行任务函数fx中的代码，args是要传递给任务函数fx的参数。
        //任务函数fx可以是【普通函数】、类的【非静态成员函数】、类的静态成员函数、lambda函数、仿函数。
    	//在实际开发中我们通常使用此构造方法来创建线程对象
		template< class Function, class... Args >
		explicit thread(Function&& fx, Args&&... args );
    
        // 删除拷贝构造函数，不允许线程对象之间的拷贝。 
        thread(const thread& ) = delete;
       // 删除了重载= 运算符，不支持拷贝构造。
    	thread& operator= (const other&) = delete;
    
    
    	// 移动构造函数，将线程other的资源所有权转移给新创建的线程对象。
    	thread(thread&& other ) noexcept;
    
        // 重载了= 运算符，支持移动构造赋值运算符。
   		 thread& operator= (thread&& other) noexcept;
      
}
```

:::



下面，我们来给我们的应用进程来创建线程。



如果开启了多线程，即我们创建新的线程`thread t1`，根据CPU的时分复用原理，在某个时间片内会执行`t1`线程，时间片到了又继续执行主线程，在一段时间内，我们可以认为我们的程序在单位时间内同时执行了函数内两段代码，做了两件事情。 从而提供我们程序执行效率。

:::details `多线程基本示例:`

```c++
#include <iostream>
#include<thread>
#include<windows.h>
using namespace std;


void func(int bh, const string& str) 
{
	for (int ii = 1; ii <= 10; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		Sleep(1000);   // 休眠1秒。
	}
}
int main(){
	
	//创建线程对象t1 并指定t1执行的线程函数是func。
    thread t1(func, 3, "我是一只傻傻鸟。");
    
    
	 cout << "任务开始。\n";
	 for (int ii = 0; ii < 10; ii++) {
		 cout << "执行任务中......\n";
		 Sleep(1000);   
	 }
	 cout << "任务完成。\n";
    
    //此时，在主线程执行循环的同时，CPU也会分时间片给线程t1,让线程t1执行func()函数。
    // 在这个时间内，我们观察结果，可以看到在该时间内，做了两件事情，一件事执行任务，一件事表白。比一个主线程串行执行做的事更多。
    
    
    //回收线程t1的资源
	 t1.join();
}
```

:::





:::details `各种线程函数的写法`

上面的例子，线程`t1` 是使用全局函数作为线程执行函数的，  关于线程执行函数我们也可以是用`Lamba函数`，`仿函数`  ` 类静态成员函数`   `类的非静态成员函数`来充当。



- `lamba函数  创建线程`

```c++
int main() {
	//lamba函数  创建线程。
	auto fuc = [](int bh, const string& str) {
		for (int ii = 1; ii <= 10; ii++)
		{
			cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
			Sleep(1000);   // 休眠1秒。
		}
	};
	thread t1(fuc, 3, "我是一只傻傻鸟。");
    t1.join();
}
```

- `仿函数 创建线程`

```c++

// 仿函数 创建线程
class mythread1
{
public:
	void operator()(int bh, const string& str) {
		for (int ii = 1; ii <= 10; ii++)
		{
			cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
			Sleep(1000);   // 休眠1秒。
		}
	}
};
int main() {
	thread t1(mythread1(), 3, "我是一只傻傻鸟。");
	t1.join();
}
```

- `类中有静态成员函数`

```c++
// 类中有静态成员函数。
class mythread2
{
public:
	static void func(int bh, const string& str) {
		for (int ii = 1; ii <= 10; ii++)
		{
			cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
			Sleep(1000);   // 休眠1秒。
		}
	}
};

int main() {
	thread t1(mythread2::func, 3, "我是一只傻傻鸟。");
	t1.join();
}
```

- `类中有普通成员函数`

```c++
// 类中有普通成员函数。
class mythread3
{
public:
	void func(int bh, const string& str) {
		for (int ii = 1; ii <= 10; ii++)
		{
			cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
			Sleep(1000);   // 休眠1秒。
		}
	}
};

int main() {
	//必须先创建类的对象，必须保证对象的生命周期比子线程要长。
	mythread3 myth;
	// 第一个参数 类成员函数的地址
	thread t1(&mythread3::func, &myth, 3, "我是一只傻傻鸟。"); // 第二个参数必须填对象的地址 即this指针
	t1.join();
}
```

:::





:::tip ` 注意`

- 先创建的子线程不一定跑得最快（程序运行的速度有很大的偶然性）。
- 线程的任务函数返回后，子线程将终止。
- 如果主程序（主线程）退出（不论是正常退出还是意外终止），全部的子线程将强行被终止。

虽然同一个进程的多个线程共享进程的栈空间，但是，每个子线程在这个栈中也是拥有自己私有的栈空间。所以，线程执行完成线程函数之后，结需要回收资源。



回收子线程的资源有两种方法：

- 在主程序中，调用join()成员函数等待子线程退出，回收它的资源。如果子线程已退出，join()函数立即返回，否则会阻塞等待，直到子线程退出。
- 在主程序中，调用detach()成员函数分离子线程，子线程退出时，系统将自动回收资源。分离后的子线程不可join()。

:::





:::details `回收线程资源示例:`

```c
class thread
{
	public:
    	// 释放子线程的资源，阻塞函数，一直阻塞到线程对象执行完线程函数为止
		void join();
    
    	//分离子线程，非阻塞函数，在主线程不退出的情况下，等线程对象执行任务函数完毕之后，会自动回收线程占用的资源。
		void detach();
    
    	//用joinable()成员函数可以判断子线程的分离状态，函数返回布尔类型。
    	bool joinable();

    
}
```

- join 的玩法

```c
void func(int bh, const string& str) 
{
	for (int ii = 1; ii <= 10; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		Sleep(1000);   // 休眠1秒。
	}
}
int main(){
	thread t1(func, 3, "我是一只傻傻鸟。");
	thread t2(func, 4, "我是一只傻傻鸟。4");
	//main主线程已经执行完毕了，调用join方法，当前的t1子线程，t2子线程正在执行任务函数。
	 t1.join();// t1.join() 会阻塞,直到线程完成线程函数之后，才会
	 t2.join();
	 return 0;
}
```

- detach 的玩法

```c

void func(int bh, const string& str) {
	for (int ii = 1; ii <= 10; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		Sleep(1000);   // 休眠1秒。
	}
}
int main(){
	thread t1(func, 3, "我是一只傻傻鸟。");
	thread t2(func, 4, "我是一只傻傻鸟。4");

	 cout << "任务完成";
    // 可以看到子线程t1,子线程2会被执行，执行完毕后，可以正常退出。
	 t1.detach();
	 t2.detach();
	
	//只要主线程不关闭,t1 t2执行他们的线程函数之后，线程会自动释放资源。
	 Sleep(12000);
	 return 0;
}
```

:::

## 线程操作

`include <thread>` 头文件中提供了命名空间`this_thread`来表示当前线程，该命名空间的函数可以有效帮助我们进行一些线程操作

|      线程操作函数名       |                    作用                    |
| :-----------------------: | :----------------------------------------: |
|        `get_id()`         |               获取当前线程ID               |
|       `sleep_for()`       |                  线程休眠                  |
|         `yield()`         |   让线程主动让出自己已经抢到的CPU时间片    |
|       `sleep_until`       |              类似sleep_for()               |
|      `thread::move`       |                  线程移动                  |
|      `thread::swap`       |                  线程交换                  |
|       `call_once()`       | 处理线程函数中，只能执行一次的代码块函数。 |
| `thread::native_handle()` |            获取操作系统线程句柄            |



:::details `获取到当前执行任务函数的线程ID thread.get_id.`

```c
namespace this_thread 
{
	int get_id();   //获取线程ID
}

//也可以是使用thread类的get_id() 获取到线程的ID
class thread{
    public:
    	int get_id();
}
```

```c
void func(int bh, const string& str) 
{
	cout << "子线程ID" << this_thread::get_id() <<endl;
	for (int ii = 1; ii <= 10; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		Sleep(1000);   // 休眠1秒。
	}
}

int main(){
	thread t1(func, 3, "我是一只傻傻鸟。");
	thread t2(func, 8, "我有一只小小鸟。");

	 cout << "主线程ID" << this_thread::get_id() <<endl;
	 cout << "T1线程ID" << t1.get_id() << endl;
	 cout << "T2线程ID" << t2.get_id() << endl;
	 Sleep(12000);
	 cout << "任务完成"<<endl; 
	
	 t1.join();
	 t2.join();

	 return 0;
}

```

:::



让一个线程暂时休眠，在`Linux`操作系统提供的核心API `sleep()`方法可以完成，在`Windows`操作系统提供了`Sleep()` API来完成。在C11中，提供了一种在两个操作系统平台都通用的处理。



:::details `sleep_for 线程休眠`

```c

--------------Windows线程休眠
#include<windows.h>
Sleep(int millS);
Sleep(12000)
    
--------------Linux线程休眠
#include <unistd.h>
unsigned int sleep(unsigned int seconds);
Sleep(12)
    
-------------------C11提供
this_thread::sleep_for(chrono::milliseconds(12000));        
```

:::





:::details `线程不支持拷贝构造 只能进行移动构造`

演示下，`thread` 类是不支持拷贝构造的。可以看到用已经创建好的`thread` t2 去复制构造t3,t4。编译器爆红了，告诉我们他是已删除的函数了。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20230516165302981.png)



而我们可以使用移动构造函数。来初始化新的线程t3,注意移动构造之后，t2就不再表示一个线程了。

```c
void func(int bh, const string& str) {
	cout << "子线程ID" << this_thread::get_id() <<endl;
	for (int ii = 1; ii <= 10; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		Sleep(1000);   // 休眠1秒。
	}
}

int main(){
	thread t1(func, 3, "我是一只傻傻鸟。");
	thread t2(func, 8, "我有一只小小鸟。");


	 cout << "主线程ID-" << this_thread::get_id() <<endl;
	 cout << "T1线程ID-" << t1.get_id() << endl;
	 cout << "T2线程ID-" << t2.get_id() << endl;
	 cout << "---------------------------------";
	 t1.swap(t2);
	 cout << "T1线程ID-" << t1.get_id() << endl;
	 cout << "T2线程ID-" << t2.get_id() << endl;

	 //移动构造
	 thread t3 = move(t2);
	 Sleep(12000);
	 cout << "任务完成"<<endl; 
	 t1.join();
	 //注意这里释放t3 ,t2代表的线程资源已经转移到t2了，不表示线程对象了。t3才表示线程。
	 t3.join();

	 return 0;
}

```

:::



现在我们知道了C11的thread对象不能被拷贝，可以转移，实际上不同的两个thread对象也是支持交换。





:::details `交换两个线程对象所有权`

```c++
class thread{
	public:
		void swap(std::thread& other);    // 交换两个线程对象。
}
```

如下演示下如何交换两个线程对象

```c
#include <iostream>
#include<thread>
#include<windows.h>
using namespace std;

void func(int bh, const string& str) 
{
	cout << "子线程ID" << this_thread::get_id() <<endl;
	for (int ii = 1; ii <= 10; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		Sleep(1000);   // 休眠1秒。
	}
}

int main(){
	thread t1(func, 3, "我是一只傻傻鸟。");
	thread t2(func, 8, "我有一只小小鸟。");


	 cout << "主线程ID-" << this_thread::get_id() <<endl;
	 cout << "T1线程ID-" << t1.get_id() << endl;
	 cout << "T2线程ID-" << t2.get_id() << endl;
	 cout << "---------------------------------";
	 t1.swap(t2);
	 cout << "T1线程ID-" << t1.get_id() << endl;
	 cout << "T2线程ID-" << t2.get_id() << endl;

	 Sleep(12000);

	 cout << "任务完成"<<endl; 
	
	 t1.join();
	 t2.join();

	 return 0;
}
```

:::



在多线程环境中，我们希望某些函数只能被调用一次，例如：初始化某个对象，而这个对象只能被初始化一次。在线程的任务函数中，可以用`std::call_once()`来保证某个函数只被调用一次。



:::details `once_func 保证某个函数只调用一次，适合用于初始化`



其实就是给`once_func()` 执行完毕之后，加了一个锁，从而不能被其他线程所执行。

头文件：`#include <mutex>`

```c++
template< class callable, class... Args >
// 第一个参数，代表锁 第二个参数表示只能执行一次的函数 第三个参数这个只能执行一次的函数的形参
void call_once( std::once_flag& flag, Function&& fx, Args&&... args );
```

```c++
#include <iostream>
#include<thread>
#include <mutex> 
#include<windows.h>
using namespace std;


once_flag onceflag; // 本质是取值为0和1的锁。
// 在线程中，打算只调用一次的函数。
void once_func(const int bh, const string& str) {
	cout << "once_func() bh= " << bh << ", str=" << str << endl;
}

void func(int bh, const string& str) {
    //在线程函数func中我只希望once_func被执行1次。
	// 所以使用 call_once调用该once_func函数
	call_once(onceflag, once_func, 0, "各位观众，我要开始表白了。");

	for (int ii = 1; ii <= 3; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		this_thread::sleep_for(chrono::seconds(1));    // 休眠1秒。
	}
}
int main(){
    //可以看到func即使线程t1的线程执行函数也是线程t2的线程执行函数，但是最终once_func()只会被执行一次
	thread t1(func, 3, "我是一只傻傻鸟。");
	thread t2(func, 8, "我有一只小小鸟。");

	t1.join();
	t2.join();
	return 0;
}

```

:::



C++11定义了线程标准，不同的平台和编译器在实现的时候，本质上都是对操作系统的线程库进行封装，会损失一部分功能。为了弥补C++11线程库的不足，thread类提供了`native_handle()`成员函数，用于获得与操作系统相关的原生线程句柄，操作系统原生的线程库就可以用原生线程句柄操作线程。





:::details `获取线程句柄native_handle`





比如`thread`类中没有可以取消线程的API,我们可以使用`native_handle()`,先获取到线程在Linux操作系统的句柄，然后再调用`pthread_cancel()` 来完成取消线程的事情。

```c
#include <iostream>
#include <thread>
#include <pthread.h>        // Linux的pthread线程库头文件。
using namespace std;

void func()    // 线程任务函数。
{
  for (int ii=1;ii<=10;ii++)
  {
    cout << "ii=" << ii << endl;
    this_thread::sleep_for(chrono::seconds(1));    // 休眠1秒。
  }
}

int main()
{
  thread tt(func);          // 创建线程。

  this_thread::sleep_for(chrono::seconds(5));    // 休眠5秒。

  pthread_t thid= tt.native_handle();  // 获取Linux操作系统原生的线程句柄。

  pthread_cancel(thid);  // 取消线程。

  tt.join();   // 等待线程退出。
}
```

:::



## 线程同步

同一进程中的多个线程共享该进程中全部的系统资源。多个线程访问同一共享资源的时候会产生冲突。





线程的顺序性：

程序按照代码的先后顺序执行。
CPU为了提高程序整体的执行效率，可能会对代码进行优化，按更高效的顺序执行。
CPU虽然不保证完全按照代码的顺序执行，但它会保证最终的结果和按代码顺序执行时的结果一致。



线程的可见性:

线程操作共享变量时，会将该变量从内存加载到CPU缓存中，修改该变量后，CPU会立即更新缓存，但不一定会立即将它写回内存。这时候，如果其它线程访问该变量，从内存中读到的是旧数据，而非第一个线程操作后的数据。
当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。



线程的原子性：

CPU执行指令:读取指令、读取内存、执行指令、写回内存。
比如进行一次 `i++`,底层CPU执行会分为三步。

- 1)从内存中读取 i 的值;

- 2）把i+1; 

- 3）把结果写回内存。

即线程一个操作(有可能包含有多个步骤）要么全部执行（生效)，要么全部都不执行(都不生效)



比如开启两个线程，可以看到对于临界资源aa,他们发生的彼此抢占，导致最后的结果不符合预期，此时线程t1,线程t2之间的关系就是竞争关系，是互斥的。针对这种情况，我们应该保护临界资源，通常会加锁。来确保线程抢占得到CPU时间片，只能由他来对临界资源进行访问操作。

:::details `线程资源竞争问题`

```c++
#include <iostream>
#include <thread>        
using namespace std;


// 定义全局变量aa,此时aa就是线程t1,t2的临界资源
int aa = 0;    
void func() {
	for (int ii = 1; ii <= 1000000; ii++) {
		aa++;
	}		
}

void func2() {
	for (int ii = 1; ii <= 1000000; ii++) {
		aa++;
	}
}

int main()
{
	//创建两个线程t1,t2，此时他们相互抢占CPU分配的时间片，然后对aa临界资源做++操作
	//有可能出现t1线程执行func()时，循环中没来得及让aa+1,就到线程t2处理了。t2又不知到aa没有+1
	//这种情况在两个线程之间相互出现，最后导致结果不符合预期
	thread t1(func);    
	thread t2(func2);     


	//释放线程资源
	t1.join();         
	t2.join();         

	cout << "aa=" << aa << endl;   // 显示全局变量aa的值。
}
```

如何处理多个线程访问同一共享资源的时候会产生冲突，即多多个线程访问时的共享资源进行一次协商分配。

可以通过下面三种方式，来达到线程同步的目的：

- 1、volatile关键字。
- 2、原子操作（原子类型)。
- 3、线程同步（锁)。

:::

## 互斥锁

C++11提供了四种互斥锁类，来处理多个线程对临界资源的访问问题，处理多个线程之间的互斥竞争关系。

-  mutex类：互斥锁。 独占的互斥量，不能递归使用。
- timed_mutex类：带超时机制的互斥锁。不能递归使用。
- recursive_mutex类：递归互斥锁。不带超时功能。
- recursive_timed_mutex类：带超时机制的递归互斥锁。

包含头文件：`#include <mutex>`



:::details `mutex 类方法说明`

- 构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。

```c
class mutex
{
	public:
    
       //为当前线程执行的所需的共享资源加锁 阻塞，必须是mutex对象是未锁定状态的时候。
    	
 //调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况:
    //1、如果该互斥量当前没 有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。
    //2、如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。
    //3、 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。
    
		void lock();
    
      // 对共享资源解锁 只有持有锁的线程才能解锁。阻塞，必须是mutex对象锁定的时候。
      //解锁，释放对互斥量的所有权。
    	void unlock();
    
    // 如果互斥锁是未锁定状态，则加锁成功，函数返回true。
	// 如果互斥锁是锁定状态，则加锁失败，函数立即返回false。（线程不会阻塞等待）
    // 针对处理临界资源不止一个的情况吧。
    
    //尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况
    //1、如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量
    //2、如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。
    //3、如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。
      void try_lock();
}
```

:::



:::details `mutex示例1：`

```c++
#include <iostream>
#include <thread>
#include<mutex>
using namespace std;

//创建互斥锁对象
mutex mtx;
int aa = 0;    

//分别对临界资源加锁保护他。确保aa++的操作完成了，确保临界资源只能被一个线程获取到
// 类别想象：排队上厕所，人（线程）厕所（临界资源）厕所门锁（mutex互斥锁对象）
void func() {
	for (int ii = 1; ii <= 1000000; ii++) {
		mtx.lock();
		aa++;
		mtx.unlock();

	}		
}

void func2() {
	for (int ii = 1; ii <= 1000000; ii++) {
		mtx.lock();
		aa++;
		mtx.unlock();

	}
}

int main()
{

	thread t1(func);    
	thread t2(func2);     


	//释放线程资源
	t1.join();         
	t2.join();         

	cout << "aa=" << aa << endl;   // 显示全局变量aa的值。
}
```

:::



:::details `mutex 示例2`

```c
#include <mutex>
#include <iostream>
#include <thread>
#define TRY_MUTEX       0
#define MY_MUTEX        1
volatile int counter(0); // non-atomic counter
std::mutex mtx;
void increases10k()
{
        for(int i=0;i<10000;i++)
        {
#if TRY_MUTEX
                if(mtx.try_lock())
                {
                        ++counter;
                        mtx.unlock();
                }
#elif MY_MUTEX
                mtx.lock();
                ++counter;
                mtx.unlock();
#endif
        }

}
int main(int argc,char **argv)
{
        std::thread threads[10];
        for(int i=0;i<10;i++)
        {
             threads[i]=std::thread(increases10k);
        }
        for(auto& th:threads)
                th.join();
        std::cout << " successful increases of the counter " << counter <<std::endl;
        return 0;

}
```

- 编译

```c
 g++ -o mutex_test mutex_test.c -std=c++11 -lpthread
```

- 执行效果

```c
# try_lock
$ ./mutex_test 
 successful increases of the counter 53612
# lock
$ vim mutex_test.c
 successful increases of the counter 100000
```

可以看到try_lock只是尝试加锁，不管是否成功都不阻塞，而lock如果加锁失败会一直阻塞直到加锁成功。

:::







:::details `timed_mutex`

timed_mutex类在 mutex 类的基础上扩展增加了两个成员函数：bool try_lock_for(时间长度)，bool try_lock_until(时间点);让加锁和时间产生了挂钩。即std::timed_mutex比std::mutex多了两个超时获取锁的接口：try_lock_for和try_lock_until。

```c
class timed_mutex{
	public:
        void lock();
    	void unlock();
        void try_lock();
    
       // -- 特性增加
	   bool try_lock_for(chrono::seconds());
       bool bool try_lock_until(时间点);
}
```



```c
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
std::timed_mutex mutex;
void work()
{
	std::chrono::milliseconds timeout(100);
	while (true)
	{
		if (mutex.try_lock_for(timeout))
		{
			std::cout << std::this_thread::get_id() << ": do work with the mutex" << std::endl;
			std::chrono::milliseconds sleepDuration(250);
			std::this_thread::sleep_for(sleepDuration);
			mutex.unlock();
			std::this_thread::sleep_for(sleepDuration);
		}
		else
		{
			std::cout << std::this_thread::get_id() << ": do work without the mutex" << std::endl;
			std::chrono::milliseconds sleepDuration(100);
			std::this_thread::sleep_for(sleepDuration);
		}
	}
}
int main(void)
{
	std::thread t1(work);
	std::thread t2(work);
	t1.join();
	t2.join();
	std::cout << "main finish\n";
	return 0;
}
```

:::



:::details `recursive_mutex`

recursive_mutex类表示一种递归互斥锁，即允许同一线程多次获得互斥锁，从而可以解决同一线程多次加锁造成的死锁问题。

```c++
#include <iostream>
#include <mutex>        // 互斥锁类的头文件。
using namespace std;

class AA
{
	mutex m_mutex;
public:
	void func1() {
		m_mutex.lock();
		cout << "调用了func1()\n";
		m_mutex.unlock();
	}

	void func2() {
		m_mutex.lock();
		cout << "调用了func2()\n";
		func1();
		m_mutex.unlock();
	}
};

int main()
{
	AA aa;
	//aa.func1();
	aa.func2(); // 主线程调用func2，对要执行的线程资源开始加锁，然后调用func1(),fun1()中又去申请锁，因为func2()的
    //资源锁还没有释放，所以fun1不可能申请到锁，就导致了这个主线程一直在等待申请申请锁，而自己又不释放锁。
}
```

我们改用递归互斥锁`recursive_mutex` 对象来处理，就不会有这种问题了。

:::





:::details `recursive_mutex 示例2:`

```c
#include <iostream>
#include <thread>
#include <mutex>
struct Complex
{
	std::mutex mutex;
	int i;
	Complex() : i(0){}
	void mul(int x)
	{
		std::lock_guard<std::mutex> lock(mutex);
		i *= x;
	}
	void div(int x)
	{
		std::lock_guard<std::mutex> lock(mutex);
		i /= x;
	}
	void both(int x, int y)
	{
		std::lock_guard<std::mutex> lock(mutex);
		mul(x);
		div(y);
	}
};
int main(void)
{
    Complex complex;
    complex.both(32, 23);
    return 0;
}
```

运行后出现死锁的情况。在调用both时获取了互斥量，在调用mul时又要获取互斥量，但both的并没有 释放，从而产生死锁。



- 使用递归锁解决同一个线程的死锁问题

```c
#include <iostream>
#include <thread>
#include <mutex>
struct Complex
{
	std::recursive_mutex mutex;
	int i;
	Complex() : i(0){}
	void mul(int x)
	{
		std::lock_guard<std::recursive_mutex> lock(mutex);
		i *= x;
	}
	void div(int x)
	{
		std::lock_guard<std::recursive_mutex> lock(mutex);
		i /= x;
	}
	void both(int x, int y)
	{
		std::lock_guard<std::recursive_mutex> lock(mutex);
		mul(x);
		div(y);
	}
};
int main(void)
{
	Complex complex;
	complex.both(32, 23); //因为同一线程可以多次获取同一互斥量，不会发生死锁
	std::cout << "main finish\n";
	return 0;
}
```



:::





:::details `recursive_timed_mutex`

带超时机制的，递归互斥锁。

:::







:::details `lock_guard`



相对于手动lock和unlock，可以使用RAII(通过类的构造析构)来实现更好的编码方式。RAII：也称为“资源获取就是初始化”，是c++等编程语言常用的管理资源、避免内存泄露的方法。它保证 在任何情况下，使用对象时先构造对象，最后析构对象。



lock_guard是模板类，可以简化互斥锁的使用，也更安全。

lock_guard的定义如下。

```c++
template<class Mutex>

class lock_guard

{

  explicit lock_guard(Mutex& mtx);

}
```

lock_guard在构造函数中加锁，在析构函数中解锁。

lock_guard采用了RAII思想（在类构造函数中分配资源，在析构函数中释放资源，保证资源在离开作用域时自动释放），类比于智能指针，只有管加锁，而不用操心解锁的事情。

```c++
#include <iostream>
#include <thread>        
#include<mutex>
using namespace std;

int aa = 0;     
mutex mtx;
void func() {
	for (int ii = 1; ii <= 1000000; ii++) {
		// 只有管加锁，不用管解锁
		lock_guard<mutex> mlock(mtx);
		aa++;
	}


}

int main()
{
	// 用普通函数创建线程。
	thread t1(func);     // 创建线程t1，把全局变量aa加1000000次。
	thread t2(func);     // 创建线程t2，把全局变量aa加1000000次。

	t1.join();       
	t2.join();       

	cout << "aa=" << aa << endl;   
}
```

:::





:::details `lock_guard/unique_lock 示例`

```c
#include <iostream>
#include <thread>
#include <mutex>
#include <stdexcept>

std::mutex mtx;

void print_event(int x)
{
        if(x%2==0)
                std::cout << x << " is even\n";
        else
                throw (std::logic_error("not even"));

}

void print_thread_id(int id)
{
        try{
                std::unique_lock<std::mutex> lck(mtx);
                print_event(id);
        }
        catch(std::logic_error&)
        {
                std::cout << "[exception caught]\n";
        }
}

int main(int argc,char **argv)
{
        std::thread threads[10];
        for(int i=0;i<10;i++)
        {
              threads[i]=std::thread(print_thread_id,i+1);
        }
        for (auto& th : threads) th.join();
        return 0;
}
```

- 编译和执行

```c
$ g++ -o mutex_test lock_test.cc -std=c++11 -lpthread
$ ./mutex_test 
[exception caught]
6 is even
[exception caught]
4 is even
[exception caught]
2 is even
[exception caught]
8 is even
[exception caught]
10 is even
```

这里的unique_lock换成lock_guard是一样的。



:::



:::details `unique_lock`

`template <class Mutex> class unique_lock`是模板类，模板参数为互斥锁类型。

unique_lock和lock_guard都是管理锁的辅助类，都是RAII风格（在构造时获得锁，在析构时释放锁），让开发只关注加锁，而不用关心在何时释放锁。

二者的区别在于：为了配合condition_variable，unique_lock还有lock()和unlock()成员函数。

```c++
#include <iostream>
#include <string>
#include <thread>                     
#include <mutex>                      
#include <deque>                     
#include <queue>                    
#include <condition_variable>  
using namespace std;
class AA
{
    mutex m_mutex;                                  
    condition_variable m_cond; 
    queue<string, deque<string>> m_q;
public:
    void incache(int num)     //模拟生产者往消息队列加消息的函数     
    {
        //加锁，将消息放到消息队列
        lock_guard<mutex> lock(m_mutex); 
        for (int ii = 0; ii < num; ii++)
        {
            static int bh = 1;           
            string message = to_string(bh++) + "号超女";    
            m_q.push(message);    
        }
        // m_cond.notify_one();    
        //利用条件变量唤醒消费者线程，处理消息队列里面的消息
        m_cond.notify_all();         
    }

    void outcache()       // 消费者线程任务函数。
    {
        while (true)
        {
            string message;
            {
                // 把互斥锁转换成unique_lock<mutex>，并申请加锁。
                unique_lock<mutex> lock(m_mutex);

                //队列是空的， 阻塞当前线程，直到通知到达。   
                while (m_q.empty()) {
                    m_cond.wait(lock);
                }  
                // 从消息队列拿出消息
                message = m_q.front(); 
                m_q.pop();
            }
                
            // 对消息进行消费，假设消费这个消息需要1秒
            this_thread::sleep_for(chrono::milliseconds(1000));   
            cout << "线程：" << this_thread::get_id() << "，" << message << endl;
        }
    }
};

int main()
{
    AA aa;

    //创建三个消费着
    thread t1(&AA::outcache, &aa);  
    thread t2(&AA::outcache, &aa);    
    thread t3(&AA::outcache, &aa);     
    
    // 让主线程休眠2秒
    //此时子线程t1,t2,t3都处于wait状态，等待条件变量m_cond的通知
    this_thread::sleep_for(chrono::seconds(2));  

    //生产者向消息队列生产加入3个数据，并且条件变量m_cond 唤醒了全部的消费者
    aa.incache(3);     
    
    //此时再让主线程休眠3秒
    // 与此同时，消费者在消费生产者的这3个数据。并消费完成了。
    //任一消费者再获得锁，判断队列为空了，就又进入wait阻塞状态，等待条件变量的唤醒。
    this_thread::sleep_for(chrono::seconds(3));   


    //主线程，又让生产者往消息队列中加入了5个消息，从而又唤醒了全部的线程去消费。
    //消费完成了，所有的消费者又进入wait阻塞状态。
    aa.incache(5);      



    t1.join();  
    t2.join();
    t3.join();
}
```

:::



:::details `unique_lock和lock_guard的区别`

- unique_lock与lock_guard都能实现自动加锁和解锁，但是前者更加灵活，能实现更多的功能。
- unique_lock可以进行临时解锁和再上锁，如在构造对象之后使用lck.unlock()就可以进行解锁，lck.lock()进行上锁，而不必等到析构时自动解锁。lock_guard是不支持手动释放的。
- 一般来说，使用unique_lock比较多，除非追求极致的性能才会考虑使用lock_guard。

```c
#include <iostream>
#include <mutex>
#include <thread>
#include <deque>
#include <condition_variable>
#include <unistd.h>

std::deque<int> q;
std::mutex mtx;
std::condition_variable cond;
int count=0;

void func1()
{
        while(true)
        {
                // {
                std::unique_lock<std::mutex> locker(mtx);
                q.push_front(count++);
                locker.unlock();//如果是lock_guard，不支持手动解锁
                cond.notify_one();

                sleep(1);
        }
}

void func2()
{
        while(true)
        {
                std::unique_lock<std::mutex> locker(mtx);
                cond.wait(locker,[](){return !q.empty();});
                auto data=q.back();
                q.pop_back();
                std::cout << "thread2 get value form thread1: " << data << std::endl;
        }
}

int main(int atgc,char ** argv)
{
        std::thread t1(func1);
        std::thread t2(func2);
        t1.join();
        t2.join();
        return 0;
 }
```

条件变量的目的就是为了，在没有获得某种提醒时长时间休眠; 如果正常情况下, 我们需要一直循环 (+sleep), 这样的问题就是CPU消耗+时延问题，条件变量的意思是在cond.wait这里一直休眠直到 cond.notify_one唤醒才开始执行下一句; 还有cond.notify_all()接口用于唤醒所有等待的线程。



那么这里为什么必须使用unique_lock呢? 原因是条件变量在wait时会进行unlock再进入休眠, lock_guard并无该操作接口。

1. wait: 如果线程被唤醒或者超时那么会先进行lock获取锁, 再判断条件(传入的参数)是否成立, 如果成立则 wait函数返回否则释放锁继续休眠。
2. notify: 进行notify动作并不需要获取锁。
3. 使用场景：需要结合notify+wait的场景使用unique_lock；如果只是单纯的互斥使用lock_guard。

:::



## 条件变量

可以说条件变量condition_variable，是C++线程库，提出的处理线程之间的协同关系的类。可以让多个线程一起去协同做好一件事。



条件变量是一种线程同步机制。当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。通过互斥锁和条件变量，我们可以实现生产者消费者的模型（比如互联网的请求响应处理机制、消息队列）



C++11的条件变量提供了两个类：

- condition_variable：只支持与普通mutex搭配，效率更高。

- condition_variable_any：是一种通用的条件变量，可以与任意mutex搭配（包括用户自定义的锁类型）。

包含头文件：<condition_variable>





互斥量是多线程间同时访问某一共享变量时，保证变量可被安全访问的手段。但单靠互斥量无法实现线 程的同步。线程同步是指线程间需要按照预定的先后次序顺序进行的行为。C++11对这种行为也提供了 有力的支持，这就是条件变量。条件变量位于头文件`#include <condition_variable>`下。【官方说明文档】。



条件变量使用过程

1. 拥有条件变量的线程获取互斥量。
2. 循环检查某个条件，如果条件不满足则阻塞直到条件满足；如果条件满足则向下执行。
3. 某个线程满足条件执行完之后调用notify_one或notify_all唤醒一个或者所有等待线程。





> 条件变量提供了两类操作：wait和notify。这两类操作构成了多线程同步的基础。





:::details `wait函数`

```c
void wait (unique_lock<mutex>& lck);
template <class Predicate>
void wait (unique_lock<mutex>& lck, Predicate pred);
```

包含两种重载，第一种只包含unique_lock对象，另外一个Predicate 对象（等待条件），这里必须使用 unique_lock，因为wait函数的工作原理：

- 当前线程调用wait()后将被阻塞并且函数会解锁互斥量，直到另外某个线程调用notify_one或者
  notify_all唤醒当前线程；一旦当前线程获得通知(notify)，wait()函数也是自动调用lock()，同理不
  能使用lock_guard对象。
- 如果wait没有第二个参数，第一次调用默认条件不成立，直接解锁互斥量并阻塞到本行，直到某一
  个线程调用notify_one或notify_all为止，被唤醒后，wait重新尝试获取互斥量，如果得不到，线程
  会卡在这里，直到获取到互斥量，然后无条件地继续进行后面的操作。
- 如果wait包含第二个参数，如果第二个参数不满足，那么wait将解锁互斥量并堵塞到本行，直到某
  一个线程调用notify_one或notify_all为止，被唤醒后，wait重新尝试获取互斥量，如果得不到，线
  程会卡在这里，直到获取到互斥量，然后继续判断第二个参数，如果表达式为false，wait对互斥
  量解锁，然后休眠，如果为true，则进行后面的操作。

:::



:::details `wait_for函数`

```c
template <class Clock, class Duration>
    cv_status wait_for (unique_lock<mutex>& lck,const chrono::time_point<Clock,Duration>& abs_time);

template <class Clock, class Duration, class Predicate>
    bool wait_for (unique_lock<mutex>& lck,const chrono::time_point<Clock,Duration>& abs_time,Predicate pred);
```

和wait不同的是，wait_for可以执行一个时间段，在线程收到唤醒通知或者时间超时之前，该线程都会 处于阻塞状态，如果收到唤醒通知或者时间超时，wait_for返回，剩下操作和wait类似。

:::



:::details `wait_until函数`

```c
template <class Clock, class Duration>
    cv_status wait_until (unique_lock<mutex>& lck,const chrono::time_point<Clock,Duration>& abs_time);
template <class Clock, class Duration, class Predicate>
    bool wait_until (unique_lock<mutex>& lck,const chrono::time_point<Clock,Duration>& abs_time,Predicate pred);
```

与wait_for类似，只是wait_until可以指定一个时间点，在当前线程收到通知或者指定的时间点超时之 前，该线程都会处于阻塞状态。如果超时或者收到唤醒通知，wait_until返回，剩下操作和wait类似 。

:::





:::details `notify_one 函数`

```c
void notify_one() noexcept;	
```

解锁正在等待当前条件的线程中的一个，如果没有线程在等待，则函数不执行任何操作，如果正在等待的线程多于一个，则唤醒的线程是不确定的。随机唤醒。

:::



:::details `notify_all函数`

```c
void notify_all() noexcept;
```

解锁正在等待当前条件的所有线程，如果没有正在等待的线程，则函数不执行任何操作

:::







:::details `condition_variable`

`condition_variable`类只有一个构造方式，就是无参构造，并且他不支持拷贝构造。 

```c++
class condition_variable{
	public:
    	// 默认构造函数。
    	condition_variable();
    	//禁止拷贝,删除了拷贝构造函数
    	condition_variable(const condition_variable &)=delete 
        // 禁止赋值 删除了重载赋值运算符    
        condition_variable& condition_variable::operator=(const condition_variable &)=delete     
           
}
```

condition_variable 常用的的成员方法是通知处于阻塞wait状态的线程，让该线程唤醒。以及让一个线程由运行状态变成阻塞态。

```c++
 class condition_variable{
	public:
       //通知一个等待的线程
		notify_one()
		// 通知全部等待的线程    
        notify_all()    
            
        //  阻塞当前线程，直到通知到达。    
        wait(unique_lock<mutex> lock) 
        //循环的阻塞当前线程，直到通知到达且谓词满足。
        wait(unique_lock<mutex> lock,Pred pred)
        wait_for(unique_lock<mutex> lock,时间长度)  
        wait_for(unique_lock<mutex> lock,时间长度,Pred pred)   
        wait_until(unique_lock<mutex> lock,时间点)
        wait_until(unique_lock<mutex> lock,时间点,Pred pred) 
  }
```

:::





## 原子类型

:::details `原子类型（atomic）`

C++11提供了`atomic<T>`模板类（结构体），用于支持原子类型.

模板参数可以是bool、char、int、long、long long、指针类型（不支持浮点类型和自定义数据类型）。

原子操作由CPU指令提供支持，它的性能比锁和消息传递更高，并且，不需要程序员处理加锁和释放锁的问题，支持修改、读取、交换、比较并交换等操作。



头文件：`#include <atomic>`





原子类型的对象包含特定type ()的值。
原子对象的主要特征是，从不同的线程访问这个包含的值不会导致数据竞争（即，这样做是明确定义的行为，访问正确排序）。通常，对于所有其他对象，导致同时访问同一对象的数据争用的可能性将操作限定为未定义行为。
【官方介绍】。此外，对象能够通过指定不同的内存顺序来同步对其线程中其他非原子对象的访问。







:::details `构造函数`

```c
class atomic<T>
{
    public:
    	 // 默认构造函数。使对象处于未初始化状态。
    	atomic() noexcept = default; 
   		 // 转换函数。使用val初始化对象
    	atomic(T val) noexcept;  
    	// 禁用拷贝构造函数。无法复制/移动对象。
    	atomic(const atomic&) = delete;  
    	 // 禁用赋值函数。
    	atomic& operator=(const atomic&) = delete;  
}
```

我们在开发中，通常使用第二个构造方法，将临界资源（基本数据类型）转为原子类型。

- 示例

```c
std::atomic<bool> ready (false);
```

:::





:::details `is_lock_free函数`

```c
     // 查询某原子类型的操作是直接用CPU指令（返回true），还是编译器内部的锁（返回false）。
    //指示对象是否无锁。无锁对象不会导致其他线程在访问时被阻塞（可能使用该类型的某种事务内存）。
	//此函数返回的值与为同一类型的所有其他对象返回的值一致；
    //调用此成员函数不会启动任何数据争用。
	//如果对象是无锁的返回true。
bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;
```

:::



:::details `store函数`

```c
      // 把val的值存入原子变量。
void store (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;
void store (T val, memory_order sync = memory_order_seq_cst) noexcept;
```

修改包含的值。将包含的值替换为val。该操作是原子操作。
参数是以下类型的可能值之一：

| value                | 内存顺序 | 描述                                                         |
| -------------------- | -------- | ------------------------------------------------------------ |
| memory_order_relaxed | 宽松     | 副作用不同步                                                 |
| memory_order_consume | 消费     | 同步对携带来自上一版本或顺序一致操作的依赖项的值的可见副作用。 |
| memory_order_acquire | 获得     | 同步上一版本或顺序一致操作的所有可见副作用。                 |
| memory_order_seq_cst | 顺序一致 | 将所有可见的副作用与其他顺序一致的操作同步，遵循单个总订单。 |

- 示例 

```c
std::atomic<int> foo (0);
foo.store(x,std::memory_order_relaxed);     // set value atomically
```

:::





:::details `load函数`

```c
// 读取原子变量的值。
T load (memory_order sync = memory_order_seq_cst) const volatile noexcept;
T load (memory_order sync = memory_order_seq_cst) const noexcept;
```

读取包含的值，返回包含的值。该操作是原子操作。
参数是以下类型的可能值之一：

| value                | 内存顺序 | 描述                                                         |
| -------------------- | -------- | ------------------------------------------------------------ |
| memory_order_relaxed | 宽松     | 副作用不同步                                                 |
| memory_order_consume | 消费     | 同步对携带来自上一版本或顺序一致操作的依赖项的值的可见副作用。 |
| memory_order_acquire | 获得     | 同步上一版本或顺序一致操作的所有可见副作用。                 |
| memory_order_seq_cst | 顺序一致 | 将所有可见的副作用与其他顺序一致的操作同步，遵循单个总订单。 |

- 示例

```c
std::atomic<int> foo (0);

int x;
do {
    x = foo.load(std::memory_order_relaxed);  // get value atomically
} while (x==0);
```

:::



:::details `exchange函数`

```c
	 // 把val的值存入原子变量，返回原值。
T exchange (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;
T exchange (T val, memory_order sync = memory_order_seq_cst) noexcept;
```

访问和修改包含的值，将包含的值替换并返回它前面的值。
整个操作是原子的（原子读-修改-写操作）：从读取（要返回）值的那一刻到此函数修改值的那一刻，该值不受其他线程的影响。

- 示例

```c
#include <iostream>       // std::cout
#include <atomic>         // std::atomic
#include <thread>         // std::thread
#include <vector>         // std::vector

std::atomic<bool> ready (false);
std::atomic<bool> winner (false);

void count1m (int id) {
  while (!ready) {}                  // wait for the ready signal
  for (int i=0; i<1000000; ++i) {}   // go!, count to 1 million
  if (!winner.exchange(true)) { std::cout << "thread #" << id << " won!\n"; }
};

int main ()
{
  std::vector<std::thread> threads;
  std::cout << "spawning 10 threads that count to 1 million...\n";
  for (int i=1; i<=10; ++i) threads.push_back(std::thread(count1m,i));
  ready = true;
  for (auto& th : threads) th.join();

  return 0;
}
```

:::



:::details `compare_exchange_weak函数`

```c
bool compare_exchange_weak (T& expected, T val,memory_order sync = memory_order_seq_cst) volatile noexcept;
bool compare_exchange_weak (T& expected, T val,memory_order sync = memory_order_seq_cst) noexcept;
bool compare_exchange_weak (T& expected, T val,memory_order success, memory_order failure) volatile noexcept;
bool compare_exchange_weak (T& expected, T val,memory_order success, memory_order failure) noexcept;
```

比较和交换包含的价值（weak）。将对象的包含值的内容与：

- 如果为 true，则用 （like） 替换包含的值。
- 如果为 false，则替换为包含的值。



该函数始终访问包含的值以读取它，并且 - 如果比较为 true- 它也会替换它。但是整个操作是原子的：在读取值的那一刻和替换值的那一刻之间，其他线程不能修改该值。



请注意，此函数直接将所包含值的物理内容与 ;这可能会导致对相等使用的值进行比较失败（如果基础类型具有填充位、陷阱值或相同值的替代表示形式），尽管此比较应在保留的循环中快速收敛。



与不同的是，这个weak版本允许通过返回来虚假地失败，即使预期确实等于所包含的对象。对于某些循环算法，这可能是可接受的行为，并且可能会在某些平台上显著提高性能。在这些虚假故障中，函数返回而不修改。



```c
#include <iostream>       // std::cout
#include <atomic>         // std::atomic
#include <thread>         // std::thread
#include <vector>         // std::vector

// a simple global linked list:
struct Node { int value; Node* next; };
std::atomic<Node*> list_head (nullptr);

void append (int val) {     // append an element to the list
  Node* oldHead = list_head;
  Node* newNode = new Node {val,oldHead};

  // what follows is equivalent to: list_head = newNode, but in a thread-safe way:
  while (!list_head.compare_exchange_weak(oldHead,newNode))
    newNode->next = oldHead;
}

int main ()
{
  // spawn 10 threads to fill the linked list:
  std::vector<std::thread> threads;
  for (int i=0; i<10; ++i) threads.push_back(std::thread(append,i));
  for (auto& th : threads) th.join();

  // print contents:
  for (Node* it = list_head; it!=nullptr; it=it->next)
    std::cout << ' ' << it->value;
  std::cout << '\n';

  // cleanup:
  Node* it; while (it=list_head) {list_head=it->next; delete it;}

  return 0;
}
```

:::





:::details `compare_exchange_strong 函数`

```c
		T compare_exchange_strong(T &expect,const T val) noexcept; // 比较原子变量的值和预期值expect，如果当两个值相等，把val存储到原子变量中，函数返回true；如果当两个值不相等，用原子变量的值更新预期值，函数返回false。CAS指令。
```

比较和交换包含的值（strong）。将包含的值的内容与：

- 如果为 true，则用 （like） 替换包含的值。
- 如果为 false，则替换为包含的值。

该函数始终访问包含的值以读取它，并且如果比较为 true它也会替换它。但是整个操作是原子的：在读取值的那一刻和替换值的那一刻之间，其他线程不能修改该值。



请注意，此函数直接将所包含值的物理内容与 ;这可能会导致对相等使用的值进行比较失败（如果基础类型具有填充位、陷阱值或相同值的替代表示形式），尽管此比较应快速收敛到保留的循环中，例如通常与 一起使用的循环。



不同的是，这个强版本需要总是在预期确实等于所包含对象时返回，不允许虚假的失败。但是，在某些计算机上，对于在循环中检查此情况的某些算法，可能会显著提高性能。

:::



:::details `专业化支持的操作`

```c
class atomic<T>
{
    public:    	

   
		T fetch_add(const T val) noexcept; // 把原子变量的值与val相加，返回原值。
		T fetch_sub(const T val) noexcept; // 把原子变量的值减val，返回原值。
		T exchange(const T val) noexcept; // 把val的值存入原子变量，返回原值。

}
```

| 操作      | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| fetch_add | 添加到包含的值并返回它在操作之前具有的值                     |
| fetch_sub | 从包含的值中减去，并返回它在操作之前的值。                   |
| fetch_and | 读取包含的值，并将其替换为在读取值和 之间执行按位 AND 运算的结果。 |
| fetch_or  | 读取包含的值，并将其替换为在读取值和 之间执行按位 OR 运算的结果。 |
| fetch_xor | 读取包含的值，并将其替换为在读取值和 之间执行按位 XOR 运算的结果。 |



:::







原子类型的别名：

- `atomic<T>`模板类重载了整数操作的各种运算符。
- `atomic<T>`模板类的模板参数支持指针，但不表示它所指向的对象是原子类型。
- 原子整型可以用作计数器，布尔型可以用作开关。
- CAS指令是实现无锁队列基础。



:::details `atomic示例1：`

```c
#include <iostream>
#include <thread>       
#include<atomic>
using namespace std;

//使用原子类型 保证线程安全
atomic<int> aa = 0;   

void func() {
	for (int ii = 1; ii <= 1000000; ii++)
		aa++;
}

int main()
{
	
	thread t1(func);    
	thread t2(func);    

	t1.join();         
	t2.join();         

	cout << "aa=" << aa << endl;   
}
```

常用API:

```c++
#include <iostream>
#include <atomic>     // 原子类型的头文件。
using namespace std;

int main()
{
	atomic<int> a = 3;       // atomic(T val) noexcept;  // 转换函数。
	cout << "a=" << a.load() << endl;   // 读取原子变量a的值。输出：a=3
	a.store(8);      // 把8存储到原子变量中。
	cout << "a=" << a.load() << endl;   // 读取原子变量a的值。 输出：a=8
	
	int old;        // 用于存放原值。
	old = a.fetch_add(5);         // 把原子变量a的值与5相加，返回原值。
	cout << "old = " << old <<"，a = " << a.load() << endl;   // 输出：old=8，a=13
	old = a.fetch_sub(2);         // 把原子变量a的值减2，返回原值。
	cout << "old = " << old << "，a = " << a.load() << endl;   // 输出：old=13，a=11
	
	atomic<int> ii = 3;  // 原子变量
	int expect = 4;         // 期待值
	int val = 5;               // 打算存入原子变量的值
	// 比较原子变量的值和预期值expect，
	// 如果当两个值相等，把val存储到原子变量中；
	// 如果当两个值不相等，用原子变量的值更新预期值。
	// 执行存储操作时返回true，否则返回false。
	bool bret = ii.compare_exchange_strong(expect, val);
	cout << "bret=" << bret << endl;
	cout << "ii=" << ii << endl;
	cout << "expect=" << expect << endl;
}
```

:::





:::details `示例2：`



```c
// atomic::load/store example
#include <iostream> // std::cout
#include <atomic> // std::atomic, std::memory_order_relaxed
#include <thread> // std::thread
//std::atomic<int> count = 0;//错误初始化
std::atomic<int> count(0); // 准确初始化
void set_count(int x)
{
	std::cout << "set_count:" << x << std::endl;
	count.store(x, std::memory_order_relaxed); // set value atomically
}
void print_count()
{
	int x;
	do {
		x = count.load(std::memory_order_relaxed); // get value atomically
	} while (x==0);
	std::cout << "count: " << x << '\n';
}
int main ()
{
	std::thread t1 (print_count);
	std::thread t2 (set_count, 10);
	t1.join();
	t2.join();
	std::cout << "main finish\n";
	return 0;
}
```

原子操作在多线程中可以保证线程安全，而且效率会比互斥量好些。

:::





使用条件变量实现一个同步队列，同步队列作为一个线程安全的数据共享区，经常用于线程之间数据读取。



:::details `sync_queue.h`

```c
#ifndef SYNC_QUEUE_H
#define SYNC_QUEUE_H

#include <list>
#include <mutex>
#include <iostream>
#include <thread>
#include <condition_variable>

template<typename T>

class SyncQueue
{
private:

        std::list<T> _queue;                    //缓冲区
        std::mutex _mutex;                      //互斥量和条件变量结合起来使用
        std::condition_variable_any _notEmpty;  //不为空的条件变量
        std::condition_variable_any _notFull;   //没有满的条件变量
        int _maxSize;                           //同步队列最大的size

        bool IsFull() const
        {
                return _queue.size() ==_maxSize;
        }
        bool IsEmpty() const
        {
                return _queue.empty();
        }
public:
        SyncQueue(int maxSize):_maxSize(maxSize)
        {
        }
        void Put(const T& x)
        {
                std::lock_guard<std::mutex> locker(_mutex);
                while(IsFull())
                {
                        std::cout << "full wait..." << std::endl;
                        _notFull.wait(_mutex);
                }
                _queue.push_back(x);
                _notEmpty.notify_one();
        }
        void Take(T& x)
        {
                std::lock_guard<std::mutex> locker(_mutex);
                while (IsEmpty())
                {
                        std::cout << "empty wait.." << std::endl;
                        _notFull.notify_one();
                        _notEmpty.wait(_mutex);
                }
                x=_queue.front();
                _queue.pop_front();
                _notFull.notify_one();
        }
        bool Empty()
        {
                std::lock_guard<std::mutex> locker(_mutex);
                return _queue.empty();
        }
        bool Full()
        {
                std::lock_guard<std::mutex> locker(_mutex);
                return _queue.size() == _maxSize;
        }
        size_t Size()
        {
                std::lock_guard<std::mutex> locker(_mutex);
                return _queue.size();
        }
        int Count()
        {
                return _queue.size();
        }
};

#endif
```

:::





:::details `main.c`

```c
#include <iostream>
#include "sync_queue.h"
using namespace std;
SyncQueue<int> syncQueue(5);

void PutDatas()
{
        for (int i = 0; i < 20; ++i)
        {
                syncQueue.Put(888);
        }
        std::cout << "PutDatas finish\n";
}
void TakeDatas()
{
        int x = 0;
        for (int i = 0; i < 20; ++i)
        {
                syncQueue.Take(x);
                std::cout << x << std::endl;
        }
        std::cout << "TakeDatas finish\n";
}
int main(void)
{
        std::thread t1(PutDatas);
        std::thread t2(TakeDatas);
        t1.join();
        t2.join();
        std::cout << "main finish\n";
        return 0;
}
```

:::



代码中用到了std::lock_guard，它利用RAII机制可以保证安全释放mutex。

```c
std::lock_guard<std::mutex> locker(_mutex);
while(IsFull())
{
      std::cout << "full wait..." << std::endl;
      _notFull.wait(_mutex);
}
```

可以改为：

```c
std::lock_guard<std::mutex> locker(_mutex);
_notFull.wait(_mutex， [this] {return !IsFull();});
```

两种写法效果是一样的，但是后者更简洁，条件变量会先检查判断式是否满足条件，如果满足条件则重 新获取mutex，然后结束wait继续往下执行；如果不满足条件则释放mutex，然后将线程置为waiting状 态继续等待。

这里需要注意的是，wait函数中会释放mutex，而lock_guard这时还拥有mutex，它只会在出了作用域 之后才会释放mutex，所以这时它并不会释放，但执行wait时会提前释放mutex。

从语义上看这里使用lock_guard会产生矛盾，但是实际上并不会出问题，因为wait提前释放锁之后会处 于等待状态，在被notify_one或者notify_all唤醒后会先获取mutex，这相当于lock_guard的mutex在 释放之后又获取到了，因此，在出了作用域之后lock_guard自动释放mutex不会有问题。

这里应该用unique_lock，因为unique_lock不像lock_guard一样只能在析构时才释放锁，它可以随时释 放锁，因此在wait时让unique_lock释放锁从语义上更加准确。





> 使用unique_lock和condition_variable改写为用等待一个判断式的方法来实现一个简单的队列



:::details `sync_queue2.h`

```c
#ifndef SIMPLE_SYNC_QUEUE_H
#define SIMPLE_SYNC_QUEUE_H
#include <thread>
#include <condition_variable>
#include <mutex>
#include <list>
#include <iostream>
template<typename T>
class SimpleSyncQueue
{
        public:
                SimpleSyncQueue(){}
                void Put(const T& x)
                {
                        std::lock_guard<std::mutex> locker(_mutex);
                        _queue.push_back(x);
                        _notEmpty.notify_one();
                }
                void Take(T& x)
                {
                        std::unique_lock<std::mutex> locker(_mutex);
                        _notEmpty.wait(locker, [this]{return !_queue.empty(); });
                        x = _queue.front();
                        _queue.pop_front();
                }
                bool Empty()
                {
                        std::lock_guard<std::mutex> locker(_mutex);
                        return _queue.empty();
                }
                size_t Size()
                {
                        std::lock_guard<std::mutex> locker(_mutex);
                        return _queue.size();
                }
        private:
                std::list<T> _queue;
                std::mutex _mutex;
                std::condition_variable _notEmpty;
};
#endif // SIMPLE_SYNC_QUEUE_H
```

:::





:::details `main.c`

```c
#include <iostream>
#include "sync_queue2.h"
using namespace std;
SimpleSyncQueue<int> syncQueue;
void PutDatas()
{
        for (int i = 0; i < 20; ++i)
        {
                syncQueue.Put(888);
        }
        std::cout << "PutDatas finish\n";
}
void TakeDatas()
{
        int x = 0;
        for (int i = 0; i < 20; ++i)
        {
                syncQueue.Take(x);
                std::cout << x << std::endl;
        }
        std::cout << "TakeDatas finish\n";
}
int main(void)
{
        std::thread t1(PutDatas);
        std::thread t2(TakeDatas);
        t1.join();
        t2.join();
        std::cout << "main finish\n";
        return 0;
}
```

:::
