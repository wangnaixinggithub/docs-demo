# 并发多线程



:::details `什么是线程？`

程序：（静态的概念）源代码，指令。

进程：运行着的程序，一个程序可以创建多个进程

线程：线程从属于进程，一个进程可以有多个线程，线程之间共享进程的资源



在C++中，线程被抽象成了`thread` 类。

头文件：`#include <thread>`

线程类：`std::thread`

:::



## 线程状态

|                 thread类成员函数                  | 作用                                                         |
| :-----------------------------------------------: | ------------------------------------------------------------ |
| `explicit thread(Function&& fx, Args&&... args )` | 创建线程                                                     |
|                     `join()`                      | 回收线程的资源，阻塞函数。                                   |
|                    `detach()`                     | 分离子线程，可自动回收线程资源，但是需要确保主线程不提前关闭 |

`thread`类的构造方法如下所示，在开发中我们通常是用第二个构造方法来创建thread线程对象的，注意的是thread类不支持拷贝构造（故而删除了= 运算符的重载）。但是他支持移动构造。



:::details `构造函数`

```c++
class thread{
	public:
		//无参构造一个线程对象，不执行任何任务（不会创建/启动子线程）
    	thread() noexcept;
    
   		//创建线程对象，在线程中执行任务函数fx中的代码，args是要传递给任务函数fx的参数。
        //任务函数fx可以是【普通函数】、类的【非静态成员函数】、类的静态成员函数、lambda函数、仿函数。
    	//在实际开发中我们通常使用此构造方法来创建线程对象
		template< class Function, class... Args >
		explicit thread(Function&& fx, Args&&... args );
    
        // 删除拷贝构造函数，不允许线程对象之间的拷贝。 
        thread(const thread& ) = delete;
       // 删除了重载= 运算符，不支持拷贝构造。
    	thread& operator= (const other&) = delete;
    
    
    	// 移动构造函数，将线程other的资源所有权转移给新创建的线程对象。
    	thread(thread&& other ) noexcept;
    
        // 重载了= 运算符，支持移动构造赋值运算符。
   		 thread& operator= (thread&& other) noexcept;
      
}
```

:::



下面，我们来给我们的应用进程来创建线程。



如果开启了多线程，即我们创建新的线程`thread t1`，根据CPU的时分复用原理，在某个时间片内会执行`t1`线程，时间片到了又继续执行主线程，在一段时间内，我们可以认为我们的程序在单位时间内同时执行了函数内两段代码，做了两件事情。 从而提供我们程序执行效率。

:::details `多线程基本示例:`

```c++
#include <iostream>
#include<thread>
#include<windows.h>
using namespace std;


void func(int bh, const string& str) 
{
	for (int ii = 1; ii <= 10; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		Sleep(1000);   // 休眠1秒。
	}
}
int main(){
	
	//创建线程对象t1 并指定t1执行的线程函数是func。
    thread t1(func, 3, "我是一只傻傻鸟。");
    
    
	 cout << "任务开始。\n";
	 for (int ii = 0; ii < 10; ii++) {
		 cout << "执行任务中......\n";
		 Sleep(1000);   
	 }
	 cout << "任务完成。\n";
    
    //此时，在主线程执行循环的同时，CPU也会分时间片给线程t1,让线程t1执行func()函数。
    // 在这个时间内，我们观察结果，可以看到在该时间内，做了两件事情，一件事执行任务，一件事表白。比一个主线程串行执行做的事更多。
    
    
    //回收线程t1的资源
	 t1.join();
}
```

:::





:::details `各种线程函数的写法`

上面的例子，线程`t1` 是使用全局函数作为线程执行函数的，  关于线程执行函数我们也可以是用`Lamba函数`，`仿函数`  ` 类静态成员函数`   `类的非静态成员函数`来充当。



- `lamba函数  创建线程`

```c++
int main() {
	//lamba函数  创建线程。
	auto fuc = [](int bh, const string& str) {
		for (int ii = 1; ii <= 10; ii++)
		{
			cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
			Sleep(1000);   // 休眠1秒。
		}
	};
	thread t1(fuc, 3, "我是一只傻傻鸟。");
    t1.join();
}
```

- `仿函数 创建线程`

```c++

// 仿函数 创建线程
class mythread1
{
public:
	void operator()(int bh, const string& str) {
		for (int ii = 1; ii <= 10; ii++)
		{
			cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
			Sleep(1000);   // 休眠1秒。
		}
	}
};
int main() {
	thread t1(mythread1(), 3, "我是一只傻傻鸟。");
	t1.join();
}
```

- `类中有静态成员函数`

```c++
// 类中有静态成员函数。
class mythread2
{
public:
	static void func(int bh, const string& str) {
		for (int ii = 1; ii <= 10; ii++)
		{
			cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
			Sleep(1000);   // 休眠1秒。
		}
	}
};

int main() {
	thread t1(mythread2::func, 3, "我是一只傻傻鸟。");
	t1.join();
}
```

- `类中有普通成员函数`

```c++
// 类中有普通成员函数。
class mythread3
{
public:
	void func(int bh, const string& str) {
		for (int ii = 1; ii <= 10; ii++)
		{
			cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
			Sleep(1000);   // 休眠1秒。
		}
	}
};

int main() {
	//必须先创建类的对象，必须保证对象的生命周期比子线程要长。
	mythread3 myth;
	// 第一个参数 类成员函数的地址
	thread t1(&mythread3::func, &myth, 3, "我是一只傻傻鸟。"); // 第二个参数必须填对象的地址 即this指针
	t1.join();
}
```

:::





:::tip ` 注意`

- 先创建的子线程不一定跑得最快（程序运行的速度有很大的偶然性）。
- 线程的任务函数返回后，子线程将终止。
- 如果主程序（主线程）退出（不论是正常退出还是意外终止），全部的子线程将强行被终止。

虽然同一个进程的多个线程共享进程的栈空间，但是，每个子线程在这个栈中也是拥有自己私有的栈空间。所以，线程执行完成线程函数之后，结需要回收资源。



回收子线程的资源有两种方法：

- 在主程序中，调用join()成员函数等待子线程退出，回收它的资源。如果子线程已退出，join()函数立即返回，否则会阻塞等待，直到子线程退出。
- 在主程序中，调用detach()成员函数分离子线程，子线程退出时，系统将自动回收资源。分离后的子线程不可join()。

:::





:::details `回收线程资源示例:`

```c
class thread
{
	public:
    	// 释放子线程的资源，阻塞函数，一直阻塞到线程对象执行完线程函数为止
		void join();
    
    	//分离子线程，非阻塞函数，在主线程不退出的情况下，等线程对象执行任务函数完毕之后，会自动回收线程占用的资源。
		void detach();
    
    	//用joinable()成员函数可以判断子线程的分离状态，函数返回布尔类型。
    	bool joinable();

    
}
```

- join 的玩法

```c
void func(int bh, const string& str) 
{
	for (int ii = 1; ii <= 10; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		Sleep(1000);   // 休眠1秒。
	}
}
int main(){
	thread t1(func, 3, "我是一只傻傻鸟。");
	thread t2(func, 4, "我是一只傻傻鸟。4");
	//main主线程已经执行完毕了，调用join方法，当前的t1子线程，t2子线程正在执行任务函数。
	 t1.join();// t1.join() 会阻塞,直到线程完成线程函数之后，才会
	 t2.join();
	 return 0;
}
```

- detach 的玩法

```c

void func(int bh, const string& str) {
	for (int ii = 1; ii <= 10; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		Sleep(1000);   // 休眠1秒。
	}
}
int main(){
	thread t1(func, 3, "我是一只傻傻鸟。");
	thread t2(func, 4, "我是一只傻傻鸟。4");

	 cout << "任务完成";
    // 可以看到子线程t1,子线程2会被执行，执行完毕后，可以正常退出。
	 t1.detach();
	 t2.detach();
	
	//只要主线程不关闭,t1 t2执行他们的线程函数之后，线程会自动释放资源。
	 Sleep(12000);
	 return 0;
}
```

:::

## 线程操作

`include <thread>` 头文件中提供了命名空间`this_thread`来表示当前线程，该命名空间的函数可以有效帮助我们进行一些线程操作

|      线程操作函数名       |                    作用                    |
| :-----------------------: | :----------------------------------------: |
|        `get_id()`         |               获取当前线程ID               |
|       `sleep_for()`       |                  线程休眠                  |
|         `yield()`         |   让线程主动让出自己已经抢到的CPU时间片    |
|       `sleep_until`       |              类似sleep_for()               |
|      `thread::move`       |                  线程移动                  |
|      `thread::swap`       |                  线程交换                  |
|       `call_once()`       | 处理线程函数中，只能执行一次的代码块函数。 |
| `thread::native_handle()` |            获取操作系统线程句柄            |



:::details `获取到当前执行任务函数的线程ID thread.get_id.`

```c
namespace this_thread 
{
	int get_id();   //获取线程ID
}

//也可以是使用thread类的get_id() 获取到线程的ID
class thread{
    public:
    	int get_id();
}
```

```c
void func(int bh, const string& str) 
{
	cout << "子线程ID" << this_thread::get_id() <<endl;
	for (int ii = 1; ii <= 10; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		Sleep(1000);   // 休眠1秒。
	}
}

int main(){
	thread t1(func, 3, "我是一只傻傻鸟。");
	thread t2(func, 8, "我有一只小小鸟。");

	 cout << "主线程ID" << this_thread::get_id() <<endl;
	 cout << "T1线程ID" << t1.get_id() << endl;
	 cout << "T2线程ID" << t2.get_id() << endl;
	 Sleep(12000);
	 cout << "任务完成"<<endl; 
	
	 t1.join();
	 t2.join();

	 return 0;
}

```

:::



让一个线程暂时休眠，在`Linux`操作系统提供的核心API `sleep()`方法可以完成，在`Windows`操作系统提供了`Sleep()` API来完成。在C11中，提供了一种在两个操作系统平台都通用的处理。



:::details `sleep_for 线程休眠`

```c

--------------Windows线程休眠
#include<windows.h>
Sleep(int millS);
Sleep(12000)
    
--------------Linux线程休眠
#include <unistd.h>
unsigned int sleep(unsigned int seconds);
Sleep(12)
    
-------------------C11提供
this_thread::sleep_for(chrono::milliseconds(12000));        
```

:::





:::details `线程不支持拷贝构造 只能进行移动构造`

演示下，`thread` 类是不支持拷贝构造的。可以看到用已经创建好的`thread` t2 去复制构造t3,t4。编译器爆红了，告诉我们他是已删除的函数了。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20230516165302981.png)



而我们可以使用移动构造函数。来初始化新的线程t3,注意移动构造之后，t2就不再表示一个线程了。

```c
void func(int bh, const string& str) {
	cout << "子线程ID" << this_thread::get_id() <<endl;
	for (int ii = 1; ii <= 10; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		Sleep(1000);   // 休眠1秒。
	}
}

int main(){
	thread t1(func, 3, "我是一只傻傻鸟。");
	thread t2(func, 8, "我有一只小小鸟。");


	 cout << "主线程ID-" << this_thread::get_id() <<endl;
	 cout << "T1线程ID-" << t1.get_id() << endl;
	 cout << "T2线程ID-" << t2.get_id() << endl;
	 cout << "---------------------------------";
	 t1.swap(t2);
	 cout << "T1线程ID-" << t1.get_id() << endl;
	 cout << "T2线程ID-" << t2.get_id() << endl;

	 //移动构造
	 thread t3 = move(t2);
	 Sleep(12000);
	 cout << "任务完成"<<endl; 
	 t1.join();
	 //注意这里释放t3 ,t2代表的线程资源已经转移到t2了，不表示线程对象了。t3才表示线程。
	 t3.join();

	 return 0;
}

```

:::



现在我们知道了C11的thread对象不能被拷贝，可以转移，实际上不同的两个thread对象也是支持交换。





:::details `交换两个线程对象所有权`

```c++
class thread{
	public:
		void swap(std::thread& other);    // 交换两个线程对象。
}
```

如下演示下如何交换两个线程对象

```c
#include <iostream>
#include<thread>
#include<windows.h>
using namespace std;

void func(int bh, const string& str) 
{
	cout << "子线程ID" << this_thread::get_id() <<endl;
	for (int ii = 1; ii <= 10; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		Sleep(1000);   // 休眠1秒。
	}
}

int main(){
	thread t1(func, 3, "我是一只傻傻鸟。");
	thread t2(func, 8, "我有一只小小鸟。");


	 cout << "主线程ID-" << this_thread::get_id() <<endl;
	 cout << "T1线程ID-" << t1.get_id() << endl;
	 cout << "T2线程ID-" << t2.get_id() << endl;
	 cout << "---------------------------------";
	 t1.swap(t2);
	 cout << "T1线程ID-" << t1.get_id() << endl;
	 cout << "T2线程ID-" << t2.get_id() << endl;

	 Sleep(12000);

	 cout << "任务完成"<<endl; 
	
	 t1.join();
	 t2.join();

	 return 0;
}
```

:::



在多线程环境中，我们希望某些函数只能被调用一次，例如：初始化某个对象，而这个对象只能被初始化一次。在线程的任务函数中，可以用`std::call_once()`来保证某个函数只被调用一次。



:::details `once_func 保证某个函数只调用一次，适合用于初始化`



其实就是给`once_func()` 执行完毕之后，加了一个锁，从而不能被其他线程所执行。

头文件：`#include <mutex>`

```c++
template< class callable, class... Args >
// 第一个参数，代表锁 第二个参数表示只能执行一次的函数 第三个参数这个只能执行一次的函数的形参
void call_once( std::once_flag& flag, Function&& fx, Args&&... args );
```

```c++
#include <iostream>
#include<thread>
#include <mutex> 
#include<windows.h>
using namespace std;


once_flag onceflag; // 本质是取值为0和1的锁。
// 在线程中，打算只调用一次的函数。
void once_func(const int bh, const string& str) {
	cout << "once_func() bh= " << bh << ", str=" << str << endl;
}

void func(int bh, const string& str) {
    //在线程函数func中我只希望once_func被执行1次。
	// 所以使用 call_once调用该once_func函数
	call_once(onceflag, once_func, 0, "各位观众，我要开始表白了。");

	for (int ii = 1; ii <= 3; ii++)
	{
		cout << "第" << ii << "次表白：亲爱的" << bh << "号，" << str << endl;
		this_thread::sleep_for(chrono::seconds(1));    // 休眠1秒。
	}
}
int main(){
    //可以看到func即使线程t1的线程执行函数也是线程t2的线程执行函数，但是最终once_func()只会被执行一次
	thread t1(func, 3, "我是一只傻傻鸟。");
	thread t2(func, 8, "我有一只小小鸟。");

	t1.join();
	t2.join();
	return 0;
}

```

:::



C++11定义了线程标准，不同的平台和编译器在实现的时候，本质上都是对操作系统的线程库进行封装，会损失一部分功能。为了弥补C++11线程库的不足，thread类提供了`native_handle()`成员函数，用于获得与操作系统相关的原生线程句柄，操作系统原生的线程库就可以用原生线程句柄操作线程。





:::details `获取线程句柄native_handle`





比如`thread`类中没有可以取消线程的API,我们可以使用`native_handle()`,先获取到线程在Linux操作系统的句柄，然后再调用`pthread_cancel()` 来完成取消线程的事情。

```c
#include <iostream>
#include <thread>
#include <pthread.h>        // Linux的pthread线程库头文件。
using namespace std;

void func()    // 线程任务函数。
{
  for (int ii=1;ii<=10;ii++)
  {
    cout << "ii=" << ii << endl;
    this_thread::sleep_for(chrono::seconds(1));    // 休眠1秒。
  }
}

int main()
{
  thread tt(func);          // 创建线程。

  this_thread::sleep_for(chrono::seconds(5));    // 休眠5秒。

  pthread_t thid= tt.native_handle();  // 获取Linux操作系统原生的线程句柄。

  pthread_cancel(thid);  // 取消线程。

  tt.join();   // 等待线程退出。
}
```

:::



## 线程同步

同一进程中的多个线程共享该进程中全部的系统资源。多个线程访问同一共享资源的时候会产生冲突。





线程的顺序性：

程序按照代码的先后顺序执行。
CPU为了提高程序整体的执行效率，可能会对代码进行优化，按更高效的顺序执行。
CPU虽然不保证完全按照代码的顺序执行，但它会保证最终的结果和按代码顺序执行时的结果一致。



线程的可见性:

线程操作共享变量时，会将该变量从内存加载到CPU缓存中，修改该变量后，CPU会立即更新缓存，但不一定会立即将它写回内存。这时候，如果其它线程访问该变量，从内存中读到的是旧数据，而非第一个线程操作后的数据。
当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。



线程的原子性：

CPU执行指令:读取指令、读取内存、执行指令、写回内存。
比如进行一次 `i++`,底层CPU执行会分为三步。

- 1)从内存中读取 i 的值;

- 2）把i+1; 

- 3）把结果写回内存。

即线程一个操作(有可能包含有多个步骤）要么全部执行（生效)，要么全部都不执行(都不生效)



比如开启两个线程，可以看到对于临界资源aa,他们发生的彼此抢占，导致最后的结果不符合预期，此时线程t1,线程t2之间的关系就是竞争关系，是互斥的。针对这种情况，我们应该保护临界资源，通常会加锁。来确保线程抢占得到CPU时间片，只能由他来对临界资源进行访问操作。

```c++
#include <iostream>
#include <thread>        
using namespace std;


// 定义全局变量aa,此时aa就是线程t1,t2的临界资源
int aa = 0;    
void func() {
	for (int ii = 1; ii <= 1000000; ii++) {
		aa++;
	}		
}

void func2() {
	for (int ii = 1; ii <= 1000000; ii++) {
		aa++;
	}
}

int main()
{
	//创建两个线程t1,t2，此时他们相互抢占CPU分配的时间片，然后对aa临界资源做++操作
	//有可能出现t1线程执行func()时，循环中没来得及让aa+1,就到线程t2处理了。t2又不知到aa没有+1
	//这种情况在两个线程之间相互出现，最后导致结果不符合预期
	thread t1(func);    
	thread t2(func2);     


	//释放线程资源
	t1.join();         
	t2.join();         

	cout << "aa=" << aa << endl;   // 显示全局变量aa的值。
}
```



如何处理多个线程访问同一共享资源的时候会产生冲突，即多多个线程访问时的共享资源进行一次协商分配。

可以通过下面三种方式，来达到线程同步的目的：

- 1、volatile关键字。
- 2、原子操作（原子类型)。
- 3、线程同步（锁)。

## 互斥锁

C++11提供了四种互斥锁类，来处理多个线程对临界资源的访问问题，处理多个线程之间的互斥竞争关系。

-  mutex类：互斥锁。
- timed_mutex类：带超时机制的互斥锁。
- recursive_mutex类：递归互斥锁。
- recursive_timed_mutex类：带超时机制的递归互斥锁。

包含头文件：`#include <mutex>`



:::details `mutex`

互斥锁有锁定和未锁定两种状态。

如果互斥锁是未锁定状态，调用lock()成员函数的线程会得到互斥锁的所有权，并将其上锁。

如果互斥锁是锁定状态，调用lock()成员函数的线程就会阻塞等待，直到互斥锁变成未锁定状态。

```c++
class mutex
{
	public:
    
       //为当前线程执行的所需的共享资源加锁 阻塞，必须是mutex对象是未锁定状态的时候。
		void lock();
    
      // 对共享资源解锁 只有持有锁的线程才能解锁。阻塞，必须是mutex对象锁定的时候。
    	void unlock();
    
    // 如果互斥锁是未锁定状态，则加锁成功，函数返回true。
	// 如果互斥锁是锁定状态，则加锁失败，函数立即返回false。（线程不会阻塞等待）
    // 针对处理临界资源不止一个的情况吧。
      void try_lock();
}
```

```c++
#include <iostream>
#include <thread>
#include<mutex>
using namespace std;


//创建互斥锁对象
mutex mtx;
int aa = 0;    

//分别对临界资源加锁保护他。确保aa++的操作完成了，确保临界资源只能被一个线程获取到
// 类别想象：排队上厕所，人（线程）厕所（临界资源）厕所门锁（mutex互斥锁对象）
void func() {
	for (int ii = 1; ii <= 1000000; ii++) {
		mtx.lock();
		aa++;
		mtx.unlock();

	}		
}

void func2() {
	for (int ii = 1; ii <= 1000000; ii++) {
		mtx.lock();
		aa++;
		mtx.unlock();

	}
}

int main()
{

	thread t1(func);    
	thread t2(func2);     


	//释放线程资源
	t1.join();         
	t2.join();         

	cout << "aa=" << aa << endl;   // 显示全局变量aa的值。
}
```

:::



:::details `timed_mutex`

timed_mutex类在 mutex 类的基础上扩展增加了两个成员函数：bool try_lock_for(时间长度)，bool try_lock_until(时间点);让加锁和时间产生了挂钩。

```c++
class timed_mutex{
	public:
        void lock();
    	void unlock();
        void try_lock();
    
       // -- 特性增加
	   bool try_lock_for(chrono::seconds());
       bool bool try_lock_until(时间点);
}
```

:::



:::details `recursive_mutex`

recursive_mutex类表示一种递归互斥锁，即允许同一线程多次获得互斥锁，从而可以解决同一线程多次加锁造成的死锁问题。

```c++
#include <iostream>
#include <mutex>        // 互斥锁类的头文件。
using namespace std;

class AA
{
	mutex m_mutex;
public:
	void func1() {
		m_mutex.lock();
		cout << "调用了func1()\n";
		m_mutex.unlock();
	}

	void func2() {
		m_mutex.lock();
		cout << "调用了func2()\n";
		func1();
		m_mutex.unlock();
	}
};

int main()
{
	AA aa;
	//aa.func1();
	aa.func2(); // 主线程调用func2，对要执行的线程资源开始加锁，然后调用func1(),fun1()中又去申请锁，因为func2()的
    //资源锁还没有释放，所以fun1不可能申请到锁，就导致了这个主线程一直在等待申请申请锁，而自己又不释放锁。
}
```

我们改用递归互斥锁`recursive_mutex` 对象来处理，就不会有这种问题了。

:::





:::details `recursive_timed_mutex`

带超时机制的，递归互斥锁。

:::



:::details `lock_guard`

lock_guard是模板类，可以简化互斥锁的使用，也更安全。

lock_guard的定义如下：

```c++
template<class Mutex>

class lock_guard

{

  explicit lock_guard(Mutex& mtx);

}
```

lock_guard在构造函数中加锁，在析构函数中解锁。

lock_guard采用了RAII思想（在类构造函数中分配资源，在析构函数中释放资源，保证资源在离开作用域时自动释放），类比于智能指针，只有管加锁，而不用操心解锁的事情。

```c++
#include <iostream>
#include <thread>        
#include<mutex>
using namespace std;

int aa = 0;     
mutex mtx;
void func() {
	for (int ii = 1; ii <= 1000000; ii++) {
		// 只有管加锁，不用管解锁
		lock_guard<mutex> mlock(mtx);
		aa++;
	}


}

int main()
{
	// 用普通函数创建线程。
	thread t1(func);     // 创建线程t1，把全局变量aa加1000000次。
	thread t2(func);     // 创建线程t2，把全局变量aa加1000000次。

	t1.join();       
	t2.join();       

	cout << "aa=" << aa << endl;   
}
```

:::

## 条件变量

可以说条件变量condition_variable，是C++线程库，提出的处理线程之间的协同关系的类。可以让多个线程一起去协同做好一件事。



条件变量是一种线程同步机制。当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。通过互斥锁和条件变量，我们可以实现生产者消费者的模型（比如互联网的请求响应处理机制、消息队列）



C++11的条件变量提供了两个类：

condition_variable：只支持与普通mutex搭配，效率更高。

condition_variable_any：是一种通用的条件变量，可以与任意mutex搭配（包括用户自定义的锁类型）。

包含头文件：<condition_variable>

### condition_variable

`condition_variable`类只有一个构造方式，就是无参构造，并且他不支持拷贝构造。 

```c++
class condition_variable{
	public:
    	// 默认构造函数。
    	condition_variable();
    	//禁止拷贝,删除了拷贝构造函数
    	condition_variable(const condition_variable &)=delete 
        // 禁止赋值 删除了重载赋值运算符    
        condition_variable& condition_variable::operator=(const condition_variable &)=delete     
           
}
```

condition_variable 常用的的成员方法是通知处于阻塞wait状态的线程，让该线程唤醒。以及让一个线程由运行状态变成阻塞态。

```c++
 class condition_variable{
	public:
       //通知一个等待的线程
		notify_one()
		// 通知全部等待的线程    
        notify_all()    
            
        //  阻塞当前线程，直到通知到达。    
        wait(unique_lock<mutex> lock) 
        //循环的阻塞当前线程，直到通知到达且谓词满足。
        wait(unique_lock<mutex> lock,Pred pred)
        wait_for(unique_lock<mutex> lock,时间长度)  
        wait_for(unique_lock<mutex> lock,时间长度,Pred pred)   
        wait_until(unique_lock<mutex> lock,时间点)
        wait_until(unique_lock<mutex> lock,时间点,Pred pred) 
  }
```



### unique_lock

`template <class Mutex> class unique_lock`是模板类，模板参数为互斥锁类型。

unique_lock和lock_guard都是管理锁的辅助类，都是RAII风格（在构造时获得锁，在析构时释放锁），让开发只关注加锁，而不用关心在何时释放锁。

二者的区别在于：为了配合condition_variable，unique_lock还有lock()和unlock()成员函数。

```c++
#include <iostream>
#include <string>
#include <thread>                     
#include <mutex>                      
#include <deque>                     
#include <queue>                    
#include <condition_variable>  
using namespace std;
class AA
{
    mutex m_mutex;                                  
    condition_variable m_cond; 
    queue<string, deque<string>> m_q;
public:
    void incache(int num)     //模拟生产者往消息队列加消息的函数     
    {
        //加锁，将消息放到消息队列
        lock_guard<mutex> lock(m_mutex); 
        for (int ii = 0; ii < num; ii++)
        {
            static int bh = 1;           
            string message = to_string(bh++) + "号超女";    
            m_q.push(message);    
        }
        // m_cond.notify_one();    
        //利用条件变量唤醒消费者线程，处理消息队列里面的消息
        m_cond.notify_all();         
    }

    void outcache()       // 消费者线程任务函数。
    {
        while (true)
        {
            string message;
            {
                // 把互斥锁转换成unique_lock<mutex>，并申请加锁。
                unique_lock<mutex> lock(m_mutex);

                //队列是空的， 阻塞当前线程，直到通知到达。   
                while (m_q.empty()) {
                    m_cond.wait(lock);
                }  
                // 从消息队列拿出消息
                message = m_q.front(); 
                m_q.pop();
            }
                
            // 对消息进行消费，假设消费这个消息需要1秒
            this_thread::sleep_for(chrono::milliseconds(1000));   
            cout << "线程：" << this_thread::get_id() << "，" << message << endl;
        }
    }
};

int main()
{
    AA aa;

    //创建三个消费着
    thread t1(&AA::outcache, &aa);  
    thread t2(&AA::outcache, &aa);    
    thread t3(&AA::outcache, &aa);     
    
    // 让主线程休眠2秒
    //此时子线程t1,t2,t3都处于wait状态，等待条件变量m_cond的通知
    this_thread::sleep_for(chrono::seconds(2));  

    //生产者向消息队列生产加入3个数据，并且条件变量m_cond 唤醒了全部的消费者
    aa.incache(3);     
    
    //此时再让主线程休眠3秒
    // 与此同时，消费者在消费生产者的这3个数据。并消费完成了。
    //任一消费者再获得锁，判断队列为空了，就又进入wait阻塞状态，等待条件变量的唤醒。
    this_thread::sleep_for(chrono::seconds(3));   


    //主线程，又让生产者往消息队列中加入了5个消息，从而又唤醒了全部的线程去消费。
    //消费完成了，所有的消费者又进入wait阻塞状态。
    aa.incache(5);      



    t1.join();  
    t2.join();
    t3.join();
}
```



### 原子类型（atomic）

C++11提供了`atomic<T>`模板类（结构体），用于支持原子类型.

模板参数可以是bool、char、int、long、long long、指针类型（不支持浮点类型和自定义数据类型）。

原子操作由CPU指令提供支持，它的性能比锁和消息传递更高，并且，不需要程序员处理加锁和释放锁的问题，支持修改、读取、交换、比较并交换等操作。



头文件：`#include <atomic>`



我们在开发中，通常使用第二个构造方法，将临界资源（基本数据类型）转为原子类型。

```c++
class atomic<T>{
    public:
    	atomic() noexcept = default;  // 默认构造函数。
    	atomic(T val) noexcept;  // 转换函数。
    	atomic(const atomic&) = delete;  // 禁用拷贝构造函数。
    	atomic& operator=(const atomic&) = delete;   // 禁用赋值函数。
}
```

常用的原子类型类的成员方法：

```c++
class atomic<T>{
    public:    	
      // 把val的值存入原子变量。
    	void store(const T val) noexcept;  
		T load() noexcept;  // 读取原子变量的值。
		T fetch_add(const T val) noexcept; // 把原子变量的值与val相加，返回原值。
		T fetch_sub(const T val) noexcept; // 把原子变量的值减val，返回原值。
		T exchange(const T val) noexcept; // 把val的值存入原子变量，返回原值。
		T compare_exchange_strong(T &expect,const T val) noexcept; // 比较原子变量的值和预期值expect，如果当两个值相等，把val存储到原子变量中，函数返回true；如果当两个值不相等，用原子变量的值更新预期值，函数返回false。CAS指令。
		bool is_lock_free();  // 查询某原子类型的操作是直接用CPU指令（返回true），还是编译器内部的锁（返回false）。
}
```

原子类型的别名：



- `atomic<T>`模板类重载了整数操作的各种运算符。

- `atomic<T>`模板类的模板参数支持指针，但不表示它所指向的对象是原子类型。
- 原子整型可以用作计数器，布尔型可以用作开关。
- CAS指令是实现无锁队列基础。

```c++
#include <iostream>
#include <thread>       
#include<atomic>
using namespace std;

//使用原子类型 保证线程安全
atomic<int> aa = 0;   

void func() {
	for (int ii = 1; ii <= 1000000; ii++)
		aa++;
}

int main()
{
	
	thread t1(func);    
	thread t2(func);    

	t1.join();         
	t2.join();         

	cout << "aa=" << aa << endl;   
}
```

常用API:

```c++
#include <iostream>
#include <atomic>     // 原子类型的头文件。
using namespace std;

int main()
{
	atomic<int> a = 3;       // atomic(T val) noexcept;  // 转换函数。
	cout << "a=" << a.load() << endl;   // 读取原子变量a的值。输出：a=3
	a.store(8);      // 把8存储到原子变量中。
	cout << "a=" << a.load() << endl;   // 读取原子变量a的值。 输出：a=8
	
	int old;        // 用于存放原值。
	old = a.fetch_add(5);         // 把原子变量a的值与5相加，返回原值。
	cout << "old = " << old <<"，a = " << a.load() << endl;   // 输出：old=8，a=13
	old = a.fetch_sub(2);         // 把原子变量a的值减2，返回原值。
	cout << "old = " << old << "，a = " << a.load() << endl;   // 输出：old=13，a=11
	
	atomic<int> ii = 3;  // 原子变量
	int expect = 4;         // 期待值
	int val = 5;               // 打算存入原子变量的值
	// 比较原子变量的值和预期值expect，
	// 如果当两个值相等，把val存储到原子变量中；
	// 如果当两个值不相等，用原子变量的值更新预期值。
	// 执行存储操作时返回true，否则返回false。
	bool bret = ii.compare_exchange_strong(expect, val);
	cout << "bret=" << bret << endl;
	cout << "ii=" << ii << endl;
	cout << "expect=" << expect << endl;
}
```







