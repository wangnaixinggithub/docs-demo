# 类和对象

面向对象语言的出发点：更直接客观地描述客观世界中存在的事物（对象）以及它们之间的关系。



面向对象的基本概念

- 对象：系统中用来描述客观事物的一个实体，它是用来构成系统的一个基本单位。对象是由一组属性和一组行为构成。属性是用来描述对象静态特征的数据项，行为时用来描述对象动态特征的操作序列
- 类：具有相同属性和服务的一组对象的集合
- 封装：把对象的属性和服务结合成一个独立的系统单元，并尽可能隐蔽对象的内部细节。
- 继承：特殊类的对象拥有其一般类的全部属性与服务，称作特殊类对一般类的继承。
- 多态：指一般类中定义的属性或行为，被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。



面向对象优点：使程序能够直接地反应问题域的本来面目，软件开发人员能够利用人类认识事物所采用的一般思维方法来进行软件开发。



对比面向过程：

面向过程的结构化程序设计方法：

- 设计思路:自顶向下，逐步求精，采用模块分解与功能抽象，自顶向下，分而治之。
- 程序结构，按功能划分为若干个基本模块，各模块间的关系尽可能简单，功能上相对独立，每一模块内部均由顺序，选择，循环三种基本结构组成。其模块化实现的具体方法是使用子程序。
- 优点：有效地将一个较复杂的程序设计任务分解成许多易于控制和处理的子任务，便于开发和维护。
- 缺点：可重用性差，数据安全性差，难以开发大型软件和图形界面的应用软件。

面向对象:

- 将数据及对数据的操作方法封装在一起，作为一个相互依存，不可分离的整体----对象
- 对同类型对象抽象出其共性，形成类
- 类通过一个简单的外部接口，与外界发生关系
- 对象与对象之间通过信息进行通信

- 优点：程序模块间的关系更为简单，程序模块的独立性，数据的安全性就有了良好的保障,通过继承与多态性，可以大大提高程序的可重用性，使得软件的开发和维护都更为方便。



程序的开发过程:

- 编辑：将源程序输入到计算机中，生成后缀为Cpp的磁盘文件
- 编译：将程序的源代码转换为机器语言代码
- 连接：将多个源程序文件以及库中的某些文件连在一起，生成一个后缀为exe的可执行文件。
- 运行调试

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20230107140357354.png)

## 封装

:::details `从结构体到类`

对面向对象编程来说，一切都是对象，对象用类来描述。

类把对象的数据和操作数据的方法作为一个整体考虑。

```c++
//定义类的语法 
class 类名
{
public:
成员一的数据类型  成员名一;
成员二的数据类型  成员名二;
成员三的数据类型  成员名三;
......
成员n的数据类型  成员名n;
};
```

注意：

- 类的成员可以是变量，也可以是函数。
-  类的成员变量也叫属性。
-  类的成员函数也叫方法/行为，类的成员函数可以定义在类的外面。
-  用类定义一个类的变量叫创建（或实例化）一个对象。
-  对象的成员变量和成员函数的作用域和生命周期与对象的作用域和生命周期相同。

```c
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>       
using namespace std;
struct Person 
{
	string name;
	int age;
};
void setValue(Person& person, string name, int age) 
{
	person.name = name;
	person.age = age;
}
void show(const Person& person) 
{
	cout << "Person(name=" << person.name << ",age=" << person.age <<")" << endl;
}
int main()
{
	Person person;
	setValue(person,"wangnaixing",25);
	show(person);
}
```

封装是C++面对对象三大特性之一。

封装的意义：

- 将属性和形为作为一个整体，表现生活中的事物。
- 将属性和形为加以权限控制。

```c
语法：class 类名{访问权限：属性/ 行为};
```

```c++
#include <iostream>       
using namespace std;

class Person {
private:
	string name;
	int age;
public:
	void setValue(string name, int age);
	void show();
};
void Person::setValue(string name, int age) 
{
	this->name = name;
	this->age = age;
}

void Person::show()
{
	cout << "Person(name=" << this->name << ",age=" << this->age << ")" << endl;
}

int main()
{
	Person person;
	person.setValue("wangnaixing",25);
	person.show();
}
```

:::



:::details `类的访问权限`

访问权限有三种

- 公共权限 public （类内类外都可以访问）

- 保护权限 protected （类内可以访问，类外不可以访问），在继承的时候，父亲的保护权限儿子可以访问。

- 私有权限 private （类内可以访问，类外不可以访问），继承的时候，父亲的私有权限不可以被儿子访问。

创建`Person` 类，该类含有公有属性 保护属性 私有属性 和公有方法。

```c
#include<iostream>
#include<string>
using namespace std;
class person 
{
public:
	string name;
protected:
	string m_car;
private:
	int password;
public:
	void func()
	{
		name = "张三";
		m_car = "拖拉机";
		password = 123457;
	}
};
int main()
{
	person p1 ;
	p1.name = "李四";
	//不可以被访问
	//p1.m_car = "车";
	return 0;
}
```

在c++中，struct和class的唯一区别是**默认的访问权限不同**。

- struct的没有访问权限的设定，因此所有的属性都是公开的。
- class的默认访问权限是私有的。

:::





:::details `构造函数和析构函数`

- 构造函数：在创建对象时，自动的进行初始化工作。
- 析构函数：在销毁对象前，自动的完成清理工作。

```c
//构造函数
语法：类名(){......}
```

- 访问权限必须是public。
-  函数名必须与类名相同。
- 没有返回值，不写void。
- 可以有参数，可以重载，可以有默认参数。
-  创建对象时只会自动调用一次，不能手工调用。

**为什么需要构造函数？**

- c++的目标之一是想让使用类对象的时候和使用标准型一样，但是从以上代码看，我们没法像初始化int或者结构体一样初始化类对象。
- 没法初始化的原因在于：**数据的访问权限是私有的**，有的人说设置成公共权限就好了，但是这又违背了类的一个主要初衷：**数据隐藏**。
- 最好的办法是在创建对象的时就进行初始化，因此C++提供了一个特殊的成员函数--**类构造函数**，用于创建新对象，将值传给他们的成员。

**构造函数有三种形式：**

- 根据有参数和无参数分为：有参构造函数，无参函数（默认构造函数）
- 按照类型分：普通构造函数，拷贝构造函数

**值得注意的是**：编译器在默认的情况下会提供默认构造函数、有参构造函数和拷贝构造函数。

但是以下两种特殊情况：

- 当用户自定义了有参构造函数后，编译器不再提供默认构造函数，但是会提供拷贝构造函数
- 当用户自定义了拷贝构造函数后，编译器不再提供默认构造函数和有参构造函数。

```
//析构函数
语法：~类名(){......}
```

- 访问权限必须是public。
- 函数名必须在类名前加~。
- 没有返回值，也不写void。
-  没有参数，不能重载。
- 销毁对象前只会自动调用一次，但是可以手工调用

```c
#include<iostream>
using namespace std;
//构造函数的分类及调用
//分类
//按照参数分类：有参构造，无参构造（默认构造）
//按照类型分：普通构造函数，拷贝构造函数
//构造函数的名称和类名一样
class person 
{
public:
    int age;
    person()
	{
		cout<<"无参构造函数的调用" << endl;
	}
	person(int a)
	{
		age = a;
		cout << "有参构造函数的调用" << endl;
	}
	//拷贝构造函数
	person(const person &p)
	{
		//将传入的人身上的所有属性传到我身上
		age=p.age; 
		cout << "拷贝构造函数的调用" << endl;
	}
    
	~person()
	{
		cout<<"析构函数的调用" << endl;
	}
};
```

注意：

-  如果没有提供构造/析构函数，编译器将提供空实现的构造/析构函数。

```c
#include <iostream>       
using namespace std;
class Person 
{
private:
	string name;
	int age;
public:
	void show();
    //编译器将提供空实现的构造/析构函数。

};
void Person::show()
{
	cout << "Person(name=" << this->name << ",age=" << this->age << ")" << endl;
}
int main()
{
	Person person1 = Person();
	Person person2 = Person({});
	Person person3({});	
}
```

- 如果提供了构造/析构函数，编译器将不提供空实现的构造/析构函数。

![image-20230319202745830](https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/wangnaixing/image-20230319202745830.png)



-  创建对象的时候，如果重载了构造函数，编译器根据实参匹配相应的构造函数。没有参数的构造函数也叫默认构造函数。

```c++
#include <iostream>       
using namespace std;
class Person 
{
private:
	string name;
	int age;
public:
	void show();
	Person();
	Person(string name,int age);
	~Person();

};
void Person::show() {
	cout << "Person(name=" << this->name << ",age=" << this->age << ")" << endl;
}
Person::Person(){} //无参构造函数 == 默认构造函数
Person::Person(string name,int age) 
{
	this->name = name;
	this->age = age;
}
Person::~Person() 
{

}
int main()
{
	//这样Person类就有多个构造，而下面调用无参构造来初始化Person对象就不会报错了。
	Person person1 = Person();
	Person person2 = Person({});
	Person person3({});
}
```

-  创建对象的时候不要在对象名后面加空的圆括号，编译器误认为是声明函数。（在没有构造函数、构造函数没有参数、构造函数的参数都有默认参数的情况下）

```c++
#include <iostream>       
using namespace std;

class Person {
private:
	string name;
	int age;
	
public:
	void show() {
		cout << "Person(name=" << this->name << ",age=" << this->age << ")" << endl;
	}
	Person(string name, int age) :name(name) ,age(age){}
	~Person() {}

};



int main()
{
	Person person = Person("wangnaiixng", 26);//显式创建对象
}
```

- **在构造函数名后面加括号和参数不是调用构造函数，是创建匿名对象**

```c++
#include <iostream>       
using namespace std;

class Person {
private:
	string name;
	int age;
	
public:
	void show() {
		cout << "Person(name=" << this->name << ",age=" << this->age << ")" << endl;
	}
	Person(string name, int age) :name(name) ,age(age){}
	~Person() {}

};



int main()
{
	 Person person;  //创建person对象
     person  = Person("wangnaiixng", 26);// 创建匿名对象 然后给现在的person对象赋值

}
```

- 不建议在构造/析构函数中写太多的代码，可以调用成员函数。
- 用new/delete创建/销毁对象时，也会调用构造/析构函数。

```c++
#include <iostream>       
using namespace std;



class Person {
private:
	string name;
	int age;
public:
	void show();
	Person(string name,int age);
	~Person();

};


void Person::show() {
	cout << "Person(name=" << this->name << ",age=" << this->age << ")" << endl;
}

Person::Person(string name,int age) {
	cout << "Person(string name,int age) 被调用了...\n";
	this->name = name;
	this->age = age;
}

Person::~Person() {
	cout << "~Person() 被调用了...\n";

}

int main()
{
	Person* person = new Person({ "wangnaixing",26 });
	delete person;
}
```

![image-20230319203332074](https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/wangnaixing/image-20230319203332074.png)

- 除了初始化，不建议让构造函数做太多工作（只能成功不会失败）
-  C++11支持使用统一初始化列表。

```c++
class Person {
private:
	string name;
	int age;
public:
	Person(string name, int age) {
		this->name = name;
		this->age = age;
	}
	void setValue(string name, int age);
	void show();
};

int main()
{
    //向结构体一样直接使用初始化列表
	Person person1 = {"wangnaixing",26};
    // 可以省略 = 号
	Person person2{ "wangnaixing",26 };
    
    // new 动态分配内存创建Person对象后初始化
	Person* pt_person = new Person({ "wangnaixing",26 });
	Person* pt_person2 = new Person{ "wangnaixing",26 };
    
    // 清空Person对象的内存
	delete pt_person, pt_person2;	
}
```

- 如果类的成员也是类，创建对象的时候，先构造成员类；销毁对象的时候，先析构自身，再析构成员类。

```java
#include <iostream>       
using namespace std;


class Phone {
private:
	string brand;
	double price;
public:
	Phone(string brand, double price) {
		cout << "Phone(string brand, double price) 被调用了..\n";
		this->brand = brand;
		this->price = price;
	}
	~Phone() {
		cout << "~Phone() 被调用了...\n";
	}
	void show() {
		cout << "Phone(brand=" << this->brand << ",price=" << this->price << ")"<<endl;
	}
	

};



class Person {
private:
	string name;
	int age;
	Phone phone;
public:
	void show() {
		cout << "Person(name=" << this->name << ",age=" << this->age << ")" << endl;
		this->phone.show();
	}
	Person(string name, int age, string brand, double price) :name(name) ,age(age),phone(brand,price){
		cout << "Person(string name, int age, string brand, double price) 被调用了...\n";
	}
	~Person() {
		cout << "~Person() 被调用了...\n";
	}

};


int main()
{
	Person* person = new Person("wangnaixing",26,"小米",6666.6);
	person->show();
	delete person;

}
```

![image-20230319210740768](https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/wangnaixing/image-20230319210740768.png)

:::



:::details `类对象作为类成员`

c++中类的成员可以另一个类的对象，称之为**对象成员**。当**其他类作为成员，先构造其他类，再构造自身，析构和构造相反**。

```c
class Phone 
{
public:
	Phone(string name)
	{
		m_pname = name;
	}
	string m_pname;
};

class Person 
{
public:
    //Phone类没有默认构造函数，只能用初始化列表构造函数
	Person(string name, string pname):m_name(name),m_phone(pname)
	{
		
	}
	string m_name;
	Phone m_phone;
};
```

:::



:::details `拷贝构造函数`

用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。

如果类中没有定义拷贝构造函数，编译器将提供一个拷贝构造函数，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。



用一个已存在的对象创建新的对象语法：

```c
类名 新对象名(已存在的对象名);
类名 新对象名=已存在的对象名;
```

```c
#include <iostream>       
using namespace std;
class Person 
{
private:
	string name;
	int age;	
public:
	void show() 
    {
		cout << "Person(name=" << this->name << ",age=" << this->age << ")" << endl;
	}
	Person(string name, int age) :name(name) ,age(age){}
	~Person() {}
};
int main()
{
	Person person = Person("wangnaiixng", 26);
	
		// 拷贝构造函数调用形式
	Person copyPerson(person);
	Person copyPerson = person;
	copyPerson.show();
}
```

![image-20230319211830682](https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/wangnaixing/image-20230319211830682.png)

注意：

- 1、访问权限必须是public。
- 2、函数名必须与类名相同。
- 3、没有返回值，不写void。
- 4、 如果类中定义了拷贝构造函数，编译器将不提供默认的拷贝构造函数。

```c++
#include <iostream>       
using namespace std;



class Person {
private:
	string name;
	int age;
	
public:
	void show() {
		cout << "Person(name=" << this->name << ",age=" << this->age << ")" << endl;
	}
	Person(string name, int age) :name(name) ,age(age){
		cout << "构造函数被调用了...\n";
	}
	~Person() {}

	//默认的拷贝构造函数
	Person(const Person& person) {
		cout << "默认的拷贝构造函数被调用了...\n";
		this->name = person.name;
		this->age = person.age;
	}

};



int main()
{
	Person p = Person("wangnaixing",26);
	Person copy=  p;
	copy.show();
}
```

![image-20230319213933202](https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/wangnaixing/image-20230319213933202.png)

- 5、以值传递的方式调用函数时，如果实参为对象，会调用拷贝构造函数。
- 6、 拷贝构造函数可以重载，可以有默认参数。

```c++
类名(......,const 类名& 对象名,......){......}
```

- 7、如果类中重载了拷贝构造函数却没有定义默认的拷贝构造函数，编译器也会提供默认的拷贝构造函数。

```c++
#include <iostream>       
using namespace std;

class Person {
private:
	string name;
	int age;
	
public:
	void show() {
		cout << "Person(name=" << this->name << ",age=" << this->age << ")" << endl;
	}
	Person(string name, int age) :name(name) ,age(age){
		cout << "构造函数被调用了...\n";
	}
	~Person() {}

	//拷贝构造函数重载
	Person(const Person& person,int age) {
		
		this->name = person.name;
		this->age = age;
	}

};

int main()
{
	Person p = Person("wangnaixing",26);
	Person copy(p,40);
	copy.show();

	//默认的拷贝构造函数仍然可以用
	Person copy2(p);
	copy2.show();
}
```

:::



:::details `初始化列表`

构造函数的执行可以分成两个阶段：初始化阶段和计算阶段（初始化阶段先于计算阶段）。

- 初始化阶段：全部的成员都会在初始化阶段初始化。
- 计算阶段：一般是指用于执行构造函数体内的赋值操作。

[构造函数](https://so.csdn.net/so/search?q=构造函数&spm=1001.2101.3001.7020)除了参数列表和函数体之外，还可以有初始化列表。

```
初始化列表的语法：
类名(形参列表):成员一(值一), 成员二(值二),..., 成员n(值n)
{......}
```

注意：

- 1、如果成员已经在初始化列表中，则不应该在构造函数中再次赋值。
- 2、初始化列表的括号中可以是具体的值，也可以是构造函数的形参名，还可以是表达式。
- 3、**初始化列表与赋值有本质的区别，如果成员是类，使用初始化列表调用的是成员类的拷贝构造函数，而赋值则是先创建成员类的对象（将调用成员类的普通构造函数），然后再赋值。**

- 4、如果成员是类，初始化列表对性能略有提升。
- 5、**如果成员是常量和引用，必须使用初始列表，因为常量和引用只能在定义的时候初始化。**
- 6、如果成员是没有默认构造函数的类，则必须使用初始化列表。
- 7、拷贝构造函数也可以有初始化列表。
- 8、类的成员变量可以不出现在初始化列表中。
- 9、构造函数的形参先于成员变量初始化。

```c
#include <iostream>       
using namespace std;
class Boy 
{
private:
	string name;
public:
	Boy() 
    {
		cout <<"Boy() 默认构造函数被调用了!\n";
		name.clear();
	}
	Boy(string name) 
    {
		cout << "Boy(string name) 有参构造函数被调用了!\n";
		this->name = name;
	}
	Boy(const Boy& boy) 
    {
		cout << "Boy(const Boy& boy) 默认拷贝构造函数被调用了\n";
		this->name = boy.name;
	}

	string getName() 
    {
		return name;
	}
};
class Girl
{
private:
	string name;
	const int age;
	Boy& boy;
public:
	//使用初始化列表
	Girl(string name,int age,Boy& boy):name(name),age(age),boy(boy)
    {
		cout << "调用了Girl(name,age,boy)构造函数。\n";;
	}
	void show()
    { cout << "姓名：" << name << "，年龄：" << age << "，男朋友：" << boy.getName() << endl; 
    }
};
int main()
{
	Boy boy("张三");
	Girl girl("冰冰", 18, boy);
	girl.show();
}
```

:::



:::details `const修饰成员函数`

在类的成员函数后面加const关键字，表示在成员函数中保证不会修改调用对象的成员变量。

注意：

- mutable可以突破const的限制，被mutable修饰的成员变量，将永远处于可变的状态，在const修饰的函数中，mutable成员也可以被修改。
- 非const成员函数可以调用const成员函数和非const成员函数。
- const成员函数不能调用非const成员函数。
- 非const对象可以调用const修饰的成员函数和非const修饰的成员函数。
- const对象只能调用const修饰的成员函数，不能调用非cosnt修饰的成员函数。



这里出现了令人纠结的三个问题：

1、为什么要保护类的成员变量不被修改？

2、为什么用const保护了成员变量，还要再定义一个mutable关键字来突破const的封锁线？

3、到底有没有必要使用const和mutable这两个关键字？



保护类的成员变量不在成员函数中被修改，是为了保证模型的逻辑正确，通过用const关键字来避免在函数中错误的修改了[类对象](https://so.csdn.net/so/search?q=类对象&spm=1001.2101.3001.7020)的状态。并且在所有使用该成员函数的地方都可以更准确的预测到使用该成员函数的带来的影响。而mutable则是为了能突破const的封锁线，让类的一些次要的或者是辅助性的成员变量随时可以被更改。没有使用const和mutable关键字当然没有错，const和mutable 关键字只是给了建模工具更多的设计约束和设计灵活性，而且程序员也可以把更多的逻辑检查问题交给编译器和建模工具去做，从而减轻程序员的负担。

```c++
#include <iostream>       
using namespace std;
class Girl 
{
private:
	mutable	string name;
	int age;
public:
    Girl(string name, int age) :name(name), age(age) {}
    void show() const
    {
        //可以改
        name = "西施show1";
        //报错了，不能改。
        age = 30;
        cout << "姓名：" << name << "，年龄：" << age << endl;
    }
   
};
int main()
{
    Girl g1("冰冰", 18);
    g1.show();
}
```

:::



:::details `静态成员`

类的静态成员包括静态成员变量和静态成员函数。

用静态成员可以变量实现多个对象之间的数据共享，比全局变量更安全性。

用` static` 关键字把类的成员变量声明为静态，表示它在程序中（不仅是对象）是共享的。

静态成员变量不会在创建对象的时候初始化，必须在程序的全局区用代码清晰的初始化（用范围解析运算符 ::）。

静态成员使用类名加范围解析运算符 :: 就可以访问，不需要创建对象。

**如果把类的成员声明为静态的，就可以把它与类的对象独立开来（静态成员不属于对象）。**

静态成员变量在程序中只有一份（生命周期与程序运行期相同，存放在静态存储区的），不论是否创建了类的对象，也不论创建了多少个类的对象。即所有对象共享一份数据。

在静态成员函数中，只能访问静态成员，不能访问非静态成员。

静态成员函数中没有this指针。

在非静态成员函数中，可以访问静态成员。

**私有静态成员在类外无法访问。**

const静态成员变量可以在定义类的时候初始化。

```c
#include <iostream>        
using namespace std;       

class CGirl                 
{
    static int age; 
public:
    string   name;   
    CGirl(const string& name, int age) 
    {
        this->name = name;
        this->age = age; 
    }
    void showName() { cout << "姓名：" << name << endl; }
    static void showAge() { cout << "年龄：" << age << endl; }
};
// 初始化类的静态成员变量。
int CGirl::age = 8;       
int main()
{
    CGirl g1("西施1", 21), g2("西施2", 22), g3("西施3", 23);

    //静态成员变量在程序中只有一份 所以年龄都是23
    g1.showName(); g1.showAge();
    g2.showName(); g2.showAge();
    g3.showName(); g3.showAge();

    //静态方法可以通过类名调用
    CGirl::showAge();

    //私有静态成员在类外无法访问
    //cout << "CGirl::age=" << CGirl::age << endl;
}

```

:::





:::details `this指针`

如果类的成员函数中涉及多个对象，在这种情况下需要使用this指针。

this指针存放了对象的地址，它被作为隐藏参数传递给了成员函数，指向调用成员函数的对象（调用者对象）。

每个成员函数（包括构造函数和析构函数）都有一个this指针，可以用它访问调用者对象的成员。（可以解决成员变量名与函数形参名相同的问题）

`*this`可以表示对象。

如果在成员函数的括号后面使用const，那么将不能通过this指针修改成员变量。

```c
#include <iostream>       
using namespace std;
class Girl
{
private:
	string name;          // 姓名属性。
	int yz;      // 颜值：1-沉鱼落雁；2-漂亮；3-一般；4-歪瓜裂枣
public:
    Girl(string name, int yz) :name(name), yz(yz) {}
    void show() const
    {
        cout << "我是：" << name << "，最漂亮的超女。" << endl;
    }
    const Girl& pk(const Girl& g) const 
    {
        if (g.yz < yz) return g;
        return *this;
    }
    //解决同名问题
    void setName(string name)
    {
    
        this->name = name;
    }
};
int main()
{
      // 比较五个超女的颜值，然后由更漂亮的超女作自我介绍。
    Girl g1("西施", 5), g2("西瓜", 3), g3("冰冰", 4), g4("幂幂", 5), g5("金莲", 2);
    const Girl& g = g1.pk(g2).pk(g3).pk(g4).pk(g5);
    g.show();
}
```

:::

## 简单对象模型

在C语言中，**数据**和**处理数据的操作（函数）**是分开的。也就是说，C语言本身没有支持**数据和函数**之间的关联性。

C++用类描述抽象数据类型（abstract data type，ADT），在类中定义了**数据**和**函数**，把**数据**和**函数**关联起来。



对象中维护了多个指针表，表中放了成员与地址的对应关系。

```java
class CGirl       // 超女类CGirl。
{
public:
    char    m_name[10];              // 姓名属性。
    int      m_age;                   // 年龄属性。
    // 默认构造函数和析构函数。
    CGirl() { memset(m_name, 0, sizeof(m_name)); m_age = 0;  }
    ~CGirl() {  }
    // 显示超女的姓名。
    void showname() { cout << "姓名：" << m_name << endl; }
    // 显示超女的年龄。
    void showage() { cout << "年龄：" << m_age << endl; }
};

```

![image-20230319224158544](https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/wangnaixing/image-20230319224158544.png)



C++类中有两种数据成员：`nonstatic`、`static`，



三种函数成员：`nonstatic`、`static`、`virtual`。



对象内存的大小包括：

- 所有非静态数据成员的大小
- 由内存对齐而填补的内存大小
- 为了支持virtual成员而产生的额外负担

静态成员变量属于类，不计算在对象的大小之内。



成员函数是分开存储的，不论对象是否存在都占用存储空间，在内存中只有一个副本，也不计算在对象大小之内。



用空指针可以调用没有用到this指针的非静态成员函数。



对象的地址是第一个非静态成员变量的地址，如果类中没有非静态成员变量，编译器会隐含的增加一个1字节的占位成员。



:::details `示例：` 

```c++
#include <iostream>         
using namespace std;        

class CGirl      
{
public:
    char    m_name[3];             
    int       m_bh;                       
    static int       m_age;                    

    CGirl() { memset(m_name, 0, sizeof(m_name)); m_age = 0; }
    ~CGirl() {  }
    void showname() { if (this == nullptr) return;  cout << "姓名：" << this->m_name << endl; }
    void showage() { cout << "年龄：" << m_age << endl; }
};

int CGirl::m_age;
int aaa;
void func() {}

int main()
{
    CGirl g;
    cout << "对象g占用的内存大小是：" << sizeof(g) << endl;
    cout << "对象g的地址是：" << (void*)&g << endl;
    cout << "成员变量m_bh的地址是：" << (void*)&g.m_bh << endl;
    cout << "成员变量m_name的地址是：" << (void*)&g.m_name << endl;
    cout << "成员变量m_age的地址是：" << (void*)&g.m_age << endl;
    cout << "全局变量aaa的地址是：" << (void*)&aaa << endl;
    printf("成员函数showname的地址是：%p\n", &CGirl::showname);
    printf("成员函数showage的地址是：%p\n", &CGirl::showage);
    printf("函数func()的地址是：%p\n", func);

    CGirl* g1 = nullptr;
    g1->showname();
}
```

![image-20230319224452556](https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/wangnaixing/image-20230319224452556.png)

:::



## 友元

如果要访问类的私有成员变量，调用类的公有成员函数是唯一的办法，而类的私有成员函数则无法访问。

友元提供了另一访问类的私有成员的方案。友元有三种：

-  友元全局函数
- 友元类
- 友元成员函数



:::details `友元全局函数`

 在友元全局函数中，可以访问另一个类的所有成员。

```c
#include <iostream>         
using namespace std;

class Girl
{
	//func 是 Girl的友元全局函数
	friend void func();
    
public:
	Girl()
    {
		this->name = "西施";
		this->xw = 87;
	}
	void showName() 
    {
		cout << "姓名：" << name << endl;
	}
private:
	string name; //姓名
	int xw; //胸围
	void showXw() const 
    {
		cout << "胸围:" << xw << endl;
	}
};
//则友元全局函数可以访问Girl的私有属性和私有方法 公有方法和公有属性
void func() {
	Girl g;
	cout << g.name << endl;
	cout << g.xw << endl;
	g.showXw();
	g.showName();
}
int main()
{
	func();
}
```

:::



:::details `友元类`

在友元类所有成员函数中，都可以访问另一个类的所有成员。

友元类的注意事项：

-  友元关系不能被继承。
- 友元关系是单向的，不具备交换性。

若类B是类A的友元，类A不一定是类B的友元。B是类A的友元，类C是B的友元，类C不一定是类A的友元，要看类中是否有相应的声明。

```c
#include <iostream>         
using namespace std;        
class Girl {
    // Boy是 Girl的友元类
	friend class Boy;
public:
	Girl(){
		this->name = "西施";
		this->xw = 87;
	}

	void showName() {
		cout << "姓名：" << name<<endl;
	}


private:
	string name; //姓名
	int xw; //胸围
	void showXw() const {
		cout << "胸围:" << xw << endl;
	}
};
void func() {
	Girl g;
	g.showName();
	g.showXw();
}

class Boy {
public:
	void func(const Girl& g) {
        //则友元类可以访问到Girl的私有属性和私有方法
		cout << "我女朋友的姓名是：" << g.name << endl;
		cout << "我女朋友的胸围是：" << g.xw << endl;
		g.showXw();
	}

};

int main()
{
	Girl g;
	Boy b;
	b.func(g);

}

```

:::



:::details `友元成员函数`

首先，友元函数不是类成员，不能继承。

在友元成员函数中，可以访问另一个类的所有成员。

如果要把男朋友类CBoy的某成员函数声明为超女类CGirl的友元，声明和定义的顺序如下：

```c
class CGirl;      // 前置声明。  
class CBoy { ...... };   // CBoy的定义。
class CGirl { ...... };   // CGirl的定义。                  
```

```c
// 友元成员函数的定义。     
void CBoy::func(CGirl &g) { ...... }     
```

```c
#include <iostream>       
using namespace std;        
class Girl;    

class Boy    
{
public:
    //func1是Boy成员函数
    void func1(const Girl& g);
};
class Girl    
{
    // func1是Girl的友元成员函数
    friend void Boy::func1(const Girl& g);
public:
    Girl() { name = "西施";  xw = 87; }
    void showName() { cout << "姓名：" << name << endl; }
private:
    string    name;   
    int         xw;       
    void showXw() const { cout << "胸围：" << xw << endl; }
};

//友元成员函数 可以访问Girl的私有属性和方法
void Boy::func1(const Girl& g) 
{ 
    g.showXw();
    cout << g.name;
    cout << g.xw;
}

int main()
{
    Girl g;
    Boy b;
    b.func1(g);
}
```

:::

## 运算符重载

C++将运算符重载扩展到自定义的数据类型，它可以让对象操作更美观。

> 例如字符串string用加号`（+）`拼接、cout用两个左尖括号`（<<）`输出。



:::details `运算符重载基础`

运算符重载函数的语法：返回值 operator运算符(参数列表);

运算符重载函数的返回值类型要与运算符本身的含义一致。

非成员函数版本的重载运算符函数：形参个数与运算符的操作数个数相同；

成员函数版本的重载运算符函数：形参个数比运算符的操作数个数少一个，其中的一个操作数隐式传递了调用对象。

如果同时重载了非成员函数和成员函数版本，会出现二义性。

**注意：**

- 返回自定义数据类型的引用可以让多个运算符表达式串联起来。（不要返回局部变量的引用）

- 重载函数参数列表中的顺序决定了操作数的位置。

- 重载函数的参数列表中至少有一个是用户自定义的类型，防止程序员为内置数据类型重载运算符。

- 如果运算符重载既可以是成员函数也可以是全局函数，应该优先考虑成员函数，这样更符合运算符重载的初衷。

- 重载函数不能违背运算符原来的含义和优先级。

- 不能创建新的运算符。

- 以下运算符不可重载：

 不能重载的运算符：

| 运算符           | 说明               |
| ---------------- | ------------------ |
| sizeof           | sizeof运算符       |
| .                | 成员运算符         |
| .*               | 成员指针运算符     |
| ::               | 作用域解析运算符   |
| ?:               | 三目条件运算符     |
| typeid           | 一个RTTI运算符     |
| const_cast       | 强制类型转换运算符 |
| dynamic_cast     | 强制类型转换运算符 |
| reinterpret_cast | 强制类型转换运算符 |
| static_cast      | 强制类型转换运算符 |

以下运算符只能通过成员函数进行重载：

- =        赋值运算符

- ()         函数调用运算符

- []         下标运算符

- ->        通过指针访问类成员的运算符

:::



:::details `重载关系运算符`

重载关系运算符（==、!=、>、>=、<、<=）用于比较两个自定义数据类型的大小。

可以使用非成员函数和成员函数两种版本，建议采用成员函数版本。

```c++
#include <iostream>         
using namespace std;
class Girl {
private:
	string name; // 姓名。
	int yz; // 颜值：1-千年美人；2-百年美人；3-绝代美人；4-极漂亮；5-漂亮；6-一般；7-歪瓜裂枣
	int sc; // 身材：1-火辣；2-...；3-...；4-...；5-...；6-...；7-膘肥体壮。
	int acting; // 演技：1-完美；2-...；3-...；4-...；5-...；6-...；7-四不像。

public:
	Girl(string name, int yz, int sc, int acting) :name(name), yz(yz), sc(sc), acting(acting) {};
	bool operator==(const Girl & g1) {
		if ((yz+sc+acting) ==(g1.yz+g1.sc+g1.acting))
		{
			return true;
		}
		return false;
	}
	bool operator>(const Girl& g1) {
		if ((yz + sc + acting) < (g1.yz + g1.sc + g1.acting)) {
			return true;
		}
		return false;
	}
	bool operator<(const Girl& g1) {
		if ((yz + sc + acting) > (g1.yz + g1.sc + g1.acting)) {
			return true;
		}
		return false;
	}
};

int main()
{
	Girl g1("西施", 1, 1, 2);
	Girl g2("冰冰", 1, 1, 2);

	if (g1 == g2) {
		cout << "西施和冰冰的商业价值相同\n";
	}
	else if(g1 > g2)
	{
		cout << "西施商业价值相同比冰冰大。\n";
	}
	else if (g1 < g2)
	{
		cout << "冰冰商业价值相同比西施大。\n";
	}
	

}
```

:::



:::details `重载左移运算符`

重载左移运算符（<<）用于输出自定义对象的成员变量，在实际开发中很有价值（调试和日志）。

只能使用非成员函数版本。

如果要输出对象的私有成员，可以配合友元一起使用。

```c++
#include <iostream>         
using namespace std;

class Girl {

	friend ostream& operator<<(ostream& cout, const Girl& g);
private:
	string name;
	int xw;
	int score;

public:
	Girl() {
		this->name = "西施";
		this->xw = 87;
		this->score = 30;
	}

};
ostream& operator<<(ostream& cout, const Girl& g) {
	cout << "姓名：" << g.name << "，胸围：" << g.xw << "，评分：" << g.score;
	return cout;
}

int main()
{
	Girl g;
	cout << g << endl;
	
}
```

:::



:::details `重载下标运算符`

如果对象中有数组，重载下标运算符[]，操作[对象中的数组](https://so.csdn.net/so/search?q=对象数组&spm=1001.2101.3001.7020)将像操作普通数组一样方便。

下标运算符必须以成员函数的形式进行重载。

下标运算符重载函数的语法：

```c++
返回值类型 &perator[](参数);
```

或者：

```c++
const 返回值类型 &operator[](参数) const;
```

使用第一种声明方式，[]不仅可以访问数组元素，还可以修改数组元素。

使用第二种声明方式，[]只能访问而不能修改数组元素。

在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应const对象，因为[通过const 对象只能调用const成员函数](http://c.biancheng.net/view/2232.html)，如果不提供第二种形式，那么将无法访问const对象的任何数组元素。

在重载函数中，可以对下标做合法性检查，防止数组越界。

```c++
#include <iostream>         
using namespace std;

class Girl {
private:
	string boys[3];
	string name;

public:
	Girl() {
		boys[0] = "子都"; 
		boys[1] = "潘安";
		boys[2] = "宋玉";
	}
	void show() { cout << boys[0] << "、" << boys[1] << "、" << boys[2] << endl; }

	string& operator[](int index) {
		return boys[index];
	}
	const string& operator[](int index) const {
		return boys[index];
	}

};


int main()
{
	Girl g;
	g[1] = "王麻子";
	cout << "第1任男朋友：" << g[1] << endl;
	g.show();

	const Girl g1 = g;
	cout << "第1任男朋友：" << g1[1] << endl;
	
}
```

:::



:::details `重载赋值运算符`

C++编译器可能会给类添加四个函数：

- 默认构造函数，空实现。
- 默认析构函数，空实现。
-  默认拷贝构造函数，对成员变量进行浅拷贝。
- 默认赋值函数, 对成员变量进行浅拷贝。

对象的赋值运算是用一个已经存在的对象，给另一个已经存在的对象赋值。

如果类的定义中没有重载赋值函数，编译器就会提供一个默认赋值函数。

如果类中重载了赋值函数，编译器将不提供默认赋值函数。

```c++
重载赋值函数的语法：类名 & operator=(const 类名 & 源对象);
```

注意：

-  编译器提供的默认赋值函数，是浅拷贝。
-  如果对象中不存在堆区内存空间，默认赋值函数可以满足需求，否则需要深拷贝。
- 赋值运算和拷贝构造不同：拷贝构造是指原来的对象不存在，用已存在的对象进行构造；赋值运算是指已经存在了两个对象，把其中一个对象的成员变量的值赋给另一个对象的成员变量。

例子：重载赋值运算符实现深度拷贝。

```c++
#include <iostream>         
using namespace std;

class Girl {
private:
	int bh;
	string name;
	int* ptr; // 计划使用堆区内存
public:
	Girl() {
		ptr = nullptr;
	}
	~Girl() {
		if (ptr) delete ptr;
	}
	void setBh(int bh);
	void setName(string name);
	void setPtr(int* ptr);
	void show() {
		cout << "编号：" << bh << "，姓名：" << name << "，ptr=" << ptr<<endl;
		if (ptr) cout << "*ptr=" << *ptr << endl;
		
	}
	Girl& operator=(const Girl& g) {
		cout << "调用了重载赋值函数，实现深度拷贝\n";
		//如果是自己给自己赋值
		if (this == &g) {
			return *this;
		}

		if (g.ptr == nullptr) { //考虑源对象指针为空情况
			if (ptr == nullptr) {
				delete ptr;
				ptr = nullptr;
			}
		}
		else //不为空情况
		{ 
			if (ptr == nullptr) {
				ptr = new int;
			}
			//把源对象的数据复制到目标对象的内存中
			memcpy(ptr, g.ptr, sizeof(int));
		}

		bh = g.bh;
		name = g.name;
		return *this;
	}

};

void Girl::setBh(int bh) {
	this->bh = bh;
}
void Girl::setName(string name) {
	this->name = name;
}
void Girl::setPtr(int* ptr) {
	this->ptr = ptr;
}


int main()
{
	Girl g1, g2;
	g1.setBh(8);
	g1.setName("西施");
	g1.setPtr(new int(3));


	g1.show();
	g2.show();


	g2 = g1;
	g1.show();
	g2.show();
	
}
```

:::



:::details `重载new&delete运算符`

重载new和delete运算符的目是为了自定义内存分配的细节。（内存池：快速分配和归还，无碎片）

建议先学习C语言的内存管理函数malloc()和free()。

在C++中，使用new时，编译器做了两件事情：

- 调用标准库函数operator new()分配内存；
- 调用构造函数初始化内存

使用delete时，也做了两件事情：

- 调用析构函数
- 调用标准库函数operator delete()释放内存。

构造函数和析构函数由编译器调用，我们无法控制。

但是，可以重载内存分配函数operator new()和释放函数operator delete()。

- 重载内存分配函数的语法

```c
void* operator new(size_t size);   
参数必须是size_t，返回值必须是void*。
```

- 重载内存释放函数的语法

```
void operator delete(void* ptr) 
参数必须是void *（指向由operator new()分配的内存），返回值必须是void。
```

重载的new和delete可以是全局函数，也可以是类的成员函数。

为一个类重载new和delete时，尽管不必显式地使用static，但实际上仍在创建static成员函数。

编译器看到使用new创建自定义的类的对象时，它选择成员版本的operator new()而不是全局版本的new()。

new[]和delete[]也可以重载。

```c++
#include <iostream>         
using namespace std;

//重载的 new delete 作为全局函数
void* operator new(size_t size) {
	cout << "调用了全局重载的new," << size << "字节\n";
	void* ptr = malloc(size);
	cout << "申请到的内存地址是:" << ptr << endl;
	return ptr;
}


void operator delete(void* ptr) {
	cout << "调用了全局重载的delete\n";
	if (ptr == nullptr) return;
	free(ptr);
}

class Girl {
private:
	int bh;
	int xw;
public:
	Girl(int bh, int xw) {
		this->bh = bh;
		this->xw = xw;
	}
	~Girl() {
		cout << "调用了析构函数"<<endl;
	}
	void show() {
		cout << "对象的地址是：" << this << "编号：" << bh << "，胸围：" << xw << endl;
	}

	//重载的new和delete可以是全局函数，也可以是类的成员函数。
	void* operator new(size_t size) {
		cout << "调用了类的重载new\n";
		void* ptr = malloc(size);
		cout << "申请到的内存的地址是：" << ptr << endl;
		return ptr;
	}

	void operator delete(void* ptr) {
		cout << "调用了类的重载的delete\n";
		if (ptr == nullptr) return;
		free(ptr);
	}
};


int main()
{
	int* p1 = new int(3);
	cout << "p1=" << (void*)p1 << "，*p1=" << *p1 << endl;
	delete p1;

	Girl* p2 = new Girl(3, 8);
	p2->show();
	delete p2;

	
}
```



内存池例子

```c++
#include <iostream>         
using namespace std;

class Girl {
private:
	int bh;
	int xw;
	static char* objPool; //内存池的起始地址

public:
	Girl(int bh, int xw) {
		cout << "构造函数调用\n";
		this->bh = bh;
		this->xw = xw;
	}
	~Girl() {
		cout << "析构函数调用\n";
	}
	void show() {
		cout << "对象的地址是：" << this << "，编号：" << bh << "，胸围：" << xw << endl;
	}
	static bool initPool() {
		objPool = (char*)malloc(18);
		if (objPool == 0) return false;
		memset(objPool, 0, 18);
		cout << "内存池的起始地址是:" << (void*)objPool << endl;
		return true;
	}
	static void freePool() {
		if (objPool == 0) return;
		free(objPool);
		cout << "内存池已经释放\n";
	}
	//重载 new 优先使用内存池的
	void* operator new(size_t size) {
		if (objPool[0] == 0) 
		{
			cout << "分配了第一块内存：" << (void*)(objPool + 1)<<endl;
			objPool[0] = 1;
			return objPool + 1;
		}
		if (objPool[9] == 0)        
		{
			cout << "分配了第二块内存：" << (void*)(objPool + 9) << endl;
			objPool[9] = 1;             
			return objPool + 9;     
		}

		//如果以上两个位置都不够用 那就直接系统申请内存
		void* ptr = malloc(size);
		cout << "申请到的内存的地址是" << ptr << endl;
		return ptr;

	}
	//重载delete 清空的时候，内存池的就释放
	void operator delete(void* ptr) {
		if (ptr == 0) return;

		if (ptr == objPool + 1) { // 如果传进来的地址是内存池的第一个位置。
			cout << "释放了第一块内存"<<endl;
			objPool[0] = 0;
			return;
		}
		if (ptr == objPool + 9) { //如果传进来的地址是内存池的第二个位置
			cout << "释放了第二块内存"<<endl;
			objPool[9] = 0;
			return;
		}

		//如果传进来的地址不属于内存池 把它归还系统
		free(ptr);
	}



};

// 初始化内存池的指针
char* Girl::objPool = 0;

int main()
{
	if (Girl::initPool() == false) {
		cout << "初始化内存池失败";
		return -1;
	}

	Girl* p1 = new Girl(3, 8);  // 将使用内存池的第一个位置。
	p1->show();


	Girl* p2 = new Girl(4, 7);   // 将使用内存池的第二个位置。
	p2->show();


	Girl* p3 = new Girl(5, 6); // 将使用系统的内存。
	p3->show();


	delete p1;   // 将释放内存池的第一个位置。


	Girl* p4 = new Girl(6,5);    // 将使用内存池的第一个位置。
	p4->show();


	delete p2;    // 将释放内存池的第二个位置。
	delete p3;    // 将释放系统的内存。
	delete p4;    // 将释放内存池的第一个位置。
	

	Girl::freePool();     // 释放内存池。
	
}
```

:::



:::details `重载括号运算符`

括号[运算符](https://so.csdn.net/so/search?q=运算符&spm=1001.2101.3001.7020)()也可以重载，对象名可以当成函数来使用（函数对象、仿函数）。

括号运算符重载函数的语法：

```java
返回值类型 operator()(参数列表);
```

注意：

- 1、括号运算符必须以成员函数的形式进行重载。
- 2、 括号运算符重载函数具备普通函数全部的特征。
- 3、 如果函数对象与全局函数同名，按作用域规则选择调用的函数。

函数对象的用途：

- 表面像函数，部分场景中可以代替函数，在STL中得到广泛的应用；
- 函数对象本质是类，可以用成员变量存放更多的信息；
- 函数对象有自己的数据类型；
- 可以提供继承体系。

```c
#include <iostream>         
using namespace std;


void show(string str) {
	cout << "普通函数:" << str << endl;
}

class Girl {
public:
	void operator()(string str) {
		cout << "重载函数" << str << endl;
	}
};

int main()
{
	Girl show;
	::show("我是一只傻傻鸟。");
	show("我是一只傻傻鸟");
	
}
```

![image-20230320144231421](https://wnxbucket-001.oss-cn-guangzhou.aliyuncs.com/wangnaixing/image-20230320144231421.png)

:::





:::details `重载一元运算符`

可重载的一元运算符。

1）++ 自增 

2）-- 自减  

 3）! 逻辑非  

 4）& 取地址

5）~ 二进制反码  

6）* 解引用  

7）+ 一元加  

8） - 一元求反

一元运算符通常出现在它们所操作的对象的左边。

但是，自增运算符++和自减运算符--有前置和后置之分。

[C++](http://c.biancheng.net/cplus/) 规定，重载++或--时，如果重载函数有一个int形参，编译器处理后置表达式时将调用这个重载函数。

```c++
成员函数版：CGirl &operator++();             // ++前置
成员函数版：CGirl operator++(int);            // 后置++
非成员函数版：CGirl &operator++(CGirl &);   // ++前置
非成员函数版：CGirl operator++(CGirl &,int);  // 后置++
```

:::

## 自动类型转换

对于内置类型，如果两种数据类型是兼容的，C++可以自动转换，如果从更大的数转换为更小的数，可能会被截断或损失精度。

```c++
long count = 8;        // int转换为long
double time = 11;      // int转换为double
int side = 3.33         // double转换为int的3
```

C++不自动转换不兼容的类型，下面语句是非法的：

```c++
int* ptr = 8;
```

不能自动转换时，可以使用强制类型转换：

```c++
int* p = (int*)8; 
```

**如果某种类型与类相关，从某种类型转换为类类型是有意义的。**

```
string str = "我是一只傻傻鸟。";
```

在C++中，将一个参数的构造函数用作自动类型转换函数，它是自动进行的，不需要显式的转换。

```c++
CGirl g1(8);          // 常规的写法。
CGirl g1 = CGirl(8);   // 显式转换。
CGirl g1 = 8;         // 隐式转换。
CGirl g1;             // 创建对象。
g1 = 8;              // 隐式转换，用CGirl(8)创建临时对象，再赋值给g1。

```

注意：

1）一个类可以有多个转换函数。



2）多个参数的构造函数，除第一个参数外，如果其它参数都有缺省值，也可以作为转换函数。	



3）CGirl(int)的隐式转换的场景：

- 将CGirl对象初始化为int值时。  CGirl g1 = 8;
- 将int值赋给CGirl对象时。      CGirl g1; g1 = 8;
- 将int值传递给接受CGirl参数的函数时。
- 返回值被声明为CGirl的函数试图返回int值时。
- 在上述任意一种情况下，使用可转换为int类型的内置类型时。
- 如果自动类型转换有二义性，编译将报错。

4）如果自动类型转换有二义性，编译将报错。



将构造函数用作自动类型转换函数似乎是一项不错的特性，但有时候会导致意外的类型转换。explicit关键字用于关闭这种自动特性，但仍允许显式转换。

在实际开发中，如果强调的是构造，建议使用explicit，如果强调的是类型转换，则不使用explicit。

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
           
class CGirl       // 超女类CGirl。
{           
public:
    int         m_bh;           // 编号。
    string    m_name;     // 姓名。
    double  m_weight;   // 体重，单位：kg。
                
    // 默认构造函数。
    CGirl() { m_bh = 0;  m_name.clear();  m_weight = 0; cout << "调用了CGirl()\n"; }
    // 自我介绍的方法。
    void show() { cout << "bh=" << m_bh << ",name=" << m_name << ",weight=" << m_weight << endl; }
    explicit CGirl(int bh) { m_bh = bh;  m_name.clear();  m_weight = 0; cout << "调用了CGirl(int bh)\n"; }
    //CGirl(double weight) { m_bh = 0;  m_name.clear();  m_weight = weight; cout << "调用了CGirl(double weight)\n"; }
};     
          
int main()
{       
    //CGirl g1(8);                // 常规的写法。
    //CGirl g1 = CGirl(8);   // 显式转换。
    //CGirl g1 = 8;             // 隐式转换。
    CGirl g1;                    // 创建对象。
    g1 = (CGirl)8;                      // 隐式转换，用CGirl(8)创建临时对象，再赋值给g。
    //CGirl g1 = 8.7;             // 隐式转换。
    //g1.show();
}    


```

## 转换函数

构造函数只用于从某种类型到类类型的转换，如果要进行相反的转换，可以使用特殊的运算符函数-转换函数。

```
语法：operator 数据类型();
```

**注意：转换函数必须是类的成员函数；不能指定返回值类型；不能有参数。**

可以让编译器决定选择转换函数（隐式转换），可以像使用强制类型转换那样使用它们（显式转换）。

```c++
int ii=girl;       // 隐式转换。
int ii=(int) girl;  // 显式转换。
int ii=int(girl);   // 显式转换。
```

如果隐式转换存在二义性，编译器将报错。

在C++98中，关键字explicit不能用于转换函数，但C++11消除了这种限制，可以将转换函数声明为显式的。

还有一种方法是：用一个功能相同的普通成员函数代替转换函数，普通成员函数只有被调用时才会执行。

```
int ii=girl.to_int();
```

警告：应谨慎的使用隐式转换函数。通常，最好选择仅在被显式地调用时才会执行的成员函数。

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
         
class CGirl       // 超女类CGirl。
{   
public:
    int         m_bh;           // 编号。
    string    m_name;     // 姓名。
    double  m_weight;   // 体重，单位：kg。
               
    // 默认构造函数。
    CGirl() { m_bh = 8;  m_name="西施";  m_weight = 50.7; }
    explicit operator int()  { return m_bh; }
    int to_int() { return m_bh; }
    operator string() { return m_name; }
    explicit operator double() { return m_weight; }
};    
            
int main()
{         
    string name = "西施";                 // char * 转换成 string
    const char* ptr = name;             // string 转换成 char *，错误
    const char* ptr = name.c_str();  // 返回char *，正确
            
    CGirl g;
    int a = g.to_int();         cout << "a的值是：" << a << endl;
    string b = string(g);    cout << "b的值是：" << b << endl;
    double c = double(g);  cout << "c的值是：" << c << endl;
    short d = (int)g;
}
```



## 继承

继承是面向对象的三大特性之一，那么什么时候用到继承呢？继承有什么好处呢？

我们以猫来举例子，自然界中有很多猫科动物，我们举几个简单的例子，有橘猫、狸花猫、山东狮子猫等，这些猫既有共性，又有特性，都是猫，但是毛色不一样。既有共性，又有特性。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20230107142944413.png)



在程序中也一样，类和类之间既有联系又有区别，对于共性的那一部分，我们可以选择提取出来，这样的话，在创造其他类的时候，直接调用这个公共部分就可以，不需要再重新编写，这个部分就叫做继承，继承能够减小代码的重复性。



通过继承，**派生类对象获得了基类的数据成员，派生类对象可以使用基类的方法。**那么派生对象需要干些什么呢？**派生对象需要添加自己的构造函数，可以根据自己的需要添加额外的成员数据和成员函数。**

继承可以理解为一个类从另一个类获取成员变量和成员函数的过程。

```c
语法：
class 派生类名:［继承方式］基类名
{
    派生类新增加的成员
}; 
```

被继承的类称为基类或父类，继承的类称为派生类或子类。

继承和派生是一个概念，只是站的角度不同。

派生类除了拥有基类的成员，还可以定义新的成员，以增强其功能。

使用继承的场景：

- 如果新创建的类与现有的类相似，只是多出若干成员变量或成员函数时，可以使用继承。
- 当需要创建多个类时，如果它们拥有很多相似的成员变量或成员函数，可以将这些类共同的成员提取出来，定义为基类，然后从基类继承。

:::details `继承示例：`

```c
#include<iostream>
using namespace std;

class CallComer {
private:
	string name;
	string tel;
public:
	CallComer() {
		this->name = "某女";
		this->tel = "不详";
	}
	void sing() {
		cout << "我是一只小小鸟";
	}
	void setName(const string& name) {
		this->name = name;
	}
	void setTel(const string& tel) {
		this->tel = tel;
	}
	const string& getName() {
		return name;
	}
	const string& getTel() {
		return tel;
	}


};

class Girl :public CallComer {
private:
	int bh;
public:
	Girl() {
		bh = 8;
	}
	void show() { //可以使用基类的公有方法 去访问私有属性
		cout << "编号：" << bh << "姓名" << this->getName() << ",联系电话:" << this->getTel() << endl;
	}

};


int main() {
	Girl g;
    //可以使用基类的公有方法 ，设置父类属性值
	g.setName("西施");
	g.setTel("18154622909");
	g.show();
}

```

:::





:::details `继承方式`

类成员的访问权限由高到低依次为：public --> protected --> private，public成员在类外可以访问，private成员只能在类的成员函数中访问。



如果不考虑继承关系，protected成员和private成员一样，类外不能访问。但是，当存在继承关系时，protected和private就不一样了。基类中的protected成员可以在派生类中访问，而基类中的 private成员不能在派生类中访问。



继承方式有三种：public（公有的）、protected（受保护的）和[private](https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020)（私有的）。它是可选的，如果不写，那么默认为private。不同的继承方式决定了在派生类中成员函数中访问基类成员的权限。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20230322155332256.png)

基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为protected时，那么基类成员在派生类中的访问权限最高也为protected，高于protected的会降级为protected，但低于protected不会升级。再如，当继承方式为public时，那么基类成员在派生类中的访问权限将保持不变。

也就是说，继承方式中的public、protected、private是用来指明基类成员在派生类中的最高访问权限的。



**不管继承方式如何，基类中的private成员在派生类中始终不能使用**（不能在派生类的成员函数中访问或调用）。



 如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为public 或protected；只有那些不希望在派生类中使用的成员才声明为private。



 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected。



由于private和protected继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以，**在实际开发中，一般使用public**。

:::





:::details `改变基类成员的访问权限`

**在派生类中，可以通过基类的公有成员函数间接访问基类的私有成员。**

**使用 using 关键字可以改变基类成员在派生类中的访问权限。**

注意：using只能改变基类中public和protected成员的访问权限，不能改变private成员的访问权限，因为基类中的private成员在派生类中是不可见的，根本不能使用。

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class A  {        // 基类
public:
    int m_a=10;
protected:
    int m_b=20;
private:
    int m_c = 30;
};

class B :public A        // 派生类
{
public:
    using A::m_b;         // 把m_b的权限修改为公有的。
private:
    using A::m_a;         // 把m_a的权限修改为私有的。
};

int main()
{
    B b;   
    // b.m_a = 11;
    b.m_b = 21;
    //b.m_c = 21;
}

```

:::

## 继承的对象模型

- 创建派生类对象时，先调用基类的构造函数，再调用派生类的构造函数。
- 销毁派生类对象时，先调用派生类的析构函数，再调用基类的析构函数。**如果手工调用派生类的析构函数，也会调用基类的析构函数。**
- 创建派生类对象时只会申请一次内存，派生类对象包含了基类对象的内存空间，this指针相同的。
- 创建派生类对象时，先初始化基类对象，再初始化派生类对象。
- 在VS中，用cl.exe可以查看类的内存模型。
- 对派生类对象用sizeof得到的是基类所有成员（包括私有成员）+派生类对象所有成员的大小。
- 在C++中，不同继承方式的访问权限只是语法上的处理。
- 对派生类对象用memset()会清空基类私有成员。
- 用指针可以访问到基类中的私有成员（内存对齐）。

:::details `示例:`

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
            
void* operator new(size_t size)   // 重载new运算符。
{
    void* ptr = malloc(size);        // 申请内存。
    cout << "申请到的内存的地址是：" << ptr << "，大小是：" << size << endl;
    return ptr;
}
               
void operator delete(void* ptr)   // 重载delete运算符。
{
    if (ptr == 0) return;       // 对空指针delete是安全的。
    free(ptr);      // 释放内存。
    cout << "释放了内存。\n";
}
              
class A {        // 基类
public:
    int m_a = 10;
protected:
    int m_b = 20;
private:
    int m_c = 30;
public:
    A() {
        cout << "A中this指针是： " << this << endl;
        cout << "A中m_a的地址是：" << &m_a << endl;
        cout << "A中m_b的地址是：" << &m_b << endl;
        cout << "A中m_c的地址是：" << &m_c << endl;
    }
    void func() { cout << "m_a=" << m_a << ",m_b=" << m_b << ",m_c=" << m_c << endl; }
};
                 
class B :public A        // 派生类
{
public:
    int m_d = 40;
    B() {
        cout << "B中this指针是： " << this << endl;
        cout << "B中m_a的地址是：" << &m_a << endl;
        cout << "B中m_b的地址是：" << &m_b << endl;
        //cout << "B中m_c的地址是：" << &m_c << endl;
        cout << "B中m_d的地址是：" << &m_d << endl;
    }
    void func1() { cout << "m_d=" << m_d << endl; }
};
                
int main()
{
    cout << "基类占用内存的大小是：" << sizeof(A) << endl;
    cout << "派生类占用内存的大小是：" << sizeof(B) << endl;
              
    B *p=new B;
    p->func(); p->func1();
    // memset(p, 0, sizeof(B));
    *((int*)p + 2) = 31;        // 把基类私有成员m_c的值修改成31。
    p->func(); p->func1();
    delete p;
}


```

:::

## 如何构造基类



:::tip 派生类构造函数的要点如下： 

1）创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。

2）如果没以指定基类构造函数，将使用基类的默认构造函数。

3）可以用初始化列表指明要使用的基类构造函数。

4）基类构造函数负责初始化被继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。

5）派生类的构造函数总是调用一个基类构造函数，包括拷贝构造函数。

:::



:::details `示例:`

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
               
class A {        // 基类
public:
    int m_a;
private:
    int m_b;
public:
    A() : m_a(0) , m_b(0)                     // 基类的默认构造函数。
    { 
        cout << "调用了基类的默认构造函数A()。\n";  
    }
    A(int a,int b) : m_a(a) , m_b(b)     // 基类有两个参数的构造函数。
    { 
        cout << "调用了基类的构造函数A(int a,int b)。\n";  
    }
    A(const A &a) : m_a(a.m_a+1) , m_b(a.m_b+1)   // 基类的拷贝构造函数。
    {
        cout << "调用了基类的拷贝构造函数A(const A &a)。\n";
    }
               
    // 显示基类A全部的成员。
    void showA() { cout << "m_a=" << m_a << ",m_b=" << m_b << endl; }
};
               
class B :public A        // 派生类
{        
public:
    int m_c;
    B() : m_c(0) , A()             // 派生类的默认构造函数，指明用基类的默认构造函数（不指明也无所谓）。
    {
        cout << "调用了派生类的默认构造函数B()。\n";
    }
    B(int a, int b, int c) : A(a, b), m_c(c)           // 指明用基类的有两个参数的构造函数。
    {
        cout << "调用了派生类的构造函数B(int a,int b,int c)。\n";
    }
    B(const A& a, int c) :A(a), m_c(c)              // 指明用基类的拷贝构造函数。
    {
        cout << "调用了派生类的构造函数B(const A &a,int c) 。\n";
    }
           
    // 显示派生类B全部的成员。
    void showB() { cout << "m_c=" << m_c << endl << endl; }
};          
             
int main()
{
    B b1;                 // 将调用基类默认的构造函数。
    b1.showA();     b1.showB();
       
    B b2(1, 2, 3);      // 将调用基类有两个参数的构造函数。
    b2.showA();     b2.showB();
            
    A a(10, 20);      // 创建基类对象。
    B b3(a, 30);      // 将调用基类的拷贝造函数。
    b3.showA();     b3.showB();
}     

```

:::



:::details `名字遮蔽与类作用域`

如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，通过派生类对象或者在派生类的成员函数中使用该成员时，将使用派生类新增的成员，而不是基类的。

注意：基类的成员函数和派生类的成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数。

类是一种[作用域](https://so.csdn.net/so/search?q=作用域&spm=1001.2101.3001.7020)，每个类都有它自己的作用域，在这个作用域之内定义成员。

在类的作用域之外，普通的成员只能通过对象（可以是对象本身，也可以是对象指针或对象引用）来访问，静态成员可以通过对象访问，也可以通过类访问。

在成员名前面加类名和域解析符可以访问对象的成员。

如果不存在继承关系，类名和域解析符可以省略不写。

当存在继承关系时，基类的作用域嵌套在派生类的作用域中。如果成员在派生类的作用域中已经找到，就不会在基类作用域中继续查找；如果没有找到，则继续在基类作用域中查找。

如果在成员的前面加上类名和域解析符，就可以直接使用该作用域的成员。



示例：

```c++
class A { //基类
public:
    int m_a = 10;
    void func() {
        cout << "调用了A的func()函数\n";
    }

};

class B :public A
{ //子类
public:
    int m_a = 20;
    void func() {
        cout << "调用了B的func()函数\n";
    }
};

class C :public B { //孙类
public:
    int m_a = 30;

    void func() {
        cout << "调用了C的func()函数\n";
    }
    void show() {
        cout << "C::m_a的值是：" << C::m_a << endl;
        cout << "B::m_a的值是：" << B::m_a << endl;
        cout << "A::m_a的值是：" << B::A::m_a << endl;

    }
};

int main()
{
    C c;
    cout << "C:m_a的值是:" << c.m_a << endl;
    cout << "B::m_a的值是：" << c.B::m_a << endl;
    cout << "A::m_a的值是" << c.B::A::m_a << endl;
    c.C::func();
    c.B::func();
    c.B::A::func();

    
}
```

派生类和基类之间有一些特殊关系。

1）如果继承方式是公有的，派生类对象可以使用基类成员。

2）可以把派生类对象赋值给基类对象（包括私有成员），但是，会舍弃非基类的成员。

3）基类指针可以在不进行显式转换的情况下指向派生类对象。

4）基类引用可以在不进行显式转换的情况下引用派生类对象。

注意：

1）基类指针或引用只能调用基类的方法，不能调用派生类的方法。

2）可以用派生类构造基类。

3）如果函数的形参是基类，实参可以用派生类。

4）C++要求指针和引用类型与赋给的类型匹配，这一规则对继承来说是例外。但是，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针（没有价值，没有讨论的必要）。

```c++
class A { //基类
public:
    int m_a = 0;

private:
    int m_b = 0;
public:
    // 显示基类A全部的成员。
    void show() { cout << "A::show() m_a=" << m_a << ",m_b=" << m_b << endl; }
    // 设置成员m_b的值。
    void setb(int b) { m_b = b; }

};

class B :public A{ //派生类
public:
    int m_c = 0;
    // 显示派生类B全部的成员。
    void show() { cout << "B::show() m_a=" << m_a << "m_c=" << m_c << endl; }

   
};



int main()
{
    //----基类指针可以在不进行显式转换的情况下指向派生类对象。---
    B b;
    A* a = &b;

    b.m_a = 10;
    b.setb(20);          // 设置成员m_b的值。

    b.m_c = 30;
    b.show();            // 调用的是B类的show()函数。

  //----基类指针或引用只能调用基类的方法----------
    a->m_a = 11;
    a->setb(22);          // 设置成员m_b的值。
    // a->m_c = 30;
    a->show();         // 调用的是A类的show()函数。
    
}
```

:::

## 多继承与虚继承

多继承的语法：

```c
class 派生类名 : [继承方式1] 基类名1, [继承方式2] 基类名2,......
{
    派生类新增加的成员
};
```

虚继承可以解决菱形继承的**二义性**和**数据冗余**的问题。

有了多继承，就存在菱形继承，有了菱形继承就有虚继承，增加了复杂性。

**不提倡使用多继承，只有在比较简单和不出现二义性的情况时才使用多继承，能用单一继承解决的问题就不要使用多继承。**



如果继承的层次很多、关系很复杂，程序的编写、调试和维护工作都会变得更加困难，由于这个原因，C++之后的很多面向对象的编程语言，例如 [Java](http://c.biancheng.net/java/)、[C#](http://c.biancheng.net/csharp/)、[PHP](http://c.biancheng.net/php/) 等，都不支持多继承。



:::details `多继承示例：`

```c
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
            
class A1 {        // 基类一
public:
    int m_a = 10;
};
       
class A2 {        // 基类二
public:
    int m_a = 20;
};
         
class B :public A1, public A2 {       // 派生类
public:
    int m_a = 30;
};
       
int main()
{
    B b;
    cout << " B::m_a的值是：" << b.m_a << endl;
    cout << "A1::m_a的值是：" << b.A1::m_a << endl;
    cout << "A2::m_a的值是：" << b.A2::m_a << endl;
}

```

:::



:::details `菱形继承示例：`

```c
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class A {    
public:
    int m_a = 10;
};

class B : virtual public A { };

class C : virtual public A { };

class DD : public B, public C {};

int main()
{
    DD d;
    // d.B::m_a = 30;
    // d.C::m_a = 80;
    d.m_a = 80;
    cout << "B::m_a的地址是：" << &d.B::m_a << "，值是：" << d.B::m_a << endl;
    cout << "C::m_a的地址是：" << &d.C::m_a << "，值是：" << d.C::m_a << endl;
}
```

:::

## 如何析构派生类

构造函数不能继承，创建派生类对象时，先执行基类构造函数，再执行派生类构造函数。

析构函数不能继承，而销毁派生类对象时，先执行派生类析构函数，再执行基类析构函数。

派生类的析构函数在执行完后，会自动执行基类的析构函数。

如果手工的调用派生类的析构函数，也会自动调用基类的析构函数。



:::tip 析构派生类的要点如下： 

1）析构派生类对象时，会自动调用基类的析构函数。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉。

2）析构函数可以手工调用，如果对象中有堆内存，析构函数中以下代码是必要的：

```c
delete ptr;
ptr=nulllptr;
```

3）用基类指针指向派生类对象时，delete基类指针调用的是基类的析构函数，不是派生类的，如果希望调用派生类的析构函数，就要把基类的析构函数设置为虚函数。

4）C++编译器对虚析构函数做了特别的处理。

5）对于基类，即使它不需要析构函数，也应该提供一个空虚析构函数。

6）赋值运算符函数不能继承，派生类继承的函数的特征标与基类完全相同，但赋值运算符函数的特征标随类而异，它包含了一个类型为其所属类的形参。

7）友元函数不是类成员，不能继承。

:::





## 多态



:::details `多态的基本概念`



基类指针只能调用基类的成员函数，不能调用派生类的成员函数。

如果在基类的成员函数前加virtual 关键字，把它声明为虚函数，基类指针就可以调用派生类中同名的成员函数，通过派生类中同名的成员函数，就可以访问派生对象的成员变量。



有了虚函数，基类指针指向基类对象时就使用基类的成员函数和数据，指向派生类对象时就使用派生类的成员函数和数据，基类指针表现出了多种形式，这种现象称为多态。



基类引用也可以使用多态。



注意：

1）只需要在基类的函数声明中加上virtual关键字，函数定义时不能加。

2）在派生类中重定义虚函数时，函数特征要相同。

3）当在基类中定义了虚函数时，如果派生类没有重定义该函数，那么将使用基类的虚函数。

4）在派生类中重定义了虚函数的情况下，如果想使用基类的虚函数，可以加类名和域解析符。

5）如果要在派生类中重新定义基类的函数，则将它设置为虚函数；否则，不要设置为虚函数，有两方面的好处：首先效率更高；其次，指出不要重新定义该函数。

:::



:::details `示例1：`

```c
class CAllComers
{
public:
    int m_bh = 0;
    virtual void show() {
        cout << "CAllComers::show()：我是" << m_bh << "号。 " << endl;
    }
    virtual void show(int a) {
        cout << "CAllComers::show(int a)：我是" << m_bh << "号。 " << endl;
    }
};

class CGril :public CAllComers {
public:
    int m_age = 0;
    void show() { cout << "CGirl::show()：我是" << m_bh << "号， " << m_age << "岁。" << endl; }
    void show(int a) { cout << "CGirl::show(int a)：我是" << m_bh << "号， " << m_age << "岁。" << endl; }


};

int main()
{
 
    CAllComers a; a.m_bh = 3;   // 创建基类对象并对成员赋值。
    
    CGril g;g.m_bh = 8;g.m_age = 23;     // 创建派生类对象并对成员赋值。


    CAllComers* p;    // 声明基类指针。
    //p = &a; p->show();    // 让基类指针指向基类对象，并调用虚函数。

    p = &g; p->show();  // 让基类指针指向派生类对象，并调用虚函数。
     
    //默认调用派生类的 如果硬要调用基类的函数呢？
    p->show(5);
    p->CAllComers::show(5);

}
```

:::





:::details `多态的应用`

什么是多态？字面上解释就是多种形态，那么在类和对象中就可以解释为，同一个方法在基类和派生类中的行为是不同的，换句话说**针对不同对象，同一个方法的行为是不同的。**

```c
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
         
class Hero                        // 英雄基类
{
public:
	int viability;      // 生存能力。
	int attack;         // 攻击伤害。
	virtual void skill1() { cout << "英雄释放了一技能。\n"; }
	virtual void skill2() { cout << "英雄释放了二技能。\n"; }
	virtual void uskill() { cout << "英雄释放了大绝招。\n"; }
};
           
class XS :public Hero       // 西施派生类
{
public:
	void skill1() { cout << "西施释放了一技能。\n"; }
	void skill2() { cout << "西施释放了二技能。\n"; }
	void uskill() { cout << "西施释放了大招。\n"; }
};
              
class HX :public Hero       // 韩信派生类
{
public:
	void skill1() { cout << "韩信释放了一技能。\n"; }
	void skill2() { cout << "韩信释放了二技能。\n"; }
	void uskill() { cout << "韩信释放了大招。\n"; }
};
                
class LB :public Hero       // 李白派生类
{
public:
	void skill1() { cout << "李白释放了一技能。\n"; }
	void skill2() { cout << "李白释放了二技能。\n"; }
	void uskill() { cout << "李白释放了大招。\n"; }
};
              
int main()
{
	// 根据用户选择的英雄，施展一技能、二技能和大招。
	int id = 0;     // 英雄的id。
	cout << "请输入英雄（1-西施；2-韩信；3-李白。）：";
	cin >> id;
               
	// 创建基类指针，让它指向派生类对象，用基类指针调用派生类的成员函数。
	Hero* ptr = nullptr;
	if (id == 1)	{             // 1-西施
		ptr=new XS;  
	}
	else if (id == 2) {      // 2-韩信
		ptr = new HX;
	}
	else if (id == 3) {      // 3-李白
		ptr = new LB;
	}
           
	if (ptr != nullptr) {
		ptr->skill1();
		ptr->skill2();
		ptr->uskill();
		delete ptr;
	}
}
```

:::

## 多态的对象模型

类的普通成员函数的地址是静态的，在编译阶段已指定。

如果基类中有虚函数，对象的内存模型中有一个虚函数表，表中存放了基类的函数名和地址。

如果派生类中重定义了基类的虚函数，创建派生类对象时，将用派生类的函数取代虚函数表中基类的函数。



C++中的多态分为两种：静态多态与动态多态。

静态多态：也成为编译时的多态；在编译时期就已经确定要执行了的函数地址了；主要有函数重载和函数模板。

动态多态：即动态绑定，在运行时才去确定对象类型和正确选择需要调用的函数，一般用于解决基类指针或引用派生类对象调用类中重写的方法（函数）时出现的问题。







## 纯虚函数和抽象类

纯虚函数是一种特殊的虚函数，在某些情况下，[基类](https://baike.baidu.com/item/基类/9589663)中不能对[虚函数](https://baike.baidu.com/item/虚函数/2912832)给出有意义的[实现](https://baike.baidu.com/item/实现/10801654)，把它声明为纯虚函数。



纯虚函数只有函数名、参数和返回值类型，没有函数体，具体实现留给该[派生类](https://baike.baidu.com/item/派生类/9589520)去做。

```c
语法：virtual 返回值类型 函数名 (参数列表)=0;
```

[纯虚函数](https://so.csdn.net/so/search?q=纯虚函数&spm=1001.2101.3001.7020)在基类中为派生类保留一个函数的名字，以便派生类它进行重定义。如果在基类中没有保留函数名字，则无法支持[多态](https://so.csdn.net/so/search?q=多态&spm=1001.2101.3001.7020)性。



含有[纯虚函数](https://so.csdn.net/so/search?q=纯虚函数&spm=1001.2101.3001.7020)的类被称为抽象类，不能实例化对象，可以创建指针和引用。

派生类必须重定义抽象类中的纯虚函数，否则也属于抽象类。基类中的纯虚析构函数也需要实现。



有时候，想使一个类成为抽象类，但刚好又没有任何纯虚函数，怎么办？

方法很简单：在想要成为抽象类的类中声明一个纯虚析构函数。







## 运行阶段类型识别dynamic_cast

运行阶段类型识别（RTTI RunTime Type Identification）为程序在运行阶段确定对象的类型，**只适用于包含虚函数的类**。

基类指针可以指向派生类对象，如何知道基类指针指向的是哪种派生类的对象呢？（想调用派生类中的非虚函数）。

dynamic_cast运算符用指向基类的指针来生成派生类的指针，它不能回答“指针指向的是什么类的对象”的问题，但能回答“是否可以安全的将对象的地址赋给特定类的指针”的问题。

```c++
语法：派生类指针 = dynamic_cast<派生类类型 *>(基类指针);
```

如果转换成功，dynamic_cast返回对象的地址，如果失败，返回`nullptr`。

注意：

- 1、dynamic_cast只适用于包含虚函数的类。
- 2、dynamic_cast可以将派生类指针转换为基类指针，这种画蛇添足的做法没有意义。
- 3、dynamic_cast可以用于引用，但是，没有与空指针对应的引用值，如果转换请求不正确，会出现bad_cast异常。

:::details `dynamic_cast 示例：`

```c++
#include <iostream>
#include <map>
using  namespace std;

class Hero                        // 英雄基类
{
public:
	int viability;      // 生存能力。
	int attack;         // 攻击伤害。
	virtual void skill1() { cout << "英雄释放了一技能。\n"; }
	virtual void skill2() { cout << "英雄释放了二技能。\n"; }
	virtual void uskill() { cout << "英雄释放了大绝招。\n"; }
};

class XS :public Hero       // 西施派生类
{
public:
	void skill1() { cout << "西施释放了一技能。\n"; }
	void skill2() { cout << "西施释放了二技能。\n"; }
	void uskill() { cout << "西施释放了大招。\n"; }
	void show() { cout << "我是天下第一美女。\n"; }
};

class HX :public Hero       // 韩信派生类
{
public:
	void skill1() { cout << "韩信释放了一技能。\n"; }
	void skill2() { cout << "韩信释放了二技能。\n"; }
	void uskill() { cout << "韩信释放了大招。\n"; }
};

class LB :public Hero       // 李白派生类
{
public:
	void skill1() { cout << "李白释放了一技能。\n"; }
	void skill2() { cout << "李白释放了二技能。\n"; }
	void uskill() { cout << "李白释放了大招。\n"; }
};




int main()
{
	// 根据用户选择的英雄，施展一技能、二技能和大招。
	int id = 0;     // 英雄的id。
	cout << "请输入英雄（1-西施；2-韩信；3-李白。）：";
	cin >> id;


	// 创建基类指针，让它指向派生类对象，用基类指针调用派生类的成员函数。
	Hero* ptr = nullptr;


	if (id == 1) {             // 1-西施
		ptr = new XS;
	}
	else if (id == 2) {      // 2-韩信
		ptr = new HX;
	}
	else if (id == 3) {      // 3-李白
		ptr = new LB;
	}


	if (ptr != nullptr) {
		ptr->skill1();
		ptr->skill2();
		ptr->uskill();

		// 如果基类指针指向的对象是西施，那么就调用西施的show()函数。
		//if (id == 1) {
		//	XS* pxs = (XS *)ptr;        // C风格强制转换的方法，程序员必须保证目标类型正确。
		//	pxs->show();
		//}

		XS* xsptr = dynamic_cast<XS*>(ptr);         // 把基类指针转换为派生类。
		if (xsptr != nullptr) xsptr->show();              // 如果转换成功，调用派生类西施的非虚函数。

		delete ptr;



	}
	// 以下代码演示把基类引用转换为派生类引用时发生异常的情况。
/*HX hx;
Hero& rh = hx;
try{
	XS & rxs= dynamic_cast<XS &>(rh);
}
catch (bad_cast) {
	cout << "出现了bad_cast异常。\n";
}*/



}
```

:::

## typeid运算符和type_info类

typeid运算符返回type_info类（在头文件`<typeinfo>`中定义）的对象的引用。

type_info类的实现随编译器而异，但至少有name()成员函数，该函数返回一个字符串，通常是类名。

type_info重载了==和!=运算符，用于对类型进行比较。

注意：

1）type_info类的构造函数是private属性，也没有拷贝构造函数，所以不能直接实例化，只能由编译器在内部实例化。

2）不建议用name()成员函数返回的字符串作为判断数据类型的依据。（编译器可能会转换类型名）

3）typeid运算符可以用于多态的场景，在运行阶段识别对象的数据类型。

4）假设有表达式typeid(***\**ptr\****)，当ptr是空指针时，如果ptr是多态的类型，将引发bad_typeid异常。



:::details `typeid 示例:`

```c++
#include <iostream>
#include <string>
using namespace std;

class AA {   // 定义一个类。
public:
    AA() {}
};

int main()
{
    // typeid用于自定义的数据类型。
    AA aa;
    AA* paa = &aa;
    AA& raa = aa;
    cout << "typeid(AA)=" << typeid(AA).name() << endl;
    cout << "typeid(aa)=" << typeid(aa).name() << endl;
    cout << "typeid(AA *)=" << typeid(AA*).name() << endl;
    cout << "typeid(paa)=" << typeid(paa).name() << endl;
    cout << "typeid(AA &)=" << typeid(AA&).name() << endl;
    cout << "typeid(raa)=" << typeid(raa).name() << endl;

    // type_info重载了==和!=运算符，用于对类型进行比较。
    if (typeid(AA) == typeid(aa))     cout << "ok1\n";
    if (typeid(AA) == typeid(*paa)) cout << "ok2\n";
    if (typeid(AA) == typeid(raa))    cout << "ok3\n";
    if (typeid(AA*) == typeid(paa))   cout << "ok4\n";

    return 0;
}
```

:::

## 自动推导类型auto



在C语言和C++98中，auto关键字用于修饰变量（自动存储的局部变量）。

在C++11中，赋予了auto全新的含义，不再用于修饰变量，而是作为一个类型指示符，指示编译器在编译时推导auto声明的变量的数据类型。

语法：auto 变量名 = 初始值;

在Linux平台下，编译需要加-std=c++11参数。

注意：

1）auto声明的变量必须在定义时初始化。

2）初始化的右值可以是具体的数值，也可以是表达式和函数的返回值等。

3）auto不能作为函数的形参类型。

4）auto不能直接声明数组。

5）auto不能定义类的非静态成员变量。



```c
不要滥用auto，auto在编程时真正的用途如下：
1）代替冗长复杂的变量声明。
2）在模板中，用于声明依赖模板参数的变量。
3）函数模板依赖模板参数的返回值。
4）用于lambda表达式中。
```

:::details `示例：`

```c
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
          
double func(double b, const char* c, float d, short e, long f)
{
	cout << ",b=" << b << ",c=" << c << ",d=" << d << ",e=" << e << ",f=" << f << endl;
	return 5.5;
}
          
int main()
{
	double (*pf)( double , const char* , float , short , long );    // 声明函数指针pf。
	pf = func;
	pf( 2, "西施", 3, 4, 5);
	auto pf1 = func;
	pf1(2, "西施", 3, 4, 5);
}
```

:::

## 模板类



:::details `模板类的基本概念`

类模板是通用类的描述，使用任意类型（泛型）来描述类的定义。

使用类模板的时候，指定具体的数据类型，让编译器生成该类型的类定义。

语法：

```c
template <class T>
class 类模板名
{
	类的定义;
};
```

函数模板建议用`typename`描述通用数据类型，类模板建议用class。

注意：

1）在创建对象的时候，必须指明具体的数据类型。

2）使用类模板时，数据类型必须适应类模板中的代码。

3）类模板可以为通用数据类型指定缺省的数据类型（C++11标准的函数模板也可以）。

4）模板类的成员函数可以在类外实现。

5）可以用new创建模板类对象。

6）在程序中，模板类的成员函数使用了才会创建。

:::



:::details `示例：`

```c
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
          
template <class T1, class T2=string>
class AA
{
public:
	T1 m_a;      // 通用类型用于成员变量。
	T2 m_b;      // 通用类型用于成员变量。
          
	AA() {  }        // 默认构造函数是空的。
	// 通用类型用于成员函数的参数。
	AA(T1 a,T2 b):m_a(a),m_b(b) {  }
	// 通用类型用于成员函数的返回值。
	T1 geta()            // 获取成员m_a的值。
	{
		T1 a = 2;        // 通用类型用于成员函数的代码中。
		return m_a + a;
	}
	T2 getb();            // 获取成员m_b的值。
};
           
template <class T1, class T2>
T2 AA<T1,T2>::getb()            // 获取成员m_b的值。
{
	return m_b;
}
            
int main()
{
	AA<int, string>* a = new AA<int, string>(3, "西施");     // 用模板类AA创建对象a。
	
	cout << "a->geta()=" << a->geta() << endl;
	cout << "a->getb()=" << a->getb() << endl;
         
	delete a;
}
```

:::



:::details `模板类的示例-栈`

```c
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
          
// typedef string DataType;        // 定义栈元素的数据类型。
          
template <class DataType>
class Stack       // 栈类
{
private:
	DataType* items;               // 栈数组。
	int   stacksize;         // 栈实际的大小。
	int   top;                  // 栈顶指针。
public:
	// 构造函数：1）分配栈数组内存；2）把栈顶指针初始化为0。
	Stack(int size) :stacksize(size), top(0) {
		items = new DataType[stacksize];
	}
	~Stack() {
		delete [] items; items = nullptr;
	}
	bool isempty() const {            // 判断栈是否为空。
		return top == 0;
	}
	bool isfull() const {                 // 判断栈是否已满。
		return top == stacksize;
	}
	bool push(const DataType& item) {   // 元素入栈。
		if (top < stacksize) { items[top++] = item; return true; }
		return false;
	}
	bool pop(DataType& item) {               // 元素出栈。
		if (top > 0) { item = items[--top]; return true; }
		return false;
	}
};
       
int main()
{
	Stack<string> ss(5);       // 创建栈对象，大小是5。
           
	// 元素入栈。
	// ss.push(1); ss.push(2); ss.push(3); ss.push(4); ss.push(5);
	ss.push("西施"); ss.push("冰冰"); ss.push("幂幂"); ss.push("金莲");
          
	// 元素出栈。
	string item;
	while (ss.isempty() == false)
	{
		ss.pop(item);   cout << "item = " << item << endl;
	}
}
```

:::



:::details `模板类的示例-数组`

类模板可以有非通用类型参数：

- 1）通常是整型（C++20标准可以用其它的类型）；

- 2）实例化模板时必须用常量表达式；

- 3）模板中不能修改参数的值；

- 4）可以为非通用类型参数提供默认值。

优点：在栈上分配内存，易维护，执行速度快，合适小型数组。

缺点：在程序中，不同的非通用类型参数将导致编译器生成不同的类。

构造函数的方法更通用，因为数据的大小是类的成员（而不是硬编码），可以创建数组大小可变的类。



```c
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
           
template <class T,int len=10>
class Array
{
private:
	T items[len];      // 数组元素。
public:
	Array()    {}    	   // 默认构造函数。
	~Array() {}         // 析构函数
	T& operator[](int ii) { return items[ii]; }  // 重载操作符[]，可以修改数组中的元素。
	const T& operator[](int ii) const { return items[ii]; }  // 重载操作符[]，不能修改数组中的元素。
};
        
template <class T>
class Vector
{
private:
	int len;               // 数组元素的个数。
	T*  items;           // 数组元素。
public:
	// 默认构造函数，分配内存。
	Vector(int size=10):len(size) {
		items = new T[len];
	}
    
	~Vector() {         // 析构函数
		delete[] items; items = nullptr;
	}
    
	void resize(int size) {         // 护展数组的内存空间。
		if (size <= len) return;   // 只能往更大扩展。
		T* tmp = new T[size];   // 分配更大的内存空间。
		for (int ii = 0; ii < len; ii++) tmp[ii] = items[ii];     // 把原来数组中的元素复制到新数组。
		delete[] items;    // 释放原来的数组。
		items = tmp;      // 让数组指针指向新数组。
		len = size;           // 扩展后的数组长度。
	}
    
	int size() const { return len; }     // 获取数组长度。
	T& operator[](int ii) {   // 重载操作符[]，可以修改数组中的元素。
		if (ii >= len) resize(ii + 1);    // 扩展数组。
		return items[ii]; 
	}
    
	const T& operator[](int ii) const { return items[ii]; }  // 重载操作符[]，不能修改数组中的元素。
};
        
int main()
{
	// Array<string,10> aa;  // 创建模板类Array的对象。
	Vector<int> aa(1);     // 创建模板类Vector的对象。
	aa[0] = 5; aa[1] = 8; aa[2] = 3; aa[3] = 2; aa[4] = 7; 
	// aa[0] = "西施"; aa[1] = "冰冰"; aa[2] = "幂幂"; aa[3] = "金莲"; aa[4] = "小乔";
           
	for (int ii=0; ii<5;ii++) cout << "aa[" << ii << "]=" << aa[ii] << endl;
}

```

:::



:::details `模板类具体化`

模板类具体化（特化、特例化）有两种：完全具体化和部分具体化。

具体化程度高的类优先于具体化程度低的类，具体化的类优先于没有具体化的类。具体化的模板类，成员函数类外实现的代码应该放在源文件中。

```c
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

// 类模板
template<class T1, class T2>
class AA {                 // 类模板。
public:
	T1 m_x;
	T2 m_y;

	AA(const T1 x, const T2 y) :m_x(x), m_y(y) { cout << "类模板：构造函数。\n"; }
	void show() const;
};

template<class T1, class T2>
void AA<T1, T2>::show() const {    // 成员函数类外实现。
	cout << "类模板：x = " << m_x << ", y = " << m_y << endl;
}
/////////////////////////////////////////////////////////////////////////////////////////

// 类模板完全具体化
template<>
class AA<int, string> {
public:
	int      m_x;
	string m_y;

	AA(const int x, const string y) :m_x(x), m_y(y) { cout << "完全具体化：构造函数。\n"; }
	void show() const;
};

void AA<int, string>::show() const {    // 成员函数类外实现。
	cout << "完全具体化：x = " << m_x << ", y = " << m_y << endl;
}
/////////////////////////////////////////////////////////////////////////////////////////

// 类模板部分具体化
template<class T1>
class AA<T1, string> {
public:
	T1       m_x;
	string m_y;

	AA(const T1 x, const string y) :m_x(x), m_y(y) { cout << "部分具体化：构造函数。\n"; }
	void show() const;
};

template<class T1>
void AA<T1, string>::show() const {    // 成员函数类外实现。
	cout << "部分具体化：x = " << m_x << ", y = " << m_y << endl;
}
/////////////////////////////////////////////////////////////////////////////////////////

int main()
{
	// 具体化程度高的类优先于具体化程度低的类，具体化的类优先于没有具体化的类。
	AA<int, string>  aa1(8, "我是一只傻傻鸟。");   // 将使用完全具体化的类。
	AA<char, string> aa2(8, "我是一只傻傻鸟。");   // 将使用部分具体化的类。
	AA<int, double> aa3(8, 999999);                      // 将使用模板类。
}
```

:::
