# 坦克动荡游戏

坦克动荡游戏是一款简约有趣的坦克对战游戏，游戏场景设定在一个随机生成的小迷宫中，游戏双方控制已方坦克攻击对方，直至一方坦克爆炸为止。在游戏中坦克可以连续发射多颗子弹，需要小心的是子弹打到墙上会反弹，反弹的子弹可能打爆自己的坦克，所以千万要选好角度再发射子弹，不然会反射到自身。此款游戏包含动态游戏菜单、人机大战，双人大战、自动寻路、寻找最短路径和子弹反弹等功能。通过本章学习，你将学到：

- Win32窗体关键属性、方法和事件的应用
- 鼠标事件的处理方法
- 同时处理多个键盘按键的方法
- `GDIPlus`(GDI+)绘图方法
- 最短路径算法
- 随机方法的应用技巧
- 碰撞检测算法
- 自动寻路算法

**界面预览**

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616144340840.png)



**项目功能应用技术预览**

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616145145775.png)



## 开发背景

相信大家都玩过一种非常有趣的益智游戏，叫作“坦克大战”。游戏进行时，敌方
坦克攻击，玩家控制自己的坦克保卫家园，坦克可以发射子弹互相对打。但是传统的坦
克大战游戏，坦克的移动规则限于上下左右四个方向，而不能任意方向自由移动;同时子弹也只能横纵四个方向进行攻击。为增加游戏乐趣，本章将使用Windows下的C++语言，配合Windows API开发一个坦克动荡游戏，并详细介绍开发游戏时需要了解和掌握的相关开发细节，本游戏开发细节设计如下图所示：

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616145412162.png)

## 系统功能设计

### 系统功能结构

坦克动荡游戏主要功能分为两个部分:人机大战和双人大战，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616145623989.png)



### 系统业务流程

坦克动荡游戏的业务流程如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616145900658.png)

### 创建项目

#### 开发环境要求

开发坦克动荡游戏之前，本地计算机需满足以下条件:

- 操作系统: Windows 7 (SP1)以上。
- 开发环境: Visual Studio 2015免费社区版。
- 开发语言:C++。



#### 游戏所用资源介绍

本游戏使用到大量图片资源，其作用是通过绘制图片，模拟游戏中的坦克、子弹和爆炸效果等对象。如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616150242603.png)



:::tip

在游戏运行时，会用到上图中的图片。所以最后发布程序时，图片要放在Tank.exe（游戏主程序）所在的目录。

:::

#### 创建新项目

先使用`Visual Studio 2015`创建一个项目，然后逐渐修改，使之成为心中所期望的程序。使用`Visual Studio 2015`建立项目的具体步骤如下:



- (1）打开Visual Studio 2015，选择菜单项`“文件”→“新建”→“项目”`，弹出新建窗口，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616150558711.png)

- (2）在弹出的窗口中依次选择`“Visual C++”一“MFC”→“MFC应用程序”`，在`“名称”`中输入项目名称`“Tank`，最后单击“确定”按钮，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616150738424.png)

- (3)单击`“下一步”`按钮，如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616150849284.png)

- (4）应用程序类型选择`“单个文档”`，项目类型选择`“MFC标准”`，视觉样式和颜色选择`“Win-dows本机/默认”`，MFC的使用选择`“在静态库中使用MFC”`，单击“下一步”按钮，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616151008889.png)

> 说明:本程序中使用到了MFC库，在开发机器上可以直接运行。但是在其他的机器上面，若没有相关的DLL，导致程序复制过去提示“缺少xx.dll”，导致程序无法运行。所以此处选择“在静态库中使用MFC”，可以保证程序复制到其他机器上，不会因缺少DLL而无法运行。



- (5）本程序中没有使用到数据库，所以`“数据库支持”`选择`“无”`，然后单击“下一步”按钮，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616151151916.png)

- (6）选中`“最小化框”`，该选项可以使游戏窗口右上角出现最小化按钮，并使窗口可以被最小化;选中`“系统菜单”`，该选项使游戏窗口可以被关闭;选择`“使用经典菜单”`，并取消该选项下面两项的选中状态，因为本程序不需要工具栏也不需要菜单栏（游戏中的“菜单”是通过自绘模拟出来的）。然后单击“下一步”按钮，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616151434400.png)

- (7）在高级功能中选中`“ActiveX控件”` `“公共控件清单”`和`“支持重新启动管理器”`;其他选项保持未选中状态，单击“下一步”按钮，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616151738169.png)

- (8）下图展示了项目自动生成的类，此处没有需要修改的地方，直接单击“完成”按钮，完成项目的创建。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616151844586.png)

- (9）创建好的项目及文件如下图所示。进行以上操作之后Visual Studio 2015生成的项目。这是一个具有完整窗口功能，可立刻运行的项目。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616151934941.png)

:::details `运行你的窗口程序`

运行代码的方法如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616152226689.png)



选择完成之后，单击右侧的`“本地Windows调试器”`，稍等片刻，会呈现如下图所示的窗口。至此，尚未输入一行代码，IDE(集成开发工具，这里用的是Visual Studio 2015)已经生成了一个窗口程序。接下来将在此程序的基础上进行加加减减，逐步实现坦克动荡游戏程序。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616152310890.png)



初次运行可能出现如下图所示的对话框，该对话框意味着Visual Studio 2015发现程序源码被修改，但是尚未生成修改后的新程序（.exe可执行文件）。这里按图中所示操作即可。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616152439236.png)

:::

#### 创建游戏框架

##### 创建游戏主窗口


我们未写一行代码，就实现了一个窗口程序，而且还自带菜单等功能。但是有些内容对本章要完成的游戏程序是没有用处的，如菜单功能。本节改造这个程序，使之成为一个游戏程序的框架，便于后续增加其他功能。

- (1)项目目前的状态。生成的项目文件如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616152757808.png)

- (2）删除多余文件。Visual Studio2015自动生成的文件中有些是不需要的，将其删除。删除方法如下:

  - 在`“ChildView.h”`上方单击鼠标右键，在弹出的菜单中单击`“移除”`选项，在弹出的窗口中单击`“删除”`按钮，如下图所示。
  - ​    使用同样的方法，删除“ChildView.cpp”文件。

  ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616152934727.png)

- (3）修改文件。删除不需要的文件之后，原来生成的窗口相关代码已经删除。此时需要开始编写代码，产生符合游戏要求的窗口。第一步:修改`CMainFrame类`的头文件代码。该文件中保存的是类的声明部分，其中规定了游戏窗口的大小为800×600像素。打开`“MainFrm.h”`文件，删除文件中原来的内容，并输入以下代码:

:::details `MainFrm.h`

```c{26-27}
#pragma once
class CMainFrame : public CFrameWnd
{
public:
    CMainFrame();
protected:
    DECLARE_DYNAMIC(CMainFrame)
 
// 特性
public:
 
// 操作
public:
 
// 重写
public:
 
// 实现
public:
    virtual ~CMainFrame();
 
// 生成的消息映射方法
protected:
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    DECLARE_MESSAGE_MAP()
    int m_iWidth{ 800 };   // 客户区的宽
    int m_iHeight{ 600 };  // 客户区的高
}; /*这里是类定义的结尾,注意:最后有一个分号，并且是英文半角分号*/
```

:::

- (4）修改该类的实现代码。在实现代码中创建一个大小为800×600像素的窗口，设置了窗口标题为“明日科技坦克大战”，移动窗口到电脑屏幕的左上角。具体方法为:打开`MainFrm.cpp`文件，删除文件中原有代码并输入以下代码:

:::details `MainFrm.cpp`

```c{24-41}
#include "stdafx.h"
#include "Tank.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
/********************************************************************************/
#define GAME_WIN_W (800)                      // 全局变量:窗口宽
#define GAME_WIN_H (600)                      // 全局变量:窗口高


// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)    // VS2015自动生成代码

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)    // VS2015自动生成代码
    ON_WM_CREATE()
END_MESSAGE_MAP()

// CMainFrame 构造/析构

CMainFrame::CMainFrame()
{
#define MY_STYLE (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | \
        WS_MINIMIZEBOX | FWS_ADDTOTITLE)
    // 创建窗口
    Create(NULL, _T("明日科技.坦克大战"), MY_STYLE, CRect(0, 0, GAME_WIN_W, GAME_WIN_H));
    // 设置客户区大小
    {
        CRect rcCli; 
        GetClientRect(rcCli);       // 获得客户区的大小

        RECT rcFrame = { 0, 0,      // 计算边框的大小，并设置
                         m_iWidth + m_iWidth - rcCli.right,
                         m_iHeight + m_iHeight - rcCli.bottom
                       };
        MoveWindow(&rcFrame, TRUE); // 调用WindowsAPI设置窗口位置和大小
    }
}

CMainFrame::~CMainFrame()           // 析构函数
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if(CFrameWnd::OnCreate(lpCreateStruct) == -1) {
        return -1;
    }

    return 0;
}
```



:::

`CMainFrame`代表游戏的主窗口，也是程序一启动时就建立的窗口。后面所有的画面都是在此窗口上面绘制的。接下来在主程序中使用此类，建立游戏窗口。



- (5）打开`Tank.cpp`文件，找到`“BOOL CTankApp:InitInstance()”` 并输入以下内容:

:::details `Tank.cpp`

```c
BOOL CTankApp:InitInstance()
{
    CWinApp::InitInstance();
    CMainFrame *pFrame = new CMainFrame;
    if (!pFrame) {
        return FALSE;
    }
    m_pMainWnd = pFrame;
    pFrame->ShowWindow(SW_SHOW); // 显示窗口
    pFrame->UpdateWindow();       // 更新窗口
    return TRUE;   
}
```

到此为止，游戏的主窗口已经改造好了，读者可以尝试运行一下。运行的结果如下图所示:一个800×600像素、没有菜单项和状态栏等内容的Windows窗口。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616154754272.png)



接下来要做的事情是在这个窗口上画出游戏画面，并让画面上的东西接受控制，或者让电脑自动控制。



注意，读者在运行时，如果出现下图所示的对话框，说明编写代码过程中有错误，此时要选择“否”并寻找错误。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616154901174.png)

:::

##### 游戏核心框架类的建立

后续的开发会增加很多代码来实现游戏的各种功能。如果都写在同一个文件中，会显得非常拥挤，所以这里设计一个`CGame`类，把游戏相关功能拆分开来。本章还将设计很多类，每个类实现不同的功能并通过`CGame`类“串联”起这些类以实现完整的游戏程序。这样的好处是结构清晰，易于扩展，方便理解。在Visual Studio 2015的项目中建立新类的方法如图所示：

- 打开添加类对话框

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616155105139.png)

- 选择C++类

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616155221160.png)

- 输入类名

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616155306934.png)

​                                                                                                          

单击`“完成”`之后，项目中生成`Game.h`和`Game.cpp`两个文件。



##### 增加鼠标响应

本游戏在选择游戏模式时需要用到鼠标:在单击菜单时游戏画面转移到相应的游戏场景;鼠标滑过菜单项时，菜单项也会产生变化。因此程序本身必须有对鼠标消息进行响应的功能。增加鼠标响应的方法如下:

先增加相关声明函数。打开`Game.h`文件，在`“~CGame();”`下方增加如下代码:



:::details `Game.h`

```c
    void SetHandle(HWND hWnd);		// 设置输出窗口的句柄

    bool EnterFrame(DWORD dwTime); 	// 进入游戏帧

    void OnMouseMove(UINT nFlags, CPoint point); // 处理鼠标移动事件

    void OnLButtonUp(UINT nFlags, CPoint point); // 处理左键抬起事件

private:
    HWND m_hWnd; // 窗口
```

:::

然后增加实现函数。实现函数保存了游戏主窗口的句柄;为窗口的定时器消息提供了可供调用的“进入游戏帧”函数;定义了处理鼠标移动消息和处理鼠标左键抬起消息的函数。打开`Game.cpp `文件，在文件最下方增加代码:

:::details `Game.cpp`

```c
void CGame::SetHandle(HWND hWnd)  					// 设置输出窗口的句柄
{
    m_hWnd = hWnd;
}
 
bool CGame::EnterFrame(DWORD dwTime)				// 进入游戏帧
{
    return false;
}
 
void CGame::OnMouseMove(UINT nFlags, CPoint point) // 处理鼠标移动事件
{
}
 
void CGame::OnLButtonUp(UINT nFlags, CPoint point) // 处理左键抬起事件
{
}
```

:::

##### 在游戏窗口中使用游戏核心功能

我们前面增加了CGame类，本节将使用该类，使程序框架更加清晰，并且可扩展，以便日后增加新功能。CGame类在这里代表“整个游戏”对象，以后所有游戏中的其他功能模块皆由本类进行管理。具体步骤如下:

- (1）打开MainFrm.h文件，在文件最上方的“#pragma once”行下增加代码:

```c
#include "Game.h"
```

:::tip 

这一句的意思是引用头文件，因为要在`MainFrm.h`和`MainFrm.cpp`文件中使用`CGamc`类，所以要引入`CGame`类的声明文件。后面的编码过程中，会多次引用不同的头文件。

:::

- (2）下面代码中的`m_game`代表新建立的类CGame的一个实例，接下来游戏的所有操作都会用到`m _game`实例。定时器ID和OnTimer()方法则是提供给定时器使用的。有些程序可能会使用多个定时器，每个定时器都是由OnTimer()函数进行处理的，为了区分不同的定时器，需要给定时器设定一个ID，ID是一个整型值，各个定时器的ID不能重复，否则无法区别定时器。不规范的写法可能直接用1、2、3这样的数字作为ID，这样的代码无法让人们直观地看清楚数字代表的意义，因此使用C+中的枚举来代替ID值。这段代码中的ID是`ETimerIdGameLoop`。

:::details `MainFrm.h`

在`“int m_iHcight {600};”`这一行下方增加以下代码:

```c
   ...
   enum ETimerId { ETimerIdGameLoop = 1 }; // 定时器 ID
    CGame m_game; 							// 游戏对象
public:
    afx_msg void OnTimer(UINT_PTR nIDEvent);
```

:::



- ( 3 )Windows系统提供了许多消息，该如何指定要响应哪个消息呢?如:为使窗口可以响应定时器消息，该怎么做呢?具体做法如下:继续在`MainFrm.cpp`文件中找到`“ON_WM_CREATE()”`这一行，在下方增加代码:

:::details `MainFrm.cpp`

```c
ON_WM_TIMER()
```

:::



- (4）ID准备好了，现在需要指示程序启动定时器。在`OnCreate()`方法中找到“return 0;”，在此行上面增加代码:

:::details `MainFrm.cpp`

```c
SetTimer(ETimerIdGameLoop, 0, NULL);			// 启动定时器 每次都会进入游戏帧
m_game.SetHandle(GetSafeHwnd());				// 设置游戏主窗口句柄
```

:::



:::tip 

定时器消息是一种系统消息，当想让窗口“每隔一段时间做一件事”的时候，就可以使用该消息，启动定时器的方法是调用`SetTimer`函数。

:::



- (5）上面的代码启动了定时器，还需要增加一个具体的“做事”的函数，来响应定时器消息，当消息到来时，该函数被自动调用，在此函数中判断“上次调用此函数时”距离“本次调用”的时间间隔，如果该时间间隔大于或等于20毫秒，则进入游戏帧处理，否则不处理。之所以这样处理，是为了防止游戏的速度过快。在此文件的最下方增加如下代码:

:::details `MainFrm.cpp`

```c
void CMainFrame::OnTimer(UINT_PTR nIDEvent)
{
    switch(nIDEvent) {
        case ETimerIdGameLoop: {							// 游戏循环ID
            static DWORD dwLastUpdate = GetTickCount();  // 记录本次时刻
            if(GetTickCount() - dwLastUpdate >= 20) {    // 判断时间隔
                m_game.EnterFrame(GetTickCount());        // 进入游戏帧处理
                dwLastUpdate = GetTickCount();            // 记录时间间隔
            }
            	// 否则什么都不做
        }
        default:
            break;
    }
 
    CFrameWnd::OnTimer(nIDEvent);
}
```

:::



### 绘图库GDIPlus的使用

游戏运行过程中需要大量的绘图和文字输出工作，本程序中使用`GDIPlus库`来实现。C++语言在调用其他库提供的函数时，需要`包含头文件`、指定`链接库（lib）`文件。这一步工作放在`“stdafx.h”`头文件中，同时`GDIPlus`库使用时还需要初始化。在程序启动时，立即进行初始化，在整个程序结束之前，都可以使用该库的功能。

#### 绘图库的引入

`“stdafx.h”`文件会被本工程中所有`.cpp`文件包含，因此在此文件中包含的头文件相当于被引了所有文件，由于`GDIPlus`库需要在多处使用，因此把引入工作放在`“stdafx.h”`文件中。具体做法如下:
:::details `stdafx.h`

打开文件`stdafx.h`在文件最下方增加代码:

```c
#include <gdiplus.h>
#pragma comment(lib, "Gdiplus.lib")
using namespace Gdiplus; // 使用Gdiplus命名空间
```

这里引入了GDIPlus库的头文件，并链接了GDIPlus库。由于后面各个文件中都要使用GDIPlus库，所以在文件“stdafx.h”中引入头文件。本工程中大部分文件都会包含“stdafx.h”文件。在此文件中引入的库，相当于已经包含在项目中的所有文件中，在任何地方都可以使用。

:::

#### 绘图库的初始化

`GDIPlus`库在使用之前需要进行初始化，这一操作是在“整个程序”初始化时进行的。在本工程中，`“CTank”类`即代表“整个程序”，该类中的`InitInstance(`)函数，会在程序启动之后，窗口显示之前运行，把对`GDIPlus`库的初始化动作放在这里最合适。具体步骤如下:

- (1）打开`Tank.h`文件，在`“DECLARE_MESSAGE_MAP()”`行下方增加初始化所需的声明变量:

:::details `Tank.h`

```c
private:
    // 引入 GDIPlus 所需要的变量
    ULONG_PTR m_tokenGdiplus;
    Gdiplus::GdiplusStartupInput input;
    Gdiplus::GdiplusStartupOutput output;
```

:::

- (2）打开`Tank.cpp`文件，在`“CWinApp:InitInstance();”`行下方增加代码:

:::details `Tank.cpp`

```c
//GDI+初始化
Status s = GdiplusStartup(&m_tokenGdiplus， &input，&output);
```

:::

此时可尝试运行程序，发现程序的窗口依旧有没什么变化，这是因为前面一直在做准备工作。如果程序可以运行起来，说明前面的工作做得还不错;如果没有运行起来，要返回去寻找并修正错误接下来使用`GDIPus`库的文字输出功能，输出游戏的FPS，即游戏帧数。

#### 在屏幕上“画”游戏帧数

游戏帧数可以实时显示当前游戏的运行速度，本节将在屏幕右上角绘出游戏帧数。本程序中CGamc类负责协调游戏中各部分处理代码的运行，所以接下来的时间，需要频繁修改这个类以实现各种功能。下面尝试使用GDIPlus库绘制游戏帧数。

- (1）打开Game.h文件，在`“HWND m_hWnd;”`一行的下方增加函数和变量的声明:

:::details `Game.h`

```c
//游戏绘图处理
//负责 绘画 游戏中的对象
void GameRunDraw();
 
// 输出fps
void DrawFps(Graphics &gh);
 
// 记录 游戏每秒多少帧
int m_fps{ 0 };
```

:::

- (2）打开`Game.cpp`文件，找到`“bool CGame::EnterFrame(DWORD dwTime)”`方法，在`“return false;”`上方插入函数调用代码:

:::details `Game.cpp`

```c{3}
bool CGame::EnterFrame(DWORD dwTime)
{
 GameRunDraw();
 return false;
}
```

目的是在每次进入游戏帧时，都调用一次`GameRunDraw()`方法，在`GameRunDraw()`方法内，调用具体的输出图像和文字等功能。

:::



- (3）在此文件的最下方增加`GamcRunDraw`函数的实现代码。在`GameRunDraw()`函数的实现代码中，先在内存中创建一幅图片，再调用`DrawFps()`函数，把游戏帧数画到图片上，最后把该内存中的图片一次性复制到游戏窗口中，具体实现代码如下:

:::details `Game.cpp`

```c
// 游戏绘图
void CGame::GameRunDraw()
{
    HDC hdc = ::GetDC(m_hWnd);
    CRect rc; 									// 客户区的大小
    GetClientRect(m_hWnd, &rc);
 
    CDC *dc = CClientDC::FromHandle(hdc);
 
    CDC m_dcMemory; 								// 双缓冲绘图用
    CBitmap bmp;
    bmp.CreateCompatibleBitmap(dc, rc.Width(), rc.Height());
    m_dcMemory.CreateCompatibleDC(dc);
    CBitmap *pOldBitmap = m_dcMemory.SelectObject(&bmp);
 
    Graphics gh(m_dcMemory.GetSafeHdc());			// 构造对象
    gh.Clear(Color::White); 						// 清除背景
    gh.ResetClip();
 
    DrawFps(gh); 									// 画入内存

    ::BitBlt(hdc, 0, 0, rc.Width(), rc.Height(),	// 拷贝到屏幕
             m_dcMemory.GetSafeHdc(), 0, 0, SRCCOPY);
    dc->DeleteDC();								// 释放
    return;
}
 
// 画 fps
void CGame::DrawFps(Graphics &gh)
{
    static int fps = 0;							// 定义静态变量，每次进入函数时保存上次的值
    m_fps++;                                           // 记录己经画了多少帧
    static DWORD dwLast = GetTickCount();           // 记录上次输出fps的时间
    if(GetTickCount() - dwLast >= 1000) {           // 判数时间是否超过 1秒，如果超过，输出 fps
        fps = m_fps;
        m_fps = 0;                                    // 清零，方便对帧进行重新记数
        dwLast = GetTickCount();                     // 记录本次输出的时间
    }
 
    // 输出fps
    {
        CString s; 
        s.Format(_T("FPS:%d"), fps);                // 将fsp 格式化到 字符串
        SolidBrush brush(Color(0x00, 0x00, 0xFF)); // 创建红色的画刷
        Gdiplus::Font font(_T("宋体"), 10.0);       // 创建输出的字体
        CRect rc; 
        ::GetClientRect(m_hWnd, &rc);             // 获得输出窗口的大小，用来定位文字的输出位置
        PointF origin(static_cast<float>(rc.right - 50),          // 在右上角显示
                      static_cast<float>(rc.top + 2));
        gh.DrawString(s.GetString(), -1, &font, origin, &brush); // 正式出文字
    }
}
```

上面的代码获取了游戏帧数，设定了文字的字体和颜色，使用GDIPlus库的文字输出功能，将FPS输出到窗口的右上角。

运行程序，可以看到屏幕右上角显示的`“FPS:数字”`，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616164038257.png)

:::



#### 引入图片资源





## 游戏功能的详细设计及使用举例
