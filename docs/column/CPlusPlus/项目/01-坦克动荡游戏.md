坦克动荡游戏

坦克动荡游戏是一款简约有趣的坦克对战游戏，游戏场景设定在一个随机生成的小迷宫中，游戏双方控制已方坦克攻击对方，直至一方坦克爆炸为止。在游戏中坦克可以连续发射多颗子弹，需要小心的是子弹打到墙上会反弹，反弹的子弹可能打爆自己的坦克，所以千万要选好角度再发射子弹，不然会反射到自身。此款游戏包含动态游戏菜单、人机大战，双人大战、自动寻路、寻找最短路径和子弹反弹等功能。通过本章学习，你将学到：

- Win32窗体关键属性、方法和事件的应用
- 鼠标事件的处理方法
- 同时处理多个键盘按键的方法
- `GDIPlus`(GDI+)绘图方法
- 最短路径算法
- 随机方法的应用技巧
- 碰撞检测算法
- 自动寻路算法

**界面预览**

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616144340840.png)



**项目功能应用技术预览**

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616145145775.png)



## 开发背景

相信大家都玩过一种非常有趣的益智游戏，叫作“坦克大战”。游戏进行时，敌方
坦克攻击，玩家控制自己的坦克保卫家园，坦克可以发射子弹互相对打。但是传统的坦
克大战游戏，坦克的移动规则限于上下左右四个方向，而不能任意方向自由移动;同时子弹也只能横纵四个方向进行攻击。为增加游戏乐趣，本章将使用Windows下的C++语言，配合Windows API开发一个坦克动荡游戏，并详细介绍开发游戏时需要了解和掌握的相关开发细节，本游戏开发细节设计如下图所示：

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616145412162.png)

## 系统功能设计

### 系统功能结构

坦克动荡游戏主要功能分为两个部分:人机大战和双人大战，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616145623989.png)



### 系统业务流程

坦克动荡游戏的业务流程如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616145900658.png)

### 创建项目

#### 开发环境要求

开发坦克动荡游戏之前，本地计算机需满足以下条件:

- 操作系统: Windows 7 (SP1)以上。
- 开发环境: Visual Studio 2015免费社区版。
- 开发语言:C++。



#### 游戏所用资源介绍

本游戏使用到大量图片资源，其作用是通过绘制图片，模拟游戏中的坦克、子弹和爆炸效果等对象。如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616150242603.png)



:::tip

在游戏运行时，会用到上图中的图片。所以最后发布程序时，图片要放在Tank.exe（游戏主程序）所在的目录。

:::

#### 创建新项目

先使用`Visual Studio 2015`创建一个项目，然后逐渐修改，使之成为心中所期望的程序。使用`Visual Studio 2015`建立项目的具体步骤如下:



- (1）打开Visual Studio 2015，选择菜单项`“文件”→“新建”→“项目”`，弹出新建窗口，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616150558711.png)

- (2）在弹出的窗口中依次选择`“Visual C++”一“MFC”→“MFC应用程序”`，在`“名称”`中输入项目名称`“Tank`，最后单击“确定”按钮，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616150738424.png)

- (3)单击`“下一步”`按钮，如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616150849284.png)

- (4）应用程序类型选择`“单个文档”`，项目类型选择`“MFC标准”`，视觉样式和颜色选择`“Win-dows本机/默认”`，MFC的使用选择`“在静态库中使用MFC”`，单击“下一步”按钮，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616151008889.png)

> 说明:本程序中使用到了MFC库，在开发机器上可以直接运行。但是在其他的机器上面，若没有相关的DLL，导致程序复制过去提示“缺少xx.dll”，导致程序无法运行。所以此处选择“在静态库中使用MFC”，可以保证程序复制到其他机器上，不会因缺少DLL而无法运行。



- (5）本程序中没有使用到数据库，所以`“数据库支持”`选择`“无”`，然后单击“下一步”按钮，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616151151916.png)

- (6）选中`“最小化框”`，该选项可以使游戏窗口右上角出现最小化按钮，并使窗口可以被最小化;选中`“系统菜单”`，该选项使游戏窗口可以被关闭;选择`“使用经典菜单”`，并取消该选项下面两项的选中状态，因为本程序不需要工具栏也不需要菜单栏（游戏中的“菜单”是通过自绘模拟出来的）。然后单击“下一步”按钮，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616151434400.png)

- (7）在高级功能中选中`“ActiveX控件”` `“公共控件清单”`和`“支持重新启动管理器”`;其他选项保持未选中状态，单击“下一步”按钮，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616151738169.png)

- (8）下图展示了项目自动生成的类，此处没有需要修改的地方，直接单击“完成”按钮，完成项目的创建。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616151844586.png)

- (9）创建好的项目及文件如下图所示。进行以上操作之后Visual Studio 2015生成的项目。这是一个具有完整窗口功能，可立刻运行的项目。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616151934941.png)

:::details `运行你的窗口程序`

运行代码的方法如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616152226689.png)



选择完成之后，单击右侧的`“本地Windows调试器”`，稍等片刻，会呈现如下图所示的窗口。至此，尚未输入一行代码，IDE(集成开发工具，这里用的是Visual Studio 2015)已经生成了一个窗口程序。接下来将在此程序的基础上进行加加减减，逐步实现坦克动荡游戏程序。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616152310890.png)



初次运行可能出现如下图所示的对话框，该对话框意味着Visual Studio 2015发现程序源码被修改，但是尚未生成修改后的新程序（.exe可执行文件）。这里按图中所示操作即可。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616152439236.png)

:::

#### 创建游戏框架

##### 创建游戏主窗口


我们未写一行代码，就实现了一个窗口程序，而且还自带菜单等功能。但是有些内容对本章要完成的游戏程序是没有用处的，如菜单功能。本节改造这个程序，使之成为一个游戏程序的框架，便于后续增加其他功能。

- (1)项目目前的状态。生成的项目文件如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616152757808.png)

- (2）删除多余文件。Visual Studio2015自动生成的文件中有些是不需要的，将其删除。删除方法如下:

  - 在`“ChildView.h”`上方单击鼠标右键，在弹出的菜单中单击`“移除”`选项，在弹出的窗口中单击`“删除”`按钮，如下图所示。
  - ​    使用同样的方法，删除“ChildView.cpp”文件。

  ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616152934727.png)

- (3）修改文件。删除不需要的文件之后，原来生成的窗口相关代码已经删除。此时需要开始编写代码，产生符合游戏要求的窗口。第一步:修改`CMainFrame类`的头文件代码。该文件中保存的是类的声明部分，其中规定了游戏窗口的大小为800×600像素。打开`“MainFrm.h”`文件，删除文件中原来的内容，并输入以下代码:

:::details `MainFrm.h`

```c{26-27}
#pragma once
class CMainFrame : public CFrameWnd
{
public:
    CMainFrame();
protected:
    DECLARE_DYNAMIC(CMainFrame)
 
// 特性
public:
 
// 操作
public:
 
// 重写
public:
 
// 实现
public:
    virtual ~CMainFrame();
 
// 生成的消息映射方法
protected:
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    DECLARE_MESSAGE_MAP()
    int m_iWidth{ 800 };   // 客户区的宽
    int m_iHeight{ 600 };  // 客户区的高
}; /*这里是类定义的结尾,注意:最后有一个分号，并且是英文半角分号*/
```

:::

- (4）修改该类的实现代码。在实现代码中创建一个大小为800×600像素的窗口，设置了窗口标题为“明日科技坦克大战”，移动窗口到电脑屏幕的左上角。具体方法为:打开`MainFrm.cpp`文件，删除文件中原有代码并输入以下代码:

:::details `MainFrm.cpp`

```c{24-41}
#include "stdafx.h"
#include "Tank.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
/********************************************************************************/
#define GAME_WIN_W (800)                      // 全局变量:窗口宽
#define GAME_WIN_H (600)                      // 全局变量:窗口高


// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)    // VS2015自动生成代码

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)    // VS2015自动生成代码
    ON_WM_CREATE()
END_MESSAGE_MAP()

// CMainFrame 构造/析构

CMainFrame::CMainFrame()
{
#define MY_STYLE (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | \
        WS_MINIMIZEBOX | FWS_ADDTOTITLE)
    // 创建窗口
    Create(NULL, _T("明日科技.坦克大战"), MY_STYLE, CRect(0, 0, GAME_WIN_W, GAME_WIN_H));
    // 设置客户区大小
    {
        CRect rcCli; 
        GetClientRect(rcCli);       // 获得客户区的大小

        RECT rcFrame = { 0, 0,      // 计算边框的大小，并设置
                         m_iWidth + m_iWidth - rcCli.right,
                         m_iHeight + m_iHeight - rcCli.bottom
                       };
        MoveWindow(&rcFrame, TRUE); // 调用WindowsAPI设置窗口位置和大小
    }
}

CMainFrame::~CMainFrame()           // 析构函数
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if(CFrameWnd::OnCreate(lpCreateStruct) == -1) {
        return -1;
    }

    return 0;
}
```



:::

`CMainFrame`代表游戏的主窗口，也是程序一启动时就建立的窗口。后面所有的画面都是在此窗口上面绘制的。接下来在主程序中使用此类，建立游戏窗口。



- (5）打开`Tank.cpp`文件，找到`“BOOL CTankApp:InitInstance()”` 并输入以下内容:

:::details `Tank.cpp`

```c
BOOL CTankApp:InitInstance()
{
    CWinApp::InitInstance();
    CMainFrame *pFrame = new CMainFrame;
    if (!pFrame) {
        return FALSE;
    }
    m_pMainWnd = pFrame;
    pFrame->ShowWindow(SW_SHOW); // 显示窗口
    pFrame->UpdateWindow();       // 更新窗口
    return TRUE;   
}
```

到此为止，游戏的主窗口已经改造好了，读者可以尝试运行一下。运行的结果如下图所示:一个800×600像素、没有菜单项和状态栏等内容的Windows窗口。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616154754272.png)



接下来要做的事情是在这个窗口上画出游戏画面，并让画面上的东西接受控制，或者让电脑自动控制。



注意，读者在运行时，如果出现下图所示的对话框，说明编写代码过程中有错误，此时要选择“否”并寻找错误。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616154901174.png)

:::

##### 游戏核心框架类的建立

后续的开发会增加很多代码来实现游戏的各种功能。如果都写在同一个文件中，会显得非常拥挤，所以这里设计一个`CGame`类，把游戏相关功能拆分开来。本章还将设计很多类，每个类实现不同的功能并通过`CGame`类“串联”起这些类以实现完整的游戏程序。这样的好处是结构清晰，易于扩展，方便理解。在Visual Studio 2015的项目中建立新类的方法如图所示：

- 打开添加类对话框

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616155105139.png)

- 选择C++类

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616155221160.png)

- 输入类名

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616155306934.png)

​                                                                                                          

单击`“完成”`之后，项目中生成`Game.h`和`Game.cpp`两个文件。



##### 增加鼠标响应

本游戏在选择游戏模式时需要用到鼠标:在单击菜单时游戏画面转移到相应的游戏场景;鼠标滑过菜单项时，菜单项也会产生变化。因此程序本身必须有对鼠标消息进行响应的功能。增加鼠标响应的方法如下:

先增加相关声明函数。打开`Game.h`文件，在`“~CGame();”`下方增加如下代码:



:::details `Game.h`

```c
    void SetHandle(HWND hWnd);		// 设置输出窗口的句柄

    bool EnterFrame(DWORD dwTime); 	// 进入游戏帧

    void OnMouseMove(UINT nFlags, CPoint point); // 处理鼠标移动事件

    void OnLButtonUp(UINT nFlags, CPoint point); // 处理左键抬起事件

private:
    HWND m_hWnd; // 窗口
```

:::

然后增加实现函数。实现函数保存了游戏主窗口的句柄;为窗口的定时器消息提供了可供调用的“进入游戏帧”函数;定义了处理鼠标移动消息和处理鼠标左键抬起消息的函数。打开`Game.cpp `文件，在文件最下方增加代码:

:::details `Game.cpp`

```c
void CGame::SetHandle(HWND hWnd)  					// 设置输出窗口的句柄
{
    m_hWnd = hWnd;
}
 
bool CGame::EnterFrame(DWORD dwTime)				// 进入游戏帧
{
    return false;
}
 
void CGame::OnMouseMove(UINT nFlags, CPoint point) // 处理鼠标移动事件
{
}
 
void CGame::OnLButtonUp(UINT nFlags, CPoint point) // 处理左键抬起事件
{
}
```

:::

##### 在游戏窗口中使用游戏核心功能

我们前面增加了CGame类，本节将使用该类，使程序框架更加清晰，并且可扩展，以便日后增加新功能。CGame类在这里代表“整个游戏”对象，以后所有游戏中的其他功能模块皆由本类进行管理。具体步骤如下:

- (1）打开MainFrm.h文件，在文件最上方的“#pragma once”行下增加代码:

```c
#include "Game.h"
```

:::tip 

这一句的意思是引用头文件，因为要在`MainFrm.h`和`MainFrm.cpp`文件中使用`CGamc`类，所以要引入`CGame`类的声明文件。后面的编码过程中，会多次引用不同的头文件。

:::

- (2）下面代码中的`m_game`代表新建立的类CGame的一个实例，接下来游戏的所有操作都会用到`m _game`实例。定时器ID和OnTimer()方法则是提供给定时器使用的。有些程序可能会使用多个定时器，每个定时器都是由OnTimer()函数进行处理的，为了区分不同的定时器，需要给定时器设定一个ID，ID是一个整型值，各个定时器的ID不能重复，否则无法区别定时器。不规范的写法可能直接用1、2、3这样的数字作为ID，这样的代码无法让人们直观地看清楚数字代表的意义，因此使用C+中的枚举来代替ID值。这段代码中的ID是`ETimerIdGameLoop`。

:::details `MainFrm.h`

在`“int m_iHcight {600};”`这一行下方增加以下代码:

```c
   ...
   enum ETimerId { ETimerIdGameLoop = 1 }; // 定时器 ID
    CGame m_game; 							// 游戏对象
public:
    afx_msg void OnTimer(UINT_PTR nIDEvent);
```

:::



- ( 3 )Windows系统提供了许多消息，该如何指定要响应哪个消息呢?如:为使窗口可以响应定时器消息，该怎么做呢?具体做法如下:继续在`MainFrm.cpp`文件中找到`“ON_WM_CREATE()”`这一行，在下方增加代码:

:::details `MainFrm.cpp`

```c
ON_WM_TIMER()
```

:::



- (4）ID准备好了，现在需要指示程序启动定时器。在`OnCreate()`方法中找到“return 0;”，在此行上面增加代码:

:::details `MainFrm.cpp`

```c
SetTimer(ETimerIdGameLoop, 0, NULL);			// 启动定时器 每次都会进入游戏帧
m_game.SetHandle(GetSafeHwnd());				// 设置游戏主窗口句柄
```

:::



:::tip 

定时器消息是一种系统消息，当想让窗口“每隔一段时间做一件事”的时候，就可以使用该消息，启动定时器的方法是调用`SetTimer`函数。

:::



- (5）上面的代码启动了定时器，还需要增加一个具体的“做事”的函数，来响应定时器消息，当消息到来时，该函数被自动调用，在此函数中判断“上次调用此函数时”距离“本次调用”的时间间隔，如果该时间间隔大于或等于20毫秒，则进入游戏帧处理，否则不处理。之所以这样处理，是为了防止游戏的速度过快。在此文件的最下方增加如下代码:

:::details `MainFrm.cpp`

```c
void CMainFrame::OnTimer(UINT_PTR nIDEvent)
{
    switch(nIDEvent) {
        case ETimerIdGameLoop: {							// 游戏循环ID
            static DWORD dwLastUpdate = GetTickCount();  // 记录本次时刻
            if(GetTickCount() - dwLastUpdate >= 20) {    // 判断时间隔
                m_game.EnterFrame(GetTickCount());        // 进入游戏帧处理
                dwLastUpdate = GetTickCount();            // 记录时间间隔
            }
            	// 否则什么都不做
        }
        default:
            break;
    }
 
    CFrameWnd::OnTimer(nIDEvent);
}
```

:::



### 绘图库GDIPlus的使用

游戏运行过程中需要大量的绘图和文字输出工作，本程序中使用`GDIPlus库`来实现。C++语言在调用其他库提供的函数时，需要`包含头文件`、指定`链接库（lib）`文件。这一步工作放在`“stdafx.h”`头文件中，同时`GDIPlus`库使用时还需要初始化。在程序启动时，立即进行初始化，在整个程序结束之前，都可以使用该库的功能。

#### 绘图库的引入

`“stdafx.h”`文件会被本工程中所有`.cpp`文件包含，因此在此文件中包含的头文件相当于被引了所有文件，由于`GDIPlus`库需要在多处使用，因此把引入工作放在`“stdafx.h”`文件中。具体做法如下:
:::details `stdafx.h`

打开文件`stdafx.h`在文件最下方增加代码:

```c
#include <gdiplus.h>
#pragma comment(lib, "Gdiplus.lib")
using namespace Gdiplus; // 使用Gdiplus命名空间
```

这里引入了GDIPlus库的头文件，并链接了GDIPlus库。由于后面各个文件中都要使用GDIPlus库，所以在文件“stdafx.h”中引入头文件。本工程中大部分文件都会包含“stdafx.h”文件。在此文件中引入的库，相当于已经包含在项目中的所有文件中，在任何地方都可以使用。

:::

#### 绘图库的初始化

`GDIPlus`库在使用之前需要进行初始化，这一操作是在“整个程序”初始化时进行的。在本工程中，`“CTank”类`即代表“整个程序”，该类中的`InitInstance(`)函数，会在程序启动之后，窗口显示之前运行，把对`GDIPlus`库的初始化动作放在这里最合适。具体步骤如下:

- (1）打开`Tank.h`文件，在`“DECLARE_MESSAGE_MAP()”`行下方增加初始化所需的声明变量:

:::details `Tank.h`

```c
private:
    // 引入 GDIPlus 所需要的变量
    ULONG_PTR m_tokenGdiplus;
    Gdiplus::GdiplusStartupInput input;
    Gdiplus::GdiplusStartupOutput output;
```

:::

- (2）打开`Tank.cpp`文件，在`“CWinApp:InitInstance();”`行下方增加代码:

:::details `Tank.cpp`

```c
//GDI+初始化
Status s = GdiplusStartup(&m_tokenGdiplus， &input，&output);
```

:::

此时可尝试运行程序，发现程序的窗口依旧有没什么变化，这是因为前面一直在做准备工作。如果程序可以运行起来，说明前面的工作做得还不错;如果没有运行起来，要返回去寻找并修正错误接下来使用`GDIPus`库的文字输出功能，输出游戏的FPS，即游戏帧数。

#### 在屏幕上“画”游戏帧数

游戏帧数可以实时显示当前游戏的运行速度，本节将在屏幕右上角绘出游戏帧数。本程序中CGamc类负责协调游戏中各部分处理代码的运行，所以接下来的时间，需要频繁修改这个类以实现各种功能。下面尝试使用GDIPlus库绘制游戏帧数。

- (1）打开Game.h文件，在`“HWND m_hWnd;”`一行的下方增加函数和变量的声明:

:::details `Game.h`

```c
//游戏绘图处理
//负责 绘画 游戏中的对象
void GameRunDraw();
 
// 输出fps
void DrawFps(Graphics &gh);
 
// 记录 游戏每秒多少帧
int m_fps{ 0 };
```

:::

- (2）打开`Game.cpp`文件，找到`“bool CGame::EnterFrame(DWORD dwTime)”`方法，在`“return false;”`上方插入函数调用代码:

:::details `Game.cpp`

```c{3}
bool CGame::EnterFrame(DWORD dwTime)
{
 GameRunDraw();
 return false;
}
```

目的是在每次进入游戏帧时，都调用一次`GameRunDraw()`方法，在`GameRunDraw()`方法内，调用具体的输出图像和文字等功能。

:::



- (3）在此文件的最下方增加`GamcRunDraw`函数的实现代码。在`GameRunDraw()`函数的实现代码中，先在内存中创建一幅图片，再调用`DrawFps()`函数，把游戏帧数画到图片上，最后把该内存中的图片一次性复制到游戏窗口中，具体实现代码如下:

:::details `Game.cpp`

```c
// 游戏绘图
void CGame::GameRunDraw()
{
    HDC hdc = ::GetDC(m_hWnd);
    CRect rc; 									// 客户区的大小
    GetClientRect(m_hWnd, &rc);
 
    CDC *dc = CClientDC::FromHandle(hdc);
 
    CDC m_dcMemory; 								// 双缓冲绘图用
    CBitmap bmp;
    bmp.CreateCompatibleBitmap(dc, rc.Width(), rc.Height());
    m_dcMemory.CreateCompatibleDC(dc);
    CBitmap *pOldBitmap = m_dcMemory.SelectObject(&bmp);
 
    Graphics gh(m_dcMemory.GetSafeHdc());			// 构造对象
    gh.Clear(Color::White); 						// 清除背景
    gh.ResetClip();
 
    DrawFps(gh); 									// 画入内存

    ::BitBlt(hdc, 0, 0, rc.Width(), rc.Height(),	// 拷贝到屏幕
             m_dcMemory.GetSafeHdc(), 0, 0, SRCCOPY);
    dc->DeleteDC();								// 释放
    return;
}
 
// 画 fps
void CGame::DrawFps(Graphics &gh)
{
    static int fps = 0;							// 定义静态变量，每次进入函数时保存上次的值
    m_fps++;                                           // 记录己经画了多少帧
    static DWORD dwLast = GetTickCount();           // 记录上次输出fps的时间
    if(GetTickCount() - dwLast >= 1000) {           // 判数时间是否超过 1秒，如果超过，输出 fps
        fps = m_fps;
        m_fps = 0;                                    // 清零，方便对帧进行重新记数
        dwLast = GetTickCount();                     // 记录本次输出的时间
    }
 
    // 输出fps
    {
        CString s; 
        s.Format(_T("FPS:%d"), fps);                // 将fsp 格式化到 字符串
        SolidBrush brush(Color(0x00, 0x00, 0xFF)); // 创建红色的画刷
        Gdiplus::Font font(_T("宋体"), 10.0);       // 创建输出的字体
        CRect rc; 
        ::GetClientRect(m_hWnd, &rc);             // 获得输出窗口的大小，用来定位文字的输出位置
        PointF origin(static_cast<float>(rc.right - 50),          // 在右上角显示
                      static_cast<float>(rc.top + 2));
        gh.DrawString(s.GetString(), -1, &font, origin, &brush); // 正式出文字
    }
}
```

上面的代码获取了游戏帧数，设定了文字的字体和颜色，使用GDIPlus库的文字输出功能，将FPS输出到窗口的右上角。

运行程序，可以看到屏幕右上角显示的`“FPS:数字”`，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616164038257.png)

:::



#### 引入图片资源

游戏中需要输出图片到游戏窗口中，因此需要引入图片资源到项目当中。
实际开发时，读者需要自己处理图片。由于图片处理增加目标目录并不是本书内容，为了节省时间，读者可以直接把本书提供的图片复制到项目目录下备用，注意存放的目录位置(放在`Tank.vcxprog`同级目录下)），否则程序运行时找不到图片，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616210737210.png)

- 打开项目文件夹

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616210856449.png)



:::tip

读者自己建立的项目，可能会有两个目录，类似`“...Tank\Tank”`，此时不要把图片放到第一个Tank目录下。这里的第一个Tank目录是“解决方案目录”，一个解决方案下可以有多个“项目”，在新建项目时，同时也建立了一个解决方案。必须把资源图片放到第二层“Tank"目录即项目目录下，该目录下有一个`“Tank.vcxproj”`文件，这个目录才是正确的目录。

:::



#### 画出游戏菜单背景

为达到美观的效果，游戏中需要画出的对象大多会使用到多张图片、如背景菜单是一个图片，菜单项的移动即是变换这张图片的输出位置，菜单则变换成其他的图片。

下面进行一个简单的尝试:输出该游戏的菜单背景图片，即项目目录的“menu_background.png”文件。



先载入这张图片，保存为一个Image类型的指针。之后调用GDIPlus库的`DrawImage()`函数进行图片输出。打开`Game.cpp`文件，先找到`“void CGame::GameRunDraw()”`方法，然后在方法中找到`“DrawFps(gh);”`，在此行下方插入如下代码:



:::details `Game.cpp`

```c{6-15}

void CGame::GameRunDraw()
{
     ...
     DrawFps(gh);
    // 画出一幅图片
    {
        // 获得 游戏窗口大小
        CRect rc;
        GetClientRect(m_hWnd, rc);
        // 载入要绘制的图片
        Gdiplus::Image * img = Image::FromFile(_T("menu_background.png"));
        //画出图片
        gh.DrawImage(img, rc.left, rc.top, rc.Width(), rc.Height());
    }     
}
```

运行项目，发现游戏窗口中呈现了`“menu background.png”`这张图片,如图所示：

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616211605563.png)

:::

## 游戏功能的详细设计及使用举例

为了使后面的开发更加顺利，本节做一些程序结构上的设计，主要包括游戏菜单、游戏地图、游戏中的机器人（电脑控制的坦克)、玩家一、玩家二以及寻路算法和碰撞检测算法的设计和实现。在本节中设计好这些功能，后面的代码只需要把它们组合起来即可实现完整的游戏了。



:::tip

前面章节中单向屏幕上绘制了FPS和一-幅背景图片，这-一部分是为了演示输出文字和图片以便让读者快速看到成果。这部分破坏了最终程序的整体结构，因此把这一部分代码删掉。接下来的开发，以删掉之后的代码为基础。代码见`“src/006/Tank_删减代码之后”`，读者可以把这个目录复制一份到本机硬盘上，并打开里面的`Tank.sln`文件继续进行下面的部分。

:::





### 游戏对象概述

在上面章节中，程序只输出了一幅背景图片到游戏窗口中，功能比较简单。在真实的游戏开发中，需要输出大量图片和文字，图片和文字又处于不停的变化之中，功能较为复杂。这些复杂功能在程序中表现为多种或多个对象。每种对象都可能拥有不同状态和行为，如果在一个方法中绘制全部对象，则程序流程过于复杂，难以理解。正确的方法是建立各种不同的对象类，让每种对象为自己负责。每种需要绘制的对象自己都有绘制方法，调用绘制方法时，让对象自己绘制自己，调用方只需在合适的时机调用即可，至于如何绘制，调用方并不需要关心。同样，每种对象的其他行为，也由对象自己实现，状态由对象自己记录，这样就将大量的工作分解到了不同的模块中。下面就来设计游戏中的各种对象。

### 游戏中可移动对象的设计

`CGameEntry`是所有其他可绘制对象的父类，它是一个抽象类。其他类继承了此类之后，必须实现自己的Draw()方法，用于绘制自身。



`CGameEntryMoveable`是`CGameEntry`子类，扩展了父类的功能，除了可以绘制自己以外，还提供了移动、旋转等相关方法。



下面开始设计`CGameEntry`类。在项目中新增加一个文件，名为`GameEntry.h`，增加方法如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616212245165.png)



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616212310290.png)



打开`CGameEntry.h`文件，代码主要是对`CGameEntry`类的声明，包括构造函数、析构函数和一个纯虚函数Draw)。`CGameEntry`类不能直接使用，它的作用是给继承它的子类规定接口，即规定子类应该做什么。如这里通过纯虚函数Draw()规定子类必须实现该函数，用以绘制子类自身。通过这种方法，可以让不同的子类各自负责自己的绘制工作，具体代码如下:

:::details `CGameEntry.h`

```c
#pragma once
#include <gdiplus.h>
#include <math.h>
#include <cmath>
 
class CGameEntry
{
public:
    CGameEntry()              // 构造函数：产生新对象时调用
    {
    }
 
    virtual ~CGameEntry()    // 构造函数：销毁对象时调用
    {
    }
public:
    virtual void Draw(Gdiplus::Graphics &gh) const = 0; // 用于绘制自己的纯虚函数
}
```

:::

上面代码声明了一个类`“CGameEntry”`，此类代表游戏中所有的对象，包括可移动对象和不可移动对象。



接着实现代表可移动对象的类。该对象中增加对象速度相关方法、位置相关方法和角度方向相关方法等。通过这些方法，可以很方便地控制对象的移动、旋转等，但该类依然不能直接使用，因为`Draw()`方法没有实现，还是纯虚方法。该类的子类可以自动获取上述“可移动”的特性。在文件`“CGameEntry.h”`中接着输入以下代码:



:::details `CGameEntry.h`

```c

// 可移动的物体
class CGameEntryMoveable : public CGameEntry
{
public:
    CGameEntryMoveable()                                    // 构造函数：产生新对象时调用
    {
    }
 
    virtual ~CGameEntryMoveable()                          // 构造函数：销毁对象时调用
    {
    }
 
    // 拷贝构造方法
    CGameEntryMoveable(const CGameEntryMoveable &rhs)
    {
        if(this != &rhs) {
            this->m_bActive = rhs.m_bActive;				// 是否有效
            this->m_rect = rhs.m_rect;						// 占用的区域
            this->m_fSpeed = rhs.m_fSpeed;					// 移动速度
            this->m_direction = rhs.m_direction;			// 当前的角度
            this->m_directionTurn = rhs.m_directionTurn; 	// 每次旋转的角度
        }
    }
 
    // 重载赋值运算
    CGameEntryMoveable &operator=(const CGameEntryMoveable &rhs)
    {
        if(this != &rhs) {
            this->m_bActive = rhs.m_bActive;				// 是否有效
            this->m_rect = rhs.m_rect;						// 占用的区域
            this->m_fSpeed = rhs.m_fSpeed;					// 移动速度
            this->m_direction = rhs.m_direction; 			// 当前的角度
            this->m_directionTurn = rhs.m_directionTurn; 	// 每次旋转的角度
        }
        return *this;
    }
public:
    virtual void Draw(Gdiplus::Graphics &gh) const = 0;
 
    /********************可移动物体的 共同属性********************/
    // 右转
    virtual void RotateRight()
    {
 
        m_direction += m_directionTurn; // 当前角度增加
        if(m_direction >= 360) {         // 增加满一周之后，减去360度，使其始终保持在小角度
            m_direction -= 360;
        }
    }
 
    // 左转
    virtual void RotateLeft()
    {
        m_direction -= m_directionTurn; // 当前角度减少
        if(m_direction < 0) {            // 使其始终保持在大于0的角度
            m_direction = static_cast<float>(360 - m_directionTurn);
        }
    }
 
    // 前移动
    virtual void Forward()
    {
         // 根据当前角度，在x,y方向上分别进行增减
        m_rect.X += static_cast<Gdiplus::REAL>((m_fSpeed) * sin(GetDirectionArc()));
        m_rect.Y -= static_cast<Gdiplus::REAL>((m_fSpeed) * cos(GetDirectionArc()));
    }
 
    // 后移动
    virtual void Backward()
    {
        // 根据当前角度，在x,y方向上分别进行增减
        m_rect.X -= static_cast<Gdiplus::REAL>((m_fSpeed) * sin(GetDirectionArc()));
        m_rect.Y += static_cast<Gdiplus::REAL>((m_fSpeed) * cos(GetDirectionArc()));
    }
 
    // 获得平方向的速度分量
    virtual float GetXSpeed() const
    {
        return static_cast<Gdiplus::REAL>((m_fSpeed) * sin(GetDirectionArc()));
    }
 
    // 获得坚直方向的速度分量
    virtual float GetYSpeed() const
    {
        return -static_cast<Gdiplus::REAL>((m_fSpeed) * cos(GetDirectionArc()));
    }
 
    // 下一步(前进的)位置
    virtual RectF ForwardNextRect() const
    {
        RectF rc = m_rect;
        rc.X += static_cast<Gdiplus::REAL>((m_fSpeed) * sin(GetDirectionArc()));
        rc.Y -= static_cast<Gdiplus::REAL>((m_fSpeed) * cos(GetDirectionArc()));
        return rc;
    }
 
    // 下一步(后退的)位置
    virtual RectF BackwardNextRect() const
    {
        RectF rc = m_rect;
        rc.X -= static_cast<Gdiplus::REAL>((m_fSpeed) * sin(GetDirectionArc()));
        rc.Y += static_cast<Gdiplus::REAL>((m_fSpeed) * cos(GetDirectionArc()));
        return rc;
    }
 
    // 获取头部位置 : 图片为矩型：头部位置 就是角度为0时，
    // 距离中心点为半径（对角线/2)长度，重值于自己的 X轴的位置
    virtual PointF GetHeadPos() const
    {
        PointF ptCenter = GetCenterPoint();
        PointF ptHead = ptCenter;
        float fRadius = std::sqrt(std::pow(m_rect.Width / 2, 2) +   // 计算半径
                                     std::pow(m_rect.Height / 2, 2));
 
        ptHead.X += fRadius * sin(GetDirectionArc());                // 计算头部坐标x
        ptHead.Y -= fRadius * cos(GetDirectionArc());                // 计算头部坐标y
        return ptHead;                                                  // 返回头部坐标
    }
 
    // 获取中心点
    virtual PointF GetCenterPoint()const
    {
        PointF center = PointF(m_rect.X + m_rect.Width / 2,
                               m_rect.Y + m_rect.Height / 2);
        return center;
    }
 
    // 设置中心点
    virtual void SetCenterPoint(const PointF &ptCenter)
    {
        PointF cen = GetCenterPoint();
        cen.X = ptCenter.X - cen.X;
        cen.Y = ptCenter.Y - cen.Y;
        m_rect.Offset(cen);
    }
 
    // 属性存取器
#ifndef PI
#define PI (3.1415926f)
#endif
    // 设置角度 : 单位为 a*PI
    virtual void SetDirectionArc(float dir)
    {
        m_direction = dir * 180.0f / PI;
    };
 
    // 设置角度(单位是 度)
    virtual void SetDirection(float dir)
    {
        m_direction = dir;
    }
 
    // 获得当前的角度(单位是 a*PI)
    virtual float GetDirectionArc() const
    {
        return PI * m_direction / 180.0f;
    }
 
    // 获得当前的角度(单位是 度)
    virtual float GetDirection() const
    {
        return m_direction;
    }
 
    // 设置每次旋转的角度
    virtual void SetDirectionTurnArc(float dir)
    {
        m_directionTurn = PI * dir / 180.0f;
    };
 
    // 设置每次旋转的角度
    virtual void SetDirectionTurn(float dir)
    {
        m_directionTurn = dir;
    }
 
    // 获得当前的角度(单位是 PI)
    virtual float GetDirectionTurnArc() const
    {
        return PI * m_directionTurn / 180.0f;
    }
 
    // 获得当前的弧度(单位是度)
    virtual float GetDirectionTurn() const
    {
        return m_direction;
    }
 
    // 是否是有效的
    virtual  bool IsActive() const
    {
        return m_bActive;
    };
 
    // 是否是有效的
    virtual void SetActive(bool bActive)
    {
        m_bActive = bActive;
    }
 
    // 占用范围
    virtual void SetRect(const RectF rect)
    {
        m_rect = rect;
    }
 
    // 占用范围
    virtual RectF GetRect() const
    {
        return m_rect;
    }
 
    // 移动速度
    virtual void SetSpeed(float speed)
    {
        m_fSpeed = speed;
    }
 
    // 移动速度
    virtual float GetSpeed() const
    {
        return m_fSpeed;
    }
 
private:
    bool m_bActive{false};  		// 是否有效
    RectF m_rect{0, 0, 100, 100}; // 占用的区域
    float m_fSpeed{10}; 			// 移动速度
    float m_direction{0}; 		// 当前的角度
    float m_directionTurn{5}; 	// 每次旋转的角度
};

```

以上代码声明了CGameEntryMoveable类，该类是CGameEntry类的子类，该类代表游戏中的可移动物体。本部分代码较多，但是提供了更多的功能，后面再进行设计该类的子类时，可以用更少的代码实现其功能，因为大部分功能已在本类中实现了。

:::

### 设计游戏菜单

游戏菜单是游戏启动之后的第一个画面，游戏启动显示的画面如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616212954714.png)

当鼠标移动到菜单上面时，图片会改变，以响应菜单功能并增加游戏乐趣。



这一部分相关的类主要包括：

- `CGameMenuBackground`:显示背景图片
- `CGameMenuPanel`:选择菜单的显示与响应。



`GameMenuPanel.h`文件是`CGameMenuPanel`类的声明。其中增加了对鼠标消息的响应函数、背景图片指针和存放两个菜单子项的数组。打开`GameMenuPanel.h文`件，删除该文件中原来的内容，输入以下代码:

:::details `GameMenuPanel.h`

```c
#pragma once
#include <tuple>
#include <vector>
#include "GameEntry.h"
using namespace std;
class CGame;
class CGameMenuPanel : public CGameEntryMoveable
{
public:
    CGameMenuPanel();
    ~CGameMenuPanel();
 	// 存放一个CGame类的指针在本中
    void SetParent(CGame *g)
    {
        m_pParent = g;
    };
     // 存放一个CGame类的指针在本类示例中
    CGame *m_pParent{ nullptr };                  

    virtual void Draw(Graphics &gh) const;        // 画自己

    RectF m_rect{0, 0, 800, 600};                  // 自己的范围

    void OnMouseMove(UINT nFlags, CPoint point);  // 处理 鼠标移动事件

    void OnLButtonUp(UINT nFlags, CPoint point);  // 处理 鼠标左键抬起事件
    Image *m_imgBackground;                         // 背景图
   // 菜单项
    struct
    {                                        
        vector<tuple<Image*, RectF>> vImgInfoPtr;
        int index;
    } m_menuItems[2];
};
```

:::

下面代码是菜单类的实现代码。在构造函数中载入5张图片:背景图片、人机大战菜单项的两张图片、双人大战菜单项的两张图片。该类实现了Draw()方法，负责绘制整个菜单。为了使菜单项可以在鼠标滑过时展开，本类实现了鼠标移动消息，在该消息的处理函数中，依据当前的鼠标位置，决定菜单项该显示哪张图片。菜单的主要功能是获取用户的输入，即根据用户的点击项，进入不同的游戏场景，因此该类实现了鼠标左键抬起消息。打开GameMenuPanel.cpp文件，该文件为CGameMenuPanel类的具体实现代码。删除原内容，输入以下代码:



:::details `GameMenuPanel.cpp`

```c
#include "stdafx.h"
#include "GameMenuPanel.h"
#include "Game.h"
 // 构造函数
CGameMenuPanel::CGameMenuPanel()
{
    // 背景图
    m_imgBackground = Image::FromFile(_T("menu_background.png"));
 
    // 菜单项一 : 人机对战
    m_menuItems[0].index = 0;
    for(int i = 0; i < 2; ++i) {
        TCHAR path[MAX_PATH];
        _stprintf_s(path, _T("menu_1player_%d.png"), i);               // 格式化文件名
        auto imgPtr = Image::FromFile(path);                            // 载入图片
        RectF rc(0, 300, static_cast<float>(imgPtr->GetWidth()),
                 static_cast<float>(imgPtr->GetHeight()));
        m_menuItems[0].vImgInfoPtr.push_back(make_tuple(imgPtr, rc)); // 图片存在数组中
    }
 
    // 菜单项一 : 双人对战
    m_menuItems[1].index = 0;
    for(int i = 0; i < 2; ++i) {
        TCHAR path[MAX_PATH];
        _stprintf_s(path, _T("menu_2plyaer_%d.png"), i);              // 格式化文件名
        auto imgPtr = Image::FromFile(path);                           // 载入图片
        RectF rc(400, 300, static_cast<float>(imgPtr->GetWidth())
                 , static_cast<float>(imgPtr->GetHeight()));
        m_menuItems[1].vImgInfoPtr.push_back(make_tuple(imgPtr, rc)); // 图片存在数组中
    }
}
 
CGameMenuPanel::~CGameMenuPanel()                                        // 析构函数
{
 
}
 
// 绘制自己
void CGameMenuPanel::Draw(Graphics &gh) const
{
    gh.DrawImage(m_imgBackground, m_rect);                              // 画出背景图片
 
    // 画子菜单
    for(auto menuItem : m_menuItems) {
        auto img = get<0>(menuItem.vImgInfoPtr[menuItem.index]);      // 获取菜单项的图片
        auto rect = get<1>(menuItem.vImgInfoPtr[menuItem.index]);     // 获取菜单项的大小
        gh.DrawImage(img, rect);
    }
}
 
// 处理 鼠标移动事件
void CGameMenuPanel::OnMouseMove(UINT nFlags, CPoint point)
{
    PointF pt(static_cast<float>(point.x), static_cast<float>(point.y));
    // 画子菜单
    for(auto &menuItem : m_menuItems) {
        auto img = get<0>(menuItem.vImgInfoPtr[menuItem.index]); // 获取菜单项的图片
        auto rect = get<1>(menuItem.vImgInfoPtr[menuItem.index]);// 获取菜单项的大小
         if(rect.Contains(pt)) {                                     // 判断是否包含当前鼠标位置
            menuItem.index = 1;                                     // 包含：显示第1张图片                                       
        }
        else {
            menuItem.index = 0;                                     // 不包含：显示第0张图片
        }
    }
}
 
// 处理 鼠标左键抬起事件
void CGameMenuPanel::OnLButtonUp(UINT nFlags, CPoint point)
{
    PointF pt(static_cast<float>(point.x), static_cast<float>(point.y));
    {
        auto &menuItem = m_menuItems[0];							// 获取第0张图片
        auto img = get<0>(menuItem.vImgInfoPtr[menuItem.index]);	// 获取图片指针
        auto rect = get<1>(menuItem.vImgInfoPtr[menuItem.index]);	// 获取图片大小
        if(rect.Contains(pt)) {									// 判断是否点中图片
            // 人机对战：暂时不设置
            // m_pParent->SetStep(CGame::EGameTypeOne2BotMenu);
            return;
        }
    }
    {
        auto &menuItem = m_menuItems[1];							// 获取第0张图片
        auto img = get<0>(menuItem.vImgInfoPtr[menuItem.index]);	// 获取图片指针
        auto rect = get<1>(menuItem.vImgInfoPtr[menuItem.index]);	// 获取图片大小
        if(rect.Contains(pt)) {									// 判断是否点中图片
            // 双人对战：暂时不设置
            //m_pParent->SetStep(CGame::EGameTypeOne2OneMenu);
            return;
        }
    }
}
```

:::



`类“CGameMenuBackground”`为游戏菜单的背景。该类比较简单,只是在每次调用Draw()函数时，输出一张图片。本类没有关于键盘鼠标的消息处理。打开`CGameMenuBackground.h `文件，删除原内容，输入以下代码:



:::details `CGameMenuBackground.h`

```c
#pragma once
#include "GameEntry.h"
class CGame;
class CGameMenuBackground : public CGameEntryMoveable
{
public:
    CGameMenuBackground();
    ~CGameMenuBackground();
    void SetParent(CGame *g)
    {
        m_pParent = g;
    };
    CGame *m_pParent{ nullptr };
    virtual void Draw(Graphics &gh) const; 						// 画自己的函数
    RectF m_rect{0, 0, 800, 600};           						// 自己的范围
    Image *m_imgBackground;                  						// 背景图
};
```

:::

下面是该类的实现代码。打开`CGameMenuBackground.cpp`文件，删除原内容，输入以下代码:

:::details `CGameMenuBackground.cpp`

```c
#include "stdafx.h"
#include "GameMenuBackground.h"
#include "Game.h"
 
 
CGameMenuBackground::CGameMenuBackground()
{
    m_imgBackground = Image::FromFile(_T("menu_background.png")); 	// 载入背景图
}
 
CGameMenuBackground::~CGameMenuBackground()
{
 
}
 
void CGameMenuBackground::Draw(Graphics &gh) const
{
    gh.DrawImage(m_imgBackground, m_rect);                          	// 绘制背景图片
}
```

:::

现在只是“写完”了这几个类，并没有在程序中使用到，只有使用到，才能看效果。下一节中就来使用下菜单类。

### 人机大战与双人大战

本程序中支持两种场景:人机大战与双人大战。这两种场景，需要在每次游戏开始之前确定。确定方法是把前面设计的游戏菜单提供给玩家，选择不同的菜单项，进入不同的游戏场景。这里正好用前面写的“游戏菜单”相关类。具体使用步骤如下:

- (1）包含头文件。打开`Game.h`文件，在文件顶部`“#pragma once”`下方插入以下代码:

```c
#include "GameMenuPane1.h”
#include "GameMenuBackground.h”
```

- (2）声明菜单类变量。在“HWND m hWnd;”下方一行加入代码，声明菜单相关类的成员变量:

:::details `Game.h`

```c
HWND m_hWnd;                  // 游戏窗口

/* 游戏绘图处理
   负责绘画游戏中的对象
*/
void GameRunDraw();
CGameMenuPanel m_menuSelect; // 开始菜单
CGameMenuBackground m_menu;  // 开始菜单背景图
```

:::

- (3）编写绘图方法的实现。该方法中调用菜单类自身的绘画方法，把菜单背景和菜单子项绘制到内存中，最后再把内存中的数据一次输出到游戏窗口中。打开`Game.cpp`文件，在文件最下方加入:

:::details `Game.cpp`

```c{20-24}
// 游戏绘图
void CGame::GameRunDraw()
{
    HDC hdc = ::GetDC(m_hWnd);
    CRect rc; 								// 客户区的大小
    GetClientRect(m_hWnd, &rc);
 
    CDC *dc = CClientDC::FromHandle(hdc);
 
    CDC m_dcMemory; 							// 双缓冲绘图用
    CBitmap bmp;
    bmp.CreateCompatibleBitmap(dc, rc.Width(), rc.Height());
    m_dcMemory.CreateCompatibleDC(dc);
    CBitmap *pOldBitmap = m_dcMemory.SelectObject(&bmp);
 
    Graphics gh(m_dcMemory.GetSafeHdc());	// 构造对象
    gh.Clear(Color::White);				// 清除背景
    gh.ResetClip();
 
    // 画入内存
    {
        m_menu.Draw(gh); 					// 画背景
        m_menuSelect.Draw(gh);			// 画菜单
    }
 
    // 拷贝到屏幕
    ::BitBlt(hdc, 0, 0, rc.Width(), rc.Height(), m_dcMemory.GetSafeHdc(), 0, 0, SRCCOPY);
    dc->DeleteDC();						// 释放
    return;
}
```

:::

- (4）调用绘图方法。打开Game.cpp文件，找到`“bool CGame:.EnterFrame(DWORD dwTime)”`方法，在`“return false;”`上面插入代码:

:::details `Game.cpp`

```c{2}
bool CGame:.EnterFrame(DWORD dwTime)
{
    GameRunDraw();
    return false;
}
```

上述代码调用了游戏的绘制方法。绘制方法中调用菜单项和背景项自身的绘制方法，把这两个对象绘制到游戏窗口上。

:::

运行程序，显示画面如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616214942841.png)

此时把鼠标移动到菜单上面，菜单并没有变化，这是因为程序还没有响应鼠标消息。这就要麻烦好久都未出场的`CMainFrm`类了，因为只有这里才可以响应鼠标消息，接下来要做的是:把鼠标消息“传递”给后续代码，让后面需要响应鼠标消息的地方可以“感知”到消息。



- (5）鼠标和定时器消息声明。打开`MainFrm.h`文件，在`“afx_msg void OnTimer(UINT_PTRnIDEvent); ”`下面一行加入代码:

:::details `MainFrm.h`

```c
afx_msg void OnMouseMove(UINT nFlagsCPoint point);
afx_msg void OnLButtonUp(UINT nFlags，CPoint point);
```

:::

这两行代码是鼠标消息处理方法的声明，其中` OnMouseMove()`对应“鼠标移动消息”;`OnLBut-tonUp()`对应“鼠标左键抬起消息”。光有声明还不够，还需要在`CMainFrm`类的消息映射表中添加代码，以绑定处理方法。



打开`MainFrm.cpp`文件，找到`“ON_WM_TIMER()”`，在下方增加两行代码;



:::details `MainFrm.cpp`

```c
ON_WM_MOUSEMOVE()
ON_wM_LBUTTONUP()
```

:::

- (6）消息处理函数的实现。实现方法中直接调用了CGame类对应的鼠标消息处理方法，使CGame类有机会处理到鼠标消息。在文件的最后增加:

:::details `MainFrm.cpp`

```c
void CMainFrame::OnMouseMove(UINT nFlags, CPoint point)
{
    m_game.OnMouseMove(nFlags, point); // 直接把鼠标消息转给 CGame对象
    CFrameWnd::OnMouseMove(nFlags, point);
}
  
void CMainFrame::OnLButtonUp(UINT nFlags, CPoint point)
{
    m_game.OnLButtonUp(nFlags, point); // 直接把鼠标消息转给 CGame对象
    CFrameWnd::OnLButtonUp(nFlags, point);
}
```

:::



- (7）在`CGame`类转发鼠标消息。打开`Game.cpp`文件，找到`“OnMouseMove”`所在行，在下方的大括号内增加一行代码:

:::details `Game.cpp`

```c
m_menuSelect.OnMouseMove(nFlags, point); //选择游戏类型
```

:::

找到`“OnLButtonUp”`所在行，在下方大括号内增加:

:::details `Game.cpp`

```c
m_menuSelect.OnLButtonUp(nFlags,point);//选择游戏类型
```

:::

这两行代码又把鼠标消息转给了菜单对象进行相关的处理。菜单对象会根据不同的消息，做出不同的动作，如:当发现鼠标移动到“自己”的范围内时，变换显示的图片;当移出时再恢复之前的图片。



> 再次运行，把鼠标移动到菜单上面，发现菜单已经可以变化了。





### 设计坦克及子弹

本程序中共有3种坦克对象:机器人（电脑控制的坦克)、玩家一和玩家二，3种都是坦克对象的子类。可以把相同的部分放在CTankEntry中，不同的部分放在子类中。这一部分主要用到的类有4个，分别是:

- CTankEntry:基类，负责坦克共有的功能，如前后移动、发射子弹等;
- CPlayer:玩家类，一个该类的对象，可能代表一个玩家;
- CBot:机器人（电脑控制的坦克）类，在人机大战中，代表电脑一方;
- CBullet:子弹类，坦克发出的子弹。





- (1）将目录下的文件“`TankEntry.h TankEntry.cpp  Bot.h Bot.cpp` 

  `Bullet.h Bollet.cpp` `Player.h Player.cpp` `KeyMenuPlayer01.h KeyMenuPlayer01.cpp`  KeyMenuPlayer02.h KeyMenuPlayer02.cpp`复制到自己项目的目录下，项目目录的打开方法如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616220754070.png)



- (2）复制好文件之后，把文件添加到项目中，如下图所示。

**在工程中添加现有项**

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616220919433.png) 

**在工程中添加现有项——选择文件**



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616221014520.png)

:::tip

此时项目是可以正常编译运行的，但引入的类还没有被使用到。

:::





:::details `TankEntry.h`

```c
#pragma once
#include "GameEntry.h"
#include "Bullet.h"
#include <list>
#include "GameTimer.h"
class CTankEntry : public CGameEntryMoveable
{
public:
    CTankEntry();
    CTankEntry(float x, float y, PCTSTR szImgName);
    virtual ~CTankEntry();
    virtual void Draw(Gdiplus::Graphics &gh) const;

    // 设置开枪间隔时间
    void SetFireTimeval(unsigned long timeval);

    // 开火 : 如果时间到达，且有子弹，就发射，并返回 true 否则返回false
    bool Fire(CBullet &blt);

    // 增加子弹
    void AddBullet(CBullet &blt);

    // 获得枪的位置
    virtual PointF GetGunPosition() const;

    // 获取子弹 出枪口时的初始位置
    virtual PointF GetBulletFirstStepPos(float bulletRadius) const;

    // 使坦克爆炸
    void Bomb();

    // 是否有效
    bool IsActive() const;

    // 是否爆炸结束(如果根本有爆炸，同样返回false)
    virtual bool IsBombEnd() const;

    // 判断是否被子弹击中
    virtual bool IsHitted(const CBullet &blt) const;

    // 获取碰撞信息, pDelay：如果发生碰撞，返回碰撞时间
    bool GetHitInfo(const CBullet &blt, float *pDelay = nullptr) const;

    // 对坦克的方向进行微调
    virtual void ChangeDirection(bool bForward);

private:
    // 画正常的坦克
    void DrawTank(Graphics &gh) const;

    // 绘制尾焰
    void DrawTankTail(Graphics &gh) const;

    // 画爆炸的坦克
    void DrawExplosion(Graphics &gh) const;

    // 当前状态: 1,正常,2:爆炸
    int m_status{1};

    // 坦克图片 正常时
    Image *m_imgTank;

    // 坦克图片 爆炸时
    Image *m_imgExplosion[12];
    mutable int m_explosionIndex{ 0 };

    // 子弹
    std::list<CBullet> m_lstBullets;

    // 开火间隔时间
    CGameTimeval m_timer_fire;

    // 爆炸时间
    CGameTimer m_timerBomb;
};
```

:::



:::details `TankEntry.cpp`

```c
#include "stdafx.h"
#include "TankEntry.h"
#include "GameHit.h"


CTankEntry::CTankEntry()
{
}

CTankEntry::CTankEntry(float x, float y, PCTSTR szImgName)
{
    m_imgTank = Image::FromFile(szImgName);
    for(int i = 0; i < _countof(m_imgExplosion); ++i) {
        TCHAR szPath[MAX_PATH];
        _stprintf_s(szPath, _T("%d.gif"), i);
        m_imgExplosion[i] = Image::FromFile(szPath);
    }
    int width = m_imgTank->GetWidth();
    int height = m_imgTank->GetHeight();

    // 计算 坦克 前占用的区域
    RectF r(static_cast<float>(x)
            , static_cast<float>(y)
            , static_cast<float>(width)
            , static_cast<float>(height));
    SetRect(r);

    // 速度
    SetSpeed(10);
    // 当前的角度
    SetDirection(0);
    // 每次按键转 30度
    SetDirectionTurn(30);
    // 默认为有效
    SetActive(true);
    // 子弹信息
    for(int i = 0; i < 5; ++i) {
        m_lstBullets.push_back(CBullet(0, 0, 12, 0));
    }
}

CTankEntry::~CTankEntry()
{
}

// 画自己
void CTankEntry::Draw(Gdiplus::Graphics &gh) const
{
    if(!IsActive()) {
        return;
    }

    //旋转绘图平面
    PointF center = GetCenterPoint();

    // 1.平移变换 : 移动坐标点到 坦克中心
    gh.TranslateTransform(center.X, center.Y);
    // 2.旋转变换 : 使作标系，跟坦克的角度一致
    gh.RotateTransform(GetDirection());
    // 3.恢复原点
    gh.TranslateTransform(-center.X, -center.Y);

    switch(m_status) {
        case 1: {
            //绘制坦克
            DrawTank(gh);
            DrawTankTail(gh);
            break;
        }
        case 2: {
            // 绘制爆制的坦克
            DrawExplosion(gh);
            break;
        }
        default:
            break;
    };


#if 1
    // 重置坐标变换 : 精度是否够呢？
    // 1.移动到中心点
    gh.TranslateTransform(center.X, center.Y);
    // 2.逆向转
    gh.RotateTransform(-GetDirection());
    // 3.再移动回去
    gh.TranslateTransform(-center.X, -center.Y);
    //ScaleTransform : 缩放
#else
    // 第二种恢复的方式 : 缺点：直接重置，不好啊
    gh.ResetTransform();
#endif
}

// 设置开枪间隔时间
void CTankEntry::SetFireTimeval(unsigned long timeval)
{
    m_timer_fire.SetTimeval(timeval);
}

// 获得枪的位置
PointF CTankEntry::GetGunPosition() const
{
    return GetHeadPos();
}

// 获取子弹 出枪口时的初始位置
PointF CTankEntry::GetBulletFirstStepPos(float bulletRadius) const
{
    //枪口的位置
    PointF p = GetGunPosition();
    // 向前申出去一点儿,避免第一次发射时，就打爆自己
    p.X += static_cast<Gdiplus::REAL>((bulletRadius) * sin(GetDirectionArc()));
    p.Y -= static_cast<Gdiplus::REAL>((bulletRadius) * cos(GetDirectionArc()));
    return p;
}

// 使坦克爆炸
void CTankEntry::Bomb()
{
    m_timerBomb.SetTimeout(3000);
    m_timerBomb.StartTimer();
    m_status = 2;
}

// 是否有效
bool CTankEntry::IsActive() const
{
    return (CGameEntryMoveable::IsActive() && m_explosionIndex <= _countof(m_imgExplosion));
}

// 是否爆炸结束(如果根本有爆炸，同样返回false)
bool CTankEntry::IsBombEnd() const
{
    return m_status == 2 && m_timerBomb.IsTimeout();
}

// 对坦克的方向进行微调
void CTankEntry::ChangeDirection(bool bForward)
{
    return; // 不要了
    float dir = GetDirection();
    int _d = int(dir);
    if(bForward) {
        if(0 < _d && _d < 180) {
            dir += 1;
        }
        else {
            dir -= 1;
        }
    }
    else {
        if(0 < _d && _d < 180) {
            dir -= 1;
        }
        else {
            dir += 1;
        }
    }
    SetDirection(dir);
}

// 画正常的坦克
void CTankEntry::DrawTank(Graphics &gh) const
{
    if(!IsActive()) {
        return;
    }
    gh.DrawImage(m_imgTank, GetRect());
}

// 绘制尾焰
void CTankEntry::DrawTankTail(Graphics &gh) const
{
}

// 画爆炸的坦克
void CTankEntry::DrawExplosion(Graphics &gh) const
{
    if(!IsActive()) {
        return;
    }
    //绘制爆炸图片
    auto p = m_imgExplosion[m_explosionIndex];
    if(p) {
        RectF rect;
        // 自己的中心点
        PointF pCenter = GetCenterPoint();
        rect.Width = static_cast<float>(p->GetWidth());
        rect.Height = static_cast<float>(p->GetHeight());
        rect.X = 0;
        rect.Y = 0;
        rect.Offset(pCenter.X - rect.Width / 2, pCenter.Y - rect.Height / 2);
        gh.DrawImage(p, rect);
    }
    // 换一下张图片
    static unsigned long last = GetTickCount();
    if(GetTickCount() - last > 50) {
        m_explosionIndex++;
        if(m_explosionIndex >= _countof(m_imgExplosion)) {
            m_explosionIndex = _countof(m_imgExplosion) - 1;
        }
    }
}

// 开火
bool CTankEntry::Fire(CBullet &_blt)
{
    if(!IsActive()) {
        return false;
    }
    // 检测开枪间隔时间
    if(!m_timer_fire.IsTimeval()) {
        return false;
    }

    // 获取头部位置
    PointF front = GetGunPosition();// GetBulletFirstStepPos(_blt.GetDiameter() / 2.0f);
    //检查 子弹信息
    //如果还有子弹，就在头部发出,并且从列表中移除，加到另一个列表
    if(!m_lstBullets.empty()) {
        CBullet &blt = m_lstBullets.back();
        // 设置初始 坐标
        blt.SetPositionForCenter(front);
        // 设置 运动方向
        blt.SetDirection(GetDirection());
        // 设置初始速度
        blt.SetSpeed(5);
        // 设置为有效
        blt.SetActive(true);
        // 设置发射时间
        blt.SetFireTime(GetTickCount());
        // 设置所有者
        blt.SetOwner(this);
        // 设置为首次发射
        blt.SetFirst();
        // 加入到地图列表列表中
        _blt = blt;
        // 本地删除
        m_lstBullets.pop_back();
        // 记录开枪时间
        m_timer_fire.SetLastTime();
        return true;
    }
    return false;
}

// 增加子弹
void CTankEntry::AddBullet(CBullet &blt)
{
    if(!IsActive()) {
        return;
    }
    m_lstBullets.push_back(blt);
}

// 判断是否被子弹击中
bool CTankEntry::IsHitted(const CBullet &blt) const
{
    if(blt.IsFirstFire() && blt.GetOwner() == this) {
        return false;
    }
    return GetHitInfo(blt);
}

// 获取碰撞信息
bool CTankEntry::GetHitInfo(const CBullet &blt, float *pDelay /*= nullptr*/) const
{
    // 子弹 初次发射，不能把自己打爆
    if(blt.IsFirstFire() && blt.GetOwner() == this) {
        return false;
    }
    // 检查是否发生碰撞
    //代表子弹当前的位置
    game_hit::Circle A;
    A.r = blt.GetDiameter() / 2.0f;
    A.x = blt.GetCenterPoint().X;
    A.y = blt.GetCenterPoint().Y;

    // 把小球向某方向移动
    auto move_step = [](game_hit::Circle & A, float dir, float distance) {
        A.x += distance * sin(dir);
        A.y -= distance * cos(dir);
    };

    // 自己
    RectF B = GetRect();

    // 为了防止子弹穿过导致的碰撞检测失效
    // 使子弹对象在行进方向上，一个像素，一个像素的前进，并进行碰撞检测
    for(int step = 0; step < blt.GetSpeed(); ++step) {
        move_step(A, blt.GetDirectionArc(), step);
        if(game_hit::check_collision(A, B, GetDirectionArc())) {
            if(pDelay) {
                *pDelay = step;
            }
            return true;
        }
    }
    return false;
}
```

:::



:::details `Bot.h`

```c
#pragma once
#include "TankEntry.h"
class CBot : public CTankEntry 
{
public:
	CBot();
	CBot(float x, float y, PCTSTR szImgName);
	virtual ~CBot();
};
```

:::

:::details `Bot.cpp`

```c
#include "stdafx.h"
#include "Bot.h"


CBot::CBot()
{
}


CBot::~CBot()
{
}

CBot::CBot(float x, float y, PCTSTR szImgName) : CTankEntry(x, y, szImgName)
{

}
```

:::



:::details `Bullet.h`

```c
#pragma once
#include "GameEntry.h"

class CTankEntry;

class CBullet : public CGameEntryMoveable
{
public:
    CBullet();
    CBullet(float x, float y, float speed, float direction);
    virtual ~CBullet();

    CBullet(const CBullet &rhs);

    CBullet &operator=(const CBullet &rhs);

    // 画自己
    virtual void Draw(Graphics &gh) const;

    // 移动子弹
    void Move();

    // 是否超时了
    bool IsTimeout() const;

    // 设置子弹位置
    void SetPositionForCenter(PointF pfCenter);

    // 设置子弹所有者(子弹是由谁发出的)
    void SetOwner(CTankEntry *pOwner);

    // 获得所有者(子弹是由谁发出的)
    CTankEntry *GetOwner() const;

    // 设置存在时间
    void SetKeepTime(unsigned long keepTime);

    // 设置开始时间，并设置为有效
    void SetFireTime(unsigned long fireTime);

    // 获得直径
    float GetDiameter() const;

    // 设置直径
    void SetDiameter(float diameter);

    // 设置子弹为首次发出
    void SetFirst();

    // 是否是首次发出
    bool IsFirstFire() const;

private:
    int m_step{0};
    // 直径
    float m_iDiameter{10};
    // 子弹存在的时间 : 默认10秒
    unsigned long m_keepTime{10 * 1000};
    // 记录子弹发射时间
    unsigned long m_fireTime{0};
    // 属于谁的
    CTankEntry *m_pOwner{nullptr};
};
```

:::



:::details `Bullet.cpp`

```c
#include "stdafx.h"
#include "GameEntry.h"
#include "Bullet.h"


CBullet::CBullet()
{
}

CBullet::CBullet(float x, float y, float speed, float direction)
{
    SetSpeed(speed);
    SetDirection(direction);
    SetRect(RectF(x, y, m_iDiameter, m_iDiameter));
    m_step = 0;
}

CBullet::~CBullet()
{
}

CBullet::CBullet(const CBullet &rhs)
    : CGameEntryMoveable(rhs)
{
    if(this != &rhs) {
        m_step = rhs.m_step;
        // 直径
        m_iDiameter = rhs.m_iDiameter;
        // 子弹存在的时间 : 默认10秒
        m_keepTime = rhs.m_keepTime;
        // 记录子弹发射时间
        m_fireTime = rhs.m_fireTime;
        // 属于谁的
        m_pOwner = rhs.m_pOwner;
    }
}

CBullet &CBullet::operator=(const CBullet &rhs)
{
    if(this != &rhs) {
        CGameEntryMoveable::operator=(rhs);
        m_step = rhs.m_step;
        // 直径
        m_iDiameter = rhs.m_iDiameter;
        // 子弹存在的时间 : 默认10秒
        m_keepTime = rhs.m_keepTime;
        // 记录子弹发射时间
        m_fireTime = rhs.m_fireTime;
        // 属于谁的
        m_pOwner = rhs.m_pOwner;
    }
    return *this;
}

// 是否超时了
bool CBullet::IsTimeout() const
{
    return (GetTickCount() - m_fireTime >= m_keepTime);
}

// 设置子弹位置
void CBullet::SetPositionForCenter(PointF pfCenter)
{
    // 子弹的位置
    RectF rect{
        pfCenter.X - m_iDiameter / 2,
        pfCenter.Y - m_iDiameter / 2,
        m_iDiameter, m_iDiameter
    };
    SetRect(rect);
}

// 画自己
void CBullet::Draw(Graphics &gh) const
{
    if(!IsActive()) {
        return;
    }

    // 画一个圆...
    gh.FillEllipse(&SolidBrush(Color::OrangeRed), GetRect());
}

// 设置子弹所有者(子弹是由谁发出的)
void CBullet::SetOwner(CTankEntry *pOwner)
{
    m_pOwner = pOwner;
}

// 获得所有者(子弹是由谁发出的)
CTankEntry *CBullet::GetOwner() const
{
    return m_pOwner;
}

// 设置存在时间
void CBullet::SetKeepTime(unsigned long keepTime)
{
    m_keepTime = keepTime;
}

// 设置开始时间，并设置为有效
void CBullet::SetFireTime(unsigned long fireTime)
{
    m_fireTime = fireTime;
    SetActive(true);
};

// 获得直径
float CBullet::GetDiameter() const
{
    return m_iDiameter;
}

// 设置直径
void CBullet::SetDiameter(float diameter)
{
    m_iDiameter = diameter;
}

// 设置子弹为首次发出
void CBullet::SetFirst()
{
    m_step = 0;
};

// 是否是首次发出
bool CBullet::IsFirstFire() const
{
    return m_step == 0;
}

// 移动子弹
void CBullet::Move()
{
    if(!IsActive()) {
        return;
    }
    ++m_step;
    // 子弹 只能向前进
    Forward();
}
```

:::





:::details `Player.h`

```c
#pragma once
#include "TankEntry.h"
class CPlayer :
    public CTankEntry
{
public:
    CPlayer();
    CPlayer(float x, float y, PCTSTR szImgName);
    virtual ~CPlayer();
    // 左右转 : 两次转动之间有时间限制。不能转得太快
    virtual void RotateRight();
    
    virtual void RotateLeft();

private:
    // 检查两次动作之间的时间
    CGameTimeval m_timer{100};
};
```

:::



:::details `Player.cpp`

```c
#include "stdafx.h"
#include "Player.h"
CPlayer::CPlayer()
{
}
CPlayer::~CPlayer()
{
}
CPlayer::CPlayer(float x, float y, PCTSTR szImgName) : CTankEntry(x, y, szImgName)
{

}
// 左右转 : 两次转动之间有时间限制。不能转得太快
void CPlayer::RotateRight()
{
    if(m_timer.IsTimeval()) {
        CTankEntry::RotateRight();
    }
}
void CPlayer::RotateLeft()
{
    if(m_timer.IsTimeval()) {
        CTankEntry::RotateLeft();
    }
}
```

:::



:::details `KeyMenuPlayer01.h`

```c
#pragma once
#include "GameEntry.h"
#include "GameTimer.h"

class CGame;
class CKeyMenuPlayer01 : public CGameEntryMoveable
{
public:
    CKeyMenuPlayer01();
    ~CKeyMenuPlayer01();

    // 画
    virtual void Draw(Gdiplus::Graphics &gh) const;

    // 停止动画
    void SetStop(bool bStop = true)
    {
        m_bStop = bStop;
    };
    bool GetStop() const
    {
        return m_bStop;
    }

private:
    mutable CGameTimeval m_time{300};
    // 菜单 图片
    Image *m_img[2];

    // 是否停止动画状态
    bool m_bStop{false};
};
```

:::



:::details `KeyMenuPlayer01.cpp`

```c
#include "stdafx.h"
#include "KeyMenuPlayer01.h"
#include "Game.h"
CKeyMenuPlayer01::CKeyMenuPlayer01()
{
    m_img[0] = Image::FromFile(_T("menu_key_player01_0.png"));
    m_img[1] = Image::FromFile(_T("menu_key_player01_1.png"));
    if(m_img[0]) {
        RectF rc = {800 - 100, 600 - 40
                    , static_cast<float>(m_img[0]->GetWidth())
                    , static_cast<float>(m_img[0]->GetHeight())
                   };
        SetRect(rc);
    }
}
CKeyMenuPlayer01::~CKeyMenuPlayer01()
{

}
void CKeyMenuPlayer01::Draw(Graphics &gh) const
{
    if(m_bStop) {
        gh.DrawImage(m_img[0], GetRect());
        return;
    }

    static bool bFlag{ false };
    if(bFlag) {
        gh.DrawImage(m_img[0], GetRect());
    }
    else {
        gh.DrawImage(m_img[1], GetRect());
    }
    if(m_time.IsTimeval()) {
        bFlag = !bFlag;
    }
}
```

:::

### 画出移动的坦克

接下来在屏幕上画一个坦克，并使坦克可以移动和发射子弹，实现步骤如下。



- (1）引入坦克类和子弹类相关头文件。打开`Game.h`文件，在`“#include "GameMenuBackground.h"”`一行下方增加以下代码:

:::details `Game.h`

```c
#include "TankEntry.h"
#include "Player.h"
#include "Bullet.h"
#include "Bot.h"
```

:::



- (2）声明坦克类的变量，并设定坦克的初始位置和坦克的图片;声明子弹变量的数组，用于存储从坦克中射出的子弹对象。在类的最后增加以下代码:

:::details `Game.h`

```c
CPlayer m_player01{100, 100, _T("tank_player1.png")}; // 两个玩家对象

CPlayer m_player02{200, 100, _T("tank_player2.png")}; // 玩家对象2: 双人对战时才会用到

CBot m_bot{300, 200, _T("tank_bot.png")};              // 一个电脑: 人机对战时用到

std::list<CBullet> m_lstBullets;                        // 存在于地图场景中的 子弹对象数组
```

:::



- (3）上面代码的作用是在`CGamc`类中声明成员变量，接下来就可以在后面的代码中使用这几个成员变量了。首先尝试使用“玩家一”对象，即`“m_player01”`。控制坦克需要使用键盘，因此在这个类中需要增加键盘处理方法:

在`Game.h`文件中找到`“void GameRunDraw();”`，在下面增加函数的声明代码:

:::details `Game.h`

```c
  /* 游戏逻辑处理:
      1. 维护子弹状态
      2. 维护 机器人AI的自动移动,自动发射子弹
      3. 维护 玩家 坦克的状态
      碰撞检测包括： 撞墙，子弹命中坦克...
  */
  void GameRunLogic();
```

:::

- (4）声明后，需要实现该代码的方法。这部分代码功能如下:



🚩①使用GetAsynKeyState函数获取当前的按键状态，如:发现当下按下了键盘上的“上”方向键，则调用玩家一的Forward()函数，使坦克前进;



🚩②遍历子弹对象数组，依次调用每个子弹对象的前进方法，使子弹向前移动一段距离;



🚩③查找超时的子弹，把它从数组中删除，这样下次绘画时，就不绘画该子弹了，实现子弹超时消失的效果。



打开Game.cpp文件，并在最后增加该方法的定义代码:



:::details `Game.cpp`

```c
void CGame::GameRunLogic()
{
#define KEYDOWN(vk) (GetAsyncKeyState(vk) & 0x8000)
    //按键处理
    {
        if(KEYDOWN(VK_LEFT))          // 左方向盘按下
        {
            m_player01.RotateLeft(); // 玩家一向左转
        }
        if(KEYDOWN(VK_RIGHT))          			// 右方向盘按下
        {
            m_player01.RotateRight();			// 玩家一向右转
        }
        if(KEYDOWN(VK_UP))            			// 上方向盘按下
        {
            m_player01.Forward();     			// 玩家一向前走
        }
        if(KEYDOWN(VK_DOWN))          			// 下方向盘按下
        {
            {
                m_player01.Backward(); 		// 玩家一向后退
            }
        }
        if(KEYDOWN('M'))                		// 按下M键
        {
            CBullet blt;
            if(m_player01.Fire(blt)) {        	// 开火
                m_lstBullets.push_back(blt); 	// 加入到地图列表中
            }
        }
    }
 
    for(auto &blt : m_lstBullets) {          	// 处理子弹对象的移动
        blt.Move();                            	// 子弹向前移动
    }
 
    // 移除超时的子弹
    {
         // 查找超时的子弹
        auto itRemove = std::remove_if(m_lstBullets.begin(),
                                       m_lstBullets.end(),
            [] (CBullet & blt)->bool {
                return blt.IsTimeout(); 
            });
        for(auto it = itRemove; it != m_lstBullets.end(); ++it) {
            it->SetActive(false);				// 设置为无效
            it->GetOwner()->AddBullet(*it);	// 给对应的坦克增加子弹
        }
        // 从本地 删除 子弹
        m_lstBullets.erase(itRemove, m_lstBullets.end());
    }
}
```

:::

- (6）找到`Game.cpp`文件中的`“bool CGame::EnterFrame(DWORD dwTime)”`，在此方法内的`“GamcRunDraw():”`下方增加对游戏逻辑处理函数的调用:

:::details `Game.cpp`

```c{3}
bool CGame::EnterFrame(DWORD dwTime)
{
    GameRunLogic();
    GameRunDraw();
    return false;
}
```

:::



到此为止，程序实现的功能为:在游戏窗口上画一辆坦克，可以用键盘上的左右键控制方向，用上下键控制前后移动，按M键发射子弹，最多5颗，子弹会因为超时而消失。此时再按M键，还可以继续发射子弹。运行结果如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616223148167.png)



### 自动寻路与碰撞检测

上面已经实现了一个坦克类，并使用了第一个玩家对象。第二个玩家和第一个玩家是一样的，只是用来控制的键不相同。在游戏中第二个玩家是`<Q><A> <S><W><D>`来控制的，读者也可以自由增加多个玩家。机器人（电脑控制的坦克）类不必由人来控制，而是由电脑来控制的。但是这些坦克目前的移动过于自由，需要增加地图、寻路以及碰撞检测相关功能来控制坦克及子弹的行为:哪里可以走、哪里不可以走、子弹撞墙的反弹和机器人（电脑控制的坦克）自动寻路等功能。



:::tip

- 本游戏中地图相关的类为:`CGameMap`，代表整个地图;
- `CGameMapElement`，地图中的小方格
- `CWall`，地图中的墙。
- 碰撞检测相关文件: `GamcHit.h/GameHit.cpp`，定义了所有碰撞检测相关的类及方法。
- 自动寻路相关类`CGamePathFinder`，采用深度优先搜索算法的最短路径查找。

:::



为方便使用前面编写的各种对象代码和系统提供的标准库，这里要处理一下“Stdafx.h”文件。此文件会被所有其他.cpp文件包含，在该文件中包含的头文件，相当于把这些头文件包含进入了所有的.cpp文件。





打开`stdafx.h`文件，在`“#include<gdiplus.h>”`上方插入如下代码;

:::details `stdafx.h`

```c
#include <cassert>
#include <cmath>
#include <algorithm>
#include <deque>
#include <exception>
#include <fstream>
#include <functional>
#include <ios>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <numeric>
#include <ostream>
#include <queue>
#include <random>
#include <regex>
#include <set>
#include <stack>
#include <string>
#include <strstream>
#include <tuple>
#include <vector>
using namespace std;
```

:::



由于本程序要计算坦克的角度，会频繁用到圆周率，因此定义一个宏`“PI”`﹔在自动寻路时，需要用到一个表示坐标点的结构体，因此定义一个`PathNodc`结构体，并声明代表路径的`VPath`类型。在“using namespace Gdiplus;”下方增加如下代码:



:::details `stdafx.h`

```c
#define PI 3.14159265357f
 
typedef struct PathNode {
    int x;
    int y;
} PathNode;
 
typedef std::vector<PathNode> VPath;
 
// 删除内存的宏 
#define SAFE_DEL_PTR(ptr) if((ptr) != nullptr){delete ptr;ptr= nullptr;}
```

SAFE_DEL_PTR的作用是删除内存并把指针赋值为空，以免后续代码误用已经删除的内存。

:::



将源码文件夹中的以下文件复制到自己的项目目录下，并加入项目。这些文件为已经实现好的碰撞检测、游戏地图以及自动寻路模块。具体功能如下:

- GameHit.h/GameHit.cpp:碰撞检测;

- GameMap.h/GameMap.cpp:游戏地图;

- GamcPathFinder.h:自动寻路;
- Wall.h/Wall.cpp:地图上的“墙”



:::details `GameHit.h`

```c
#pragma once

// 向量及相关运算
namespace game_hit
{

#if !defined(PI)
#  define PI (3.14159265357)
#endif


    // 个向量表示的各种形状，及向量类
    // 二维向量，及相关计算
    // 二维向量
    class CVector2D
    {
    public:
        float x, y;
        CVector2D() {}
        CVector2D(float _x, float _y) : x(_x), y(_y) {}
        CVector2D(const CVector2D &rhs) : x(rhs.x), y(rhs.y) {}
        CVector2D &operator = (const CVector2D &a)
        {
            x = a.x;
            y = a.y;
            return *this;
        }
        bool operator == (const CVector2D &a)
        {
            return x == a.x  && y == a.y;
        }
        bool operator != (const CVector2D &a)
        {
            return x != a.x || y != a.y;
        }

        /// 向量运算

        //置为0向量
        void Zero()
        {
            x = y = 0.0f;
        }

        // 重载 '-' 求负向量
        CVector2D operator - () const
        {
            return CVector2D(-x, -y);
        }

        CVector2D operator + (const CVector2D &a) const
        {
            return CVector2D(x + a.x, y + a.y);
        }

        // 减法
        CVector2D operator - (const CVector2D &a) const
        {
            return CVector2D(x - a.x, y - a.y);
        }

        // 与标量的 乘除法
        CVector2D operator *(float a) const
        {
            return CVector2D(x * a, y * a);
        }

        // 与标量的 乘除法
        CVector2D operator /(float a) const
        {
            return CVector2D(x / a, y / a);
        }

        // +=
        CVector2D &operator+=(const CVector2D &a)
        {
            x += a.x;
            y += a.y;
            return *this;
        }
        // -=
        CVector2D &operator-=(const CVector2D &a)
        {
            x -= a.x;
            y -= a.y;
            return *this;
        }
        // *=
        CVector2D &operator*=(const CVector2D &a)
        {
            x *= a.x;
            y *= a.y;
            return *this;
        }
        // /=
        CVector2D &operator/=(const CVector2D &a)
        {
            x /= a.x;
            y /= a.y;
            return *this;
        }
        // 求向量长度
        float magintude() const
        {
            return sqrt(x * x + y * y);
        }
        // 求两个向量之间的夹角
        float angleBetween(const CVector2D &vector2)
        {
            CVector2D vector3 = *this - vector2;
            auto m1 = this->magintude();
            auto m2 = vector2.magintude();
            auto m3 = vector3.magintude();
            assert(m1 != 0 && m2 != 0);
            if(m3 == 0) {
                return 0;
            }
            else {
                return acos((m2 * m2 + m1 * m1 - m3 * m3) / (2 * m1 * m2));
            }
        }

        // 向量标准化
        void Normal()
        {
            // 求向量长度
            float magSq = x * x + y * y;
            if(magSq > 0.000001f) {
                float oneOverMag = 1.0f / sqrt(magSq);
                x *= oneOverMag;
                y *= oneOverMag;
            }
        }

        // 求法向量 : 重直于本向量的向量 点积 = 0 可得 fx * vx  + fy* vy = 0 , 最简单的解为:
        //    fx = -vy, fy = vx
        // or fx =  vy, fy = -vx
        CVector2D NormalizeLeft()
        {
            CVector2D f = *this;
            f.Normal();
            return CVector2D(f.y, -f.x);
        }

        CVector2D NormalizeRight()
        {
            CVector2D f = *this;
            f.Normal();
            return CVector2D(-f.y, f.x);
        }

        // 向量的点乘
        float operator * (const CVector2D &a) const
        {
            return x * a.x + y * a.y;
        }

    };

    // 求向量的点积
    inline float dotProduct(const CVector2D &a, const CVector2D &b)
    {
        return a.x * b.x + a.y * b.y;
    }

    // 标量的左乘
    inline CVector2D operator * (float k, const CVector2D &v)
    {
        return CVector2D(k * v.x, k * v.y);
    }

    //计算两点间的距离
    inline float distance(const CVector2D &a, const CVector2D &b)
    {
        return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));
    }

    // 给定初始位置，和时间T，计算新位置？
    // 给定向量 v,k,返回4个值 i'(k的标准化版本), j', i'和j'方向上的v 分量 a和b;
    // v = ai' + bj'
    inline void switchBasis(const CVector2D &vector, const CVector2D &directionVector, CVector2D &basis1, CVector2D &basis2, float &a, float &b)
    {
        // 输入的方向向量的标准化版本
        basis1 = directionVector;
        basis1.Normal();
        // 输入的方向向量的法线
        basis2 = basis1;
        basis2.NormalizeLeft();
        auto alpha = atan2(basis1.y, basis1.x);
        auto theta = atan2(vector.y, vector.x);
        auto mag = vector.magintude();
        a = mag * cos(theta - alpha);
        b = mag * sin(theta - alpha);
    }

    // 计算新坐标系中的独立分量的长度
    inline float component(CVector2D &vector, CVector2D &directionVector)
    {
        // 标准化
        auto alpha = atan2(directionVector.y, directionVector.x);
        auto theta = atan2(vector.y, vector.x);
        auto mag = vector.magintude();
        auto a = mag * cos(theta - alpha);
        return a;
    }

    // 计算新坐标系中的独立分量(结果是一个向量,也就是 vector 在 directionVector 上面的投影)
    inline CVector2D componentVector(CVector2D &vector, CVector2D &directionVector)
    {
        // 标准化
        auto v = directionVector;
        v.Normal();
        return component(vector, directionVector) * v;
    }
}

// 定义 需要用到的形状状
namespace game_hit
{
    // 线段
    class CLine
    {
    public:
        CLine() : startPoint(0, 0), endPoint(0, 0) {}
        CLine(float x0, float y0, float x1, float y1) : startPoint(x0, y0), endPoint(x1, y1)
        {
        }
        CVector2D startPoint, endPoint;
    };

    // 运动的点,有当前位置，和速度
    class CMovePoint
    {
    public:
        CMovePoint()
            : pos(0, 0), speed(0, 0)
        {
        }
        CMovePoint(float x, float y, float vx, float vy)
            : pos(x, y), speed(vx, vy)
        {
        }
        CMovePoint(CVector2D _pos, CVector2D _speed)
            : pos(_pos), speed(_speed)
        {
        }

    public:
        // 当前速度(像素/帧)
        CVector2D speed;
        // 当前位置
        CVector2D pos;
    };

    // 代表 圆的结构体
    struct Circle {
        float x, y;
        float r;
    };

}

// 碰撞检测：主要是向量计算
namespace game_hit
{
    // 输入四个向量参数(代表直线 ab, cd),判断是否相交，如果相交，返回交点位置
    // 相交返回 true, 否则返回false;
    inline bool intersectionPoint(const CVector2D &a, const CVector2D &b, const CVector2D &c, const CVector2D &d, CVector2D *pCorssPoint)
    {
        /*
            AB = {a,b}, CD = {c,d}
            // 如果相交 则推出方程:
            OP = OA + t*AB = a + t*(b-a);
            OP = OC + s*CD = c + s*(d-c);

            =>

            a + t * (b - a) = c + s * (d - c);

            =>

            a.x + t*(b.x - a.x) = c.x + s*(d.x - c.x);
            a.y + t*(b.y - a.y) = c.y + s*(d.y - c.y);

            a.x + t* tc1 = c.x + s* sc1;
            a.y + t* tc2 = c.y + s* sc2;
        */
        float tc1 = b.x - a.x;
        float tc2 = b.y - a.y;

        float sc1 = c.x - d.x;
        float sc2 = c.y - d.y;

        float con1 = c.x - a.x;
        float con2 = c.y - a.y;

        float det = tc2 * sc1 - tc1 * sc2;
        if(det == 0) {
            return false;
        }
        float con = tc2 * con1 - tc1 * con2;
        float s = con / det;
        if(pCorssPoint) {
            *pCorssPoint = c + s * (d - c);
        }
        return true;
    }

    // 计算两个直线的相交时间
    // 返回 t 为时间 如果 t = [0,1]
    // t>1 : t 位于 B点一侧
    // t<0 : t 位于 A点一侧
    inline bool intersectionTime(const CVector2D &p1, const CVector2D &v1, const CVector2D &p2, const CVector2D &v2, float *pt = nullptr)
    {
        auto tc1 = v1.x;
        auto tc2 = v1.y;

        auto sc1 = v2.x;
        auto sc2 = v2.y;

        auto con1 = p2.x - p1.x;
        auto con2 = p2.y - p1.y;

        auto det = tc2 * sc1 - tc1 * sc2;

        if(det == 0) {
            return false;
        }
        auto con = sc1 * con2 - sc2 * con1;
        auto t = con / det;
        if(pt) {
            *pt = t;
        }
        return true;
    }

    // 计算两个线段的交点
    inline bool intersection(const CVector2D &a, const CVector2D &b, const CVector2D &c, const CVector2D &d, float *pt = nullptr)
    {
        auto tc1 = b.x - a.x;
        auto tc2 = b.y - a.y;

        auto sc1 = c.x - d.x;
        auto sc2 = c.y - d.y;

        auto con1 = c.x - a.x;
        auto con2 = c.y - a.y;
        auto det = tc2 * sc1 - tc1 * sc2;
        if(det == 0) {
            return false;
        }
        auto con = tc2 * con1 - tc1 * con2;
        auto s = con / det;
        if(s < 0 || s > 1) {
            return false;
        }
        float t = 0;
        if(tc1 != 0) {
            t = (con1 - s * sc1) / tc1;
        }
        else {
            t = (con2 - s * sc2) / tc2;
        }

        if(t < 0 || t > 1) {
            return false;
        }
        if(pt) {
            *pt = t;
        }
        return true;
    }

    // 全局0向量
    extern const CVector2D kZeroVector2D;

    // 计算三角形外积
    inline float signed2DTriArea(CVector2D a, CVector2D b, CVector2D c)
    {
        return ((a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x));
    }

    // 判断两条线段是否相交,如果是，返回交点位置，和相交比例(pIntersectionTime)
    inline bool IntersectLineSegments(const CLine a, const CLine b,
                                      __out CVector2D *pIntersectionPoint = nullptr,
                                      __out float *pIntersectionTime = nullptr)
    {
        auto a1 = signed2DTriArea(a.startPoint, a.endPoint, b.endPoint);
        auto a2 = signed2DTriArea(a.startPoint, a.endPoint, b.startPoint);
        if(a1 * a2 < 0) {
            auto a3 = signed2DTriArea(b.startPoint, b.endPoint, a.startPoint);
            auto a4 = a3 + a2 - a1;
            if(a3 * a4 < 0) {
                auto intersectionTime = a3 / (a3 - a4);
                auto intersectionPoint = CVector2D(a.endPoint.x, a.endPoint.y);
                intersectionPoint -= a.startPoint;
                intersectionPoint = intersectionPoint * intersectionTime;
                intersectionPoint += a.startPoint;
                if(pIntersectionPoint) {
                    *pIntersectionPoint = intersectionPoint;
                }
                if(pIntersectionTime) {
                    *pIntersectionTime = intersectionTime;
                }
                return true;
            }
        }
        return false;
    }

    // 判断移到的点(可以视为射线？)，是否与直线产碰撞，如果碰撞，返回碰撞的点，和反射之后的速度
    inline bool IsHit(const CMovePoint &Ray, const CLine &line,
                      __out CVector2D &newSpeed,
                      __out CVector2D &crossPoint,
        __out float * pHitDelay = nullptr)
    {
        using namespace game_hit;
        // 下一帧之位置
        auto next = Ray.pos + Ray.speed;
        // 两个位置构成一条线段
        CLine a(Ray.pos.x, Ray.pos.y, next.x, next.y);
        // 相交点
        CVector2D hitPoint;
        // 相交时间
        float hitDelay;

        // 判断是否相交
        bool b = IntersectLineSegments(a, line, &hitPoint, &hitDelay);

        if(b) {
            if (pHitDelay) * pHitDelay = hitDelay;
            //设置新的坐标为碰撞位置
            crossPoint = hitPoint;
            // 求 被撞直线的法线
            auto N = (line.endPoint - line.startPoint);
            N = N.NormalizeRight();
            // 新的速度 R = I - 2(I.N)N, I=原速度
            // 求点积
            auto dot = dotProduct(Ray.speed, N);
            // 最终结果
            auto R = Ray.speed - N * 2 * dot;
            newSpeed = R;
            return true;
        }
        else {
            return false;
        }
    }

}

// 碰撞检测 : 圆与旋转矩型,圆与圆是否相交
namespace game_hit
{
    // 计算两点之间的距离
    inline float distance(float x1, float y1, float x2, float y2)
    {
        return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));
    }

    // 判断两个圆是否相交
    inline bool check_collision(const Circle &A, const Circle &B)
    {
        return true;
    }

    // 圆型 是否与未旋转的矩型相交
    inline bool check_collision(const Circle &A, const RectF &B)
    {
        float cX, cY;
        if(A.x < B.X) {
            cX = B.X;
        }
        else if(A.x > (B.X + B.Width)) {
            cX = B.X + B.Width;
        }
        else {
            cX = A.x;
        }

        if(A.y < B.Y) {
            cY = B.Y;
        }
        else if(A.y > (B.Y + B.Height)) {
            cY = B.Y + B.Height;
        }
        else {
            cY = A.y;
        }


        if(distance(A.x, A.y, cX, cY) < A.r) {
            return true;
        }

        return false;
    }

    // 多个矩型同时判断
    inline bool check_collisions(const Circle &A, const std::vector<RectF> &vRects)
    {
        for(auto r : vRects) {
            if(check_collision(A, r)) {
                return true;
            }
        }

        return false;
    }

    // 获得点在旋转之后的 坐标
    inline PointF GetRotatePoint(const PointF &pt, const float fRadius, const PointF &ptCenter, const float dir)
    {
        PointF ptLeftTop = pt;
        // 原来的角度
        float theta = 2 * PI - atan2(ptLeftTop.Y - ptCenter.Y, ptLeftTop.X - ptCenter.X);
        // 旋转之后的角度
        float alpha = dir - theta;
        float offsetX = ptCenter.X + cos(alpha) * fRadius;
        float offsetY = ptCenter.Y + sin(alpha) * fRadius;
        ptLeftTop.X = offsetX;
        ptLeftTop.Y = offsetY;
        return ptLeftTop;
    }

    // 判断圆与旋转矩型相交
    // theta : 为距型的角度
    inline bool check_collision(const Circle &A, const RectF &B, const float alpha)
    {
        // 这里我们不旋转距型,变成旋转圆
        // 圆的角度 = 距型逆向旋转
        float theta = 2 * PI - alpha;
        // 距型中心：既旋转圆的中心
        Circle A2;
        A2.r = A.r;
        PointF ptCenter(B.X + B.Width / 2.0f, B.Y + B.Height / 2.0f);
        auto pt = GetRotatePoint(PointF(A.x, A.y), distance(A.x, A.y, ptCenter.X, ptCenter.Y), ptCenter, theta);
        A2.x = pt.X;
        A2.y = pt.Y;
        return check_collision(A2, B);
    }

    // 距型旋转一定角度之后， 四个顶点的坐标
    inline void GetRotateRectPoints(const RectF &rect, const float dir, std::vector<PointF> &vPts)
    {
        /*
          一以使用矩阵 进行计算
          这里使用的是三角函数进行计算的
        */
        using namespace std;
        vPts.clear();

        // 中心点坐标
        PointF ptCenter(rect.X + rect.Width / 2, rect.Y + rect.Height / 2);
        // 对角线长度的一半
        float fRadius = sqrt(pow(rect.Width / 2, 2) + pow(rect.Height / 2, 2));
        // 计算第一个点
        {
            // 原来的坐标
            PointF ptLeftTop(rect.X, rect.Y);
            vPts.push_back(GetRotatePoint(ptLeftTop, fRadius, ptCenter, dir));
        }
        {
            // 原来的坐标
            PointF ptLeftTop(rect.X + rect.Width, rect.Y);
            vPts.push_back(GetRotatePoint(ptLeftTop, fRadius, ptCenter, dir));
        }
        {
            // 原来的坐标
            PointF ptLeftTop(rect.X + rect.Width, rect.Y + rect.Height);
            vPts.push_back(GetRotatePoint(ptLeftTop, fRadius, ptCenter, dir));
        }
        {
            // 原来的坐标
            PointF ptLeftTop(rect.X, rect.Y + rect.Height);
            vPts.push_back(GetRotatePoint(ptLeftTop, fRadius, ptCenter, dir));
        }
        return ;
    }
}
```

:::



:::details `GameHit.cpp`

```c
#include "stdafx.h"
#include "GameHit.h"
```

:::



:::details `GameMap.h`

```c
#pragma once

#include "Wall.h"
#include "Bullet.h"

class CGamePathFinder;

/*
    代表中地图中的一个方块
    四周可能有墙不可通过， 中间是空地可以通过
*/
class CGameMapElement : public CGameEntryMoveable
{
public:
    CGameMapElement();
    CGameMapElement(float x, float y
                    , bool bLeft, bool bTop, bool bRight, bool bBottom
                    , float wallLen = 10, float spaceLen = 80);

    ~CGameMapElement();

    virtual void Draw(Graphics &gh) const;
    // 四个方向上面是否有墙
    bool m_bLeft{ false };
    bool m_bTop{ false };
    bool m_bRight{ false };
    bool m_bBottom{ false };

    // 代表四个方向
    typedef enum { EWLeft = 0, EWTop, EWRight, EWBottom, EWSize } EWallIndex;

    // 重载运算符 可以像数组一样取到本地块的墙
    const CWall &operator[](CGameMapElement::EWallIndex eIndex) const
    {
        return m_wallArray[eIndex];
    };

    // 设置空地的颜色
    void SetSpaceColor(Color clr)
    {
        m_sapceClr = clr;
    }

private:
    // 空地的颜色
    Color m_sapceClr{ Color(0xE6, 0xE6, 0xE6) };

    // 墙的宽度
    float m_wallWidth{ 10 };

    // 中间空地的宽度
    float m_spaceLen{ 80 };

    // 代表四面的墙 : 左上右下, 注意顺序
    CWall m_wallArray[4];
};

/* 代表整个地图
*/
class CGameMap : public CGameEntryMoveable
{
public:
    CGameMap();
    CGameMap(int x, int y, int width, int height);
    virtual ~CGameMap();

    // 载入地图
    void LoadMap();

    // 画地图
    virtual void Draw(Gdiplus::Graphics &gh) const;

    // 子弹撞墙处理
    bool HitWallProcess(const CBullet &blt) const;

    // 判断是否撞上墙，如查撞上了，返回 返射角，撞墙的时间
    bool GetHitWallInfo(const CBullet &blt, float *pTime = nullptr, float *pDir = nullptr) const;

    // 坦克是否撞墙
    bool IsHitTheWall(const CTankEntry &tank, bool bForward) const;

    // 获得一个可以放置物品的位置，位置是随机的
    bool FindRandomPosition(PointF &ptCenter) const;

    // 判断当前物所在的坐标, x : 返回在第几行,y : 返回在第几列
    bool FindObjPosition(const CGameEntryMoveable &obj, int &row, int &col) const;

    /// ///////////////////////////////////////////////////////////////////////////////
    /// 路径 搜索
    //  path 返回路径 [起点，。。。， 终点]
    void FindPath(int startX, int startY, int targetX, int targetY, VPath &path) const;

    // 获得下一次的前进方向
    bool FindNextDirection(float *dir, int startX, int startY, int targetX, int targetY) const;

    // 获得某块的中心点位置
    PointF GetElementAreaCenter(int row, int col) const;

    // 判断现在发射子弹是否可以打到玩家
    bool IsCanKillTarget(const CGameEntryMoveable &bot, const CGameEntryMoveable &target, float *dir = nullptr) const;

private:
    // 存讲所有的地图
    std::vector<std::vector<CGameMapElement>> m_arr;

    // 整个地图的范围
    Gdiplus::Rect m_rectMap{ 0, 0, 800, 600 };

    // 地图中墙的宽度
    int m_wallWidth{ 7 };

    // 地图中中间空位的宽度
    int m_spaceLen{ 42 };
private:
    // 路径搜索
    CGamePathFinder *m_finder{ nullptr };
};
```

:::



:::details `GameMap.cpp`

```c
#include "stdafx.h"
#include "GameMap.h"
#include "Bullet.h"
#include "GamePathFinder.h"

CGameMapElement::CGameMapElement()
{
}

CGameMapElement::~CGameMapElement()
{

}

CGameMapElement::CGameMapElement(float x, float y
                                 , bool bLeft, bool bTop, bool bRight, bool bBottom
                                 , float wallWidth, float spaceLen)
    : m_bLeft(bLeft), m_bTop(bTop), m_bRight(bRight), m_bBottom(bBottom)
    , m_wallWidth(wallWidth)
    , m_spaceLen(spaceLen)
{
    RectF rectf(x, y, spaceLen + 2 * wallWidth, spaceLen + 2 * wallWidth);
    SetRect(rectf);

    // 四面的墙的初始化
    {
        {
            CWall &w = m_wallArray[EWLeft];
            w.SetRect(RectF(x, y, wallWidth, spaceLen + 2 * wallWidth));
            w.SetDir(CWall::EDirectionY);
        }
        {
            CWall &w = m_wallArray[EWRight];
            w.SetRect(RectF(x + wallWidth + spaceLen, y, wallWidth, spaceLen + 2 * wallWidth));
            w.SetDir(CWall::EDirectionY);
        }
        {
            CWall &w = m_wallArray[EWTop];
            w.SetRect(RectF(x, y, spaceLen + 2 * wallWidth, wallWidth));
            w.SetDir(CWall::EDirectionX);
        }
        {
            CWall &w = m_wallArray[EWBottom];
            w.SetRect(RectF(x, y + wallWidth + spaceLen, spaceLen + 2 * wallWidth, wallWidth));
            w.SetDir(CWall::EDirectionX);
        }
    }
}

void CGameMapElement::Draw(Graphics &gh) const
{
    // 画空位置
    {
        SolidBrush spaceBrush(m_sapceClr);
        RectF rect(GetRect().X + m_wallWidth, GetRect().Y + m_wallWidth, m_spaceLen + m_wallWidth, m_spaceLen + m_wallWidth);
        gh.FillRectangle(&spaceBrush, rect);
    }

    // 画四周的墙
    if(m_bLeft) {
        m_wallArray[EWLeft].Draw(gh);
    }

    if(m_bTop) {
        m_wallArray[EWTop].Draw(gh);
    }

    if(m_bRight) {
        m_wallArray[EWRight].Draw(gh);
    }

    if(m_bBottom) {
        m_wallArray[EWBottom].Draw(gh);
    }
}


/// ////////////////////////////////////////////////////////////////////////////////

CGameMap::CGameMap()
{
    LoadMap();
}

CGameMap::CGameMap(int x, int y, int width, int height) : m_rectMap(x, y, width, height)
{
    m_finder = nullptr;
    LoadMap();
}

CGameMap::~CGameMap()
{
    SAFE_DEL_PTR(m_finder);
}

// 载入地图
void CGameMap::LoadMap()
{
    // 一个占用的空间宽高
    int Space1Element = m_wallWidth + m_spaceLen;
    // 计算多少行， 多少列
    int m_row = 0, m_col = 0;
    {
        m_row = m_rectMap.Height / Space1Element;
        m_col = m_rectMap.Width / Space1Element;
    }

    if(m_row <= 0 || m_col <= 0) {
        AfxMessageBox(_T("地图数据不正"));
        return;
    }
    //生成地图
    srand(GetTickCount());
    m_arr.clear();
    int step = Space1Element;
    for(int r = 0; r < m_row; ++r) {
        // 一行地图空间
        vector<CGameMapElement> vRow;
        // 列数据
        for(int c = 0; c < m_col; ++c) {
            vRow.push_back(CGameMapElement(
                               static_cast<float>(m_rectMap.X + c * step)
                               , static_cast<float>(m_rectMap.Y + r * step)
                               , c == 0 ? true : (1 == rand() % 5)
                               , r == 0 ? true : (1 == rand() % 5)
                               , c == m_col - 1 ? true : (1 == rand() % 5)
                               , r == m_row - 1 ? true : (1 == rand() % 5)
                               , static_cast<float>(m_wallWidth), static_cast<float>(m_spaceLen)
                           ));
        }
        // 追加一行
        m_arr.push_back(vRow);
    }

    // 由于四周的墙是随机生成的，所以会有重复的;
    // 对地图进行处理。去掉重复的墙
    for(size_t m_row = 1; m_row < m_arr.size(); ++m_row) {
        for(size_t m_col = 1; m_col < m_arr[m_row].size(); ++m_col) {
            auto &a = m_arr[m_row][m_col];
            // 上面的
            auto const &top = m_arr[m_row - 1][m_col];
            // 左边的
            auto const &left = m_arr[m_row][m_col - 1];
            if(top.m_bBottom && a.m_bTop) {
                a.m_bTop = false;
            }
            if(left.m_bRight && a.m_bLeft) {
                a.m_bLeft = false;
            }
        }
    }

    // 对地图进行处理，去掉 完全封闭的区域


    // 初始化查找工具
    SAFE_DEL_PTR(m_finder);
    m_finder = new CPathFinderBFS(m_arr);
}

// 画地图
void CGameMap::Draw(Gdiplus::Graphics &gh) const
{
    int m_col = m_arr[0].size();
    int m_row = m_arr.size();
    for(int y = 0; y != m_col; ++y) {
        for(int x = 0; x != m_row; ++x) {
            m_arr[x][y].Draw(gh);
        }
    }
}

// 子弹撞墙处理
bool CGameMap::HitWallProcess(const CBullet &blt) const
{
    float delay, dir;
    bool b = GetHitWallInfo(blt, &delay, &dir);
    // 改变方向
    if(b) {
        const_cast<CBullet &>(blt).SetDirectionArc(dir);
    }

    return b;
}

// 判断是否撞上墙，如查撞上了，返回 返射角，撞墙的时间
bool CGameMap::GetHitWallInfo(const CBullet &blt, float *pTime /*= nullptr*/, float *pDir /*= nullptr*/) const
{
    // 查找产生碰撞的墙
    struct info {
        CWall const &w; // 相交的墙
        PointF ptHit; // 相交点
        float dir; // 返射速度
        float delay; // 相交时间
    };

    vector<struct info> v;
    for(auto &line : m_arr) {  // 行
        for(auto &ele : line) {  // 列
            // 有墙，且产生碰撞
            PointF ptHit;
            float dir;
            float delay;
            if(ele.m_bLeft && ele[CGameMapElement::EWLeft].CheckHit(blt, &ptHit, &dir, &delay)) {
                struct info s {
                    ele[CGameMapElement::EWLeft], ptHit, dir, delay
                };
                v.push_back(s);
            }
            if(ele.m_bTop && ele[CGameMapElement::EWTop].CheckHit(blt, &ptHit, &dir, &delay)) {
                struct info s {
                    ele[CGameMapElement::EWTop], ptHit, dir, delay
                };
                v.push_back(s);
            }
            if(ele.m_bRight && ele[CGameMapElement::EWRight].CheckHit(blt, &ptHit, &dir, &delay)) {
                struct info s {
                    ele[CGameMapElement::EWRight], ptHit, dir, delay
                };
                v.push_back(s);
            }
            if(ele.m_bBottom && ele[CGameMapElement::EWBottom].CheckHit(blt, &ptHit, &dir, &delay)) {
                struct info s {
                    ele[CGameMapElement::EWBottom], ptHit, dir, delay
                };
                v.push_back(s);
            }
        }
    }
    if(v.empty()) {
        return false;
    }
    // 查找最先撞击的墙面
    auto it = std::min_element(v.begin(), v.end(), [](auto & lhs, auto & rhs)->bool {
        return lhs.delay < rhs.delay;
    });

    // 返回撞墙信息
    if(pTime) {
        *pTime = it->delay;
    }

    if(*pDir) {
        *pDir = it->dir;
    }
    return true;
}

// 判断
bool CGameMap::IsHitTheWall(const CTankEntry &tank, bool bForward) const
{
    // 判断所有的墙，查看是否产生碰撞
    for(auto &line : m_arr) {  // 行
        for(auto &ele : line) {  // 列
            // 有墙，且产生碰撞
            if(ele.m_bLeft && ele[CGameMapElement::EWLeft].IsWillHit(tank, bForward)) {
                return true;
            }
            if(ele.m_bTop && ele[CGameMapElement::EWTop].IsWillHit(tank, bForward)) {
                return true;
            }
            if(ele.m_bRight && ele[CGameMapElement::EWRight].IsWillHit(tank, bForward)) {
                return true;
            }
            if(ele.m_bBottom && ele[CGameMapElement::EWBottom].IsWillHit(tank, bForward)) {
                return true;
            }
        }
    }
    return false;
}


// 获得一个可以放置物品的位置，位置是随机的
bool CGameMap::FindRandomPosition(PointF &ptCenter) const
{
    if(m_arr.empty() || m_arr[0].empty()) {
        return false;
    }
    try {
        // 随机产生 行，列
        size_t m_row, m_col;
        m_row = static_cast<size_t>(rand()) % m_arr.size();
        m_col = static_cast<size_t>(rand()) % m_arr[0].size();
        // 获得选中的 地图块的 中心点
        ptCenter = m_arr[m_row][m_col].GetCenterPoint();
    }
    catch(...) {
        return false;
    }
    return true;
}

// 判断当前物所在的坐标, x : 返回在第几行,y : 返回在第几列
bool CGameMap::FindObjPosition(const CGameEntryMoveable &obj, int &row, int &col) const
{
    PointF ptCenter = obj.GetCenterPoint();
    size_t m_row = m_arr.size();
    size_t m_col = m_arr[0].size();
    for(size_t _x = 0; _x != m_row; ++_x) {
        for(size_t _y = 0; _y != m_col; ++_y) {
            RectF rc = m_arr[_x][_y].GetRect();
            if(rc.Contains(ptCenter)) {
                row = _x, col = _y;
                return true;
            }
        }
    }
    // 没有找到？
    return false;
}

//  path 返回路径 [起点，。。。， 终点]
void CGameMap::FindPath(int startX, int startY, int targetX, int targetY, VPath &path) const
{
    path.clear();
    m_finder->FindPath(startX, startY, targetX, targetY, path);
}

// 获得下一次的前进方向
bool CGameMap::FindNextDirection(float *dir, int startX, int startY, int targetX, int targetY) const
{
    VPath path;
    FindPath(startX, startY, targetX, targetY, path);
    if(path.empty()) {
        return false;
    }

    // 获得第一个位置
    auto it = path.begin();
    it++;

    if(it == path.end()) {
        return false;
    }

    it->x;
    it->y;
    // 判断在哪个方向？
    if(startX == it->x) {
        // 同一行
        if(startY < it->y) {
            // 左侧
            *dir = 90;
        }
        else if(startY > it->y) {
            // 右侧
            *dir = 270;
        }
        else {

        }
    }
    else if(startY == it->y) {
        // 同一列
        if(startX < it->x) {
            // 上方
            *dir = 180;
        }
        if(startX > it->x) {
            // 下方
            *dir = 0;
        }
    }
    else {

    }
    return true;
}

// 获得某块的中心点位置
PointF CGameMap::GetElementAreaCenter(int row, int col) const
{
    try {
        return m_arr[row][col].GetCenterPoint();
    }
    catch(...) {
        return PointF(-1, -1);
    }
}

// 判断现在发射子弹是否可以打到玩家
bool CGameMap::IsCanKillTarget(const CGameEntryMoveable &bot, const CGameEntryMoveable &target, float *dir/* = nullptr*/) const
{
    // 机器人，玩家 所在的位置
    int startRow, startCol, targetRow, targetCol;
    if(!FindObjPosition(bot, startRow, startCol) || !FindObjPosition(target, targetRow, targetCol)) {
        return false;
    }
    // 横坚都不在一个方向上
    if(startRow != targetRow && startCol != targetCol) {
        return false;
    }
    // 查看四方向，是否可以打到目标
    if(startCol == targetCol && startRow == targetRow) {
        if(dir) {
            *dir = 0;
        }
        return true;
    }
    // 坚向查看
    if(startCol == targetCol) {
        // 向下查看
        if(startRow < targetRow) {
            int col = startCol;
            for(int row = startRow; row <= targetRow; ++row) {
                auto &ele = m_arr[row][col];
                if(row == startRow) {
                    if(ele.m_bBottom) {
                        return false;
                    }
                }
                else if(row == targetRow) {
                    if(ele.m_bTop) {
                        return false;
                    }
                }
                else {
                    if(ele.m_bBottom || ele.m_bTop) {
                        return false;
                    }
                }
            }
            if(dir) {
                *dir = PI;
            }
            return true;
        }
        // 向上查看
        else {
            int col = startCol;
            for(int row = startRow; row >= targetRow; --row) {
                auto &ele = m_arr[row][col];
                if(row == targetRow) {
                    if(ele.m_bBottom) {
                        return false;
                    }
                }
                else if(row == startRow) {
                    if(ele.m_bTop) {
                        return false;
                    }
                }
                else {
                    if(ele.m_bBottom || ele.m_bTop) {
                        return false;
                    }
                }
            }
            if(dir) {
                *dir = 0;
            }
            return true;
        }
    }
    // 横向查看
    if(startRow == targetRow) {
        // 向右查看
        if(startCol < targetCol) {
            int row = startRow;
            for(int col = startCol; col <= targetCol; ++col) {
                auto &ele = m_arr[row][col];
                if(col == startCol) {
                    if(ele.m_bRight) {
                        return false;
                    }
                }
                else if(col == targetCol) {
                    if(ele.m_bLeft) {
                        return false;
                    }
                }
                else {
                    if(ele.m_bLeft || ele.m_bRight) {
                        return false;
                    }
                }
            }
            if(dir) {
                *dir = PI / 2.0f;
            }
            return true;
        }
        // 向左查看
        else {
            int row = startRow;
            for(int col = startCol; col >= targetCol; --col) {
                auto &ele = m_arr[row][col];
                if(col == targetCol) {
                    if(ele.m_bRight) {
                        return false;
                    }
                }
                else if(col == startCol) {
                    if(ele.m_bLeft) {
                        return false;
                    }
                }
                else {
                    if(ele.m_bLeft || ele.m_bRight) {
                        return false;
                    }
                }
            }

            if(dir) {
                *dir = PI * 1.5f;
            }
            return true;
        }
    }

    return false;
}

```

:::





:::details `GamePathFinder.h`

```c
#pragma once
#include "Wall.h"
#include "Bullet.h"
#include "GameMap.h"
class CGamePathFinder
{
public:
    CGamePathFinder(const std::vector<std::vector<CGameMapElement>> &arr) : m_arr(arr)
    {
        m_col = m_arr[0].size();
        m_row = m_arr.size();
    }

    ~CGamePathFinder()
    {
    }

    /// ///////////////////////////////////////////////////////////////////////////////
    /// 路径 搜索

    // 两点之间的寻路:判断两个地图块之间是否连通
    // 使用广度优先算法，查找最小路径
    // x,y:起始位置
    // dx,dy:最终位置
    virtual void FindPath(int startX, int startY, int targetX, int targetY, VPath &path) = 0;

protected:

    int m_targetX, m_targetY;
    // 地图的列数
    // 地图的行数
    int m_col, m_row;


#define MAX_STEP 99999999
    //记录最小步数 : 初始设置一个很大的值，如果查找完值还是这个值，则说明不是连通的
    int m_minStep{ MAX_STEP };
    // 记录 哪些路径是否走过 : 走过=true,否则=false
    std::vector<std::vector<bool>> m_mark;
    // 记录 临时搜索路径
    VPath m_path;
    // 地图的索引
    const std::vector<std::vector<CGameMapElement>> &m_arr;
};

// 使用广度优先搜索
class CPathFinderBFS : public CGamePathFinder
{
public:
    CPathFinderBFS(const std::vector<std::vector<CGameMapElement>> &arr) : CGamePathFinder(arr)
    {

    }

    ~CPathFinderBFS()
    {
    }

    /// ///////////////////////////////////////////////////////////////////////////////
    /// 路径 搜索

    // 使用广度优先算法，查找最小路径
    // x,y:起始位置
    // dx,dy:最终位置
    virtual void FindPath(int startX, int startY, int targetX, int targetY, VPath &path)
    {
        m_targetX = targetX, m_targetY = targetY;
        bfs(startX, startY, targetX, targetY, path);
    }

private:
    //记录路径
    class CNode
    {
    public:
        CNode()
            : x(0)
            , y(0)
            , s(0)
            , parent(nullptr)
        {
        }

        CNode(int _x, int _y, int _s, CNode *p = nullptr)
            : x(_x)
            , y(_y)
            , s(_s)
            , parent(p)
        {
        }


        CNode(const CNode &rhs)
        {
            if(&rhs != this) {
                this->x = rhs.x;
                this->y = rhs.y;
                this->s = rhs.s;
                this->parent = rhs.parent;
            }
        }
        CNode &operator=(const CNode &rhs)
        {
            if(&rhs != this) {
                this->x = rhs.x;
                this->y = rhs.y;
                this->s = rhs.s;
                this->parent = rhs.parent;
            }
            return *this;
        }
        //~CNode() {
        //    if (parent) {
        //        delete parent;
        //        parent = nullptr;
        //    }
        //}

        int x, y; // 坐标
        int s; // 步数
        shared_ptr<CNode> parent; // 父结点
    };

    // 定义深度优先搜索函数
    //  x,y 当前所在的行，列
    bool bfs_item(int x, int y)
    {
        bool bFind = false;
        // 存讲未访问的可连通的结点
        std::queue<CNode> q_open;
        // 起点加入到队列中
        q_open.push(CNode(x, y, 0, nullptr));
        // 标记走过了
        m_mark[x][y] = true;
        // 当队列不为空的时候
        while(!q_open.empty()) {
            // 头部的出队，并检查结果
            auto curr = q_open.front();
            q_open.pop();
            // 到达目的地
            if(curr.x == m_targetX && curr.y == m_targetY) {
                m_minStep = curr.s;
                CNode *p = &curr; //当前点就是目的地
                while(p) {
                    PathNode n;
                    n.x = p->x;
                    n.y = p->y;
                    m_path.push_back(n);
                    p = p->parent.get();
                }
                bFind = true;
                while (!q_open.empty()) {
                    q_open.pop();
                }
                break;
            }
            // 遍历周边的点,放入队列
            {
                // 当前位置
                auto const &ele = m_arr[curr.x][curr.y];
                /// 分别判断四个方向是否可以走
                //左
                {
                    // 坐标为
                    int nx = curr.x;
                    int ny = curr.y - 1;
                    if(!(nx < 0 || nx >= m_row || ny < 0 || ny >= m_col) && m_mark[nx][ny] == false) {
                        if(!ele.m_bLeft && !m_arr[nx][ny].m_bRight) {
                            q_open.push(CNode(nx, ny, 1 + curr.s, new CNode(curr)));
                            m_mark[nx][ny] = true;
                        }
                    }
                }
                //上
                {
                    // 坐标为
                    int nx = curr.x - 1;
                    int ny = curr.y;
                    if(!(nx < 0 || nx >= m_row || ny < 0 || ny >= m_col) && m_mark[nx][ny] == false) {
                        if(!ele.m_bTop && !m_arr[nx][ny].m_bBottom) {
                            q_open.push(CNode(nx, ny, 1 + curr.s, new CNode(curr)));
                            m_mark[nx][ny] = true;
                        }
                    }
                }
                //右
                {
                    // 坐标为
                    int nx = curr.x;
                    int ny = curr.y + 1;
                    if(!(nx < 0 || nx >= m_row || ny < 0 || ny >= m_col) && m_mark[nx][ny] == false) {
                        if(!ele.m_bRight && !m_arr[nx][ny].m_bLeft) {
                            q_open.push(CNode(nx, ny, 1 + curr.s, new CNode(curr)));
                            m_mark[nx][ny] = true;
                        }
                    }
                }
                //下
                {
                    // 坐标为
                    int nx = curr.x + 1;
                    int ny = curr.y;
                    if(!ele.m_bBottom && !m_arr[nx][ny].m_bTop) {
                        if(!(nx < 0 || nx >= m_row || ny < 0 || ny >= m_col) && m_mark[nx][ny] == false) {
                            q_open.push(CNode(nx, ny, 1 + curr.s, new CNode(curr)));
                            m_mark[nx][ny] = true;
                        }
                    }
                }
            }
        } // end while(!q_open.empty())

        return bFind;
    };

    // dfs 深度优先搜索
    bool bfs(int x, int y, int m_targetX, int m_targetY, VPath &path)
    {
        // 初始化标记数组 : 开始全部未走过
        m_mark.clear();
        for(int i = 0; i < m_row; ++i) {
            vector<bool> vLine(m_col, false);
            m_mark.push_back(vLine);
        }
        // 路径清空
        m_path.clear();

        // 初始化标记数组 : 开始全部未走过
        m_nodes.clear();
        for(int x = 0; x < m_row; ++x) {
            vector<CNode> vLine;
            for(int y = 0; y < m_row; ++y) {
                CNode node;
                node.x = x;
                node.y = y;
                node.s = 0;
                vLine.push_back(node);
            }
            m_nodes.push_back(vLine);
        }
        // 从起点开始查找 : 标记起点坐标己经在路径中，防止后面重复走
        m_mark[x][y] = true;
        // 开始 深度优先搜索
        bool bFind = bfs_item(x, y);
        if(bFind) {
            std::copy(m_path.rbegin(), m_path.rend(), back_inserter<VPath>(path));
        }

        return bFind;
    };
    vector<vector<CNode>> m_nodes;
};
```

:::



:::details `Wall.h`

```c
#pragma once
#include "GameEntry.h"
#include "Bullet.h"

class CWall : public CGameEntryMoveable
{

public:
    enum EWallDirection {EDirectionX /*横向*/, EDirectionY/*纵向*/};

public:
    CWall();
    CWall(float x, float y, float width, float length, CWall::EWallDirection dir);
    virtual ~CWall();

    // 画自己
    virtual void Draw(Graphics &gh) const;

    // 设置方向
    void SetDir(CWall::EWallDirection dir);

    // 获得方向
    CWall::EWallDirection GetDir() const;

public:
    // 如果 小球撞上墙,则改变方向和位置(调整为刚好不撞墙的位置)
    bool HitAction(CBullet &moveObj) const;

    // 判断是否碰撞，如果发生碰撞，返回碰撞点，及反射角
    bool CheckHit(const CBullet &moveObj, PointF *ptHit = nullptr, float *dir = nullptr, float *pDelay = nullptr) const;

    // 下一步是否会撞上墙
    bool IsWillHit(const CTankEntry &tank, bool bForward) const;

private:
    // 判断小球撞上墙的哪一边,如果相撞，返回最先碰撞的那一边的碰撞信息
    bool CheckHitEx(const CBullet &moveObj, PointF *ptHit = nullptr, float *dir = nullptr, float *pDelay = nullptr) const;

private:


    //墙的方向:只有两种方向 横向，坚向
    EWallDirection m_direction;

    // 墙的颜色
    mutable Color m_clr{0x4D, 0x4D, 0x4D};
};
```

:::



:::details `Wall.cpp`

```c
#include "stdafx.h"
#include "Wall.h"
#include "TankEntry.h"
#include "GameHit.h"


CWall::CWall()
{
}


CWall::CWall(float x, float y, float width, float length, CWall::EWallDirection dir) : m_direction(dir)
{
}


CWall::~CWall()
{
}

void CWall::Draw(Graphics &gh) const
{
    SolidBrush brush(m_clr);
    gh.FillRectangle(&brush, GetRect());
}

// 设置方向
void CWall::SetDir(CWall::EWallDirection dir)
{
    m_direction = dir;
}

// 获得方向
CWall::EWallDirection CWall::GetDir() const
{
    return m_direction;
}

// 如果 小球撞上墙,则改变方向和位置(调整为刚好不撞墙的位置)
bool CWall::HitAction(CBullet &blt) const
{
    bool b = false;
    using namespace game_hit;

    auto ptCenter = blt.GetCenterPoint();
    auto speed = blt.GetSpeed();
    // 圆心 + 速度
    CMovePoint ray(ptCenter.X, ptCenter.Y,
                   speed * sin(blt.GetDirectionArc()), // x方向分量
                   -speed * cos(blt.GetDirectionArc()) // y方向分量
                  );


    RectF rc = GetRect();
    CLine line;
    // 横墙 抽像成 横线
    if(m_direction == EDirectionX) {
        line.startPoint.x = rc.X;
        line.startPoint.y = rc.Y + rc.Height / 2.0f;
        line.endPoint.x = rc.X + rc.Width;
        line.endPoint.y = rc.Y + rc.Height / 2.0f;
    }
    // 坚墙 抽像成  坚线
    else {
        line.startPoint.x = rc.X + rc.Width / 2.0f;
        line.startPoint.y = rc.Y;
        line.endPoint.x = rc.X + rc.Width / 2.0f;
        line.endPoint.y = rc.Y + rc.Height;
    }
    CVector2D newSpeed, crossPoint;
    b = game_hit::IsHit(ray, line, newSpeed, crossPoint);
    if(b) {
        float dir = atan2f(newSpeed.x, -newSpeed.y); // atan2f()
        blt.SetDirection(dir * (180 / PI));
    }
    return b;
}

// 判断是否碰撞，如果发生碰撞，返回碰撞点，及反射角
bool CWall::CheckHit(const CBullet &blt, PointF *ptHit/*=nullptr*/, float *dir/*=nullptr*/, float *pDelay/*=nullptr*/) const
{
    return CheckHitEx(blt, ptHit, dir, pDelay);
}

// 判断小球撞上墙的哪一边,如果相撞，返回最先碰撞的那一边的碰撞信息
bool CWall::CheckHitEx(const CBullet &blt, PointF *ptHit/*=nullptr*/, float *dir/*=nullptr*/, float *pDelay/*=nullptr*/) const
{
    using namespace game_hit;

    auto ptCenter = blt.GetCenterPoint();
    auto speed = blt.GetSpeed();
    // 圆心 + 速度
    CMovePoint ray(ptCenter.X, ptCenter.Y,
                   speed * sin(blt.GetDirectionArc()), // x方向分量
                   -speed * cos(blt.GetDirectionArc()) // y方向分量
                  );


    RectF rc = GetRect();
    vector<tuple<CVector2D, float, float>> v;
    {
        //  左线
        {
            CLine line;
            line.startPoint.x = rc.X;
            line.startPoint.y = rc.Y;
            line.endPoint.x = rc.X;
            line.endPoint.y = rc.Y + rc.Height;

            // 新速度
            CVector2D newSpeed;
            // 撞击点
            CVector2D crossPoint;
            // 相交比例
            float fDelay;
            if(game_hit::IsHit(ray, line, newSpeed, crossPoint, &fDelay)) {
                // 反射角度
                float theta = atan2f(newSpeed.x, -newSpeed.y);
                v.push_back(make_tuple(crossPoint, fDelay, theta));
            }

        }

        // 上线
        {
            CLine line;
            line.startPoint.x = rc.X;
            line.startPoint.y = rc.Y;
            line.endPoint.x = rc.X + rc.Width;
            line.endPoint.y = rc.Y;

            // 新速度
            CVector2D newSpeed;
            // 撞击点
            CVector2D crossPoint;
            // 相交比例
            float fDelay;
            if(game_hit::IsHit(ray, line, newSpeed, crossPoint, &fDelay)) {
                // 反射角度
                float theta = atan2f(newSpeed.x, -newSpeed.y);
                v.push_back(make_tuple(crossPoint, fDelay, theta));
            }

        }

        // 右线
        {
            CLine line;
            line.startPoint.x = rc.X + rc.Width;
            line.startPoint.y = rc.Y;
            line.endPoint.x = rc.X + rc.Width;
            line.endPoint.y = rc.Y + rc.Height;

            // 新速度
            CVector2D newSpeed;
            // 撞击点
            CVector2D crossPoint;
            // 相交比例
            float fDelay;
            if(game_hit::IsHit(ray, line, newSpeed, crossPoint, &fDelay)) {
                // 反射角度
                float theta = atan2f(newSpeed.x, -newSpeed.y);
                v.push_back(make_tuple(crossPoint, fDelay, theta));
            }

        }

        // 下线
        {
            CLine line;
            line.startPoint.x = rc.X;
            line.startPoint.y = rc.Y + rc.Height;
            line.endPoint.x = rc.X + rc.Width;
            line.endPoint.y = rc.Y + rc.Height;

            // 新速度
            CVector2D newSpeed;
            // 撞击点
            CVector2D crossPoint;
            // 相交比例
            float fDelay;
            if(game_hit::IsHit(ray, line, newSpeed, crossPoint, &fDelay)) {
                // 反射角度
                float theta = atan2f(newSpeed.x, -newSpeed.y);
                v.push_back(make_tuple(crossPoint, fDelay, theta));
            }

        }
    }
    // 进行排序
    if(!v.empty()) {
        auto it = std::min_element(v.begin(), v.end(), [](auto & lhs, auto & rhs)->bool {
            return std::get<1>(lhs) < std::get<1>(rhs);
        });
        if(ptHit) {
            ptHit->X = get<0>(*it).x;
            ptHit->Y = get<0>(*it).y;
        }
        if(pDelay) {
            * pDelay = get<1>(*it);
        }
        if(dir) {
            *dir = get<2>(*it);
        }
        return true;
    }

    return false;
}


// 下一步是否会撞上墙
bool CWall::IsWillHit(const CTankEntry &tank, bool bForward) const
{
    // 获得一下步的位置，如果要撞上了，就不移动
    if(bForward) {
        RectF r = tank.ForwardNextRect();
        if(r.Intersect(GetRect())) {
            return true;
        }
    }
    else {
        RectF r = tank.BackwardNextRect();
        if(r.Intersect(GetRect())) {
            return true;
        }
    }
    return false;
}
```

:::

### 画出游戏地图，控制运行轨迹

本节将实现地图的绘制，并使用地图控制对象的运行轨迹。

#### 画出地图对象

前文已经编写好地图对象的相关代码，画出地图需要在`CGame`类的绘制函数中调用地图类`CGameMap`自身的方法`“Draw()”`，调用方法如下:

在Game.h文件顶部`“#include "Bot.h"”`下方增加一行:

:::details `CGame.h`

```c
#include "GameMap.h"
```

:::

在`“std::list<CBullet> m_lstBullets;”`下方增加:

```c
CGameMap m_mapi 10,10，780,580 }; //地图对象
```

这一句增加并初始化了一个地图对象。接下来只要在游戏帧方法中调用地图对象自己的Draw方法，画出地图对象即可。
打开Game.cpp文件找到游戏绘图方法`“void CGame:GamcRunDraw);”`，找到方法内的`“//画入内存”`一行，将下方括号内的内容修改为如下代码:

:::details `Game.cpp`

```c
m_map.Draw(gh); 					// 画出地图
m_player01.Draw(gh); 				// 画坦克(玩家一)
for(auto &blt : m_lstBullets) {	// 画子弹(所有存在于地图上的子弹)
    blt.Draw(gh);
}
```

map.Draw(gh)调用了地图对象自身绘制方法，绘制地图自身。这里同时调用了玩家的绘制方法和子弹的绘制方法。

:::



运行程序，结果如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240622224646366.png)





#### 逻辑处理

:::details `Game.cpp`

```c
        if(KEYDOWN(VK_UP)) {
            // 坦克撞墙检测试
            {
                if(m_map.IsHitTheWall(m_player01, true)) {
                    m_player01.ChangeDirection(true);     // 撞墙了，改变方向
                }
                else {
                    m_player01.Forward();                  // 没有撞墙，继续前进
                }
            }
        }
```

:::



接下来调整一下坦克的初始位置，如果坦克一出现就在墙的位置上，相当于坦克一开始就是嵌在墙里面的，这样坦克就寸步难行了，所以在坦克初始化时，要把坦克随机放到“空地”上。
然后，增加一个初始化方法，负责载入地图，及初始化坦克等工作。



打开Game.h文件，在`“CGameMap m map{10,10,780,580 };”`下方增加如下代码:



:::details `Game.h`

```c
bool CGame::GameInitOne2Bot();//游戏初始化:人机大战
```

:::



下面实现这个方法，该方法通过`LoadMap()`方法载入地图数据;设置玩家一的图片;调用地图类的`FindRandomPosition()`函数在地图中寻找一个空白点，把玩家一放入“空地”中;最后清空子弹数组。在`Game.cpp`文件最下方增加如下代码:

:::details `Game.cpp`

```c
// 游戏初始化 : 单人对电脑
bool CGame::GameInitOne2Bot()
{
    {
        m_map.LoadMap();// 载入地图
        // 玩家一
        {
            m_player01 = CPlayer(0, 0, _T("tank_player1.png"));
            PointF ptCenter;
            if(!m_map.FindRandomPosition(ptCenter)) {
                AfxMessageBox(_T("调整Player01位置失败"));
            }
            else {
                 // 设置玩家一的中心点，让玩家一处于地图格子的正中间位置
                m_player01.SetCenterPoint(ptCenter);    
            }
        }
 
        // 子弹
        m_lstBullets.clear();
    }
    return true;
}

```

:::

在构造方法`“CGame:CGame()”`中增加初始化函数的调用代码，使`CGame`的对象一产生，即进行初始化动作。修改后的代码如下:



:::details `CGame.cpp`

```c
CGame::CGame()
{
    GameInitOne2Bot(); // 初始化人机对战游戏
}
```

:::

> 运行程序，发现坦克现在只能在空地处移动，再也不能穿墙乱跑了。
>
> ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240622225335265.png)



#### 子弹的反射处理

上面的修改限制了坦克的移动，但是子弹还是不能反射，需要遍历所有的子弹依次进行判断，如果撞墙，则变换子弹的方向，然后继续前进。

```c
// 子弹撞墙处理
{
    for(auto &blt : m_lstBullets) { // 子弹是否撞上墙 : 如果撞上了，改变方向等等
        m_map.HitWallProcess(blt);  //  进行撞墙处理
        blt.Move();                   // 子弹移动
    }
}
```

再次运行，子弹就可撞墙反射了。



#### 击中坦克爆炸的实现

坦克类本身具有对被击中的判断函数`“IsHitted()”`，这里只要调用即可，如果被击中，则让坦克“自爆”。
在上面代码下方继续增加如下代码:

```c
// 检查子弹是否击中坦克 :  击中要使坦克爆炸(子弹可不用移除了，因为游戏都结束了)
for (auto &blt : m_lstBullets) {    
    if (m_player01.IsHitted(blt)) {  // 如果玩家一被击中
        m_player01.Bomb();            // 使玩家一“自爆”
    }
    break;
}
```

> 让自己的坦克垂直对着一-面墙发射子弹，子弹反射回来击中自己，坦克爆炸。
>
> ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240622225741476.png)



### 实现完整的游戏

前面各节实现了游戏的基本功能，但目前为止还没有把各部分功能有效地组织起来，形成一个完整的游戏程序。CGame类相当于游戏的总调度师，负责控制整个游戏的流程。下面就来修改这个类，最终实现完整的游戏功能。

本游戏可以分成3个部分

- 1.游戏菜单

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240622225902864.png)

- 2.人机大战

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240622225955570.png)

- 3.双人大战

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240622230015981.png)



在前面各节中设计了游戏中用到的所有对象，主要是菜单、坦克、子弹及地图对象。下面的任务是有效地组织这些对象，使它们“和谐”工作。
组织这些对象的工作，主要在`CGame`类中，其中有部分功能前面已经用过，只需修改`CGame`类的代码，其他类完全不用改动。



`CGame`类的代码在`Game.h`和`Game.cpp`文件中，下面将详解`CGame`类的全部内容。



#### 引进所有游戏对象的声明

所有游戏对象的设计都是服务于CGame类的，因此需要在Game.h文件中引入所有的头文件。打开Game.h文件，删除原内容，输入以下代码:



:::details `Game.h`

```c
#pragma once
 
#include "wall.h"
#include "Bullet.h"
#include "Player.h"
#include "Bot.h"
#include "GameMap.h"
#include "GameMenuPanel.h"
#include "GameMenuPanel2.h"
#include "KeyMenuPlayer02.h"
#include "KeyMenuPlayer01.h"
#include "GameMenuBackground.h"
```

:::

上面代码引入了需要的头文件，全都是前面各节写好的各种对象，此处引入它们的头文件，后续代码就可以使用了。



#### 声明核心对象——CGame类的公有方法

本节代码是`CGame`类的公有方法，定义了类的初始化、游戏帧处理、鼠标消息处理以及游戏步骤相关成员。公有方法是提供给类外的其他代码调用的，如游戏窗体相关代码会调用下面的`OnButton()`方法把鼠标消息传递给`CGame`类。

:::details `Game.h`

```c

class CGame
{
public:
    CGame();
    ~CGame();
 
    // 设置输出窗口的句柄
    void SetHandle(HWND hWnd);
 
    // 进入游戏帧
    bool EnterFrame(DWORD dwTime);
 
    // 处理鼠标移动事件
    void OnMouseMove(UINT nFlags, CPoint point);
 
    // 处理左键抬起事件
    void OnLButtonUp(UINT nFlags, CPoint point);
 
    // 当前游戏所处的阶段
    enum EGameType {
        EGameTypeMenu = 0,		// 选择阶段
        EGameTypeOne2BotMenu,	// 单人对电脑 菜单阶段
        EGameTypeOne2Bot,		// 单人对电脑
        EGameTypeOne2BotEnd,		// 单人对电脑 结束
        EGameTypeOne2OneMenu,	// 双人对战 菜单阶段
        EGameTypeOne2One,		// 双人对战
        EGameTypeOne2OneEnd,		// 双人对战 结束
        EGameTypeCount,			// = 5
    };
 
    // 设置当前游戏所处的阶段,并根据步聚 初始化
    void SetStep(CGame::EGameType step);
```

:::

#### 声明私有方法

私有方法是本类内部需要调用的方法，这些方法不提供给类外部的代码调用，使类外面的代码不能随意修改本类功能，达到了实现隐藏的目的。





- (1）声明初始化方法。该方法包含游戏各个阶段的初始化，如:选择阶段初始化和人机大战阶段初始化等。程序运行时，根据玩家的选择和游戏当前的阶段，分别调用下面对应的方法。同时为了方便调用，把初始化方法放入一个方法指针数组中，这样后面就可以根据游戏所处的阶段直接调用这些方法了。具体代码如下:

:::details `Game.h`

```c
private:
    // 窗口
    HWND m_hWnd;
 
    /* 游戏初始化
    生成 游戏对象，初始化地图，对象位置等
    */
    bool GameInit();
 
    bool GameInitMenu();				// 游戏初始化 : 选择阶段

    bool GameInitOne2BotMenu(); 		// 游戏初始化 : 单人对电脑 菜单阶段

    bool GameInitOne2Bot();			// 游戏初始化 : 单人对电脑

    bool GameInitOne2BotEnd();		// 游戏初始化 : 单人对电脑 结束

    bool GameInitOne2OneMenu();		// 游戏初始化 : 双人对战 菜单阶段

    bool GameInitOne2One();			// 游戏初始化 : 双人对战

    bool GameInitOne2OneEnd();		// 游戏初始化 : 双人对战 结束

    // 把上述方法放入数组，方便调用
    bool (CGame::*m_initFunc[EGameTypeCount])() = {
        &CGame::GameInitMenu,        	// 选择阶段
        &CGame::GameInitOne2BotMenu, 	// 单人对电脑键盘提示
        &CGame::GameInitOne2Bot,     	// 单人对电脑
        &CGame::GameInitOne2BotEnd,  	// 单人对电脑 结束
        &CGame::GameInitOne2OneMenu, 	// 双人对战键盘提示
        &CGame::GameInitOne2One,      	// 双人对战
        &CGame::GameInitOne2OneEnd   	// 双人对战 结束
    };
```

:::

- (2）声明游戏逻辑处理方法。该方法包含游戏各个阶段的逻辑处理。程序运行时，根据游戏当前的阶段，分别调用下面对应的方法，以实现对各个阶段的不相同的逻辑处理，如:双人大战时需要同时处理两个玩家的键盘消息，而人机大战则需要自动寻路功能，具体代码如下:

:::details `Game.h`

```c
/* 游戏逻辑处理:
    1. 维护子弹状态
    2. 维护 机器人AI的自动移动,自动发射子弹
    3. 维护 玩家 坦克的状态
    以测检测包括： 撞墙，子弹命中坦克...*/
void GameRunLogic();
 
void GameRunLogicOnMenu();				// 游戏逻辑处理 : 选择阶段

void GameRunLogicOnOne2BotMenu();			// 游戏逻辑处理 : 单人对电脑 菜单阶段

void GameRunLogicOnOne2Bot();				// 游戏逻辑处理 : 单人对电脑

void GameRunLogicOnOne2BotEnd();			// 游戏逻辑处理 : 单人对电脑 结束

void GameRunLogicOnOne2OneMenu();			// 游戏逻辑处理 : 双人对战 菜单阶段

void GameRunLogicOnOne2One();				// 游戏逻辑处理 : 双人对战

void GameRunLogicOnOne2OneEnd();			// 游戏逻辑处理 : 双人对战 结束

// 把上述方法放入数组，方便调用
void(CGame::*m_logicFunc[EGameTypeCount])() = {
    &CGame::GameRunLogicOnMenu,         	// 选择阶段
    &CGame::GameRunLogicOnOne2BotMenu, 	// 人机对战按键提示
    &CGame::GameRunLogicOnOne2Bot,      	// 单人对电脑
    &CGame::GameRunLogicOnOne2BotEnd,   	// 单人对电脑 结束
    &CGame::GameRunLogicOnOne2OneMenu,  	// 双人对战按键提示
    &CGame::GameRunLogicOnOne2One,      	// 双人对战
    &CGame::GameRunLogicOnOne2OneEnd    	// 双人对战 结束
};
```

:::

- (3）声明游戏绘图方法。本段代码是游戏各个阶段的绘图方法声明。各个阶段的绘图是不同的，如菜单阶段只需要绘制菜单，而人机大战阶段不需要绘制菜单，却需要绘制机器人么电脑控制的坦克)、玩家坦克、地图和子弹等多个对象。具体代码如下:

:::details `Game.h`

```c
/* 游戏绘图处理
    负责 绘画 游戏中的对象
    */
 void GameRunDraw();
 
 void GameRunDrawOnMenu(Graphics &gh); 		// 游戏绘图处理 : 选择阶段

 void GameRunDrawOnOne2BotMenu(Graphics &gh); 	// 游戏绘图处理 : 单人对电脑 菜单阶段

 void GameRunDrawOnOne2Bot(Graphics &gh); 		// 游戏绘图处理 : 单人对电脑

 void GameRunDrawOnOne2BotEnd(Graphics &gh); 	// 游戏绘图处理 : 单人对电脑 结束

 void GameRunDrawOnOne2OneMenu(Graphics &gh); 	// 游戏绘图处理 : 双人对战 菜单阶段

 void GameRunDrawOnOne2One(Graphics &gh); 		// 游戏绘图处理 : 双人对战

 void GameRunDrawOnOne2OneEnd(Graphics &gh); 	// 游戏绘图处理 : 双人对战 结束

 // 把上述方法放入数组，方便调用
 void(CGame::*m_drawFunc[EGameTypeCount])(Graphics &) = {
     &CGame::GameRunDrawOnMenu, 				// 选择阶段
     &CGame::GameRunDrawOnOne2BotMenu, 		// 人机对战阶段
     &CGame::GameRunDrawOnOne2Bot, 			// 单人对电脑
     &CGame::GameRunDrawOnOne2BotEnd, 			// 单人对电脑 结束
     &CGame::GameRunDrawOnOne2OneMenu, 		// 双人对战阶段
     &CGame::GameRunDrawOnOne2One, 			// 双人对战
     &CGame::GameRunDrawOnOne2OneEnd 			// 双人对战 结束
 };
```

:::

- (4）声明辅助方法，包括移动子弹、维护子弹运行轨迹、电脑自动寻路攻击及输出游戏帧数。具体代码如下:

:::details `Game.h`

```c
private:
 
    void RemoveTimeoutBullets();				// 移除超时子弹,并给对应的坦克装弹

    void ProcessHitBullets();					// 维护子弹的运行，及撞墙处理

    void AI();								// 维护电脑的自动寻路攻击

    void DrawFps(Graphics &gh); 				// 输出fps

```

:::

- (5）声明私有成员并初始化部分成员，包括游戏帧数、当前游戏阶段、两个玩家对象、机器人(电脑控制的坦克）对象、发射出来的子弹的数组、地图对象，开始菜单，返回菜单及游戏准备阶段的按键提示菜单等。这些对象为整个游戏中需要用到的全部对象。具体代码如下:

:::details `Game.h`

```c
private:
    int m_fps{ 0 }; 						// 记录 游戏每秒多少帧

    EGameType m_eStep{ EGameTypeMenu }; 	// 当前阶段:菜单选择阶段

    CPlayer m_player01; 					// 两个玩家对象

    CPlayer m_player02; 					// 玩家对象2: 双人对战时才会用到

    CBot m_bot; 							// 一个电脑: 人机对战时用到

    std::list<CBullet> m_lstBullets; 		// 存在于地图场景中的 子弹对象数组

    CGameMap m_map{ 10, 10, 780, 580 }; 	// 地图对象

    CGameMenuPanel m_menuSelect; 			// 开始菜单

    CGameMenuBackground m_menu; 			// 开始菜单背景图

    CGameMenuPanel2 m_menuBackup; 			// 返回菜单

    CKeyMenuPlayer01 m_keymenu01; 			// 提示按键的菜单
    CKeyMenuPlayer02 m_keymenu02;
};  // 注意：此处有分号

```

:::



#### 实现公有方法

`Game.h`文件中，声明了公有方法，其意义是通知`CGame`类的使用者，该类有哪些方法可用，这些方法的实现，决定了“怎么做”的部分包含在`“Game.cpp”`文件中。



- (1)引入头文件，其中`“stdafx.h”`文件为预编译头文件，其中又引入了其他头文件，具体可参考该文件的代码。`“Game.h”`文件包含`CGame`类的声明部分。具体代码如下:

```c
#include "stdafx.h"
#include "Game.h"
```

- (2）定义宏，下面代码定义一个宏，用于判断按键是否按下，方便后面使用。具体代码如下:

```c
#define KEYDOWN(vk) (GetAsyncKeyState(vk) & 0x8000)
```

(3）类的初始化及析构，在初始化时，设置了菜单成员的父成员指针，这样在菜单成员中就可以访问`CGame`对象的一些属性和方法了。具体代码如下:

```c

CGame::CGame()
{
    m_menuSelect.m_pParent = this;						// 设置菜单选择项指向当前对象
    m_menuBackup.m_pParent = this;						// 设置菜单背景项指向当前对象
} 
CGame::~CGame()
{
}

```

(4）实现为外界提供的方法，下面的方法是为了方便调用方控制`CGame`对象的行为，包括设置窗口句柄、进入游戏帧、处理鼠标移动消息、鼠标左键抬起消息及设置游戏阶段，具体代码如下:

:::details `Game.cpp`

```c

// 设置输出窗口的句柄
void CGame::SetHandle(HWND hWnd)
{
    m_hWnd = hWnd;
}
 
// 进入游戏帧
bool CGame::EnterFrame(DWORD dwTime)
{
    GameRunLogic();										// 调用逻辑处理函数
    GameRunDraw();										// 调用绘图函数
    return false;
}
 
// 处理鼠标移动事件
void CGame::OnMouseMove(UINT nFlags, CPoint point)
{
    // 选择阶段
    if (m_eStep == EGameTypeMenu) {
        m_menuSelect.OnMouseMove(nFlags, point); 		// 选择游戏类型
    }
    else {
        m_menuBackup.OnMouseMove(nFlags, point); 		// 返回主菜单
    }
}
 
// 处理左键抬起事件
void CGame::OnLButtonUp(UINT nFlags, CPoint point)
{
    // 选择阶段
    if (m_eStep == EGameTypeMenu) {
        m_menuSelect.OnLButtonUp(nFlags, point); 		// 选择游戏类型
    }
    else {
        m_menuBackup.OnLButtonUp(nFlags, point); 		// 返回主菜单
    }
}
 
// 设置当前游戏所处的阶段
// 并根据步聚 初始化
void CGame::SetStep(CGame::EGameType step)
{
    m_eStep = step;
    GameInit();											// 调用初始化函数
}
```

:::



#### 实现初始化方法

游戏的每一阶段都要准备一些资源以方便后续代码使用，同时也会设置各对象的初始状态。如在人机大战阶段，需要随机生成地图，随机设置机器人（电脑控制的坦克）和玩家在地图中的初始位置等。这些准备工作的相关代码位于初始化方法中。



:::details `Game.cpp`

```c

/* 游戏初始化
   生成 游戏对象，初始化地图，对象位置等
*/
bool CGame::GameInit()
{
    srand(GetTickCount());								// 初始化随机数生成器
    return (this->*m_initFunc[m_eStep])();					// 根据不同阶段调用不同的处理方法
}
 
// 游戏初始化 : 选择阶段
bool CGame::GameInitMenu()
{
    return true;
}
 
// 游戏初始化 : 单人对电脑 菜单阶段
bool CGame::GameInitOne2BotMenu()
{
    
    RECT rc;
    GetWindowRect(m_hWnd, &rc);
    PointF pt;
    pt.X = rc.left + (rc.right - rc.left) / 2.0f;
    pt.Y = rc.top + (rc.bottom - rc.top) / 2.0f;
    m_keymenu01.SetCenterPoint(pt);				// 设置单人对战keyMenu位置为屏幕正中间
    m_keymenu01.SetStop(false);					// 设置“不”停止播放动画
    return true;
}
 
// 游戏初始化 : 单人对电脑
bool CGame::GameInitOne2Bot()
{
    for (; ;) {													// 死循环的一种写法
        m_map.LoadMap();											// 载入地图
        // 玩家一
        {
            m_player01 = CPlayer(0, 0, _T("tank_player1.png"));		// 制造玩家一对象
            PointF ptCenter;
            if (!m_map.FindRandomPosition(ptCenter)) {				// 随机查找地图中的空地
                AfxMessageBox(_T("调整Player01位置失败"));    		// 提示调整位置失败
            }
            else {
                m_player01.SetCenterPoint(ptCenter);				// 放置玩家一到空地正中
            }
        }
 
        // 机器人
        {
            m_bot = CBot(0, 0, _T("tank_bot.png"));				// 制造机器人对象
            PointF ptCenter;
            if (!m_map.FindRandomPosition(ptCenter)) {				// 随机查找地图中的空地
                AfxMessageBox(_T("调整Bot位置失败")); 				// 提示调整位置失败
            }
            else {
                m_bot.SetCenterPoint(ptCenter);					// 放置机器人到空地正中
            }
        }
        m_lstBullets.clear();										// 清空子弹数组

        // 判断是否合法
        {
            // 获取机器人，玩家 所在的位置
            int startX, startY, targetX, targetY; 
            if (!m_map.FindObjPosition(m_bot, startX, startY) || 
				!m_map.FindObjPosition(m_player01, targetX, targetY)) {
                AfxMessageBox(_T("获取坦克位置发生错误"));
                goto __Init_End;
            }
             // 判断玩家和机器人是否连通，如果无法连通，则无法进个游戏，所以需要重新设置
            VPath path;
            m_map.FindPath(startX, startY, targetX, targetY, path);
            if (!path.empty()) {
                goto __Init_End; // 可以连通，跳出循环，直接跳到函数尾部，初始化结束
            }
        }
    }
__Init_End:
    return true;
}
 
// 游戏初始化 : 单人对电脑 结束
bool CGame::GameInitOne2BotEnd()
{
     return true;
}
 
// 游戏初始化 : 双人对战 菜单阶段
bool CGame::GameInitOne2OneMenu()
{
    // 设置 两个玩家的 keyMenu 位置 : 屏幕正中间
    RECT rc;
    GetWindowRect(m_hWnd, &rc);
    PointF pt;
    pt.X = rc.left + m_keymenu01.GetRect().Width / 2.0f + 100;
    pt.Y = rc.top + (rc.bottom - rc.top) / 2.0f;
    m_keymenu01.SetCenterPoint(pt);							// 设置该菜单项的位置
    m_keymenu01.SetStop(false);								// 设置不停止播放动画
 
 
    pt.X = rc.right - m_keymenu02.GetRect().Width / 2.0f - 100;
    pt.Y = rc.top + (rc.bottom - rc.top) / 2.0f;
    m_keymenu02.SetCenterPoint(pt); 							// 设置该菜单项的位置
    m_keymenu02.SetStop(false); 								// 设置不停止播放动画
 
    return true;
}
 
// 游戏初始化 : 双人对战
bool CGame::GameInitOne2One()
{
    for (;;) {
        m_map.LoadMap();										// 载入地图
        //中间放置坦克
        {
            m_player01 = CPlayer(0, 0, _T("tank_player1.png"));	// 构造玩家一对象
            PointF ptCenter;
            if (!m_map.FindRandomPosition(ptCenter)) {			// 查找随机的空地位置
                AfxMessageBox(_T("调整Player01位置失败"));		// 提示查找失败
            }
            else {
                m_player01.SetCenterPoint(ptCenter); // 设置玩家一位置到这块空地中心	
            }
        }
        {
            m_player02 = CPlayer(0, 0, _T("tank_player2.png"));	// 构造玩家二
            PointF ptCenter;
            if (!m_map.FindRandomPosition(ptCenter)) {			// 随机查找地图中的空地
                AfxMessageBox(_T("调整Player02位置失败"));		// 提示查找失败
            }
            else {
                m_player02.SetCenterPoint(ptCenter);	// 设置玩家二的位置到这块空地中心
            }
        }
 
        m_lstBullets.clear();							// 清空子弹数组
        // 判断是否合法
        {
            // 查找机器人，玩家 所在的位置
            int startX, startY, targetX, targetY;
            if (!m_map.FindObjPosition(m_player02, startX, startY) || 
                !m_map.FindObjPosition(m_player01, targetX, targetY)) {
                AfxMessageBox(_T("获取坦克位置发生错误")); 	// 提示查找失败
                break;
            }
             // 判断两个玩家是否可以连通
            VPath path;
            m_map.FindPath(startX, startY, targetX, targetY, path);
            if (!path.empty()) {
                break;									// 可以连通跳出循环,初始化完成
            }
             // 不可以连通，说明本次初始化失败，不跳出循环，继续尝试一下初始化
        }
    }
    return true;
}
 
// 游戏初始化 : 双人对战 结束
bool CGame::GameInitOne2OneEnd()
{
    return true;	// 不需要初始化动作，直接返回true表示初始化成功
}
```

:::



#### 实现游戏逻辑处理方法

游戏的每一帧中，都要更新游戏中各个对象的状态，如子弹当前的位置和前进方向等。

这些功能是在游戏逻辑处理方法中实现的。
下面是游戏逻辑处理的具体实现:子弹反射、坦克撞墙、子弹打爆坦克、按键处理、机器人（电脑控制的坦克）的自动寻路及主动攻击玩家等。具体代码如下:



:::details `Game.cpp`

```c

/* 游戏逻辑处理:
1. 维护子弹状态
2. 维护 机器人AI的自动移动,自动发射子弹
3. 维护 玩家 坦克的状态
以测检测包括： 撞墙，子弹命中坦克...*/
void CGame::GameRunLogic()
{
    // 根据不同阶段调用不同的处理方法
    (this->*m_logicFunc[m_eStep])();
}
 
// 游戏逻辑处理 : 选择阶段
void CGame::GameRunLogicOnMenu()
{
    // 什么也不做，还没开始游戏
}
 
// 游戏逻辑处理 : 单人对电脑 菜单阶段
void CGame::GameRunLogicOnOne2BotMenu()
{
    if (KEYDOWN('M')) { 				// 如果按下了M键，停止动画状态
        m_keymenu01.SetStop();
    }
 
    if (m_keymenu01.GetStop()) { 		// 如果都按下了，正式开始游戏
        SetStep(EGameTypeOne2Bot);
    }
}
 
// 游戏逻辑处理 : 单人对电脑
void CGame::GameRunLogicOnOne2Bot()
{
    // 状态维护
    // 移动除列表中无效的子弹,并给相应的坦克增加子弹
    RemoveTimeoutBullets();
 
    // 检查子弹是否击中坦克 :  击中要使坦克爆炸(子弹可不用移除了，
    // 因为游戏都结束了)
    for (auto &blt : m_lstBullets) {
        if (m_bot.IsHitted(blt)) {			// 击中机器人
            m_bot.Bomb();						// 机器人爆炸
            m_eStep = EGameTypeOne2BotEnd; 	// 游戏结束
            blt.SetActive(false);				// 使子弹不再有效
        }
        if (m_player01.IsHitted(blt)) { 		// 击中玩家一
            m_player01.Bomb();				// 玩家一爆炸
            m_eStep = EGameTypeOne2BotEnd; 	// 游戏结束
            blt.SetActive(false);				// 使子弹不再有效
        }
        break;
    }
 
    ProcessHitBullets();  					// 子弹运动维护

    AI();									// 使机器人自动攻击玩家
 
    //按键处理
    {
        if (KEYDOWN(VK_LEFT)) {				// 左方向键按下
            m_player01.RotateLeft();			// 玩家一向左旋转
        }
        if (KEYDOWN(VK_RIGHT)) {				// 右方向键按下
            m_player01.RotateRight();			// 玩家一向右旋转
        }
        if (KEYDOWN(VK_UP)) {					// 上方向键按下
            // 坦克撞墙检测试	
            {
                if (m_map.IsHitTheWall(m_player01, true)) {		// 如果撞墙了
                    m_player01.ChangeDirection(true);			// 改变坦克方向
                }
                else {
                    m_player01.Forward();						// 没撞墙继续向前进
                }
            }
        }
        if (KEYDOWN(VK_DOWN)) {								// 下方向键按下
        		// 坦克撞墙检测试
        		{
             	if (m_map.IsHitTheWall(m_player01, false)) {	// 如果撞墙了
             		m_player01.ChangeDirection(true);		  	// 改变坦克方向
             	}
             	else {
             		m_player01.Backward();				  	// 没撞墙继续向前进
             	}
        		}
        }
        if (KEYDOWN('M')) {									// M键按下
            CBullet blt;
            if (m_player01.Fire(blt)) {						// 发射子弹
                m_lstBullets.push_back(blt);					// 加入到地图列表中
            }
        }
        if (KEYDOWN('I')) {						// 按下键盘上面的I键，机器人步进(测试功能)
            // 机器人，玩家 所在的位置
            int startX, startY, targetX, targetY;
            if (!m_map.FindObjPosition(m_bot, startX, startY) || 
                !m_map.FindObjPosition(m_player01, targetX, targetY)) {
                return;
            }
            float fDirNext = 0; //机器人下一步的方向
            if (!m_map.FindNextDirection(&fDirNext, startX, startY, 
                targetX, targetY)) {
                return;
            }
             //获取机器人坦克的中心点
            PointF ptTankCenter = m_bot.GetCenterPoint();
            PointF ptAreaCenter = m_map.GetElementAreaCenter(startX, startY);
            RectF rc(ptAreaCenter.X - 5, ptAreaCenter.Y - 5, 10, 10);
 
 
            if (!rc.Contains(ptTankCenter)) { 		// 判断 坦克是否己经走到了中心点位置了
                m_bot.Forward(); 					// 没有到达中心点，继续前进
                return;
            }
            else {
                m_bot.SetDirection(fDirNext);		// 设置机器人的方向			
                m_bot.Forward();					// 机器人前进
            }
        }
    }
 
}
 
// 游戏逻辑处理 : 单人对电脑 结束
void CGame::GameRunLogicOnOne2BotEnd()
{
    //按键处理
    // 不再接受按键
 
 
    // 状态维护
    // 移动除列表中无效的子弹,并给相应的坦克增加子弹
    RemoveTimeoutBullets(); 
 
 
    // 子弹是否撞上墙 : 如果撞上了，改变方向等等
    ProcessHitBullets();
}
 
// 游戏逻辑处理 : 双人对战 菜单阶段
void CGame::GameRunLogicOnOne2OneMenu()	
{
    if (KEYDOWN('M')) { 									// 如果按下了M键，停止动画状态
        m_keymenu01.SetStop();
    }
    if (KEYDOWN('Q')) { 									// 如果按下了Q键，停止动画状态
        m_keymenu02.SetStop();
    }
 
    if (m_keymenu01.GetStop() && m_keymenu02.GetStop()) { 	// 如果都按下了，正式开始游戏
        SetStep(EGameTypeOne2One);
    }
}
 
// 游戏逻辑处理 : 双人对战
void CGame::GameRunLogicOnOne2One()
{
    //按键处理
    {
        if (KEYDOWN(VK_LEFT)) { 								// 左方向键按下
            m_player01.RotateLeft();							// 玩家向左旋转
        }
        if (KEYDOWN(VK_RIGHT)) {								// 右方向键按下
            m_player01.RotateRight();							// 玩家一向右旋转
        }
        if (KEYDOWN(VK_UP)) {									// 上方向键按下
            // 坦克撞墙检测试
            {
                if (m_map.IsHitTheWall(m_player01, true)) {		// 判断玩家一是否撞墙
                    m_player01.ChangeDirection(true);			// 撞墙，玩家一改变方向
                }
                else {
                    m_player01.Forward();						// 玩家一没撞墙，继续前进
                }
            }
        }
        if (KEYDOWN(VK_DOWN)) {								// 下方向键按下
            {
                // 坦克撞墙检测试
                {
                    if (m_map.IsHitTheWall(m_player01, false)) {// 判断是否撞墙
                        m_player01.ChangeDirection(false);
                    }
                    else {
                        m_player01.Backward();
                    }
                }
            }
        }
        if (KEYDOWN('M')) {								// 开火键M按下
            CBullet blt;
            if (m_player01.Fire(blt)) {					// 调用玩家一开火函数
                m_lstBullets.push_back(blt);				// 把发射的子弹存入子弹数组
            }					
        }
        // 玩家二
        if (KEYDOWN('A')) {								// A键按下
            m_player02.RotateLeft();						// 玩家二向左旋至
        }
        if (KEYDOWN('D')) {								// D键按下
            m_player02.RotateRight();						// 玩家二向右旋转
        }
        if (KEYDOWN('W')) {								// W键按下
            // 坦克撞墙检测试
            {
                if (m_map.IsHitTheWall(m_player02, true)) {// 判断玩家二是否撞墙
                    m_player02.ChangeDirection(true);		// 玩家二改变方向
                }
                else {
                    m_player02.Forward();					// 玩家二继续向前进
                }
            }
        }
        if (KEYDOWN('S')) {								// S键按按下
            {
                // 坦克撞墙检测试
                {
                    if (m_map.IsHitTheWall(m_player02, false)) {// 判断玩家二是否撞墙
                        m_player02.ChangeDirection(false);	// 玩家二改变方向
                    }
                    else {
                        m_player02.Backward();				// 玩家二继续向前
                    }
                }
            }
        }
        if (KEYDOWN('Q')) {								// Q键按下，开火键
            CBullet blt;
            if (m_player02.Fire(blt)) {					// 调用玩家二开火函数
                m_lstBullets.push_back(blt);				// 把发射的子弹存入子弹数组
            }
        }
        if (KEYDOWN('Z')) {								// 调试用的代码，正式工程无效
            if (m_map.IsCanKillTarget(m_player01, m_player02)) {
                AfxMessageBox(_T("可以打到"));
            }
        }
    }
 
    // 先判断状态
    // 移动除列表中无效的子弹,并给相应的坦克增加子弹
    RemoveTimeoutBullets();
 
    // 检查子弹是否击中坦克 :  击中要使坦克爆炸(子弹可不用移除了，因为游戏都结束了)
    for (auto &blt : m_lstBullets) {
        if (!blt.IsActive()) {
            continue;
        }
        if (m_player01.IsHitted(blt)) {	// 击中玩家一
            m_player01.Bomb();			// 玩家一爆炸
            m_eStep = EGameTypeOne2OneEnd;// 游戏结束
            blt.SetActive(false);
        }
        if (m_player02.IsHitted(blt)) { 	// 击中玩家二
            m_player02.Bomb();			// 玩家二爆炸
            m_eStep = EGameTypeOne2OneEnd;// 游戏结束
            blt.SetActive(false);
        }
    }
 
    ProcessHitBullets();					// 子弹撞墙处理
}
 
// 游戏逻辑处理 : 双人对战 结束
void CGame::GameRunLogicOnOne2OneEnd()
{
    //按键处理
    // 不需要按键处理
 
    RemoveTimeoutBullets();				// 移动除列表中无效的子弹,并给相应的坦克增加子弹

    ProcessHitBullets();					// 子弹撞墙处理
}

```

:::



#### 实现游戏绘图处理方法

游戏绘图方法调用各个对象自己的绘图方法，在合适的时机绘制对象，最后共同呈现一帧完整的画面给玩家。在下面的代码中，GameRunDraw()方法是各个绘图方法的调用入口，在此方法中，首先准备好了一幅“内存图片”，之后根据游戏所处的阶段，调用该阶段的绘图方法，把应该输出的图片绘制到“内存图片”上，最后把整个“内存图片”一次性复制到游戏窗口。具体代码如下:



:::details `Game.cpp`

```c

// 游戏绘图
void CGame::GameRunDraw()
{
    HDC hdc = ::GetDC(m_hWnd);							// 设备:图片要画到这上面
    CRect rc; 											// 客户区的大小
    GetClientRect(m_hWnd, &rc);
 
    CDC *dc = CClientDC::FromHandle(hdc);
 
    CDC m_dcMemory; 										// 双缓冲绘图用
    CBitmap bmp;
    bmp.CreateCompatibleBitmap(dc, rc.Width(), rc.Height());
    m_dcMemory.CreateCompatibleDC(dc);
    CBitmap *pOldBitmap = m_dcMemory.SelectObject(&bmp);
 
    Graphics gh(m_dcMemory.GetSafeHdc());				// 构造对象
    gh.Clear(Color::White); 								// 清除背景
    gh.ResetClip();
 
    (this->*m_drawFunc[m_eStep])(gh); 					// 画入内存

    ::BitBlt(hdc, 0, 0, rc.Width(), rc.Height(), 		// 拷贝到屏幕
        m_dcMemory.GetSafeHdc(), 0, 0, SRCCOPY);
    ::ReleaseDC(m_hWnd, hdc); 							// 释放
    return;
}
 
// 选择阶段
void CGame::GameRunDrawOnMenu(Graphics &gh)
{
    m_menuSelect.Draw(gh);
}
 
//单人对电脑 : 菜单阶段
void CGame::GameRunDrawOnOne2BotMenu(Graphics &gh)
{
    m_menu.Draw(gh); 									// 画背景

    m_keymenu01.Draw(gh); 								// 画菜单
}
 
//单人对电脑
void CGame::GameRunDrawOnOne2Bot(Graphics &gh)
{
    m_menuBackup.Draw(gh); 								// 画菜单
    m_map.Draw(gh); 										// 画墙

    m_player01.Draw(gh); 								// 画玩家一

    m_bot.Draw(gh); 										// 画机器人

    for (auto b : m_lstBullets) { 						// 画子弹 :  己经发射的
        b.Draw(gh);
    }
 
    DrawFps(gh); 										// 输出 : FPS
}
 
//单人对电脑 结束
void CGame::GameRunDrawOnOne2BotEnd(Graphics &gh)
{
    m_menuBackup.Draw(gh); 								// 菜单
    m_map.Draw(gh); 										// 墙
    m_player01.Draw(gh); 								// 玩家
    m_bot.Draw(gh); 										// 机器人

    DrawFps(gh); 										// 输出 : FPS

    if (m_player01.IsBombEnd() || m_bot.IsBombEnd()) { 	// 判断游戏整体结束
        m_eStep = EGameTypeMenu;							// 设置为菜单状态
    }
}
 
// 双人对战 : 菜单阶段
void CGame::GameRunDrawOnOne2OneMenu(Graphics &gh)
{
    m_menu.Draw(gh); 									// 画菜单背景
    m_keymenu01.Draw(gh); 								// 画菜单项一
    m_keymenu02.Draw(gh); 								// 画菜单项二
}
 
// 双人对战
void CGame::GameRunDrawOnOne2One(Graphics &gh)
{
    m_menuBackup.Draw(gh); 								// 画菜单

    m_map.Draw(gh); 										// 画墙

    m_player01.Draw(gh); 								// 画玩家一
    m_player02.Draw(gh); 								// 画玩家二

    for (auto b : m_lstBullets) { 						// 画子弹 :  己经发射的
        b.Draw(gh);
    }
 
    DrawFps(gh); 											// 输出 : FPS
}
 
// 双人对战 结束
void CGame::GameRunDrawOnOne2OneEnd(Graphics &gh)
{
    m_menuBackup.Draw(gh); 									// 菜单
    m_map.Draw(gh); 											// 墙
    m_player01.Draw(gh); 									// 玩家一
    m_player02.Draw(gh); 									// 玩家二
    for (auto b : m_lstBullets) { 							// 画子弹 :  己经发射的
        b.Draw(gh);
    }
    DrawFps(gh);	 											// 输出 : FPS

    if (m_player01.IsBombEnd() || m_player02.IsBombEnd()) { // 判断游戏整体结束
        m_eStep = EGameTypeMenu;								// 设置游戏状态为菜单状态
    }
}
```

:::

#### 实现辅助方法



`CGame`类中有一些步骤的处理代码较长，从中可以提炼出来一些单独的方法，这样的代码结构更清晰，提炼出来的方法也可以被复用。如`DrawFps()`方法，在几个地方都会被调用，形成单独的方法只需实现一次，多次调用即可。下面是几个单独的方法，包括绘制游戏帧数的`DrawFps()`方法、处理子弹超时问题的`RemoveTimeoutBullets()`方法、维护子弹运行轨迹的`ProcessHitBullets()`方法及机器人(电脑控制的坦克）自动寻路攻击的AI方法。



:::details `Game.cpp`

```c

// 画 fps
void CGame::DrawFps(Graphics &gh)
{
    static int fps = 0;						// 定义局部静态变量
    m_fps++;									// 进入一次该函数值自增一，静态变量可以保持值
    static DWORD dwLast = GetTickCount();	// 记录上次运行的时间
    if (GetTickCount() - dwLast >= 1000) {	// 如果时间到达一秒
        fps = m_fps;							//   记录累积的fps值
        m_fps = 0;							// 清空静态量的值，以防污染下次的记录
        dwLast = GetTickCount();				// 记录本次时间
    }
 
    // 输出fps
    {
        CString s;
        s.Format(_T("FPS:%d"), fps);			// 将整型值格式化为字符串，后面输出时用到
        SolidBrush brush(Color(0x00, 0x00, 0xFF));		// 定义画刷，主要是颜色属性
        Gdiplus::Font font(_T("宋体"), 10.0);			// 定义输出的字体、大小
        CRect rc;
        ::GetClientRect(m_hWnd, &rc);					// 获取游戏窗口的大小
        PointF origin(static_cast<float>(rc.right - 50),	// 在右上角显示
            static_cast<float>(rc.top + 2));
        gh.DrawString(s.GetString(), -1, &font, origin, &brush); // 输出文字
    }
}
 
// 移除超时子弹,并给对应的坦克装弹
void CGame::RemoveTimeoutBullets()
{
    // 定义查找方法
    auto itRemove = std::remove_if(m_lstBullets.begin(), 
        m_lstBullets.end(),
        [](CBullet & blt)->bool {return blt.IsTimeout(); });
 
	// 把子弹移除,并给对应的坦克增加子弹,
    for (auto it = itRemove; it != m_lstBullets.end(); ++it) {
        // 设置为无效
        it->SetActive(false);
        // 给对应的坦克增加子弹
        it->GetOwner()->AddBullet(*it);
    }
    // 从本地 删除 子弹
    m_lstBullets.erase(itRemove, m_lstBullets.end());
}
 
// 子弹运动的维护:撞墙拐弯
void CGame::ProcessHitBullets()
{
    // 子弹是否撞上墙 : 如果撞上了，改变方向等等
    for (auto &blt : m_lstBullets) {
        m_map.HitWallProcess(blt);	// 进行撞墙处理,如果撞墙，该函数中会改变子弹方向
        blt.Move();					// 子弹继续前进
    }
}
 
// 维护电脑的自动寻路攻击
void CGame::AI()
{
    // 电脑运动状态态维护
    static CGameTimer acTimer(-1, 150);
    if (acTimer.IsTimeval()) {
        // 获得机器人，玩家 所在的位置
        int startX, startY, targetX, targetY;
        if (!m_map.FindObjPosition(m_bot, startX, startY) || 
			!m_map.FindObjPosition(m_player01, targetX, targetY)) {
            return;
        }
        float fDirNext = 0; //机器人下一步的方向
        if (!m_map.FindNextDirection(&fDirNext, 
			startX, startY, 
			targetX, targetY)) {
            return;
        }
 		// 获得机器人、地图中空格的中心点
        PointF ptTankCenter = m_bot.GetCenterPoint();
        PointF ptAreaCenter = m_map.GetElementAreaCenter(startX, startY);
        RectF rc(ptAreaCenter.X - 5, ptAreaCenter.Y - 5, 10, 10);
 
 
        // 判断 坦克是否己经走到了中心点位置了
        if (!rc.Contains(ptTankCenter)) {
            m_bot.Forward(); // 没有到达中心点，继续前进
            return;
        }
        else {
            m_bot.SetDirection(fDirNext);	// 设置机器人下一步的运行方向
            float dir;
             // 判断是否可以打开玩家一
            if (m_map.IsCanKillTarget(m_bot, m_player01, &dir)) {
                CBullet blt;
                if (m_bot.Fire(blt)) {		// 机器人开会，进行主动攻击
                    m_lstBullets.push_back(blt);
                }
                return;
            }
            m_bot.Forward();					// 机器人前进
        }
    }
}
```

:::



#### 在主窗口中完成全部游戏功能



前面两节实现了CGame类，此类是联系游戏窗口和其他游戏对象的纽带。CGame类中使用了各种游戏对象，游戏窗口则通过`CGame`类间接使用各游戏对象。下面是对该类的使用步骤



- (1）在MainFrm.h文件中的CMainFrm类中声明成员变量，类型为CGame。该文件中的完整代码如下:

:::details `MainFrm.h`

```c

// MainFrm.h : CMainFrame 类的接口
//
 
#pragma once
 
#include "Game.h"
 
class CMainFrame : public CFrameWnd
{
    
public:
    CMainFrame();
protected: 
    DECLARE_DYNAMIC(CMainFrame)
 
// 特性 : 类的公共成员
public:
 
// 操作 : 类的公共成员
public:
 
// 重写 : 类的公共成员
public:
 
// 实现 : 类的共共成员
public:
    virtual ~CMainFrame();
 
// 生成的消息映射方法
protected:
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    DECLARE_MESSAGE_MAP()
 
    int m_iWidth{ 800 }; 					// 客户区的大小
    int m_iHeight{ 600 };
 
    enum ETimerId { ETimerIdGameLoop = 1 }; // 定时器 ID

    CGame m_game; 							// 游戏对象 : 注意,此处使用了CGame类
public:
    afx_msg void OnTimer(UINT_PTR nIDEvent);	// 定时器消息处理函数
    afx_msg void OnMouseMove(UINT nFlags, CPoint point); // 鼠标移动消息处理函数
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point); // 鼠标左键抬起函数
};

```

:::



- (2）在窗口创建之时初始化m_gamc对象，把当前窗口的句柄传给m_gamc对象;启动定时器，形成消息循环，定时器的时间间隔设置为0，表示让系统以尽可能快的速度，发送定时器消息给游戏窗口。打开“MainFrm.cpp”文件，找到“OnCreate”函数，将代码修改为如下代码:

:::details `MainFrm.cpp`

```c
/*内容来自MainFrm.cpp文件*/

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if(CFrameWnd::OnCreate(lpCreateStruct) == -1) {
        return -1;
    }
    SetTimer(ETimerIdGameLoop, 0, NULL); 					// 启动定时器 每次都会进入游戏帧
    m_game.SetHandle(GetSafeHwnd());						// 设置游戏主窗口句柄

    return 0;
}
```

:::



- (3）下面是定时器处理方法，每当有定时器消息到来，则自动调用此方法。在该方法中判断两次进入该方法的时间间隔，如果该值大于或等于20毫秒，则调用进入游戏帧的方法，具体代码如下:



:::details `Game.cpp`

```c
/*内容来自MainFrm.cpp文件*/

void CMainFrame::OnTimer(UINT_PTR nIDEvent)
{
    switch(nIDEvent) {
        case ETimerIdGameLoop: { 							// 游戏循环ID
            static DWORD dwLastUpdate = GetTickCount();		// 记录本次时刻
            if(GetTickCount() - dwLastUpdate >= 20) { 		// 判断时间隔
                m_game.EnterFrame(GetTickCount());			// 进入游戏帧处理
                dwLastUpdate = GetTickCount();				// 记录时间间隔
            }
            // 否则什么都不做
        }
        default:
            break;
    }
 
    CFrameWnd::OnTimer(nIDEvent);
}

```

:::



- (4）CMainFrame类为窗口类，键盘鼠标消息会发送给该类，被该类中的消息处理方法处理。在这里转发鼠标消息给m game对象，使m _game也有机会感知消息。如:菜单的动画效果，需要感知鼠标移动消息。具体代码如下:



:::details`CMainFrame.cpp` 

```c
/*内容来自MainFrm.cpp文件*/

void CMainFrame::OnMouseMove(UINT nFlags, CPoint point)
{
    m_game.OnMouseMove(nFlags, point); 					// 直接把鼠标消息转给 CGame对象
    CFrameWnd::OnMouseMove(nFlags, point);
}
 
 
void CMainFrame::OnLButtonUp(UINT nFlags, CPoint point)
{
    m_game.OnLButtonUp(nFlags, point); 				// 直接把鼠标消息转给 CGame对象
    CFrameWnd::OnLButtonUp(nFlags, point);
}
```

:::



### 本章总结



本章通过开发一个完整的游戏程序，帮助用户逐步了解了事件驱动程序的编程机制，熟悉了MFC应用程序的开发方法，掌握了能开发应用程序的基本思路和技巧。对读者来说，这是一次全方位的学习体验。通过本章的学习，读者能在下面4个方面获得巨大提升:



- 掌握严谨的项目命名规范和代码书写规范;
- 学会开发项目程序必须掌握的基础语法和相关方法;
- 掌握GDIPlus绘图技巧;
- 获得解决编程中出现的常见错误的能力。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240622233051227.png)

