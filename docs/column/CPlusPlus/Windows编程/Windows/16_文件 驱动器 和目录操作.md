# 文件 驱动器 和目录操作

## 磁盘



文件是系统中操作最为频繁的对象，例如文本文档、音视频、可执行文件等。文件存储的载体是磁盘



:::details `生活中的磁盘-硬盘`

磁盘(Disk)是指利用磁记录技术存储数据的存储器，早期计算机使用的磁盘是软磁盘(Soft Disk，简称软盘)，现在常用的磁盘是硬磁盘(Hard Disk，简称硬盘)。





硬盘有机械硬盘(Hard Disk Drive，HDD)和固态硬盘(Solid State Drive，SSD)之分。机械硬盘是传统的普通硬盘，主要由盘片、盘片旋转轴及控制电机、磁头、磁头控制器、数据转换器、接口和缓存等几部分组成。



硬盘是精密设备，尘埃是其大敌，所以进入硬盘的空气必须过滤。

- 硬盘按体积大小可以分为1.8英寸、2.5英寸、3.5英寸的。
- 按转数可以分为5400转/分、7200转/分、10000转/分，甚至15000转/分。转速是硬盘内盘片旋转轴的旋转速度(盘片固定在旋转轴上),转速的快慢是决定硬盘档次的重要参数之一。硬盘的转速越快,硬盘的读写以及传输速度也就越快。
- 按接口可以分为PATA  SATA  SCSI的。PATA SATA一般为桌面级应用，容量大，价格相对较低，适合家用。而SCSI一般为服务器、工作站等高端应用，容量相对较小，价格较贵，但是性能较好，稳定性也较高。



机械硬盘的物理结构如下图所示：

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240130190646072.png)

硬盘由多个盘片叠加在一起，盘片之间通过垫圈隔开。盘片通常是双面都可以使用的。一个盘片通常有2个盘面，盘面上面附着磁性物质用于存储数据，因为盘片在硬盘内部高速旋转，因此制作盘片的材料对硬度和耐磨性要求很高，一般采用合金或玻璃材质。



硬盘中的所有盘片都安装固足在一个旋转轴上，每张盘片之回是平行的，每个盘面上都有一个磁头，磁头与盘面之间的距离比头发丝的直径还要小许多，所有的磁头连在一个磁头控制器上，由磁头控制器负责各个磁头的运动。磁头可以沿着盘面的半径方向运动，加上盘片每分钟几千转的高速旋转，磁头就可以定位在盘面的指定位置上进行数据的读写操作。



:::



:::details `硬盘存储的几个概念`



- 磁道Track。当盘片旋转时，如果磁头保持在一个位置上，那么每个磁头都会在盘面划出一个圆形轨迹，这些圆形轨迹称为磁道。磁道用肉眼看不见，磁道仅是盘面上以特殊方式磁化的一些区域，硬盘上的数据就是治着这样的磁道存放的。相邻磁道之间并不是紧挨着的，因为磁化单元相隔太近的话磁性会相互产生影响，一个盘面通常有几十万个磁道。



- 扇区Sector 。盘面上的每个磁道可以被等分为若干个弧段，这些弧段称为扇区，每个扇区通常可以存放512字节的数据(以后可能发展为4096字节)。向硬盘读取和写入数据时，要以扇区为单位，扇区是硬盘物理存取的最小单位。



- 柱面(Cylinder 。如下图所示，硬盘由多个盘片叠加在一起，每个盘面都被划分为数目相等的磁道，盘面最外缘的磁道编号为0，具有相同编号的多个盘面的磁道形成一个圆柱，称为硬盘的柱面。很明显硬盘的柱面数与一个盘面上的磁道数相等。另外，因为每个盘面都有自己的磁头，所以总的盘面数等于总的磁头数。硬盘容量的计算方式∶柱面数×磁头数(盘面数)×每磁道扇区数×每扇区字节数。
- 簇(Cluster)。扇区是硬盘最小的物理存储单元，但是如果对数目众多的扇区进行操作则会大大降低效率，于是系统将相邻的扇区组合在一起，形成一个簇,然后再对簇进行管理。簇是系统使用的一个逻辑概念，而不是硬盘的物理特性。簇就是一组扇区，在对一个硬盘分区进行格式化时可以选择分配单元大小(也就是簇大小)，簇大小可以是8～128个扇区。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240130190921810.png)





为了更好地管理硬盘空间以及更高效地从硬盘读写数据，系统规定一个簇中只能存放一个文件的数据，不允许两个或两个以上的文件共用一个簇，不然会造成数据混乱，即簇是存储文件的最小单位，因此文件所占用的空间只能是簇的整数倍。如果文件实际大小小于一个簇,那么它也要占用一个簇的空间;如果文件实际大小大于一个簇，那么该文件要占用两个或两个以上簇的空间。一般情况下文件所占空间要略大于文件的实际大小，只有当文件的实际大小恰好是簇的整数倍时，文件的实际大小才会与所占空间一致。

:::



:::details `分区 逻辑驱动器 文件系统 卷`



一块物理硬盘可以划分为一个或多个称为分区的逻辑区域，如果使用MBR分区方案在一块物理硬盘上最多可以创建4个分区。

- 4个主分区
- 1～3个主分区和1个扩展分区



每个主分区就是一个逻辑驱动器，而一个扩展分区则可以划分成一个或多个逻辑驱动器，逻辑驱动器就是我们熟悉的C盘、D盘等盘符。主分区可以有1～4个，主要用来安装操作系统。



如果需要在一块物理硬盘中安装多个操作系统，则可以创建多个主分区，用于当前操作系统的主分区称为活动分区。扩展分区可以没有，最多只能有1个。为了文件分类管理，一个扩展分区可以划分成多个逻辑驱动器。



:::



:::details `分区示例`



例如计算机中安装了2块硬盘，每块硬盘都分为一个主分区和一个扩展分区，其中第1块硬盘的扩展分区分为3个逻辑驱动器，第2块硬盘的扩展分区分为2个逻辑驱动器，那么计算机中的逻辑驱动器就会从C盘排列到l盘（早期的计算机没有硬盘，只有两个软盘驱动器A和B，所以现在的逻辑驱动器从C开始)，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240130191326812-17066132078974.png)



:::





:::details `分区方式(方案)MBR和GPT (GUID)`



在对一块硬盘进行分区时需要选择分区方式，MBR和GPT是在硬盘上存储分区信息的两种不同方式，这些分区信息包含分区从哪里开始，这样操作系统了解扇区与分区的从属关系，以及哪个分区可以后动操作系统等。



- MBR指主引导记录(Master Boot Record) ，在该方案中，一块物理硬盘有一个主引导扇区，即该硬盘的O号柱面0号磁头的第1个扇区，大小为512字节，该扇区包含主引导记录(MBR)数据结构。MBR包含以下内容∶引导程序(最大442字节)，硬盘签名(唯一的4字节数字)，分区表(最多4个表项，每个表项16字节)，MBR结束标记（始终为OxAA55)。主引导扇区用于管理整个硬盘空间，它不属于硬盘上的任何分区，也不属于任何一个操作系统。当计算机开机时，执行BIOS初始化与自检，执行引导程序。引导程序用于检查硬盘分区表是否完好、在分区表中寻找可引导的活动分区、将活动分区的第一逻辑扇区的内容载入内存，然后将控制权交给活动分区内的操作系统(引导程序是可以改变的，从而能够实现多系统引导)。
- GPT指GUID分区表(GUID Partition Table) ，即全局唯—标识分区表。GPT是一种新的分区方式，正在逐渐取代MBR分区方式。



虽然GPT有很多新特性，但MBR仍然拥有更好的兼容性。MBR最大支持2TB硬盘，它无法处理大于2TB容量的硬盘，最多支持4个主分区(或1～3个主分区，1个扩展分区及其包含的多个逻辑驱动器);GPT不再区分主分区和扩展分区，每个物理硬盘的分区个数没有上限，只受操作系统的限制，64位Windows系统最多可以创建128个分区，每个分区都有一个全局唯一标识符GUID，GPT使用64位的扇区地址，对当前技术来说，GPT分区方式支持的硬盘大小可以说是无限制的。



在MBR分区方式的计算机后动过程中，BIOS担负着初始化、检测硬件以及引导操作系统的责任，BIOS程序存放于一个断电后内容不会丢失的只读存储器中，系统加电时处理器的第一条指合的地址会被定位到BIOS程序地址处，在MBR分区方式的硬盘中分区和后动信息是保存在一起的，如果这部分数据被覆盖或破坏，则无法后动操作系统﹔而GPT与支持UEFI模式的主板配合使用，UEFI用于取代老旧的BIOS，而GPT则取代老旧的MBR，GPT在整个硬盘上保存了多份分区表信息、后动信息的副本，因此它更安全，并可以恢复被破坏的后动信息，GPT还为这些信息保存了循环冗余校验码CRC，如果数据被破坏，GPT会自动发现，并从硬盘上的其他地方进行恢复，因此，今后GPT的发展越来越占优势，MBR也会逐渐被GPT所取代。



:::





:::details `文件系统FAT32 NTFS和 ReFS`



在对一块硬盘进行分区时还需要选择文件系统，文件系统是指在存储设备(例如硬盘)或分区上组织文件的方法。从系统角度来看，文件系统是对存储设备的存储空间进行组织、分配和回收，负责文件的存储、获取、共享和保护;从用户角度来看，文件系统主要是实现"按名存取"，用户只要知道所需文件的文件名，就可以存取文件中的数据，而无须知道这些文件究竟存放在什么地方。常用的文件系统有FAT32 NTFS ReFS等。



- `FAT (File Allocation Table)`是MS-DOS操作系统使用的文件系统，文件地址以FAT表结构存放，文件目录为32B，文件名为8个基本名称加上一个”.”和3个字符的扩展名(最多12个字符，称为8.3短文件名格式)。FAT32是FAT文件系统的升级版，是32位文件系统，支持的最大分区为2TB，单个文件的大小不能超过4GB .FAT32不支持日志，不能设置权限，因此安全等级较低。除小容量U盘为了设备兼容考虑可以使用FAT,FAT32之外，没有推荐使用的理由。
- `NTFS (NT File System)`是Windows NT操作系统使用的文件系统，NTFS提供长文件名(凡文件基本名称超过8字节或扩展名超过3字节的文件名，都称为长文件名，Windows XP及以后的系统支持最多可达255个字符的长文件名），支持压缩分区、文件索引、数据保护和恢复、加密访问等，支持的最大分区为2TB，支持的单个文件大小为2TB。
- `ReFS (Resilient File System)`，弹性文件系统)是Windows 8和Server 2012及以后的系统中新引入的一个文件系统，ReFS与NTFS大部分兼容，主要目的是保持较高的稳定性，可以自动验证数据是否损坏，并尽力恢复数据，目前只能应用于存储数据，不能引导系统。

:::



:::details `卷`



对于每个逻辑驱动器，都可以取一个标号叫作卷标`(Volume Label) `，卷标被当作一个目录项存放在逻辑驱动器的根目录中，如果不设置卷标，默认情况下显示为本地硬盘或U盘一类的名称。要谈论卷(Volume)，就需要区分基本硬盘和动态硬盘。在基本硬盘中，一个逻辑驱动器就是一个卷;而在动态硬盘中可以实现跨越物理硬盘进行分区管理，例如计算机中有160GB和250GB的硬盘各一块，如果想划分为90GB和320GB的两个分区，只能使用动态硬盘来划分管理，即在动态硬盘中一个卷可以跨越多块物理硬盘。不再深究基本硬盘和动态硬盘,平时我们只需要基本硬盘。

:::



:::details `文件名目录路径和当前目录`



在逻辑驱动器中的文件可以存放在各个目录中，目录按照多层树状结构来组织，每个逻辑驱动器中有一个顶层目录叫作根目录（例如`C:\ D:\`)，根目录下可以存放多个文件和子目录，每个子目录中也可以存放多个文件和下层子目录。



同一个目录中的文件名必须是唯一的，但是不同的子目录中可以存在同名的文件，所以只依靠文件名并不能唯一确定一个文件，要唯一确定一个文件还需要指出文件的位置，包括文件位于的逻辑驱动器以及从根目录开始一直到文件所在目录为止的所有子目录名，这就是路径。





从当前目录开始直到文件为止所构成的路径称为相对路径名，而从根目录开始直到文件为止的路径称为绝对路径（完整路径)，比如说

```c
F:\Source\Windows\Chapter3\CopyFileExDemo\Debug\CopyFileExDemo.exe
```

是一个完整路径的文件名，以反斜杠\分隔的每个部分称为文件名的组成部分。路径名的最大长度为MAX_PATH(260)个字符，Unicode版本的函数支持32767个字符的路径名，每个组成部分都不能超过255个字符。





一个文件名的最大字符个数限制为255个，在8.3格式短文件名规范中不合法的一些字符例如小数点、空格等在长文件名中都可以使用，只有`/\:*?"<>(`9个字符不能用于长文件名。





目录是一种特殊的文件，命名规则与文件名相同。`"..\"`表示当前目录的父目录，也就是上一级目录，`".\"`表示当前目录，不过表示当前目录时通常可以省略`".\"`。





:::





:::tip 



对一个进程来说，Windows维护一个当前驱动器，并为每个逻辑驱动器维护一个当前目录。如果不指定路径，则表示要操作的文件位于当前驱动器的当前目录下。如果要操作非当前目录下的文件，则必须明确指出包含全路径的文件名。例如指定一个文件System.ini，如果当前目录下有这个文件，那么操作的对象就是这个文件。如果当前目录下并没有这个文件，即使其他目录中存在多个同名的文件，那么程序也无法知道它究竟对应哪个文件。

:::







进程默认当前目录就是其可执行文件所在的目录(但是在VS中按Ctrl +F5组合键编译运行程序时，进程的当前目录被认为是源文件所在的目录)，程序可以通过调用`SetCurrentDirectory `  `GetCurrentDirectory`函数设置、获取当前目录，通过`GetFullPathName`函数获取一个文件的完整路径∶



:::details `SetCurrentDirectory/GetCurrentDirectory/GetFullPathName 函数说明`

```c
BOoL SetCurrentDirectory(LPCTSTR lpPathName);


DWORD GetCurrentDirectory(
_In_  DWORD nBufferLength,//缓冲区大小，以字符为单位
_Out_ LPTSTR lpBuffer //返回当前目录
);


DWORD WINAPI GetFullPathName(
_In_ LPCTSTR lpFileName, //文件的名称
_In_ DWORD nBufferLength,//缓冲区大小，以字符为单位
_out_ LPTSTR lpBuffer,//返回包括路径和文件名的完整路径文件名
_out_ LPTSTR* lpFilePart //返回文件名起始地址的指针，如果不需要可以设置为NULL
);
```

:::



## 文件操作



### 创建和打开文件

要对文件进行操作，首先需要通过调用`CreateFile`函数创建或打开一个文件，该函数返回一个文件句柄，后续对文件执行的操作都会用到这个句柄。



:::details `CreateFile 函数说明`

```c

/// <summary>
/// 创建或打开文件
/// </summary>
/// <param name="lpFileName">要创建或打开的文件的名称字符串</param>
/// <param name="dwDesiredAccess">对文件的访问权限</param>
/// <param name="dwShareMode">文件的共享模式</param>
/// <param name="lpSecurityAttributes">含义同其他内核对象的安全属性结构</param>
/// <param name="dwCreationDisposition">创建或打开标志</param>
/// <param name="dwFlagsAndAttributes">文件的标志和系统属性</param>
/// <param name="hTemplateFile">模板文件的句柄，可以设置为NULL</param>
/// <returns></returns>
HANDLE WINAPI CreateFile(_In_ LPCTSTR lpFileName, _In_ DWORD dwDesiredAccess,_In_ DWORD dwShareMode,_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,_In_ DWORD dwCreationDisposition,_In_ DWORD dwFlagsAndAttributes,_In_opt_ HANDLE hTemplateFile);
```

- `lpFileName`参数指定要创建或打开的文件的名称字符串，如果使用函数的ANSI版本，则路径名称字符串限制为`MAX_PATH个`字符﹔如果使用函数的Unicode版本，则路径名称字符串限制为32767个字符。
- `dwDesiredAccess`参数指定对文件的访问权限，通过这个参数可以指定要对打开的文件进行什么操作。指定为`GENERIC_READ`标志表示需要读取文件数据，指定为`GENERIC_WRITE`标志表示需要向文件写入数据，如果要对一个文件进行读写则需要同时指定这两个标志 `GENERIC_READ|GENERIC_WRITE`。
- `dwShareMode`参数指定文件的共享模式，即文件被打开后是否还允许其他进程或线程以某种方式再次打开文件，可以是下表所示的值的组合。

|       常量宏        |                  含义                  |
| :-----------------: | :------------------------------------: |
|  `FILE_SHARE_READ`  | 允许其他进程或线程同时以读方式打开文件 |
| `FILE_SHARE_WRITE`  | 允许其他进程或线程同时以写方式打开文件 |
| `FILE_SHARE_DELETE` |  允许其他进程或线程同时对文件进行删除  |

- `lpSecurityAttributes`参数的含义同其他内核对象的安全属性结构。
- `dwCreationDisposition`参数指定创建或打开标志，该参数用来设置文件已经存在或不存在时系统采取的操作，在这里指定不同的标志就可以决定函数执行的功能究竟是创建文件还是打开文件。该参数可以是下表所示的值之一。

|       宏定义        |                             含义                             |
| :-----------------: | :----------------------------------------------------------: |
|    `CREATE_NEW`     | 仅在指定的文件尚不存在的情况下创建一个新文件。如果指定的文件已经存在，则函数调用失败，此时调用`GetLastError`函数返回错误码`ERROR_FILE_EXISTS(80)` |
|   `CREATE_ALWAYS`   | 始终创建一个新文件。如果指定的文件不存在并且是有效路径，则创建一个新文件，函数调用成功，此时调用`GetLastError`函数返回错误码0﹔如果指定的文件已经存在并且可写，则函数将覆盖该文件(文件内容会被清空)，函数调用成功，此时调用`GetLastError`函数返回错误码`ERROR_ALREADY_EXISTS(183)` |
|  `OPEN_EXISTING `   | 仅打开已经存在的文件。如果指定的文件不存在，则函数调用失败，此时调用`GetLastError`函数返回错误码`RROR_FILE_NOT_FOUND(2)` |
| `TRUNCATE_EXISTING` | 打开文件并将其截断，使其大小为0字节（仅当文件存在时)。如果指定的文件不存在，函数调用失败，此时调用`GetLastError`函数返回错`误码ERROR_FILE_NOT_FOUND(2)` |

简单来说，如果要创建文件，则可以指定为CREATE_NEW(如果指定的文件已经存在，则函数调用失败)或CREATE_ALWAYS(如果指定的文件已经存在，则函数将覆盖该文件);



如果要打开文件，则可以指定为OPEN_EXISTING(如果指定的文件不存在，则函数调用失败)或
OPEN_ALWAYS(如果指定的文件不存在，则创建一个新文件)。





- `dwFlagsAndAttributes`参数指定文件的标志和系统属性，一般设置为`FILE_ATTRIBUTE_NORMAL`即可，文件系统属性`(FILE_ATTRIBUTE_*)`和文件标志`(FILE_FLAG_*)`可以组合使用。`dwFlagsAndAttributes`参数可以指定的常用文件系统属性如下表所示。

|           宏常量           |                             含义                             |
| :------------------------: | :----------------------------------------------------------: |
|  `FILE_ATTRIBUTE_NORMAL`   |                           普通文件                           |
| `FILE_ATTRIBUTE_READONLY`  | 该文件是只读的，程序可以读取文件，但不能向文件写入数据或删除文件 |
|  `FILE_ATTRIBUTE_HIDDEN`   |           该文件是隐藏的，不会出现在普通目录列表中           |
|  `FILE_ATTRIBUTE_SYSTEM`   |          该文件是操作系统的一部分或仅由操作系统使用          |
|  `FILE_ATTRIBUTE_ARCHIVE`  | 设置归档属性，程序使用这个标志将文件标记为待备份或待删除，CreateFile在创建一个新文件时，会自动设置这个标志 |
| `FILE_ATTRIBUTE_TEMPORARY` | 该文件用于临时存储，即该文件的数据只会使用一小段时间。为了提高访问效率，系统会尽量将文件数据保存在内存中，而不是保存在硬盘中，程序不再使用文件时应该尽快将它删除。它通常与文件标志FILE_FLAG_DELETE_ON_CLOSE一起使用 |
| `FILE_ATTRIBUTE_ENCRYPTED` |                         该文件已加密                         |

文件标志用于控制文件的缓存行为、访问模式等，`dwFlagsAndAttributes`参数可以指定的常用文件标志如下表所示。



**文件标志值含义**



- `FILE_FLAG_DELETE_ON_CLOSE`  关闭文件句柄后立刻删除该文件
- `FILE_FLAG_OVERLAPPED`  创建或打开的文件使用异步l/O操作方式。异步IO通常用于网络编程
- `FILE_FLAG_NO_BUFFERING`  对文件的读写操作不使用系统缓存。为了提高性能，系统在访问硬盘时会对数据进行缓存。系统会从文件中读取超出实际需要的数据字节量，如果后续需要继续读取后面的字节，就可以直接从系统缓存中而不是从文件中读取
- `FILE_FLAG_WRITE_THROUGH` 对文件的写操作将不会通过任何中间缓存，文件的修改会被马上写入硬盘中

实际开发中，如果不想走操作系统的高速缓存，一般来说，起手就设置两个`FILE_FLAG_NO_BUFFERING| FILE_FLAG_WRITE_THROUGH` 都设置进来。





如果`CreateFile`函数执行成功，则返回一个文件对象句柄;如果函数执行失败，则返回值为
`INVALID_HANDLE_VALUE(-1)`，可以通过调用`GetLastError`函数获取错误代码。注意，函数执行失败时返回值为`INVALID_HANDLE_VALUE(-1)`，而不是NULL。





其实，`CreateFile`函数的使用方法很简单，如果需要打开一个已经存在的文件，可以按如下方式

```c
HANDLE hFile;

//打开文件
hFile = CreateFile(TEXT("D:||Test.txt"),GENERIC_READ|GENERIC_WRITE,
                   FILE_SHARE_READ,NULL,OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL,NULL);
if (hFile == INVALID_HANDLE_VALUE)
{
	//函数调用失败
}
```

```c
//创建文件
hFile = CreateFile(TEXT("D:\Test.txt"),GENERIC_READ | GENERIC_WRITE,
				FILE_SHARE_READ,NULL，CREATE_ALWAYS,
                   FILE_ATTRIBUTE_NORMAL,NULL);
if (hFile == INVALID_HANDLE_VALUE)
{
	//函数调用失败
}
```

当不再需要所创建或打开的文件句柄时，需要调用`CloseHandle`函数关闭文件对象句柄。



:::



### 读写文件

获取到文件句柄后，即可从文件读取数据或向文件写入数据。读写文件可以使用`ReadFile` ` WriteFile`函数，这两个函数读写的方式可以是同步的也可以是异步的。





对应的还有`ReadFileEx`  `WriteFileEx`函数，这两个函数只用于异步读写文件。



:::tip

异步指的是让CPU暂时搁置当前请求，继续处理下一个请求。对文件来说，例如需要读取或者写入1GB的文件，这肯定需要一定的时间（假设这些操作需要5秒的时间，那么如果是默认的同步操作，程序就会阻塞，也就是等待、卡顿5秒)，异步采取的办法是发出读取或者写入的请求后（调用相关函数)，程序并不等待请求完成，而是继续执行其他任务，当刚扌请求的操作完成后系统会通知程序，因为计算机速度很快，文件操作一般来说，通常不需要异步。

:::







:::details `ReadFile 函数说明`



`ReadFile`函数用于从指定的文件读取数据，函数原型如下

```c

/// <summary>
/// 读取文件内容
/// </summary>
/// <param name="hFile">文件句柄</param>
/// <param name="lpBuffer">接收文件数据的缓冲区</param>
/// <param name="nNumberOfBytesToRead">要读取的字节数</param>
/// <param name="lpNumberOfBytesRead">/DWORD类型变量的指针，返回实际读取到的字节数</param>
/// <param name="lpOverlapped">用于异步文件操作，不需要的话可以设置为NULL</param>
/// <returns></returns>
BOOL WINAPI ReadFile(HANDLE hFile,LPVOID lpBuffer,DWORD nNumberOfBytesToRead,LPDWORD lpNumberOfBytesRead,LPOVERLAPPED lpOverlapped);
```

- 如果函数执行成功，则返回值为TRUE，否则返回值为FALSE。

- `nNumberOfBytesToRead`参数指定要读取的字节数，实际读取到的字节数`lpNumberOfBytesRead`并不一定总是等于要求读取的字节数。

- 例如当读取到文件末尾时，`ReadFile`函数返回TRUE，此时`*lpNumberOfBytesRead`为0.

  程序可以通过`*lpNumberOfBytesRead`参数返回的值确定文件是否已经读取到文件末尾。

:::



:::details `WriteFile 函数说明`

```c


/// <summary>
/// 写入文件内容
/// </summary>
/// <param name="hFile">文件句柄</param>
/// <param name="lpBuffer">要写入文件的数据的缓冲区</param>
/// <param name="nNumberOfBytesToWrite">要写入的字节数</param>
/// <param name="lpNumberOfBytesWritten">DWORD类型变量的指针，返回成功写入的字节数</param>
/// <param name="lpOverlapped">用于异步文件操作，不需要的话可以设置为NULL</param>
/// <returns></returns>
BOOL WINAPI WriteFile(HANDLE hFile, LPVOID lpBuffer,DWORD nNumberOfBytesToWrite,LPDWORD lpNumberOfBytesWritten,LPOVERLAPPED lpOverlapped);
```

- 如果需要异步`I/O`，`CreateFile`函数的`dwFlagsAndAttributes`参数应该指定`FILE_FLAG_OVERLAPPED`标志，`ReadFile  WriteFile`等函数的`IpOverlapped`参数应该指定为一个指向`OVERLAPPED`结构的指针。

:::



:::details `FlushFileBuffers 函数说明`



调用`WriteFile`函数向指定的文件写入数据时，写入的数据可能会被系统暂时保存在内部的高速缓存中，系统会定期把高速缓存中的数据写入硬盘，虽然这些数据一般不会丢失，但并不能保证它们总是不会丢失，比如在文件关闭前计算机断电。为了保证所有数据都被正确地写入了硬盘，当写入操作完成后应该立即调用`CloseHandle`函数关闭文件句柄，关闭文件句柄后，系统会把缓冲区中的所有数据写入硬盘。或者，程序可以通过调用`FlushFileBuffers`函数来刷新指定文件的缓冲区，并使所有缓冲区中的数据写入文件︰

```c
BOOL WINAPI FlushFileBuffers(_In_ HANDLE hFile);
```

为了把关键数据即时写入硬盘，程序可能需要多次(甚至每次调用`WriteFile`函数后)调用`FlushFileBuffers`函数立即刷新缓冲区，**效率可能会很低**。对于这种情况，程序应该使用`无缓冲I/O`，而不是频繁地调用`FlushFileBuffers`函数。要使用无缓冲l/O，调用`CreateFile`函数创建或打开文件时需要指定
`FILE_FLAG_NO_BUFFERING | FILE_FLAG_WRITE_THROUGH`标志，这样可以防止文件内容被缓存，并在每次写入时将数据刷新到硬盘。



:::





:::details `读写文件示例:`



接下来实现一个读取文本文件内容到编辑控件，并同时将该文本文件复制一份到当前目录下的简单示例，`ReadWriteFile`程序。



```c
#include <windows.h>
#include "resource.h"
#define BUF_SIZE    16
INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MAIN), NULL, DialogProc, NULL);
    return 0;
}
INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND hwndEdit;
    HANDLE hFile1, hFile2;
    TCHAR szBuf[BUF_SIZE + 1] = { 0 };
    DWORD dwNumberOfBytesRead;

    if (uMsg == WM_INITDIALOG)
    {
        hwndEdit = GetDlgItem(hwndDlg, IDC_EDIT_TEXT);
        // 设置多行编辑控件的缓冲区大小为不限制
        SendMessage(hwndEdit, EM_SETLIMITTEXT, 0, 0);
        return TRUE;
    }
    else if (uMsg == WM_COMMAND)
    {
        if (LOWORD(wParam) == IDC_BTN_OPEN)
        {
          
            hFile1 = CreateFile(TEXT("Test.txt"), GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            hFile2 = CreateFile(TEXT("Test2.txt"), GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

            if (hFile1 != INVALID_HANDLE_VALUE && hFile2 != INVALID_HANDLE_VALUE)
            {
                while (TRUE)
                {
                    // 从Test文件读取数据
                    ZeroMemory(szBuf, BUF_SIZE * sizeof(TCHAR));
                    ReadFile(hFile1, szBuf, BUF_SIZE * sizeof(TCHAR), &dwNumberOfBytesRead, NULL);
                    if (dwNumberOfBytesRead == 0)
                    {
                        break;
                    }
                       

                    // 把读取到的数据显示到编辑控件中
                    SendMessage(hwndEdit, EM_SETSEL, -1, -1);
                    SendMessage(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);

                    // 把读取到的数据写入到新文件Test2.txt中
                    // 第3个参数不能写为BUF_SIZE * sizeof(TCHAR)，否则最后一次可能会出现问题
                    WriteFile(hFile2, szBuf, dwNumberOfBytesRead, NULL, NULL);
                }

                CloseHandle(hFile1);
                CloseHandle(hFile2);
            }
        }
        else if (LOWORD(wParam) == IDCANCEL)
        {
            EndDialog(hwndDlg, 0);
        }
    }
    return FALSE;
}
```

单击"打开"按钮，程序调用`CreateFile`函数打开当前目录下的文本文件Test.txt，并调用`CreateFile`函数创建一个新文本文件Test2.txt ;然后程序循环调用`ReadFile`函数读取Test.txt文件的内容，每次读取16个字符的数据，然后把读取到的数据显示到编辑控件中，同时把读取到的数据写入新文件Test2.txt。



每次读取BUF_SIZE(16)个字符，但是EM_REPLACESEL消息的
lParam参数需要一个以0结尾的字符串，因此szBuf缓冲区大小为`BUF_SIZE＋ 1`。



不过，不管是什么编码格式，都不影响文件的复制，复制出来的文件必定和源文件一致，因为读写的是二进制数据。

:::



:::details `示例2:读文件`

```c
#include <iostream>
#include <Windows.h>
int main(int argc, char* argv[])
{
    HANDLE hFile = INVALID_HANDLE_VALUE; //文件句柄
    LARGE_INTEGER fileSize = { 0 }; //打开的文件大小
    DWORD numberOfBytesRead; //要读取的字节数，等价于文件字符数
    char* lpBuffer = NULL; //文件内容加载到内存时的内存块
    //以只读的方式打开一个已经存在的文件，并且不允许别的进程访问他。
    hFile = ::CreateFileA(
        "E:\\journal.cxx",     
        GENERIC_READ, //读取权限        
        0,    //阻止其他进程访问                 
        NULL,  //子进程不可继承本句柄             
        OPEN_EXISTING,// 仅当该文件或设备存在时，打开它        
        FILE_ATTRIBUTE_NORMAL,  //普通文件
        NULL);     // 不适用模板文件                
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return 0;
    }
     //查文件大小
     ::GetFileSizeEx(hFile, &fileSize); 
     numberOfBytesRead = fileSize.QuadPart;//得到文件字符数量
     // 基于文件字符数量，分配一块内存
     lpBuffer = (char*)malloc(numberOfBytesRead + 1);
     if (!lpBuffer)
     {
         return -1;
     }
     lpBuffer[numberOfBytesRead] = '\0';       //设置结尾      
    ::ReadFile(
        hFile,      // 文件句柄
        lpBuffer,     // 读取到的文件所存放的缓冲区
        numberOfBytesRead,   // 要读取的字节数
        &numberOfBytesRead,  // 实际读取的字节数
        NULL        // 采用阻塞式同步读取
    );
    //打印文件内容
    printf(lpBuffer);
    //释放资源
    ::CloseHandle(hFile);
    free(lpBuffer);
    system("pause");
    return 0;
}
```

:::







 MFC提供了[CFile类](https://so.csdn.net/so/search?q=CFile类&spm=1001.2101.3001.7020)方便文件的读写，在了解如何写入文件内容之前我们需要明确二点。第一点数据的写入和文件指针的操作都是以字节为单位的。第二点当打开一个文件的时候，文件的指针总是在文件的开头。所在在实际开发中，为了不破坏原有文件本来就有的内容，通常需要将文件指针移动到文件末尾。



:::details `CFile/CStdioFile 类`



在打开文件的时候，你需要告诉MFC框架，打开文件采用的模式是什么。nOpenFlags的常用模式有

|        nOpenFlag        |                           说明                            |
| :---------------------: | :-------------------------------------------------------: |
|   `CFile::modeCreate`   |        创建新文件，如果文件已存在，则将其长度变成0        |
| `CFile::modeNoTruncate` | 与modeCreate组合使用，如果文件已存在，则不会将其长度变成0 |
|    `CFile::modeRead`    |                    以只读方式打开文件                     |
| `CFile::modeReadWrite`  |                    以读写方式打开文件                     |
|   `CFile::modeWrite`    |                    以只写方式打开文件                     |
| `CFile::modeNoInherit`  |                   组织该文件被子项继承                    |
| `CFile::shareDenyNone`  |     以共享模式打开文件，不会禁止其他进程对文件的读写      |
| `CFile::shareDenyRead`  |                禁止其他进程对文件的读操作                 |
| `CFile::shareDenyWrite` |                禁止其他进程对文件的写操作                 |
| `CFile::shareExclusive` |       以独占模式打开文件，禁止其他进程对文件的读写        |
|    `CFile::typeText`    |                    以文本方式打开文件                     |
|   `CFile::typeBinary`   |                   以二进制方式打开文件                    |

使用`CFile`写入文件内容的流程如下：

- 构造一个CFile对象。
- 调用CFile::Open()函数创建、打开指定的文件。
- 调用CFile::Write ()进行文件内容写入操作。
- 调用CFile::Close()关闭文件句柄。
- 实际开发，写入文件内容前最好`CFile::SeekToEnd()`事先把文件指针移到文件末尾，确保写入文件内容的完整性。



`CStdioFile` 是 `CFile`的子类，所以操作等价于`CFile` 类，区别在于子类扩展了`WriteString()` 方法。便于直接写入一行内容并进行换行输出。不用我们自己加换行符。

:::



:::details `MFC写文件示例:`

```c
#include<afx.h>
#include<Windows.h>
#include<iostream>
int _tmain(int argc, TCHAR* argv)
{
	CFile cfile;
	BOOL bRet = FALSE;
	//如果说，文件不存在则新建文件。文件存在则使用存在的文件进行写入操作
	CFileException ex;
	bRet = cfile.Open("1.txt",CFile::modeNoTruncate | CFile::modeCreate | CFile::modeWrite,&ex);
	if (!bRet)
	{
		std::cout << "文件打开失败!" << std::endl;
	}
	//查当前模块路径
	char szModuleName[MAX_PATH] = { 0 };
	if (!::GetModuleFileNameA(NULL, szModuleName, _countof(szModuleName)))
	{
		return -1;
	}

	CStringA writeToFile;
	writeToFile.Format("%s\n%s", szModuleName,"JacksonWang");
	//文件指针移动到文件末尾，确保写入的新内容不会覆盖之前的
	cfile.SeekToEnd(); 
	cfile.Write(writeToFile.GetString(), (writeToFile.GetLength() + 1) * sizeof(char)); 
	cfile.Flush(); 
	cfile.Close();

	return 0;
}
```

```c
#include<afx.h>
#include<Windows.h>
#include<iostream>
#include<strsafe.h>
using namespace std;
int _tmain(int argc, TCHAR* argv)
{
	CStdioFile cstdioFile;
	SYSTEMTIME systemTime;
	BOOL bRet = FALSE;
	CHAR szBuf[MAX_PATH] = { 0 };

	//如果文件存在则清空已经存在的文件内容再写入
	bRet = cstdioFile.Open("1.txt", CFile::modeCreate  | CFile::modeWrite);
	if (!bRet)
	{
		cout << "文件打开失败" << endl;
	}
	::GetLocalTime(&systemTime);
	::StringCchPrintfA(szBuf, _countof(szBuf), "%04u-%02u-%02u %02u:%02u:%02u", 
		systemTime.wYear,
		systemTime.wMonth,
		systemTime.wDay,
		systemTime.wHour,
		systemTime.wMinute,
		systemTime.wSecond);
	CStringA writeToFile;
	writeToFile.Format("%s\n%s", "当前系统时间", szBuf);
	//cstdioFile.SeekToEnd(); 每一次都是重新写入SeekToEnd() 在这里无意义
	cstdioFile.WriteString(writeToFile);
	cstdioFile.Flush();
	cstdioFile.Close();
	return 0;
}
```

:::



:::details `文件路径需提心! BUG`

需要注意的是，我们写入文件的文件名。通过为了区别文件和文件的差异性，但又不想改变其含义。比如说日志文件。做日志库的时候我们会给我们的日志文件名加上时间戳，有的时候觉得时间戳不直观，会把时间戳转为格式日期字符串。形同`YYYY-MM-dd HH:mm:ss` ，再拼接到日志文件名上，这里有一个很大的问题。即文件路径名在`WINDOWS` 平台上有一些字符是不能出现的。比如`:`,这时 `GetLassError()` 就会被告知`文件名、目录名或卷标语法不正确; `

经过查阅资料，可知此类的问题处理，可参见[文件名、目录名或卷标语法不正确；AttributeError: module ‘numpy‘ has no attribute ‘long‘；shell脚本：Syntax error: Bad for-CSDN博客](https://blog.csdn.net/weixin_44724619/article/details/130735367)



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20231218201912519-17029019538941.png)



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20231218201936425-17029019776372.png)



:::



:::details `MFC读文件示例`

先说明，并不建议使用子类`CStdioFile::ReadString()` 很大几率会出现乱码。

```c
#include<afx.h>
#include<Windows.h>
#include<iostream>
#include<strsafe.h>
using namespace std;
int _tmain(int argc, TCHAR* argv)
{
	CString fileFullPath = _T("E:\\xx.cxx");
	char* curLocale = NULL;
	CFile cFile;
	CFileException pError;
	CFileFind cFinder;
	BOOL bRet = FALSE;
	UINT fileLength = 0;
	char* szBuf = NULL;
	int piResult = IS_TEXT_UNICODE_SIGNATURE | IS_TEXT_UNICODE_REVERSE_SIGNATURE;
	BOOL bIsUnicode = FALSE;
	CStringA fileContext;

	//查当前区域设置，默认是C
	curLocale = _strdup(setlocale(LC_CTYPE, NULL));
	setlocale(LC_CTYPE, "chs");


	bRet = cFinder.FindFile(fileFullPath); 
	cFinder.Close();
	if (!bRet)
	{
		cout << "文件不存在!" << endl;
		return FALSE;
	}
	//只读模式，打开文件，如果文件不存在会报错！
	bRet = cFile.Open(fileFullPath, CFile::modeRead , &pError);
	if (!bRet)
	{
		return FALSE;
	}
	szBuf = new char[100];
	if (!szBuf)
	{
		return FALSE;
	}
	//确定缓冲区是否可能包含 Unicode 文本形式。
	cFile.SeekToBegin();
	cFile.Read(szBuf,100);
	bIsUnicode = ::IsTextUnicode(szBuf, 100, &piResult);
	delete szBuf; 
	szBuf = NULL;
	//文件指针移动到开头
	cFile.SeekToBegin();
	//查文件大小
	fileLength = cFile.GetLength();
	if (0 == fileLength)
	{
		return FALSE;
	}
	//把文件内容字符读到字节数组
	szBuf = new char[fileLength+1];
	memset(szBuf, 0, (fileLength+1)* sizeof (char));
	cFile.Read(szBuf, fileLength);
	if (bIsUnicode)
	{
		fileContext = szBuf;
	}
	else
	{
		//如果不是Unicode字符，则转换一下
		CString tempBuf = CA2W(szBuf, CP_UTF8);
		fileContext = tempBuf.GetString();
	}

	//输出缓冲区内容
	cout << fileContext.GetBuffer();

	if (szBuf)
	{
		delete[] szBuf;
		szBuf = NULL;
	}
	cFile.Close();
	//还原区域设定
	if (curLocale)
	{
		setlocale(LC_CTYPE, curLocale);
		free(curLocale);
		curLocale = NULL;
	}
	return 0;
}
```

:::





:::details `Win32读文件示例`

```c
#include<afx.h>
#include<Windows.h>
#include<iostream>
#include<strsafe.h>
using namespace std;
int _tmain(int argc, TCHAR* argv)
{
	CString fileFullPath = _T("E:\\xx.cxx");
	char* curLocale = NULL;
	LARGE_INTEGER fileSize;
	CFileFind cFinder;
	BOOL bRet = FALSE;
	CString fileContext;
	char* lpBuffer = NULL;
	DWORD nNumberOfBytesToRead = 0;
	DWORD dxNumberOfBytesReadReturn = 0;
	BYTE szTestBuf[100];
	BOOL bIsUnicode = FALSE;
	int piResult = IS_TEXT_UNICODE_SIGNATURE | IS_TEXT_UNICODE_REVERSE_SIGNATURE;

	//查当前区域设置，默认是C
	curLocale = _strdup(setlocale(LC_CTYPE, NULL));
	setlocale(LC_CTYPE, "chs");
	//文件不存在，不支持读取操作
	bRet = cFinder.FindFile(fileFullPath);
	cFinder.Close();
	if (!bRet)
	{
		cout << "文件不存在!" << endl;
		return FALSE;
	}
	//Win32方式读取
	HANDLE hFile = ::CreateFile(fileFullPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	//查文件大小
	::GetFileSizeEx(hFile, &fileSize);
	nNumberOfBytesToRead = fileSize.QuadPart;
	if (0 == nNumberOfBytesToRead)
	{
		cout << "此文件为空";
		return FALSE;
	}
	//文件定位
	::SetFilePointer(hFile, 0, 0, FILE_BEGIN);
	lpBuffer = new char[nNumberOfBytesToRead + 1];
	if (!lpBuffer)
	{
		return FALSE;
	}
	memset(lpBuffer, '\0', sizeof(char) * nNumberOfBytesToRead + 1);
	//读文件内容到char[] 可以说是字节缓冲区中，字节不存在乱码
	::ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, &dxNumberOfBytesReadReturn, NULL);
	::ReadFile(hFile, szTestBuf, 100, &dxNumberOfBytesReadReturn, NULL);
	bIsUnicode = ::IsTextUnicode(szTestBuf, 100, &piResult);
	if (bIsUnicode)
	{
		fileContext = lpBuffer;
	}
	else
	{
		//转为宽字节
		fileContext = CA2W(lpBuffer, CP_UTF8);
	}
	cout << fileContext.GetString();
	::CloseHandle(hFile);
	//还原区域设定
	if (curLocale)
	{
		setlocale(LC_CTYPE, curLocale);
		free(curLocale);
		curLocale = NULL;
	}
	return 0;
}
```

:::





:::details `Win32 写文件示例`

```c
#include<afx.h>
#include<Windows.h>
#include<iostream>
#include<strsafe.h>
using namespace std;
int _tmain(int argc, TCHAR* argv)
{
	HANDLE hFile;
	LARGE_INTEGER liDistanceToMove;
	LARGE_INTEGER newFilePointer;
	char szComputerNameBuf[MAX_COMPUTERNAME_LENGTH + 1] = { '\0' };
	CStringA writeContextToFile;
	DWORD nNumberOfBytesToWrite;
	DWORD numberOfBytesWritten;
	//文件存在，则用存在的文件，文件不存在则会新建文件.
	hFile = ::CreateFileA("1.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		cout << "打开文件失败!" << endl;
	}
	//查本地计算机的 NetBIOS 名称
	DWORD nComputerNameBufSize = _countof(szComputerNameBuf);
	::GetComputerNameA(szComputerNameBuf, &nComputerNameBufSize);
	writeContextToFile.Format("%s:\n%s\n", "本地计算机名称", szComputerNameBuf);
	
	//让文件指针指向文件末尾
	liDistanceToMove.QuadPart = 0;
	::SetFilePointerEx(hFile, liDistanceToMove, NULL, FILE_END);
	nNumberOfBytesToWrite = (writeContextToFile.GetLength() + 1) * sizeof(char);
	::WriteFile(hFile, writeContextToFile.GetString(), nNumberOfBytesToWrite, &numberOfBytesWritten, NULL);
	::CloseHandle(hFile);
	return 0;
}
```

:::











### 文件指针





:::details `什么是文件指针？`

打开一个文件后，系统会为该文件维护一个文件指针，文件指针是一个64位的偏移值，用于指定要读取或要写入的下一字节的位置。打开一个文件时，文件指针位于文件的开头，偏移量为0，每个读取或写入操作都会使文件指针前进所读取或写入的字节数，例如，如果文件指针位于文件的开头，然后请求5字节的读取操作,那么文件指针将在读取操作后立即位于偏移量5处，因此在循环读取或者写入一个文件时，随着数据的读取或者写入，文件指针会随之移动，我们并不需要关心文件指针的问题。

:::



但是有时候我们可能需要从文件的指定位置读取或写入数据，这就需要先调整文件指针，然后再进行读写操作。调整文件指针可以使用`SetFilePointerEx`函数



:::details `SetFilePointerEx 函数说明`

```c
/// <summary>
/// 调整文件指针的位置
/// </summary>
/// <param name="hFile">文件句柄</param>
/// <param name="liDistanceToMove">文件指针要移动的字节数</param>
/// <param name="lpNewFilePointer">返回新文件指针，不需要可以设置为NULL</param>
/// <param name="dwMoveMethod">文件指针移动的起点</param>
/// <returns></returns>
BOOL WINAPI SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer,DWORD dwMoveMethod);
```

- `dwMoveMethod`参数指定文件指针移动的起点，该参数可以是下表所示的常量之一。
  - `FILE_BEGIN` 起点为0，也就是文件的开头
  - `FILE_CURRENT` 起点为文件指针的当前位置
  - `FILE_END`  起点为文件的结束位置（末尾)



- `dwMoveMethod`参数指定的起点加上`liDistanceToMove`参数指定的值就是我们要设定的新文件指针。
  - 如果`dwMoveMethod`参数指定为`FILE_BEGIN`，那么`liDistanceToMove`参数相当于一个绝对值，应该指定为一个正数，因为起点为0。
  - 如果`dwMoveMethod`参数指定为`FILE_CURRENT或FILE_END`，`liDistanceToMove`参数指定为正数就是把文件指针向文件尾部移动，指定为负数就是把文件指针向文件头部移动。
  - `dwMoveMethod`参数指定为`FILE_END`  `iDistanceToMove`参数指定为正数，即往文件尾部的后面移动指针，这没有问题，文件指针完全可以移动到文件所有数据的后面，例如现在文件的长度是100B，执行下面的代码可以成功地把文件指针移动到1000B的位置。该操作的用途是可以将文件扩展到需要的长度，然后继续调用WriteFile函数写入数据。如果没有再次调整文件指针，系统会将文件从100B扩展到1000B后再从1000B处写入数据。例如下面的代码︰

```c
TCHAR szStr[]= TEXT("你好，Windows程序设计");
static HANDLE hFile;
LARGE_INTEGER liDistanceToMove = { 900 };
LARGE_INTEGER liNewFilePointer;
hFile = CreateFile(TEXT("D:\\Test.txt")，GENERIC_READ |GENERIC_WRITE,
FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
if (hFile != INVALID_HANDLE_VALUE)
{
	SetFilePointerEx(hFile,liDistanceToMove,&liNewFilePointer， FILE_END);
	WriteFile(hFile, szStr，_tcslen(szStr) * sizeof(TCHAR)，NULL, NULL);
	CloseHandle(hFile);
}
```

在上面的代码中，Test.txt文件的长度是100字节，也就是0～99。调用SetFilePointerEx函数后liNewFilePointer参数返回1000，然后从1000字节处开始写入字符串"你好，Windows程序设计"(本例中没有包括字符串结尾的0）。

执行上述代码后，新的文件大小= 1000 +"你好，Windows程序设计"但不包括字符串结尾的0，字节数为1000 +28 = 1028字节。第100B～999B的内容被设为0，新文件后半部分的数据如下图所示(使用十六进制编辑工具WinHex查看)。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240130210507268.png)

:::





:::details `获取当前文件指针`



如何获取当前的文件指针呢?微软公司并没有提供一个获取当前文件指针的函数，我们可以通过调用`SetFilePointerEx`函数把`liDistanceToMove`参数的值设置为0，把`dwMoveMethod`参数设置为`FILE_CURRENT`，即从文件指针的当前位置移动0字节，文件指针不会作任何移动，调用函数后在
`lpNewFilePointer`参数中返回当前文件指针。例如

```c
LARGE_INTEGER liDistanceToMove = { 0 };
SetFilePointerEx(hFile, liDistanceToMove, &liNewFilePointer, FILE_CURRENT);
```

:::



`SetEndOfFile`函数用于把文件结尾设置为文件指针的当前位置。



:::details `SetEndOfFile 函数说明`

```c
BOOL WINAPI SetEndOfFile( _In_ HANDLE hFile);
```

`SetEndOfFile`函数用于把文件结尾设置为文件指针的当前位置，即把文件的文件大小设置为文件指针的当前位置,该函数可以实现文件的截断或扩展。



例如，假设调用`CreateFile`函数打开了一个1KB大小的文件，调用`SetFilePointerEx`函数把文件指针设置为1000B的位置，然后调用`SetEndOfFile`函数可以把该文件从1000B的地方截断，截断以后的文件只有1000B大小。如果把文件指针设置为2000B然后调用`SetEndOfFile`函数即可把该文件扩展到2000B大小，新扩展部分的数据通常是全是0。





例如下面的代码把一个文件的大小扩展为8GB大小

```c
static HANDLE hFile;
LARGE_INTEGER liDistanceToMove;
liDistanceToMove.QuadPart = (LONGLONG) 8 * 1024*1024*1024; //8GB
LARGE_INTEGER liNewFilePointer;
hFile = CreateFile(TEXT("D:\Test.txt"),GENERIC_READ |GENERIC_WRITE,
FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
if(hFile != INVALID_HANDLE_VALUE)
{
	SetFilePointerEx(hFile,liDistanceToMove,&liNewFilePointer,FILE_BEGIN);
	SetEndOfFile(hFile);
}
```

`liDistanceToMove.QuadPart = (LONGLONG)8*1024*1024*1024;`中的`liDistanceToMove.QuadPart`字段是一个`LONGLONG`类型，表达式的右值`8*1024*1024*1024`默认为一个int类型，而`8*1024*1024*1024`作为int会溢出，因此需要强制转换为`LONGLONG`类型。





通过网络下载文件时通常是创建一个文件，立即设置文件指针到要下载的文件大小处，然后调用`SetEndOfFile`函数扩展其大小，再慢慢填充数据，其目的是先占用磁盘空间。



:::







### 文件属性



有了文件句柄后，可以通过调用`GetFileSizeEx`函数获取该文件的文件大小



:::details `GetFileSizeEx 函数说明`

```c
/// <summary>
/// 获取文件大小
/// </summary>
/// <param name="hFile">文件句柄</param>
/// <param name="lpFileSize">在这个LARGE_INTEGER结构中返回的文件大小的字节数</param>
/// <returns></returns>
BOOL WINAPI GetFileSizeEx(HANDLE hFile,PLARGE_INTEGER lpFileSize);
```

:::





:::details `GetFileType 函数说明`

`CreateFile`函数不仅可以创建、打开普通磁盘文件，还可以用于创建或打开控制台、管道等。

`GetFileType`函数用于获取指定文件的文件类型,函数返回下表所示的值之一。

|       宏常量        |                    含义                     |
| :-----------------: | :-----------------------------------------: |
| `FILE_TYPE_UNKNOWN` |    指定的文件类型未知，或者函数调用失败     |
|  `FILE_TYPE_DISK`   |            指定的文件是磁盘文件             |
|  `FILE_TYPE_CHAR`   | 指定的文件是字符文件，通常是LPT设备或控制台 |
|  `FILE_TYPE_PIPE`   |   指定的文件是套接字、命名管道或匿名管道    |

:::



:::details `GetFileTime/SetFileTime 函数说明`



GetFileTime  SetFileTime函数用于获取、设置文件的创建时间、最后访问时间和最后修改时间

```c
BOOL WINAPI GetFileTime(
_In_ HANDLE hFile,//文件句柄
_out_opt_ LPFILETIME lpCreationTime, //文件创建时间
_out_opt_LPFILETIME lpLastAccessTime, //最后访问时间
_out_opt_LPFILETIME lpLastWriteTime); //最后修改时间

BOOL WINAPl SetFileTime(
_In_ HANDLE hFile,
_In_opt_ const FILETIME* lpCreationTime,
_In_opt_ const FILETIME*lpLastAccessTime,
_In_opt_ const FILETIME*lpLastWriteTime);
```

调用GetFileTime函数后，为了得到年月日时间数据，可以调用FileTimeToSystemTime函数将FILETIME转换为SYSTEMTIME结构。



调用SetFileTime函数设置时间时，可以先设置好SYSTEMTIME结构，再调用SystemTimeToFileTime函数将SYSTEMTIME结构转换为FILETIME。



:::



:::details `获取文件属性G/SetFileAttributes `



要获取、设置文件系统属性可以调用`GetFileAttributes` `SetFileAttributes`函数，这里的文件系统属性是指`CreateFile`函数的`dwFlagsAndAttributes`参数指定的`FILE_ATTRIBUTE_*`值。



```c
DWORD WINAPI GetFileAttributes(
	_In_ LPCTSTR lpFileName //函数返回FILE_ ATTRIBUTE_*值的组合
);

BOOL WINAPI SetFileAttributes(
_In_ LPCTSTR lpFileName, //文件名称
_In_ DWORD dwFileAttributes); //指定为FILE_ATTRIBUTE_*值的组合
```

:::





:::details `GetFileAttributesEx 函数说明`

如果需要获取更完整的文件属性信息，包括`FILE_ATTRIBUTE_*`值的文件系统属性，以及文件的创建时间、最后访问时间和最后修改时间，以及文件大小等信息，可以调用`GetFileAttributesEx`函数

```c
BOOL WINAPI GetFileAttributesEx(
_In_ LPCTSTR lpFileName, //文件名称
_In_ GET_FILEEX_INFO_LEVELS flnfoLevelld, //指定为GetFileExlnfoStandard
_out_ LPVOID lpFilelnformation); //返回文件属性
```

- `flnfoLevelld`参数是一个`GET_FILEEX_INFO_LEVELS`枚举类型,在这个函数中，该枚举值只能指定为`GetFileExlnfoStandard`，表示`lpFilelnformation`参数是一个指向`WIN32_FILE_ATTRIBUTE_DATA`结构的指针。

```c
typedef enum _GET_FILEEX_INFO_LEVELS 
{
	GetFileExInfoStandard,
	GetFileExMaxInfoLevel
}GET_FILEEX_INFO_LEVELS;
```

- lpFilelnformation参数需要指定为一个指向`WIN32_FILE_ATTRIBUTE_DATA`结构的指针，函数在这个结构中返回文件的属性信息。

```c
typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
DWORD dwFileAttributes;	//文件系统属性信息，FILE_ATTRIBUTE_*值的组合
FILETIME ftCreationTime; //文件创建时间
FILETIME ftLastAccessTime; //最后访问时间
FILETIME ftLastWriteTime; //最后修改时间
DwORD nFileSizeHigh; //文件大小的高32位
DWORD nFileSizeLow; //文件大小的低32位
} WIN32_FILE_ATTRIBUTE_DATA，*LPWIN32_FILE_ATTRIBUTE_DATA;
```

:::





:::details `GetFilelnformationByHandle 函数说明`

```c
typedef struct_BY_HANDLE_FILE_INFORMATION {
	DWORD dwFileAttributes;	//文件系统属性信息，FILE_ATTRIBUTE_*值的组合
	FILETIME ftCreationTime; //文件创建时间
  	FILETIME ftLastAccessTime;//最后访问时间
    FILETIME ftLastWriteTime;//最后修改时间
	DWORD dwVolumeSerialNumber;//文件所属的卷的序列号
	DWORD nFileSizeHigh; //文件大小的高32位
	DWORD nFileSizeLow; //文件大小的低32位
	DWORD nNumberOfLinks;//指向该文件的链接数
	DWORD nFileIndexHigh; //该文件ID的高32位
	DWORD nFilelndexLow; //该文件ID的低32位
}BY_HANDLE_FILE_INFORMATION,*PBY_HANDLE_FILE_INFORMATION，*LPBY_HANDLE_FILE_ INFORMATION;
```

- 与`GetFileAttributesEx`函数使用的`WIN32_FILE_ATTRIBUTE_DATA`结构相比，
  `BY_HANDLE_FILE_INFORMATION`结构多了4个字段︰`dwVolumeSerialNumber ` `nNumberOfLinks`
  `nFilelndexHigh`和 `nFilelndexLow`。

- 卷序列号和文件lD组合才可以唯一地标识一台计算机上的文件，要确定两个打开的文件句柄是否代表同一个文件，卷序列号和文件ID必须相同，因为在不同的逻辑驱动器上可以有相同ID的文件。



对应地，还有一个`SetFilelnformationByHandle`函数可以通过文件句柄来设置一个文件的信息，如果需要，可以自行参考MSDN。

:::





### 复制文件

`CopyFile`函数用于将现有文件复制到新文件，函数原型如下。



:::details `CopyFile 函数说明`

```c
/// <summary>
/// 复制文件
/// </summary>
/// <param name="lpExistingFileName">现有文件对应于源文件文件名</param>
/// <param name="IpNewFileName">新文件对应于目标文件文件名</param>
/// <param name="bFailfExists"></param>
/// <returns></returns>
BOOL WINAPI CopyFile(_In_ LPCTSTR lpExistingFileName, _In_ LPCTSTR IpNewFileName, _In_ BOOL bFailfExists);
```

- 如果`lpExistingFileName`参数指定的源文件不存在，则函数调用失败，调用`GetLastError`函数返回
  `ERROR_FILE_NOT_FOUND`。
- 如果`bFailfExists`参数设置为TRUE 参数指定的目标文件已经存在，函数调用将失败，调用`GetLastError`函数返回`ERROR_FILE_EXISTS`
- 如果设置为FALSE并且指定的目标文件已经存在，则函数将覆盖已经存在的文件并成功执行。但是在这种情况下，如果目标文件设置了`FILE_ATTRIBUTE_HIDDEN`或`FILE_ATTRIBUTE_READONLY`属性，则函数调用还是会失败，调用`GetLastError`函数返回`ERROR_ACCESS_DENIED`。例如下面的代码

```c
    //先直接走一波直接复制
    if (!CopyFile(TEXT("F:\|Test.rar"),TEXT("F:\\DownloadslITest.rar"),TRUE))
    {
        //复制失败了，给用户提示。告知情况，是不是要覆盖
        if (GetLastError() == ERROR_FILE_EXISTS)
        {
            int nRet = MessageBox(NULL,TEXT("指定的新文件已经存在，是否覆盖目标文件"),TEXT("提示"),MB_OKCANCEL|MB_ICONINFORMATION|MB_DEFBUTTON2);
            if (nRet == IDOK)
            {
                CopyFile(TEXT("F:\\Test.rar"),TEXT("F:\\Downloads\\Test.rar"),FALSE);
            }
            else if (nRet == IDCANCEL)
            {
              
            }

        }
    }
    else
    {
        MessageBox(hwnd, TEXT("函数执行失败，错误原因未知"),TEXT("提示"),MB_OK);
    }
```

:::



`CopyFile`函数仅仅实现了基本的复制文件功能，如何在复制过程中实时获取复制进度呢?



这里介绍一下`CopyFileEx`函数。



:::details `CopyFileEx函数说明`



`CopyFileEx`函数提供了两个附加功能，该函数通常用于复制比较大的文件。

- 每当一部分复制操作完成时可以调用指定的回调函数。

- 在复制操作期间可以取消正在进行的复制操作

```c
/// <summary>
/// 复制文件 带复制过程进度回调
/// </summary>
/// <param name="lpExistingFileName">现有文件,对应于源文件文件名</param>
/// <param name="lpNewFileName">新文件对应于目标文件文件名</param>
/// <param name="lpProgressRoutine">回调函数的地址，可以设置为NULL</param>
/// <param name="lpData">传递给回调函数的参数，可以设置为NULL</param>
/// <param name="pbCancel">指向布尔变量的指针，如果在复制操作过程中将该指针指向的变量设置为TRUE，则操作将被取消</param>
/// <param name="dwCopyFlags">指定如何复制文件的标志，可以设置为0</param>
/// <returns></returns>
BOOL WINAPI CopyFileEx(_In_ LPCTSTR lpExistingFileName,_In_ LPCTSTR lpNewFileName,_In_opt_ LPPROGRESS_ROUTINE lpProgressRoutine,_In_opt_ LPVOID lpData,_In_opt_ LPBOOL pbCancel,_In_ DWORD dwCopyFlags);
```

- `lpProgressRoutine`参数指定为一个指向回调函数的指针,每当一部分复制操作完成时系统会调用该回调函数。
- `lpData`参数是传递给回调函数的参数，可以指定为一个自定义数据，如果不需要则设置为NULL。
- `pbCancel`参数是一个指向布尔变量的指针，如果在复制操作过程中将该指针指向的变量设置为TRUE，则操作将被取消，例如当用户按下"取消"按钮时，程序可以把该参数指向的变量设置为TRUE，CopyFileEx函数会取消复制操作并立即返回FALSE(调用GetLastError返回ERROR_REQUEST_ABORTED)，并删除目标文件。
- `dwCopyFlags`参数是指定如何复制文件的标志，如果没有特殊需求，则设置为0。该参数可以是表所示的值的组合(仅列举部分)。

|                 宏常量                  |                             含义                             |
| :-------------------------------------: | :----------------------------------------------------------: |
|       `COPY_FILE_FAIL_IF_EXISTS`        | 如果目标文件已经存在，则函数调用将失败，此时调用GetLastError函数返回错误码ERROR_FILE_EXISTS |
| `COPY_FILE_ALLOW_DECRYPTED_DESTINATION` | 调用CopyFileEx函数复制加密文件时，该函数尝试使用在源文件加密中使用的密钥对目标文件进行加密﹔如果无法完成此操作，则函数尝试使用默认密钥对目标文件进行加密。如果这两种方法都不能完成，则CopyFileEx函数调用失败，调用GetLastError函数返回ERROR_ENCRYPTION_FAILED。如果指定了该标志，即使无法对目标文件进行加密，CopyFileEx函数依然可以完成复制操作 |
|        `COPY_FILE_NO_BUFFERING`         | 复制操作使用无缓冲l/O，不使用系统的I/O缓存，该标志通常用于传输非常大的文件 |

- `dwCopyFlags`参数指定了`COPY_FILE_FAIL_IF_EXISTS`标志并且`lpNewFile Name`参数指定的目标文件已经存在，则函数调用将失败，调用`GetLastError`函数返回 `ERROR_FILE_EXISTS`;
- 如果`dwCopyFlags`参数没有指定`COPY_FILE_FAIL_IF_EXISTS`标志并且指定的目标文件已经存在，则函数将覆盖已经存在的文件并成功执行，但是在这种情况下，如果目标文件设置了`FILE_ATTRIBUTE_HIDDEN`或`FILE_ATTRIBUTE_READONLY`属性，则函数调用还是会失败，调用`GetLastError` 函数返回`ERROR ACCESS DENIED` .

- 如果`lpExistingFileName`参数指定的源文件不存在，则函数调用失败，调用`GetLastError`函数返回
  `ERROR_FILE_NOT_FOUND` 。

:::





`CopyFileEx`函数使用的回调函数格式也适用于移动文件所使用的`MoveFileWithProgress`函数，每当复制或移动操作完成一部分时系统会调用回调函数。回调函数的定义格式如下



:::details `回调格式`

```c
DWORD CALLBACK CopyProgressRoutine(
_In_ LARGE_INTEGER TotalFileSize, //文件的总大小，以字节为单位
_In_ LARGE_INTEGER TotalBytesTransferred, //已经从源文件传输到目标文件的字节总数
_In_ LARGE_INTEGER StreamSize, //当前文件流的总大小，以字节为单位
_In_ LARGE_INTEGER StreamBytesTransferred,//当前流中已经从源文件传输到目标文件的字节总数
_In_ DWORD dwStreamNumber, //当前流的编号
_In_ DWORD dwCallbackReason,//调用该回调函数的原因
_In_ HANDLE hSourceFile, //源文件的句柄
_In_ HANDLE hDestinationFile,//目标文件的句柄
_In_opt_ LPVOID lpData //传递过来的回调函数参数
);
```

我们感兴趣的通常是前两个参数`TotalFileSize`和`TotalBytesTransferred`。

- `dwCallbackReason`参数指出调用该回调函数的原因，如果是CALLBACK_STREAM_SWITCH,则说明一个文件流已经创建，即将开始复制，这是在首次调用回调函数时给出的回调原因,如果是CALLBACK_CHUNK_FINISHED，则说明复制操作已经完成了一部分，关于这里说的一部分到底是多大，不同的系统可能有不同的定义，可能是64KB，也可能是1MB。





回调函数`CopyProgressRoutine`应返回下表所示的值之一

|        宏常量        |                             含义                             |
| :------------------: | :----------------------------------------------------------: |
| `PROGRESS_CONTINUEO` |                继续复制操作，通常都是返回该值                |
|  `PROGRESS_CANCEL`   |                 取消复制操作，并删除目标文件                 |
|   `PROGRESS_STOP`    | 停止复制操作，已复制的目标文件会保留。通常不应该返回该值，如果仅仅复制了一部分数据，那么目标文件是不完整的，保留目标文件没有意义. |
|   `PROGRESS_QUIET`   | 继续复制操作，但在以后的复制操作过程中停止调用`CopyProgressRoutine`回调函数程序中可以放置一个"取消"按钮，当用户按下"取消"按钮时，程序可以把`CopyFileEx`函数的`pbCancel`参数指向的变量设置为TRUE，CopyFileEx函数会取消复制操作并立即返回FALSE(调用GetLastError返回ERROR_REQUEST_ABORTED) ,并删除目标文件。 |

:::





:::details `复制文件示例:`



关于`CopyFileEx`函数的示例参见`CopyFileExDemo`项目，可以看到每复制完0x100000字节(即1MB)，系统就会调用回调函数一次。示例中复制的是一个4.12GB，(即4 424850 689，对应0x107BDDDO1)字节的压缩文件。

```c
#include <windows.h>
#include <Shlwapi.h>
#include "resource.h"

#pragma comment(lib, "Shlwapi.lib")

// 全局变量
HWND g_hwndDlg;
BOOL g_bCancel = FALSE;     // 复制操作过程中，如果用户点击了“取消”按钮，设置该变量为TRUE

// 函数声明
INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// 线程函数，创建一个新线程负责复制操作
DWORD WINAPI ThreadProc(LPVOID lpParameter);

// CopyFileEx函数的回调函数
DWORD CALLBACK CopyProgressRoutine(
    LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber,
    DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MAIN), NULL, DialogProc, NULL);
    return 0;
}

INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HANDLE hThread = NULL;

    if (uMsg == WM_INITDIALOG)
    {
        g_hwndDlg = hwndDlg;
        // 初始化源文件、目标文件编辑框
        SetDlgItemText(hwndDlg, IDC_EDIT_SOURCE, TEXT("F:\\Test.rar"));
        SetDlgItemText(hwndDlg, IDC_EDIT_TARGET, TEXT("F:\\Downloads\\Test.rar"));

        // 设置多行编辑控件的缓冲区大小为不限制
        SendMessage(GetDlgItem(hwndDlg, IDC_EDIT_PROCESS), EM_SETLIMITTEXT, 0, 0);
        return TRUE;

    }
    else if (uMsg == WM_COMMAND)
    {
        if (LOWORD(wParam) == IDC_BTN_COPY)
        {
            if ((hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL)) != NULL)
            {
                CloseHandle(hThread);
            }
        }
        else if (LOWORD(wParam) == IDC_BTN_CANCEL)
        {
            g_bCancel = TRUE;
        }
        else if (LOWORD(wParam) == IDCANCEL)
        {
            EndDialog(hwndDlg, 0);

        }
    }
    return FALSE;
}
DWORD WINAPI ThreadProc(LPVOID lpParameter)
{
    TCHAR szSource[MAX_PATH] = { 0 };
    TCHAR szTarget[MAX_PATH] = { 0 };
    BOOL bRet = FALSE;

    GetDlgItemText(g_hwndDlg, IDC_EDIT_SOURCE, szSource, _countof(szSource));
    GetDlgItemText(g_hwndDlg, IDC_EDIT_TARGET, szTarget, _countof(szTarget));

    // 指定的源文件是否有效
    if (!PathFileExists(szSource))
    {
        MessageBox(g_hwndDlg, TEXT("指定的源文件不存在！"), TEXT("提示"), MB_OK);
        return 0;
    }
    // 指定的目标文件是否已存在
    if (PathFileExists(szTarget))
    {
        int nRet = MessageBox(NULL, TEXT("指定的新文件已经存在，是否覆盖目标文件"),TEXT("提示"), MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON2);
        switch (nRet)
        {
        case IDOK:
            break;
        case IDCANCEL:
            return 0;
        }
    }
    bRet = CopyFileEx(szSource, szTarget, CopyProgressRoutine, NULL, &g_bCancel, 0);
    if (!bRet)
    {
        if (GetLastError() == ERROR_REQUEST_ABORTED)
        {
            MessageBox(g_hwndDlg, TEXT("用户取消了复制操作，线程函数返回"), TEXT("已取消"), MB_OK);
        }  
    }
    else
    {
        MessageBox(g_hwndDlg, TEXT("已经成功复制了文件，线程函数返回"), TEXT("已成功"), MB_OK);
    }

    g_bCancel = FALSE;
    return  0;
}

DWORD CALLBACK CopyProgressRoutine(
    LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber,
    DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData)
{

    HWND hwndEdit = GetDlgItem(g_hwndDlg, IDC_EDIT_PROCESS);
    TCHAR szBuf[256] = { 0 };
    // 实时显示复制进度
    wsprintf(szBuf, TEXT("文件总大小：%I64X\t已传输：%I64X\t文件流总大小：%I64X\t已传输：%I64X\t流编号：%d\t\n"), 
        TotalFileSize.QuadPart,
        TotalBytesTransferred.QuadPart, 
        StreamSize.QuadPart, 
        StreamBytesTransferred.QuadPart, dwStreamNumber);
    SendMessage(hwndEdit, EM_SETSEL, -1, -1);
    SendMessage(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szBuf);

    // 继续复制操作
    return PROGRESS_CONTINUE;
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E7%9B%91%E6%8E%A7%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%E7%9A%84%E5%9B%9E%E8%B0%83.gif)

:::





:::details `复制文件示例2:`



```c
#include <iostream>
#include <Windows.h>
#include<strsafe.h>
#include<Shlwapi.h>
#pragma comment(lib, "shlwapi.lib")
BOOL IsDirectory(char* path)
{
    WIN32_FIND_DATAA fd; //查到的文件信息结构体
    BOOL bRet = FALSE;//最终结果
    HANDLE hFind = INVALID_HANDLE_VALUE; //文件查找句柄，通常借此做遍历。
    char* lpFilePath = path;
    //查一下给定的路径 最后一个字符是不是文件分隔符，是则一定为目录,并帮他补充终止符
    while (*lpFilePath != '\0')
    {
        lpFilePath++;
    }
    if (*(--lpFilePath) == '\\' || *(lpFilePath) == ' / ')
    {
        *lpFilePath = '\0';
        return TRUE;
    }
    // 最后一个字符不是文件分割符，但也可能是一个目录，则查这个路径表示的东西是不是目录
    hFind = ::FindFirstFileA(path, &fd);

    // 判断是否获取错误
    if (hFind != INVALID_HANDLE_VALUE)
    {
        // 文件信息按位与上目录属性, 非目录则全部置零
        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            bRet = TRUE;
        }
        ::FindClose(hFind);
    }
    return bRet;
}
int main(int argc, char* argv[])
{
    char szFileSrc[MAX_PATH] = { 0 }; 
    char szFileDest[MAX_PATH] = { 0 };
    char szBuffer[MAX_PATH] = { 0 };
    ::StringCchCopyA(szFileSrc, _countof(szFileSrc), "E:\\xxx\\111.txt");
    ::StringCchCopyA(szFileDest, _countof(szFileDest), "D:\\");
   
    // 如果第二个参数是目录,则拼装新的文件路径
    if (IsDirectory(szFileDest))
    {
        ::StringCchCopyA(szBuffer,_countof(szBuffer), szFileSrc);
        ::PathStripPathA(szBuffer);
        ::StringCchPrintfA(szFileDest, _countof(szFileDest), "%s\\%s", szFileDest, szBuffer);
    }

    if (::CopyFile(szFileSrc, szFileDest, 0) == 0)
    {
        printf("文件复制失败 \n");
    }
    else
    {
        printf("文件已复制 \n");
    }

    system("pause");
    return 0;
}
```

:::









### 移动文件(目录)

`MoveFile`函数用于移动一个文件或者目录，移动成功后源文件或源目录会被删除



:::details `MoveFile 函数说明`

```c
BOOL WINAPI MoveFile(
_In_ LPCTSTR lpExistingFileName,//现有文件(目录)对应于源文件(目录)名
_In_ LPCTSTR IpNewFileName //新文件(目录)对应于目标文件(目录)名
);
```

调用MoveFile函数移动文件或者目录时，需要注意以下几点



- 如果指定的源文件（目录)不存在，则函数调用会失败，此时调用GetLastError函数会返回
  ERROR_FILE_NOT _FOUND。
- 不管移动的是文件还是目录，如果目标文件(目录)已经存在，则函数调用会失败。如果目标文件已经存在，则调用GetLastError函数会返回ERROR_FILE_EXISTS (80);如果目标目录已经存在，则调用GetLastError函数会返回ERROR_ALREADY_EXISTS (183)。
- 不管移动的是文件还是目录，目标文件（目录)名的上一层目录必须存在，否则函数调用会失败，调用GetLastError函数会返回ERROR_PATH_NOT_FOUND。例如，下面的代码︰

```c
//移动文件
MoveFile(TEXT("F:\\Test.avi")，TEXT("F:\\Downloads\\Test.avi"));
//移动目录
MoveFile(TEXT("F:\\DTLFolder")，TEXT("F:\\Downloads\\DTLFolder"));
```

上面的代码中，F:\Downloads目录必须存在，否则移动到其下层的文件或目录都会失败。







如果移动的是文件，目标文件名可以位于同一个逻辑驱动器中，也可以位于其他逻辑驱动器中

如果移动的是目录，目标目录必须位于同一个逻辑驱动器中。否则函数调用会失败，调用GetLastError函数会返回ERROR_ACCESS_DENIED

:::





`MoveFileEx`函数同样用于移动一个文件或者目录，在移动文件或目录时可以设置一些移动选项



:::details `MoveFileEx 函数说明`

```c
BOOL WINAPI MoveFileEx(
_In_ LPCTSTR lpExistingFileName, //现有文件(目录)对应于源文件(目录)名
_In_ opt_LPCTSTR lpNewFileName, //新文件(目录)对应于目标文件(目录)名
_In_ DWORD dwFlags //移动选项标志
);
```

调用MoveFileEx函数移动文件或者目录时，需要注意以下几点。

- 如果指定的源文件(目录)不存在，则函数调用会失败，此时调用GetLastError函数会返回
  ERROR_FILE_NOT_FOUND。
- 不管移动的是文件还是目录，如果目标文件(目录)已经存在，则函数调用会失败。如果目标文件已经存在，则调用GetLastError函数会返回ERROR_ALREADY_EXISTS;如果目标目录已经存在，则调用GetLastError函数也会返回ERROR_ALREADY_EXISTS。
- 不管移动的是文件还是目录，目标文件(目录)名的上一层目录必须存在，否则函数调用会失败，调用GetLastError函数返回ERROR PATH NOT FOUND.
- 默认情况下，不管移动的是文件还是目录，目标文件(目录)名必须位于同一个逻辑驱动器中﹔否则函数调用会失败，调用GetLastError函数返回ERROR_NOT_SAME_DEVICE.



要把一个文件成功移动到其他逻辑驱动器中，可以在调用MoveFileEx函数时为dwFlags参数指定
MOVEFILE_COPY_ALLOWED标志，但是不能通过指定该标志把一个目录移动到其他逻辑驱动器中。dwFlags参数是移动选项标志，可以是以下值的组合（(仅列举部分)，如下表所示。

|            宏常量             |                             含义                             |
| :---------------------------: | :----------------------------------------------------------: |
|  `MOVEFILE_REPLACE_EXISTING`  | 用于移动文件，允许目标文件已经存在。如果存在，MoveFileEx函数会覆盖目标文件 |
|    `MOVEFILE_COPY_ALLOWED`    | 用于移动文件，允许把一个文件移动到其他逻辑驱动器中，MoveFileEx函数在内部调用CopyFile和DeleteFile函数模拟该移动操作 |
| `MOVEFILE_DELAY_UNTIL_REBOOT` | ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240131195407236.png) |

`MoveFileEx`函数也不能把一个目录移动到其他逻辑驱动器中。



:::





`MoveFileWithProgress`函数的功能与`MoveFileEx`相同，可以指定一个接收进度通知的回调函数。



:::details `MoveFileWithProgress 函数说明`

```c
BOOL WINAPl MoveFileWithProgress(
_In_ LPCTSTR lpExistingFileName, //现有文件(目录)对应于源文件(目录)名
_In_opt_ LPCTSTR lpNewFileName,//新文件(目录)对应于目标文件（目录)名
_In_opt_ LPPROGRESS_ROUTINE lpProgressRoutine,//回调函数的地址，可以设置为NULL
_In_opt_ LPVOID lpData,//传递给回调函数的参数，可以设置为NULL
_In_ DWORD dwFlags //移动选项标志
);
```

MoveFileEx函数的使用方法非常简单，这里不再重复介绍。

:::





:::details `示例:`

```c
#include <iostream>
#include <Windows.h>
#include<strsafe.h>
#include<Shlwapi.h>
#include<string>
#pragma comment(lib, "shlwapi.lib")
// 判断是否为目录
BOOL IsDirectory(std::string path)
{
    WIN32_FIND_DATAA fd; //查到的文件信息结构体
    BOOL bRet = FALSE;//最终结果
    HANDLE hFind = INVALID_HANDLE_VALUE; //文件查找句柄，通常借此做遍历。
    char* lpFilePath = (char*)path.c_str();
    //查一下给定的路径 最后一个字符是不是文件分隔符，是则一定为目录,并帮他补充终止符
    while (*lpFilePath != '\0')
    {
        lpFilePath++;
    }
    if (*(--lpFilePath) == '\\' || *(lpFilePath) == ' / ')
    {
        *lpFilePath = '\0';
        return TRUE;
    }

    // 最后一个字符不是文件分割符，但也可能是一个目录，则查这个路径表示的东西是不是目录
    hFind = ::FindFirstFileA(path.c_str(), &fd);
    // 判断是否获取错误
    if (hFind != INVALID_HANDLE_VALUE)
    {
        // 文件信息按位与上目录属性, 非目录则全部置零
        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            bRet = TRUE;
        }
        ::FindClose(hFind);
    }
    return bRet;
}
int main(int argc, char* argv[])
{
    char szFileSrc[MAX_PATH] = { 0 };
    char szFileDest[MAX_PATH] = { 0 };
    char szBuffer[MAX_PATH] = { 0 };

    ::StringCchCopyA(szFileSrc, _countof(szFileSrc), "E:\\xxx\\111.txt");
    ::StringCchCopyA(szFileDest, _countof(szFileDest), "D:\\");
    // 如果第二个参数是目录,则拼装新的文件路径
    if (IsDirectory(szFileDest))
    {
        ::StringCchCopyA(szBuffer, _countof(szBuffer), szFileSrc);
        ::PathStripPathA(szBuffer);
        ::StringCchPrintfA(szFileDest, _countof(szFileDest), "%s\\%s", szFileDest, szBuffer);
    }
    if (::MoveFileA(szFileSrc, szFileDest) == 0)
    {
        printf("文件剪切失败 \n");
    }
    else
    {
        printf("文件剪切成功 \n");
    }

    system("pause");
    return 0;
}
```

:::

### 删除文件(目录)

删除一个文件可以调用`DeleteFile`函数。



:::details `DeleteFile 函数说明`

```c
BOOL WINAPI DeleteFile(_In_ LPCTSTR lpFileName);//目标文件
```

如果目标文件是只读文件，函数调用会失败，调GetLastError函数会返回ERROR_ACCESS_DENIED(隐藏文件不影响，可以删除隐藏文件)。如果需要删除一个只读文件，只需要调用SetFileAttributes函数删除其FILE_ATTRIBUTE_READONLY属性即可。





一个文件处于打开状态时不能进行删除，DeleteFile函数调用会失败，GetLastError函数返回

`ERROR_SHARING_VIOLATION`，通常应该先调用CloseHandle函数关闭文件，然后再调用DeleteFile函数删除文件。但是，如果调用CreateFile函数时指定了FILE_SHARE_DELETE共享标志，那么在调用CloseHandle函数关闭文件前，调用DeleteFile函数会成功，例如下面的代码︰

```c
   hFile = CreateFile(TEXT("D:1|Test.txt"),GENERIC_READ | GENERIC_WRITE,
       FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
   DeleteFile(TEXT("D:\\Test.txt"));  // 函数调用成功，但是文件还没有被删除
   CloseHandle(hFile);

   //执行CloseHandle以后，文件会被删除
   //如果没有调用CloseHandle函数，程序关闭后D:\Test.txt文件也会被删除。

```

:::



:::details `示例`

```c
#include <iostream>
#include <Windows.h>
int main(int argc, const char* argv[])
{
  // 如果非零则删除失败
  if (!DeleteFile("d://xxx.exe"))
  {
    printf("删除文件错误：%x \n", GetLastError());
  }
  system("pause");
  return 0;
}
```

:::



首先我们知道`RemoveDirectory()` 只能删除一个空的目录，如果目录中有子目录或者是子文件的话就会删除失败的。解决的方法是递归的思想，将子文件删除，之后就可以调用这个函数删除一个空的文件夹了。

:::details `删除目录示例:`

```c
//删除某个文件夹 如果这个文件夹下面有子目录或者文件，统统删除。
void EnumDeleteFile(TCHAR* szDir)
{
	WIN32_FIND_DATA findData;
	TCHAR szDir_[MAX_PATH];
	HANDLE hFind;
	CString szDirCstring(szDir);
	if (szDirCstring.ReverseFind('\\') == szDirCstring.GetLength() - 1) /* 最后一个字符是\ 则做删除处理*/
	{
		szDirCstring.Delete(szDirCstring.GetLength()-1,1);
		SecureZeroMemory(szDir_,sizeof szDir_);
		StringCchCopy(szDir_,MAX_PATH, szDirCstring.GetBuffer());
		StringCchCopy(szDir,MAX_PATH, szDirCstring.GetBuffer());
	}
	else
	{
		SecureZeroMemory(szDir_, sizeof szDir_);
		StringCchCopy(szDir_, MAX_PATH, szDir);
	}
	StringCchCat(szDir_,MAX_PATH,_T("\\*.*"));

	hFind = FindFirstFile(szDir_,&findData);

	if (INVALID_HANDLE_VALUE == hFind)
	{
		//此目录不存在！
		return;
	}
	do
	{
		TCHAR lpSzDirOrFile[MAX_PATH];
		if (!_tccmp(findData.cFileName, _T(".")) || !_tccmp(findData.cFileName, _T("..")))
			continue;
		if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			SecureZeroMemory(lpSzDirOrFile, sizeof lpSzDirOrFile);
			StringCchPrintf(lpSzDirOrFile, MAX_PATH, _T("%s\\%s"),szDir,findData.cFileName);
			EnumDeleteFile(lpSzDirOrFile);
		}
		else
		{
			SecureZeroMemory(lpSzDirOrFile, sizeof lpSzDirOrFile);
			StringCchPrintf(lpSzDirOrFile, MAX_PATH, _T("%s\\%s"), szDir, findData.cFileName);
			wcout << lpSzDirOrFile << endl;

			if (!DeleteFile(lpSzDirOrFile)) 
			{
				if (ERROR_ACCESS_DENIED == GetLastError()) //删除失败的原因，可能是文件是只读文件属性
				{
					 SetFileAttributes(lpSzDirOrFile, FILE_ATTRIBUTE_NORMAL);
					 DeleteFile(lpSzDirOrFile);
				}
			}
		}

	} while (FindNextFile(hFind,&findData));
	FindClose(hFind);
	RemoveDirectory(szDir); 
}

int _tmain(int argc,TCHAR* argv)
{
	/*TCHAR* target_dir = _T("D:\\copyDestDirectory");
	TCHAR ugii_root_dir[50] = {0};
	GetEnvironmentVariable(_T("UGII_ROOT_DIR"), ugii_root_dir,50); 
	

	CreateDirectory(_T("D:\\copyDestDirectory"), NULL);
	EnumCopyFile(ugii_root_dir, target_dir);*/
	
	EnumDeleteFile(_T("D:\\copyDestDirectory"));
	return 0;
}
```

:::



### 无缓冲I/O





调用CreateFile函数时指定`FILE_FLAG_NO_BUFFERING | FILE_FLAG_WRITE_THROUGH`标志，表示使用无缓冲l/O，这里涉及系统缓存和硬盘缓存。`FILE_FLAG_NO_BUFFERING`标志表示对文件的读写操作不使用系统缓存，但是不影响硬盘缓存和内存映射文件



- `FILE_FLAG_WRITE_THROUGH`标志表示对文件的写操作不会通过任何中间缓存，写请求会被马上写入物理硬盘中。
- 使用`FILE_FLAG_NO_BUFFERING|FILE_FLAG_WRITE_THROUGH`标志，读操作理论上还会使用硬盘缓存，写操则不会使用系统缓存和硬盘缓存。



- 不建议使用FILE_FLAG_WRITE_THROUGH标志，当进行写操作的时候，如果没有使用该标志，那么通过硬盘缓存可以立即完成I/O请求并延迟执行物理I/O，硬盘寻址和磁头定位需要时间，因此不使用该标志可以提高程序性能。

也不建议使用FILE_FLAG_NO_BUFFERING标志，如果有需要使用该标志的场合，对于文件的读写操作，请注意以下问题。

- 读取/写入文件的时候文件偏移量必须是扇区大小的整数倍。
- 读取/写入文件的字节数必须是扇区大小的整数倍，例如，如果扇区大小为512字节，那么可以请求读取/写入512字节、1024字节、1536字节，但不能请求读取/写入335字节、981字节、1500字节。
- 用于读取/写入文件的缓冲区地址必须是物理扇区大小的整数倍（根据硬盘的不同，可能不会强制执行此要求)。



前2项指的是逻辑扇区大小，第3项指的是物理扇区大小。以前硬盘物理扇区大小通常是512字节，现在则多数是4KB，直接使用4KB作为寻址单位可能会存在兼容性问题，临时兼容性解决方案是引入模拟常规512字节扇区硬盘的设备。上述模拟解决方案导致出现了逻辑扇区大小和物理扇区大小两个概念，逻辑扇区大小是逻辑寻址单位，物理扇区大小是硬盘原子写入单位，为了获得最佳的性能和可靠性，微软公司强烈建议无缓冲I/O应该与物理扇区大小对齐。例如，在一台计算机上，通过`fsutil fsinfo ntfsinfo c:`命合获取的固态硬盘的逻辑扇区和物理扇区大小均为512字节，通过`fsutil fsinfo ntfsinfo e:`命今获取的机械硬盘的逻辑扇区和物理扇区大小分别为512字节和4KB。



大多数情况下，页面对齐的内存也是扇区对齐的，因为扇区大小大于页面大小的情况很少见，因此读取/写入文件时文件偏移量和读写字节数可以设置为页面大小的整数倍;为了保证用于读取/写入文件的缓冲区地址一定是物理扇区大小的整数倍，可以使用VirtualAlloc函数分配缓冲区，该函数可以保证内存区域的起始地址是分配粒度的整数倍（在所有Windows平台上分配粒度均为64KB)，所分配的内存区域大小一定是页面大小的整数倍。
通过GetDiskFreeSpace函数可以获取逻辑扇区大小，使用控制代IOCTL_DISK_GET_DRIVE_GEOMETRY_EX调用DeviceloControl函数也可以获取逻辑扇区大小，如果需要获取物理扇区大小，可以使用控制代码
IOCTL_STORAGE_QUERY_PROPERTY调用DeviceloControl函数。





