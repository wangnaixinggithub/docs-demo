# 菜单和其他资源

资源是添加到程序可执行文件中的二进制数据，包括标准资源和自定义资源。标准资源包括菜单、图标、光标、位图、加速键（快捷键)、字符串表、程序版本信息、HTML和对话框等，自定义资源可以是程序所需的任何格式的数据。这里我们主要聊一聊菜单资源





## 菜单和快捷键

菜单通常是一个程序必不可少的组成部分，这里以记事本程序为例说明一下与菜单有关的术语。



- 记事本程序的菜单栏位于标题栏下方，这样的菜单栏称为程序的**主菜单或顶级菜单**

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616090057592.png)

- 主菜单中有文件、编辑、格式、查看、帮助等菜单项，这些菜单项称为**主菜单项**

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616090201905.png)

- 单击每一个主菜单项还可以弹出下一级菜单，这称为**弹出菜单**

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616090254223.png)

- 单击主菜单项通常用于弹出子菜单项列表，单击子菜单项时系统才会发送命令消息，这些子菜单项也称为命今项。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616090654082.png)

- 有的子菜单项中还包含下一级子菜单项列表，这样的子菜单项右边通常附带一个三角箭头。

  ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616090802804.png)

- 另外，点击标题栏左侧的小图标可以弹出一个系统菜单项列表，在某些程序窗口的客户区中单击鼠标右键也可以弹出一个子菜单项列表，这些都属于弹出菜单。

  ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616091038979.png)



## 为程序添加菜单栏

要为程序添加菜单，需要先添加菜单资源。最简单的方法是通过VS的资源视图添加。右击`HelloWindows项目`→添加→资源，打开添加资源对话框，选择Menu并单击新建，如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127161844858-17063435260871-17185003700051.png)

可以看到VS自动为我们添加了`HelloWindows.rc`资源脚本文件，在该资源脚本文件中添加了Menu类型的ID为IDR_MENU1的菜单资源。选中左侧资源视图中的IDR_MENU1，打开VS软件右侧的属性对话框。属性对话框中显示了菜单资源IDR_MENU1的相关属性，如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127161946974-17063435882172-17185004576422.png)

修改菜单资源ID为IDR_MENU。现在可以给菜单资源添加若干个主菜单项了。我们在"请在此处键入"编辑框中输入主菜单项"文件"，然后在"文件"菜单项的下一级依次输入子菜单项"新建"  "打开" "保存" "另存为"，在子菜单项"另存为"下面的编辑框中右键插入分隔符，然后继续添加子菜单项"退出"，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127162148657.png)

:::tip 

单击主菜单项。比如说单击主菜单项"文件"的作用是弹出子菜单项列表，而不是执行程序命令。

因此主菜单项"文件"是没有菜单项ID(或者说命今ID)的。

:::



我们依次将子菜单项新建、打开、保存、另存为、退出 的菜单项ID，修改为见名知义的名字：`ID_FILE_NEW` `ID_FILE_OPEN`  `ID_FILE_SAVE   ID_FILE_SAVEAS `  `ID_FILE_EXIT`。



继续在主菜单项"文件" 右边的"请在此处键入"编辑框中添加主菜单项"编辑"，以及子菜单项"剪切"  "复制" "粘贴";然后添加主菜单项"帮助"及子菜单项"关于HelloWindows"。



分别设置子菜单项剪切、复制、粘贴和关于HelloWindows的ID为`ID_EDIT_CUT`  `ID_EDIT_COPY`  `ID_EDIT_PASTE`和`ID_HELP_ABOUT`，然后按Ctrl+S组合键保存资源脚本文件`HelloWindows.rc`，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127162748287-17063440696684.png)

可以看到VS软件自动为我们创建了`HelloWindows.rc`和`resource.h`两个文件。



:::details `.rc .h` 这两个文件的用途

`HelloWindows.rc`是资源脚本文件，除了VS的可视化资源编辑视图(资源编辑器），我们也可以通过自己编写资源脚本文件来添加资源。切换到解决方案资源管理器视图，用鼠标右键单击资源文件下面的`HelloWindows.rc`并**查看代码**，`HelloWindows.rc`文件的主要内容如下所示:

```c
// Microsoft Visual C++ generated resource script.
/
#include "resource.h"
IDR_MENU MENUEX
BEGIN
    POPUP "文件",            65535,MFT_STRING,MFS_ENABLED
    BEGIN
        MENUITEM "新建",              ID_FILE_NEW,MFT_STRING,MFS_ENABLED
        MENUITEM "打开",              ID_FILE_OPEN,MFT_STRING,MFS_ENABLED
        MENUITEM "保存",      ID_FILE_SAVE,MFT_STRING|MFT_MENUBREAK,MFS_CHECKED
        MENUITEM "另存为",             ID_FILE_SAVEAS,MFT_STRING,MFS_ENABLED
        MENUITEM MFT_SEPARATOR
        MENUITEM "退出(&X)",           ID_FILE_EXIT,MFT_STRING,MFS_ENABLED
    END
    POPUP "编辑",             65535,MFT_STRING,MFS_GRAYED
    BEGIN
        MENUITEM "剪切",              ID_EDIT_CUT,MFT_STRING,MFS_ENABLED
        MENUITEM "复制",              ID_EDIT_COPY,MFT_STRING,MFS_ENABLED
        MENUITEM "粘贴",              ID_EDIT_PASTE,MFT_STRING,MFS_ENABLED
    END
    POPUP "帮助",             65535,MFT_STRING|MFT_RIGHTJUSTIFY,MFS_ENABLED
    BEGIN
        MENUITEM "关于HelloWindows(&A)",   ID_HELP_ABOUT,MFT_STRING,MFS_ENABLED
    END
END
```



资源脚本文件`HelloWindows.rc`中包含了`resource.h`头文件，`resource.h`头文件中实则为对菜单资源和子菜单项的ID定义等。这是因为资源在程序中的引用往往用一个数值来表示，但是直接使用数值不直观，往往用#define语句将数值定义为容易记忆和理解的宏常量，便于开发引用。



针对本次的`HelloWindow.rc` 对应的`resource.h`头文件的主要内容如下所示

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 HelloWindows.rc 使用
//
#define IDR_MENU                        101
#define IDR_ACC                         102
#define ID_FILE_NEW                     40010
#define ID_FILE_OPEN                    40011
#define ID_FILE_SAVE                    40012
#define ID_FILE_SAVEAS                  40013
#define ID_FILE_EXIT                    40014
#define ID_EDIT_CUT                     40015
#define ID_EDIT_COPY                    40016
#define ID_EDIT_PASTE                   40017
#define ID_HELP_ABOUT                   40018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40042
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

:::



正是有VS整合的资源视图的存在，让我们编写`HelloWorld.rc` 资源脚本文件的工作可视化，变得简单。但实际开发时，可能需要手撕`HellWorld.rc`文件，所以我们仍然需要对`HelloWorld.rc` 定义菜单资源的格式有所学习。





:::details `菜单的定义`

在资源脚本文件中菜单的定义格式如下：

```c
菜单ID MENU
BEGIN
	菜单定义
END
```

"菜单ID MENU"语句用来指定菜单资源的ID。菜单ID是一个16位的整数，范围是1～65535，本例中定义的菜单ID是IDR_MENU(101)  当然了，菜单ID也可以用字符串来表示，例如下面的定义∶

```
MainMenu MENU
BEGIN
	菜单定义
END
```

> 表示菜单资源的ID是字符串类型的`"MainMenu"`



菜单的具体定义语句包含在BEGIN和END关键字之内，这两个关键字也可以用`{}`代替。

:::



:::details `弹出菜单的定义`

弹出菜单的定义方式如下︰

```c
POPUP 菜单文字[,选项列表]
	BEGIN
		子菜单项定义
	END
```

菜单文字指主菜单项名称字符串，BEGIN和END关键字中的内容定义弹出菜单的每一个子菜单项。主菜单通常由多个主菜单项及下面的弹出菜单组成，本例中主菜单由"文件" "编辑" 和"帮助"3个主菜单项及下面的弹出菜单组成。弹出菜单的定义也可以嵌套，以达到单击子菜单项弹出下一级子菜单项列表的目的，子弹出菜单的定义同样需要`POPUP BEGIN和END`关键字。



针对弹出菜单，常用的选项值如下:

- GRAYED——菜单项是灰化的
- DISABLED——菜单项是禁用的
- ENABLED ——菜单项是可用的

:::





:::details `子菜单项的定义`

子菜单项的定义方式如下:

```c
MENUITEM 菜单文字 命今ID [,选项列表]
```

- 菜单文字指子菜单项名称字符串。有时候在字符串的后面需要加一个带下划线的字母，例如"打开(O)"，可以在字母前面加`"&"`符号，`即"打开(&O)"`。这时带&的字母称为访问键，例如本例中当"文件"弹出菜单打开的时候按下O键，那么就相当于用鼠标单击了子菜单项"打开"，在同一个弹出菜单中不同的子菜单项所用的访问键必须不同。
- 另外，要使加速键的提示信息显示在子菜单项的右边，例如子菜单项"打开"可以使用Ctrl +O组合键，可以加一个\t(表示插入一个Tab字符),然后写上"Ctrl + O"，即`"打开(&O)\tCtrl + O"`，这样\t后面的字符会右对齐显示。
- 命今ID用于区分不同的子菜单项。当单击子菜单项的时候，系统会向窗口过程发送WM_COMMAND消息，消息的`LOWORD(wParam)`就是这个命今ID，通过命今ID可以区分用户到底单击了哪一个子菜单项，以作出不同的处理。
- 选项列表用来定义子菜单项的各种属性，常用的值如下表所示。

| 子菜单选项列表项 |                             含义                             |
| :--------------: | :----------------------------------------------------------: |
|    `CHECKED`     | 表示在菜单项前面打上选定标志(对钩)，也就是复选标志。选定标志还包括类似单选按钮的圆圈标志，但是在菜单资源中设置选定标志以后，菜单项前面显示的是复选标志对钩，而不是单选标志圆圈 |
|     `GRAYED`     |                       表示菜单项是灰的                       |
|    `INACTIVE`    |                      表示菜单项是禁用的                      |
|   `MENUNBREAK`   | 这个菜单项和以后的菜单项放到新的一行（主菜单中的菜单项)或一列(子菜单项)中，行与行之间没有分隔线，列与列之间也没有分隔线，没有这个选项的话，保存、另存为、退出这些应该都会直接再打开下面。![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127182254986.png) |
|  `MENUBARBREAK`  | 表示将这个菜单项和以后的菜单项放到新的一行(主菜单中的菜单项)或一列(子菜单项)中，行与行之间没有分隔线，列与列之间有分隔线。![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127182233009.png) |

:::



:::details `菜单之间的分割线定义`

子菜单项之间的分隔线的定义方式如下:

```c
MENUITEM SEPARATOR
```

分隔线不需要命今ID和属性选项。实际开发中我们这样写

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127214605577.png)

:::



接下来，我们为各子菜单项设置访问键。

- 为子菜单项新建、打开、保存、剪切、复制、粘贴分别设置加速键提示信息
- 在主菜单项"文件"中子菜单项"保存"的前面设置一个复选标记，并把该子菜单项及以后的子菜单项放到新的一列中。
- 禁用弹出主菜单项"编辑"

实际上，这些属性的设置完全可以通过VS资源编辑器的属性对话框来设置，在此只是为了练习一下书写资源脚本文件。

```c
IDR_MENU MENU
BEGIN
    POPUP "文件",                            
    BEGIN
        MENUITEM "新建(&N)\tCtrl+N",             ID_FILE_NEW
        MENUITEM "打开(&O)\tCtrl+O",             ID_FILE_OPEN
        MENUITEM "保存(&S)\tCtrl+S",             ID_FILE_SAVE,MENUBREAK,CHECKED
        MENUITEM "另存为(&A)",                    ID_FILE_SAVEAS
        MENUITEM  SEPARATOR
        MENUITEM "退出(&X)",                     ID_FILE_EXIT
    END
    POPUP "编辑", GRAYED
    BEGIN
        MENUITEM "剪切(&T)\tCtrl+X",              ID_EDIT_CUT
        MENUITEM "复制(&C)\tCtrl+C",              ID_EDIT_COPY
        MENUITEM "粘贴(&P)\tCtrl+V",              ID_EDIT_PASTE
    END
    POPUP "帮助"                 
    BEGIN
        MENUITEM "关于HelloWindows(&A)",          ID_HELP_ABOUT
    END
END
```

除此之外，VS的属性对话框中还有Right Justify (右对齐）和Right Order (从右到左显示）等菜单项属性。我发现Right Order属性一般在设置子菜单项"`新建"`为`Right Order`属性以后，资源脚本文件会发生变化。

```c
IDR_MENU MENUEX
BEGIN
    POPUP "文件",                             65535,MFT_STRING,MFS_ENABLED
    BEGIN
        MENUITEM "新建(&N)\tCtrl+N",              ID_FILE_NEW,MFT_STRING,MFS_ENABLED
        MENUITEM "打开(&O)\tCtrl+O",              ID_FILE_OPEN,MFT_STRING,MFS_ENABLED
        MENUITEM "保存(&S)\tCtrl+S",              ID_FILE_SAVE,MFT_STRING | MFT_MENUBREAK,MFS_CHECKED
        MENUITEM "另存为(&A)",                    ID_FILE_SAVEAS,MFT_STRING,MFS_ENABLED
        MENUITEM MFT_SEPARATOR
        MENUITEM "退出(&X)",                      ID_FILE_EXIT,MFT_STRING, MFS_ENABLED
    END
    POPUP "编辑",                             65535,MFT_STRING,MFS_GRAYED
    BEGIN
        MENUITEM "剪切(&T)\tCtrl+X",              ID_EDIT_CUT,MFT_STRING,MFS_ENABLED
        MENUITEM "复制(&C)\tCtrl+C",              ID_EDIT_COPY,MFT_STRING,MFS_ENABLED
        MENUITEM "粘贴(&P)\tCtrl+V",              ID_EDIT_PASTE,MFT_STRING,MFS_ENABLED
    END
    POPUP "帮助",                             65535,MFT_STRING | MFT_RIGHTJUSTIFY,MFS_ENABLED
    BEGIN
        MENUITEM "关于HelloWindows(&A)",          ID_HELP_ABOUT,MFT_STRING,MFS_ENABLED
    END
END
```

菜单的定义格式变为`IDR_MENU MENUEX`，这是扩展菜单的定义语句，各菜单项的属性值也变为另一种写法。

- 其中`MFT_*`表示类型标志，`MFS_*`表示状态标志。

基本上，换汤不换药，这里先不做延伸讨论。现在起，我们讨论如何给窗口使用我们配置好的菜单。



:::details `方案1:设置WNDCLASSEX结构的IpszMenuName字段`

第一种方法是设置WNDCLASSEX结构的`IpszMenuName`字段，该字段是LPCTSTR类型，可以使用MAKEINTRESOURCE宏，例如:

```c
wndclass.lpszMenuName = MAKEINTRESOURCE(IDR_MENU);
```

`MAKEINTRESOURCE`宏在`WinUser.h`头文件中定义如下:

```c
#define MAKEINTRESOURCEA(i) ((LPSTR)((ULONG_PTR)((WORD)(i))))
#define MAKEINTRESOURCEW(i) ((LPWSTR)((ULONG_PTR)((WORD)(i))))
#ifdef UNICODE
#define MAKEINTRESOURCE  MAKEINTRESOURCEW
#else
#define MAKEINTRESOURCE  MAKEINTRESOURCEA
#endif // !UNICODE
```

:::



:::details `方案2:在创建窗口的CreateWindowEx函数中指定hMenu参数`

第二种方法是在创建窗口的`CreateWindowEx`函数中指定`hMenu`参数，例如如下演示代码:

```c
    HMENU hMenu;
    hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, hMenu, hInstance, NULL);
```

:::



:::details `LoadMenu 函数说明`

```c
/// <summary>
/// 与应用程序实例关联的可执行模块中加载指定的菜单资源
/// </summary>
/// <param name="hInstance">要加载的菜单资源所属的模块句柄</param>
/// <param name="lpMenuName">菜单资源名称</param>
/// <returns></returns>
HMENU  LoadMenu(HINSTANCE hInstance,LPCTSTR lpMenuName);
```

- HMENU是菜单句柄类型，函数执行成功，返回值是菜单资源的句柄。

:::



:::details `方案3:使用SetMenu函数为指定窗口设置菜单`

第三种方法是使用`SetMenu`函数为指定窗口设置菜单

```c
  HMENU hMenu;
   TCHAR szBuf[64] = { 0 };
   if (uMsg == WM_CREATE)
   {
       hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));
       SetMenu(hwnd, hMenu);
   	   return 0; 
   }
```

- `g_hInstance`是一个全局变量，表示可执行模块句柄，在`WinMain`函数中赋值︰`g_hInstance = hInstance;`

:::



:::details `SetMenu 函数说明`

```c
/// <summary>
/// 给窗口设置菜单
/// </summary>
/// <param name="hWnd">窗口句柄</param>
/// <param name="hMenu">菜单句柄，设置为NULL表示删除窗口的当前菜单</param>
/// <returns></returns>
BOOL SetMenu(HWND hWnd,HMENU hMenu);
```

:::

添加菜单以后的`HelloWindows`程序运行效果如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E8%8F%9C%E5%8D%95%E8%B5%84%E6%BA%90.gif)



> 给窗口添加菜单Demo实现



:::details `resource.h`

```
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 HelloWindows.rc 使用
//
#define IDR_MENU                        101
#define IDR_ACC                         102
#define ID_FILE_NEW                     40010
#define ID_FILE_OPEN                    40011
#define ID_FILE_SAVE                    40012
#define ID_FILE_SAVEAS                  40013
#define ID_FILE_EXIT                    40014
#define ID_EDIT_CUT                     40015
#define ID_EDIT_COPY                    40016
#define ID_EDIT_PASTE                   40017
#define ID_HELP_ABOUT                   40018
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40042
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

:::



:::details `HelloWindows.rc`

```c
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MENU MENUEX
BEGIN
    POPUP "文件",                             65535,MFT_STRING,MFS_ENABLED
    BEGIN
        MENUITEM "新建(&N)\tCtrl+N",              ID_FILE_NEW,MFT_STRING,MFS_ENABLED
        MENUITEM "打开(&O)\tCtrl+O",              ID_FILE_OPEN,MFT_STRING,MFS_ENABLED
        MENUITEM "保存(&S)\tCtrl+S",              ID_FILE_SAVE,MFT_STRING | MFT_MENUBREAK,MFS_CHECKED
        MENUITEM "另存为(&A)",                     ID_FILE_SAVEAS,MFT_STRING,MFS_ENABLED
        MENUITEM MFT_SEPARATOR
        MENUITEM "退出(&X)",                      ID_FILE_EXIT,MFT_STRING,MFS_ENABLED
    END
    POPUP "编辑",                             65535,MFT_STRING,MFS_GRAYED
    BEGIN
        MENUITEM "剪切(&T)\tCtrl+X",              ID_EDIT_CUT,MFT_STRING,MFS_ENABLED
        MENUITEM "复制(&C)\tCtrl+C",              ID_EDIT_COPY,MFT_STRING,MFS_ENABLED
        MENUITEM "粘贴(&P)\tCtrl+V",              ID_EDIT_PASTE,MFT_STRING,MFS_ENABLED
    END
    POPUP "帮助",                             65535,MFT_STRING | MFT_RIGHTJUSTIFY,MFS_ENABLED
    BEGIN
        MENUITEM "关于HelloWindows(&A)",          ID_HELP_ABOUT,MFT_STRING,MFS_ENABLED
    END
END


#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
```

:::



:::details `HelloWindows.cpp`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    TCHAR szBuf[64] = { 0 };
    if (uMsg == WM_CREATE)
    {
         hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));
        SetMenu(hwnd, hMenu);
        return 0;
    }
    else if (uMsg == WM_COMMAND)
    {
        if (ID_FILE_NEW == LOWORD(wParam))
        {// 新建
            wsprintf(szBuf, TEXT("您点击了 新建 菜单项，命令ID：%d\n"), ID_FILE_NEW);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }
        else if (ID_EDIT_CUT == LOWORD(wParam))
        {// 剪切
            wsprintf(szBuf, TEXT("您点击了 剪切 菜单项，命令ID：%d\n"), ID_EDIT_CUT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);

        }
        else if (ID_HELP_ABOUT == LOWORD(wParam))
        {// 关于HelloWindows
            wsprintf(szBuf, TEXT("您点击了 关于HelloWindows 菜单项，命令ID：%d\n"), ID_HELP_ABOUT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);

        }
        else if (ID_FILE_EXIT == LOWORD(wParam))
        {// 退出
            wsprintf(szBuf, TEXT("您点击了 退出 菜单项，命令ID：%d\n"), ID_FILE_EXIT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
            SendMessage(hwnd, WM_CLOSE, 0, 0);

        }
        else if (ID_FILE_OPEN == LOWORD(wParam))
        {//打开
            wsprintf(szBuf, TEXT("您点击了打开 菜单项 ，命令ID：%d\n"), ID_FILE_EXIT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }
    }
    else if (uMsg == WM_SYSCOMMAND)
    {
        if ((wParam & 0xFFF0) == SC_CLOSE)
        {
            MessageBox(hwnd, TEXT("您点击了 系统菜单 关闭 菜单项"), TEXT("提示"), MB_OK);
            SendMessage(hwnd, WM_CLOSE, 0, 0);
        }
        else
        {
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
        return 0;

    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

- 在Debug下可以看到生成了HelloWindows.res文件，这是资源编译器编译资源脚本文件
  `HelloWindows.rc`后得到的二进制资源文件。
- 最后，`目标文件*.obj`和`资源文件*.res`最后通过链接器链接成可执行文件。
- `资源文件*.res`也可以通过VS的资源编辑器进行编辑。资源虽然被一起打包到可执行文件中，但是资源不在可执行文件的数据区，在程序中无法使用变量或地址直接对资源进行引用。号在，Windows提供了各种函数对资源进行加载。例如`LoadMenu  Loadlcon LoadCursor LoadAccelerators`等，这些函数加载的资源通常不需要释放，程序退出时由系统释放.程序自己创建的对象在不需要的时候通常需要释放，而程序或系统中定义的资源通常不需要释放。
- 当用户单击某一子菜单项(命今项)时，则系统会向拥有该菜单的窗口发送`WM_COMMAND`消息,果单击的是系统菜单的子菜单项，则发送`WM_SYSCOMMAND`消息，程序通常不需要处理`WM_SYSCOMMAND`消息，而是交给`DefWindowProc`函数执行默认处理。

:::



## 快捷键

键盘快捷键也称为加速键，一个加速键是一个或几个按键的组合。加速键用于激活特定的子菜单项命令，通过使用加速键不需要费力移动鼠标就能激活子菜单项。完成鼠标点击指定菜单项的工作。



前面为`HelloWindow`s程序制作菜单资源的时候，已经为子菜单项新建、打开、保存、剪切、复制、粘贴设置了加速键提示信息，还需要添加加速键资源。把加速键和菜单命合建立一对一关联。





打开VS资源视图，用鼠标右键单击`HelloWindows`项目，然后选择添加→资源,打开添加资源对话框，选择Accelerator，单击新建，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127185908046.png)

可以看到，VS自动在`HelloWindows.rc`资源脚本文件中添加了类型为Accelerator的加速键表IDR_ACCELERATOR1。选中左侧的IDR_ACCELERATOR1，打开右侧的属性对话框，可以修改加速键表的ID。



单击资源编辑器中ID一列的ID_ACCELERATOR40032两次，出现下拉框,可以看到刚添加的子菜单项的ID都在里面。选择ID_FILE_NEW，子菜单项新建的快捷键是Ctrl +N，因此选择第二列的修饰符为Ctrl，第三列是按键的虚拟键码或ASClI码，直接输入字母N，然后第四列的类型选择虚拟键码VIRTKEY，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127190224248.png)



同样的方法，为其他子菜单项添加快捷键关联，但是为剪切、复制、粘贴的按键类型选择ASCII(第四列的类型)，最后如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127190311568.png)

按Ctrl +S组合键保存HelloWindows.rc文件。打开HelloWindows.rc文件，看一下新添加的加速键资源

```c
...
IDR_ACC ACCELERATORS
BEGIN
    "N",            ID_FILE_NEW,            VIRTKEY, CONTROL, NOINVERT
    "O",            ID_FILE_OPEN,           VIRTKEY, CONTROL, NOINVERT
    "S",            ID_FILE_SAVE,           VIRTKEY, CONTROL, NOINVERT
    "^X",           ID_EDIT_CUT,            ASCII,  NOINVERT
    "^C",           ID_EDIT_COPY,           ASCII,  NOINVERT
    "^P",           ID_EDIT_PASTE,          ASCII,  NOINVERT
    "A",            ID_HELP_ABOUT,          VIRTKEY, CONTROL, NOINVERT
END
...
```

resource.h头文件的部分内容如下所示

```c{2}
#define IDR_MENU 101
#define IDR_ACC 102
#define ID_FILE_NEW 40010
```





:::details `快捷键的定义`

与菜单的定义相比，快捷键的定义要简单得多，语法如下∶

```c
加速键ID ACCELERATORS
BEGIN
    键名,菜单命今ID[,类型][,修饰符]
    ...
END
```

- 加速键lD同样可以是一个字符串或1～65535之间的数字。

- 加速键的具体定义内容包含在BEGIN和END (或{}）关键字之内，中间是各个加速键的定义，每个加速键占据一行。

- 键名，表示加速键对应的按键，有3种方式定义。

  - "大写字母"类型指定为VIRTKEY，表示字母键。

  - "大写字母"类型指定为ASCll码值，表示Ctrl键加上字母键。

  - 大写字母或小写字母或ASCIl码值，类型指定为ASCIl，表示字母键。

  - > 建议使用方式1，不建议指定类型为ASCll。

```c
例1∶
    "a",ID_HELP_ABOUT, ASCII,NOINVERT //例1中，只有按下小写字母a可以,
例2∶
    "A"，ID_HELP_ABOUT,ASCII,NOINVERT//例2只有按下大写字母A才可以,(同时按下Shift或CapsLock键)
例3∶
    "A",ID_HELP_ABOUT,VIRTKEY,NOINVERT //例3按下小写字母a或大写字母A 都可以
```

- 菜单命今ID。如果想把加速键和子菜单项关联起来，就需要指定为关联菜单项的命今ID
- 类型。可以是VIRTKEY或ASCIl，分别用来表示"键名"字段定义的是虚拟键码还是ASCII码。
- 修饰符。可以是Control Shift或Alt中的一个或多个，如果指定多个，则中间用逗号隔开，表示加速键是键名指定的按键加上这些键的组合键。

现在我们手动为"帮助"主菜单项下面的"关于HelloWindows"添加Ctrl + Shift ＋A快捷键

```c{9}
IDR_ACC ACCELERATORS
BEGIN
    "N",            ID_FILE_NEW,            VIRTKEY, CONTROL, NOINVERT
    "O",            ID_FILE_OPEN,           VIRTKEY, CONTROL, NOINVERT
    "S",            ID_FILE_SAVE,           VIRTKEY, CONTROL, NOINVERT
    "^X",           ID_EDIT_CUT,            ASCII,  NOINVERT
    "^C",           ID_EDIT_COPY,           ASCII,  NOINVERT
    "^P",           ID_EDIT_PASTE,          ASCII,  NOINVERT
    "A",            ID_HELP_ABOUT,          VIRTKEY, SHIFT, CONTROL, NOINVERT
END
```



:::



在一个资源脚本文件中，可以定义多个主菜单或多个加速键表，也可以定义其他各种各样的资源，例如图标、光标、位图等，这就涉及如何为这些资源取ID值的问题，取值的时候要掌握的原则如下。

- 对于同类别内的多个资源项，各项的ID必须为不同的值。假设定义了两个子菜单项，那么它们的ID就必须用不同的数值来表示，否则系统将无法分辨。
- 对于不同类别的资源，资源项ID在数值上可以是相同的，例如某子菜单项的ID为40010，那么也可以同时有ID为40010的位图或图标等，Windows可以按类别分清每一项。



**有两种加速键表**

- 系统维护一个可以用于所有应用程序的系统范围的加速键表，应用程序无法修改系统加速键表。例如`"Alt ＋空格"` 打开系统菜单，`"Alt + F4"`关闭程序，`"Ctrl + Esc"`打开系统开始菜单`，"Alt + PrintScreen"`将活动窗口中的图像复制到剪贴板，按键`"PrintScreen"`将屏幕上的图像复制到剪贴板等。
- 系统还**为每个应用程序维护加速键表**。应用程序可以定义任意数量的加速键表，并随时更换**活动**加速键表。
- 如果应用程序也定义了在系统加速键表中定义的加速键，则应用程序定义的加速键将覆盖系统的加速键，请避免这种做法。





要处理用户按下的加速键，程序需要在消息循环中调用`TranslateAccelerator`函数。该函数会监视消息队列中的`WM_KEYDOWN`和`WM_KEYUP`消息，以检查是否有与加速键表中相匹配的击键组合。如果有，就会将其转换为`WM_COMMAND`或`WM_SYSCOMMAND`(按下的是系统菜单中的加速键)消息，然后将该消息发送到窗口的窗口过程。





要调用`TranslateAccelerator`函数，就要先调用`LoadAccelerators`函数加载加速键表。



:::details `Load/TranslateAccelerators 函数说明`

```c
/// <summary>
/// 让应用加载指定的快捷键
/// </summary>
/// <param name="hInstance">要加载的加速键表所属的模块句柄</param>
/// <param name="lpTableName">要加载的加速键表的名称，可以使用MAKEINTRESOURCE宏</param>
/// <returns></returns>
HACCEL LoadAccelerators(HINSTANCE hInstance,LPCTSTR lpTableName);
```

- HACCEL是加速键表句柄类型，函数执行成功，返回指定的加速键表句柄。



`TranslateAccelerator`函数原型如下:

```c

/// <summary>
/// 在消息循环中，翻译快捷键的消息
/// </summary>
/// <param name="hWnd">要处理哪个窗口的消息</param>
/// <param name="hAccTable">LoadAccelerators函数加载或CreateAcceleratorTable函数创建的加速键表句柄</param>
/// <param name="lpMsg">消息结构</param>
/// <returns></returns>
int WINAPI TranslateAccelerator(HWND hWnd,HACCEL hAccTable,LPMSG lpMsg);
```

如果有消息被转换，则系统将`WM_COMMAND`或`WM_SYSCOMMAND`消息发送到窗口的窗口过程。窗口过程处理完`WM_COMMAND`或`WM_SYSCOMMAND`消息以后，`TranslateAccelerator`函数返回非零值，否则返回值为0。



如果`TranslateAccelerator`函数返回非零值，就不应该再调用`TranslateMessage`和`DispatchMessage`函数(因为消息已经处理)，而是应该继续下一次`GetMessage`消息的获取。消息循环的写法通常按如下方式:

```c
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
```

消息结构(MSG)有一个`hwnd`字段，为什么`TranslateAccelerator`函数还有一个`hWnd`参数呢?

- MSG结构由`GetMessage`函数填充。当`GetMessage`的第2个参数是NULL时，该函数获取属于应用程序主线程的所有窗口的消息，当`GetMessage`函数返回时，MSG结构的`hwnd`字段是将会得到该消息的窗口的窗口句柄。
- 然而，当`TranslateAccelerator`函数将键盘消息转换成WM_COMMAND或WM_SYSCOMMAND消息时，它将`msg.hwnd`字段替换成`TranslateAccelerator`函数第1个参数所指定的窗口句柄，于是Windows会将所有加速键消息发送给指定的窗口。
- 如果程序有多个窗口，则每个窗口都有可能收到键盘消息。
- 如果不是这种设计，就需要在每个窗口的窗口过程中处理加速键消息。所以一般把所有的加速键消息都发送到主窗口，集中在主窗口的窗口过程中处理`WM_COMMAND`或`WM_SYSCOMMAND`消息，这有利于精简代码。

:::





:::details `WM_COMMAND消息的wParam和lParam参数`



WM_COMMAND消息的`wParam`和`lParam`参数如下表所示:

|  `HIWORD(wParam)`  | `LOWORD(wParam)` |     `lParam`     |
| :----------------: | :--------------: | :--------------: |
| 子窗口控件的通知码 |  子窗口控件的ID  | 子窗口控件的句柄 |

通常，不在乎是菜单命今项还是加速键发送过来的WM_COMMAND消息，也就是不用区分`HIWORD(wParam)`，只需要区分`LOWORD(wParam)`**来根据不同的菜单项lD作出不同的处理**。







当用户单击了系统菜单中的命今项或按下了系统菜单的加速键，又或者单击了最小化、最大化、恢复、关闭按钮时，窗口过程会收到`WM_SYSCOMMAND`消息。程序通常不应该处理`WM_SYSCOMMAND`消息，而是交给`DefWindowProc`函数执行默认处理。





WM_SYSCOMMAND消息的`wParam`参数包含请求的系统命今类型，常见的值如下表所示:

|    常量宏     |            含义            |
| :-----------: | :------------------------: |
| `SC_MINIMIZE` |         最小化窗口         |
| `SC_MAXIMIZE` |         最大化窗口         |
| `SC_RESTORE`  | 将窗口恢复到正常位置和大小 |
|  `SC_CLOSE`   |          关闭窗口          |
|   `SC_SIZE`   |        调整窗口大小        |
|   `SC_MOVE`   |          移动窗口          |
| `SC_HSCROLL`  |          水平滚动          |
| `SC_VSCROLL`  |          垂直滚动          |
|  `SC_HOTKEY`  |        全局热键消息        |

可以看到系统命令类型实际上使用的是`LOWORD(wParam)`。请注意，wParam参数的最低4位由系统内部使用，因此如果想测试wParam参数的值，则应该使用`wParam&OxFFFO`来得到正确的结果。如果程序需要处理`WM_SYSCOMMAND`消息，则在处理完感兴趣的系统命今以后，其余部分必须转交给`DefWindowProc`函数执行默认处理。





如果用户使用鼠标选择系统菜单命今项，`lParam`参数的低位字表示鼠标光标的X坐标，高位字表示Y坐标（屏幕坐标)，可以使用`GET_X_LPARAM(IParam)`和`GET_Y_LPARAM(IParam)`宏来分别提取鼠标光标的X和Y坐标。

:::



> 为应用程序窗口添加快捷键Demo



:::details `HelloWindows.rc`

```c
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MENU MENUEX
BEGIN
    POPUP "文件",                             65535,MFT_STRING,MFS_ENABLED
    BEGIN
        MENUITEM "新建(&N)\tCtrl+N",              ID_FILE_NEW,MFT_STRING,MFS_ENABLED
        MENUITEM "打开(&O)\tCtrl+O",              ID_FILE_OPEN,MFT_STRING,MFS_ENABLED
        MENUITEM "保存(&S)\tCtrl+S",              ID_FILE_SAVE,MFT_STRING | MFT_MENUBREAK,MFS_CHECKED
        MENUITEM "另存为(&A)",                     ID_FILE_SAVEAS,MFT_STRING,MFS_ENABLED
        MENUITEM MFT_SEPARATOR
        MENUITEM "退出(&X)",                      ID_FILE_EXIT,MFT_STRING,MFS_ENABLED
    END
    POPUP "编辑",                             65535,MFT_STRING,MFS_GRAYED
    BEGIN
        MENUITEM "剪切(&T)\tCtrl+X",              ID_EDIT_CUT,MFT_STRING,MFS_ENABLED
        MENUITEM "复制(&C)\tCtrl+C",              ID_EDIT_COPY,MFT_STRING,MFS_ENABLED
        MENUITEM "粘贴(&P)\tCtrl+V",              ID_EDIT_PASTE,MFT_STRING,MFS_ENABLED
    END
    POPUP "帮助",                             65535,MFT_STRING | MFT_RIGHTJUSTIFY,MFS_ENABLED
    BEGIN
        MENUITEM "关于HelloWindows(&A)",          ID_HELP_ABOUT,MFT_STRING,MFS_ENABLED
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDR_ACC ACCELERATORS
BEGIN
    "N",            ID_FILE_NEW,            VIRTKEY, CONTROL, NOINVERT
    "O",            ID_FILE_OPEN,           VIRTKEY, CONTROL, NOINVERT
    "S",            ID_FILE_SAVE,           VIRTKEY, CONTROL, NOINVERT
    "^X",           ID_EDIT_CUT,            ASCII,  NOINVERT
    "^C",           ID_EDIT_COPY,           ASCII,  NOINVERT
    "^P",           ID_EDIT_PASTE,          ASCII,  NOINVERT
    "A",            ID_HELP_ABOUT,          VIRTKEY, SHIFT, CONTROL, NOINVERT
END

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

```

:::



:::details `resource.h`

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 HelloWindows.rc 使用
//
#define IDR_MENU                        101
#define IDR_ACC                         102
#define ID_FILE_NEW                     40010
#define ID_FILE_OPEN                    40011
#define ID_FILE_SAVE                    40012
#define ID_FILE_SAVEAS                  40013
#define ID_FILE_EXIT                    40014
#define ID_EDIT_CUT                     40015
#define ID_EDIT_COPY                    40016
#define ID_EDIT_PASTE                   40017
#define ID_HELP_ABOUT                   40018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40042
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127213849581.png)

:::



:::details `HelloWindows.cpp`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);

    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    //加载加速键表
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        //监视WM_KEYDOWN WM_KEYUP消息，把和加速键表匹配的消息 转为WM_COMMAND或者WM_SYSCOMMAND消息
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    TCHAR szBuf[64] = { 0 };
    if (uMsg == WM_CREATE)
    {
         hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));
        SetMenu(hwnd, hMenu);
        return 0;
    }
    else if (uMsg == WM_COMMAND)
    {
        if (ID_FILE_NEW == LOWORD(wParam))
        {// 新建
            wsprintf(szBuf, TEXT("您点击了 新建 菜单项，命令ID：%d\n"), ID_FILE_NEW);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }
        else if (ID_EDIT_CUT == LOWORD(wParam))
        {// 剪切
            wsprintf(szBuf, TEXT("您点击了 剪切 菜单项，命令ID：%d\n"), ID_EDIT_CUT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }
        else if (ID_HELP_ABOUT == LOWORD(wParam))
        {// 关于HelloWindows
            wsprintf(szBuf, TEXT("您点击了 关于HelloWindows 菜单项，命令ID：%d\n"), ID_HELP_ABOUT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }
        else if (ID_FILE_EXIT == LOWORD(wParam))
        {// 退出
            wsprintf(szBuf, TEXT("您点击了 退出 菜单项，命令ID：%d\n"), ID_FILE_EXIT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
            SendMessage(hwnd, WM_CLOSE, 0, 0);
        }
        else if (ID_FILE_OPEN == LOWORD(wParam))
        {//打开
            wsprintf(szBuf, TEXT("您点击了打开 菜单项 ，命令ID：%d\n"), ID_FILE_EXIT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }
    }
    else if (uMsg == WM_SYSCOMMAND)
    {
        if ((wParam & 0xFFF0) == SC_CLOSE)
        {
            MessageBox(hwnd, TEXT("您点击了 系统菜单 关闭 菜单项"), TEXT("提示"), MB_OK);
            SendMessage(hwnd, WM_CLOSE, 0, 0);
        }
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

:::

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E4%BD%BF%E7%94%A8%E5%BF%AB%E9%80%9F%E9%94%AE%E7%82%B9%E5%87%BB%E8%8F%9C%E5%8D%95%E9%A1%B9.gif)

## 菜单的查询 创建 添加 修改和删除

前面的菜单资源（也叫菜单模板）是通过资源编辑器或编写资源脚本文件创建的。应用程序还可以随时动态创建菜单模板，调用`LoadMenulndirect`函数加载菜单模板得到菜单句柄，然后可以通过调用`SetMenu`函数为窗口设置新的菜单。



:::details `LoadMenuIndirect 函数说明`

```c
/// <summary>
/// 加载菜单模板得到菜单句柄
/// </summary>
/// <param name="lpMenuTemplate">指向菜单模板或扩展菜单模板的指针</param>
/// <returns></returns>
HMENU LoadMenuIndirect(const MENUTEMPLATE* lpMenuTemplate);
```

- 参数lpMenuTemplate是指向菜单模板或扩展菜单模板的指针。
- 菜单模板由一个`MENUITEMTEMPLATEHEADER`结构和一个或多个连续的`MENUITEMTEMPLAT`E结构组成。
- 扩展菜单模板由一个`MENUEX_TEMPLATE_HEADER`结构和一个或多个连续的`MENUEX_TEMPLATE_ITEM`结构组成。
- `MENUITEMTEMPLATEHEADER`或`MENUEX_TEMPLATE_HEADER`结构定义菜单模板的头部，`MENUITEMTEMPLATE`或`MENUEX_TEMPLATE_ITEM`结构定义子菜单项。一个菜单模板由一个头部和一个或多个子菜单项组成。



`MENUITEMTEMPLATEHEADER`结构在`WinUser.h`头文件中定义如下:

```c
typedef struct {
    WORD versionNumber; //菜单模板版本号，必须为0
    WORD offset; //通常设置为0
}MENUITEMTEMPLATEHEADER，*PMENUITEMTEMPLATEHEADER;
```

`MENUITEMTEMPLATE`结构在`WinUser.h`头文件中定义如下:

```c
typedef struct 
{
	WORD mtOption;//菜单选项
	WORD mtlD; //菜单ID
	WCHAR mtString[1]; //菜单名称
}MENUITEMTEMPLATE，*PMENUITEMTEMPLATE;
```

- `mtOption字段`指定菜单选项，常用的值如下表所示。

|      常量宏       |                             含义                             |
| :---------------: | :----------------------------------------------------------: |
|    `MF_POPUP`     |                           弹出菜单                           |
|   `MF_CHECKED`    |                     菜单项旁边有复选按钮                     |
|    `MF_GRAYED`    |                   菜单项处于灰化或禁用状态                   |
|  `MF_MENUBREAK`   |            该菜单项及后面的菜单项位于新行或新列中            |
| `MF_MENUBARBREAK` |  该菜单项及后面的菜单项位于新行或新列中，列与列之间有分隔线  |
| `MF_RIGHTJUSTIFY` |               该菜单项和以后的菜单项是右对齐的               |
|  `MF_OWNERDRAW`   | 默认情况下，菜单项都是由系统负责绘制的，指定MF_OWNERDRAW选项表示该菜单项由程序自己负责绘制 |

此外，可用的菜单选项还有`MF_STRING MF_POPUP MF_HILITE`等。

- `mtID`字段指定菜单项ID，弹出菜单不需要指定该字段。

- `mtString`字段指定菜单名称，是`WCHAR`类型数组。请注意，不管程序使用Unicode还是ANSI字符集，程序资源中的字符串都是使用Unicode编码。

:::



> 先举一个动态菜单模板的例子，下例中当用户按下一个按键的时候就切换菜单栏。



:::details `resource.h`

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 HelloWindows.rc 使用
//
#define IDR_MENU                        101
#define IDR_ACC                         102
#define ID_FILE_NEW                     40010
#define ID_FILE_OPEN                    40011
#define ID_FILE_SAVE                    40012
#define ID_FILE_SAVEAS                  40013
#define ID_FILE_EXIT                    40014
#define ID_EDIT_CUT                     40015
#define ID_EDIT_COPY                    40016
#define ID_EDIT_PASTE                   40017
#define ID_HELP_ABOUT                   40018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40042
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

:::



:::details `HelloWindows.rc`

```c
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MENU MENUEX
BEGIN
    POPUP "文件",                             65535,MFT_STRING,MFS_ENABLED
    BEGIN
        MENUITEM "新建(&N)\tCtrl+N",              ID_FILE_NEW,MFT_STRING,MFS_ENABLED
        MENUITEM "打开(&O)\tCtrl+O",              ID_FILE_OPEN,MFT_STRING,MFS_ENABLED
        MENUITEM "保存(&S)\tCtrl+S",              ID_FILE_SAVE,MFT_STRING | MFT_MENUBREAK,MFS_CHECKED
        MENUITEM "另存为(&A)",                    ID_FILE_SAVEAS,MFT_STRING,MFS_ENABLED
        MENUITEM MFT_SEPARATOR
        MENUITEM "退出(&X)",                      ID_FILE_EXIT,MFT_STRING,MFS_ENABLED
    END
    POPUP "编辑",                             65535,MFT_STRING,MFS_GRAYED
    BEGIN
        MENUITEM "剪切(&T)\tCtrl+X",              ID_EDIT_CUT,MFT_STRING,MFS_ENABLED
        MENUITEM "复制(&C)\tCtrl+C",              ID_EDIT_COPY,MFT_STRING,MFS_ENABLED
        MENUITEM "粘贴(&P)\tCtrl+V",              ID_EDIT_PASTE,MFT_STRING,MFS_ENABLED
    END
    POPUP "帮助",                             65535,MFT_STRING | MFT_RIGHTJUSTIFY,MFS_ENABLED
    BEGIN
        MENUITEM "关于HelloWindows(&A)",          ID_HELP_ABOUT,MFT_STRING,MFS_ENABLED
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDR_ACC ACCELERATORS
BEGIN
    "N",            ID_FILE_NEW,            VIRTKEY, CONTROL, NOINVERT
    "O",            ID_FILE_OPEN,           VIRTKEY, CONTROL, NOINVERT
    "S",            ID_FILE_SAVE,           VIRTKEY, CONTROL, NOINVERT
    "^X",           ID_EDIT_CUT,            ASCII,  NOINVERT
    "^C",           ID_EDIT_COPY,           ASCII,  NOINVERT
    "^P",           ID_EDIT_PASTE,          ASCII,  NOINVERT
    "A",            ID_HELP_ABOUT,          VIRTKEY, SHIFT, CONTROL, NOINVERT
END

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
```

:::



:::details `HelloWindows.cpp`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"

// 全局变量
HINSTANCE g_hInstance;

// 函数声明，窗口过程
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    WORD arrMenuTemplate[] = {
        // MENUITEMTEMPLATEHEADER结构
        0,
        0,
        // 多个MENUITEMTEMPLATE结构，一行一个
        // 第1个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'编', L'辑', 0,
        MF_STRING, 40030, L'剪', L'切', L'(', L'&', L'T', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'X', 0,
        MF_STRING, 40031, L'复', L'制', L'(', L'&', L'C', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'C', 0,
        MF_STRING, 40032, L'粘', L'贴', L'(', L'&', L'P', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'V', 0,
        MF_SEPARATOR, 0, 0,
        MF_STRING, 40033, L'红', L'色', L'(', L'&', L'R', L')', 0,
        MF_STRING, 40034, L'绿', L'色', L'(', L'&', L'G', L')', 0,
        MF_STRING | MF_HILITE, 40035, L'蓝', L'色', L'(', L'&', L'B', L')', 0,
        // 第2个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'视', L'图', 0,
        MF_STRING, 40036, L'大', L'图', L'标', L'(', L'&', L'D', L')', 0,
        MF_STRING | MF_HILITE, 40037, L'小', L'图', L'标', L'(', L'&', L'S', L')', 0,
        // 第3个弹出菜单, 开始和结束都需要MF_HILITE标志，说明这是最后一个菜单
        MF_STRING | MF_POPUP | MF_HELP | MF_HILITE, L'帮', L'助', 0,
        MF_STRING | MF_HILITE, 40038, L'关', L'于', L'H', L'e', L'l', L'l', L'o', L'W', 
            L'i', L'n', L'd', L'o', L'w', L's', L'(', L'&', L'A', L')', 0
    };
    if (uMsg == WM_CREATE)
    {
        //窗口初始化时，直接注入.rc资源中的菜单
        hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));
        SetMenu(hwnd, hMenu);
        return 0;
    }
    else if (uMsg == WM_CHAR)
    {
        //点击某一个字符直接更新菜单为内存菜单
        hMenu = LoadMenuIndirect(arrMenuTemplate);
        SetMenu(hwnd, hMenu);
    }
    else if (uMsg == WM_COMMAND)
    {
        if (LOWORD(wParam) == 40030)
        {
            MessageBox(hwnd, TEXT("按下了 剪切"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == 40036)
        {
            MessageBox(hwnd, TEXT("按下了 大图标"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == 40038)
        {
            MessageBox(hwnd, TEXT("按下了 关于HelloWindows"), TEXT("提示"), MB_OK);
        }
        return 0;
    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```



:::



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E5%8A%A0%E8%BD%BD%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%8F%9C%E5%8D%95.gif)



动态菜单解决了什么样的需求？

- 有的收费软件，在用户注册成为正式版前，会让一些菜单项灰化，不可单击，或者干脆没有相应的菜单项。但是程序内部仍然实现了这个菜单项对应的功能。**只要我们设法启用灰化的菜单项，或添加相应的菜单项即可。**

- 此外，有时候可能需要在一个程序去控制其他目标程序，这时需要向目标程序发送`WM_COMMAND`消息，发送之前假定我们已经知道其`菜单命今ID`了。基于这种思想，我们很轻松的就可以调用系统挂载好的菜单。比如NX二次开发中，我们可以通过`UF_MB_ask_button_id()` 查到菜单项命令ID,从而发送WM_COMMAND消息，即可打开菜单项对应的功能了。



还可以通过调用`CreateMenu`函数创建一个空的菜单。



:::details `CreateMenu AppendMenu 函数说明`

通过调用`CreateMenu`函数创建一个空的菜单。该函数返回一个菜单句柄，然后调用`AppendMenu`或`InsertMenu`函数（或新版本的`InsertMenultem`）向返回的菜单句柄添加菜单项。



```c
/// <summary>
/// 创建一个空的菜单
/// </summary>
/// <returns>返回菜单句柄</returns>
HMENU CreateMenu(void);



/// <summary>
/// 往菜单中追加菜单项
/// </summary>
/// <param name="hMenu">菜单句柄(可以是主菜单句柄、弹出菜单句柄等)</param>
/// <param name="uFlags">菜单选项</param>
/// <param name="uIDNewItem">菜单项ID或弹出菜单句柄</param>
/// <param name="lpNewltem">菜单名称或位图句柄</param>
/// <returns></returns>
BOOL WINAPI AppendMenu(HMENU hMenu,UINT uFlags, UINT_PTR uIDNewItem,LPCTSTR lpNewltem);
```

- 参数`uFlags`指定菜单选项，可以是下表所示的值的组合。

|       常量        |                             含义                             |
| :---------------: | :----------------------------------------------------------: |
|    `MF_POPUP`     | 该菜单项用于弹出菜单。`uIDNewltem`参数被指定为弹出菜单的句句柄，就是说要想添加一个可以弹出菜单的菜单项，需要准备一个弹出菜单句柄； `lpNewItem`参数被指定为指向菜单名称字符串的指针 |
|    `MF_STRING`    | 菜单项是文本字符串，`lpNewItem`参数被指定为指向菜单名称字符串的指针 |
|    `MF_BITMAP`    |     使用位图作为菜单项，lpNewItem参数被指定为位图的句柄      |
|   `MF_CHECKED`    |                 在菜单项旁边显示一个复选标志                 |
|  `MF_UNCHECKED`   |             菜单项旁边没有复选标志，这是默认情况             |
|   `MF_DISABLED`   |                          禁用菜单项                          |
|   `MF_ENABLED`    |                          启用菜单项                          |
|    `MF_GRAYED`    |                          灰化菜单项                          |
|  `MF_MENUBREAK`   |            该菜单项及后面的菜单项位于新行或新列中            |
| `MF_MENUBARBREAK` |  该菜单项及后面的菜单项位于新行或新列中，列与列之间有分隔线  |
|  `MF_OWNERDRAE`   |  该菜单项由程序自己负责绘制,lpNewItem参数可以指向自定义数据  |
|  `MF_SEPARATOR`   |          分隔符，uIDNewItem和lpNewItem参数将被忽略           |

如果uFlags参数没有指定MF_POPUP标志，那么ulDNewltem参数表示菜单项ID

:::





> OK，我们假设程序窗口没有菜单栏，现在需要全新添加主菜单项及其弹出菜单。我们可以通过API的形式直接新建出来菜单。



:::details `演示菜单的新建-无菜单，从0到1新建。`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    HMENU hMenuPopup;
    WORD arrMenuTemplate[] = {
        // MENUITEMTEMPLATEHEADER结构
        0,
        0,
        // 多个MENUITEMTEMPLATE结构，一行一个
        // 第1个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'编', L'辑', 0,
        MF_STRING, 40030, L'剪', L'切', L'(', L'&', L'T', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'X', 0,
        MF_STRING, 40031, L'复', L'制', L'(', L'&', L'C', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'C', 0,
        MF_STRING, 40032, L'粘', L'贴', L'(', L'&', L'P', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'V', 0,
        MF_SEPARATOR, 0, 0,
        MF_STRING, 40033, L'红', L'色', L'(', L'&', L'R', L')', 0,
        MF_STRING, 40034, L'绿', L'色', L'(', L'&', L'G', L')', 0,
        MF_STRING | MF_HILITE, 40035, L'蓝', L'色', L'(', L'&', L'B', L')', 0,

        // 第2个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'视', L'图', 0,
        MF_STRING, 40036, L'大', L'图', L'标', L'(', L'&', L'D', L')', 0,
        MF_STRING | MF_HILITE, 40037, L'小', L'图', L'标', L'(', L'&', L'S', L')', 0,

        // 第3个弹出菜单, 开始和结束都需要MF_HILITE标志，说明这是最后一个菜单
        MF_STRING | MF_POPUP | MF_HELP | MF_HILITE, L'帮', L'助', 0,
        MF_STRING | MF_HILITE, 40038, L'关', L'于', L'H', L'e', L'l', L'l', L'o', L'W', 
            L'i', L'n', L'd', L'o', L'w', L's', L'(', L'&', L'A', L')', 0
    };

    if (uMsg == WM_CREATE) //在这里，自己新建主菜单项以及弹出菜单。
    {
        hMenu = CreateMenu(); //主菜单句柄
        hMenuPopup = CreateMenu(); //第一个弹出菜单
        AppendMenu(hMenuPopup,MF_STRING,ID_FILE_NEW,TEXT("新建"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_OPEN, TEXT("打开"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_SAVE, TEXT("保存"));
       
        // 把第1个弹出菜单添加到主菜单，TEXT("文件")是菜单名称
        AppendMenu(hMenu,MF_STRING|MF_POPUP,(UINT_PTR)hMenuPopup,TEXT("文件"));

        hMenuPopup = CreateMenu(); //第二个弹出菜单
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_CUT, TEXT("剪切"));
        AppendMenu(hMenuPopup,MF_STRING, ID_EDIT_COPY,TEXT("复制"));
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_PASTE,TEXT("粘贴"));

       // 把第2个弹出菜单添加到主菜单，TEXT("编辑")是菜单名称
        AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("编辑"));
        SetMenu(hwnd, hMenu);
        return 0;
    }
    else if (uMsg == WM_CHAR)
    {
        //点击某一个字符直接更新菜单为内存菜单
        hMenu = LoadMenuIndirect(arrMenuTemplate);
        SetMenu(hwnd, hMenu);
    }
    else if (uMsg == WM_COMMAND)
    {
        if (LOWORD(wParam) == ID_FILE_NEW)
        {
            MessageBox(hwnd, TEXT("按下了 新建"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_FILE_OPEN)
        {
            MessageBox(hwnd, TEXT("按下了 打开"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_EDIT_CUT)
        {
            MessageBox(hwnd, TEXT("按下了 剪切"), TEXT("提示"), MB_OK);
        }
        return 0;
    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E8%87%AA%E5%B7%B1%E6%9D%A5%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95.gif)



可以看到，我们用代码分别创建两个弹出菜单句柄，并为之添加子菜单项，然后把弹出菜单添加到主菜单(同时指定菜单名称)，最后调用`SetMenu`函数显示到菜单栏。

:::



> 我们接着再来假设一种情况，假设设程序窗口已经有菜单栏，现在需要添加一个主菜单项及弹出菜单。HelloWindows程序主菜单中已经有文件、编辑和帮助这3个弹出菜单，我想再添加"视图"主菜单项，和“大图标""小图标"子菜单项。



:::details `有菜单,则全量更新菜单`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;    
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    HMENU hMenuPopup;

    WORD arrMenuTemplate[] = {
        // MENUITEMTEMPLATEHEADER结构
        0,
        0,

        // 多个MENUITEMTEMPLATE结构，一行一个
        // 第1个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'编', L'辑', 0,
        MF_STRING, 40030, L'剪', L'切', L'(', L'&', L'T', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'X', 0,
        MF_STRING, 40031, L'复', L'制', L'(', L'&', L'C', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'C', 0,
        MF_STRING, 40032, L'粘', L'贴', L'(', L'&', L'P', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'V', 0,
        MF_SEPARATOR, 0, 0,
        MF_STRING, 40033, L'红', L'色', L'(', L'&', L'R', L')', 0,
        MF_STRING, 40034, L'绿', L'色', L'(', L'&', L'G', L')', 0,
        MF_STRING | MF_HILITE, 40035, L'蓝', L'色', L'(', L'&', L'B', L')', 0,

        // 第2个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'视', L'图', 0,
        MF_STRING, 40036, L'大', L'图', L'标', L'(', L'&', L'D', L')', 0,
        MF_STRING | MF_HILITE, 40037, L'小', L'图', L'标', L'(', L'&', L'S', L')', 0,

        // 第3个弹出菜单, 开始和结束都需要MF_HILITE标志，说明这是最后一个菜单
        MF_STRING | MF_POPUP | MF_HELP | MF_HILITE, L'帮', L'助', 0,
        MF_STRING | MF_HILITE, 40038, L'关', L'于', L'H', L'e', L'l', L'l', L'o', L'W', 
            L'i', L'n', L'd', L'o', L'w', L's', L'(', L'&', L'A', L')', 0
    };

    if (uMsg == WM_CREATE)
    {
        //自己新建出来默认菜单
        hMenu = CreateMenu();
        hMenuPopup = CreateMenu(); 
        AppendMenu(hMenuPopup,MF_STRING,ID_FILE_NEW,TEXT("新建"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_OPEN, TEXT("打开"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_SAVE, TEXT("保存"));
        AppendMenu(hMenu,MF_STRING|MF_POPUP,(UINT_PTR)hMenuPopup,TEXT("文件"));
        hMenuPopup = CreateMenu();
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_CUT, TEXT("剪切"));
        AppendMenu(hMenuPopup,MF_STRING, ID_EDIT_COPY,TEXT("复制"));
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_PASTE,TEXT("粘贴"));
        AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("编辑"));
        AppendMenu(hMenu, MF_STRING | MF_RIGHTJUSTIFY, (UINT_PTR)hMenuPopup, TEXT("帮助"));
        SetMenu(hwnd, hMenu);

        //基于默认菜单加添加
        hMenu = GetMenu(hwnd);
        hMenuPopup = CreateMenu();
        AppendMenu(hMenuPopup,MF_STRING, 66,TEXT("大图标"));
        AppendMenu(hMenuPopup, MF_STRING, 77, TEXT("小图标"));
        AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("视图"));
        DrawMenuBar(hwnd);
        return 0;
    }
    else if (uMsg == WM_CHAR)
    {
        //点击某一个字符直接更新菜单为内存菜单
        hMenu = LoadMenuIndirect(arrMenuTemplate);
        SetMenu(hwnd, hMenu);
    }
    else if (uMsg == WM_COMMAND)
    {
        if (LOWORD(wParam) == ID_FILE_NEW)
        {
            MessageBox(hwnd, TEXT("按下了 新建"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_FILE_OPEN)
        {
            MessageBox(hwnd, TEXT("按下了 打开"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_EDIT_CUT)
        {
            MessageBox(hwnd, TEXT("按下了 剪切"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == 66)
        {
            MessageBox(hwnd, TEXT("按下了 大图标"), TEXT("提示"), MB_OK);
        }
        return 0;

    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E8%87%AA%E5%B7%B1%E6%9D%A5%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95-17064380416391-17064380426142.gif)



"视图"菜单项出现在右边，这是因为当初为“帮助"菜单项设置了右对齐，`AppendMenu`函数总是添加菜单项到指定主菜单或弹出菜单的末尾。在菜单更改以后需要调用`DrawMenuBar`函数强制刷新菜单栏。

:::



> 我们继续讨论，假设程序窗口已经有菜单栏，现在需要在一个弹出菜单中添加几个子菜单项。`HelloWindows`程序主菜单中已经有文件、编辑和帮助3个弹出菜单，我想在"编辑"菜单项中添加"红色" "绿色" "蓝色"子菜单项，再添加一个可以弹出子菜单项列表的子菜单项"更改大小写”，下面有"大写字母"和"小写字母"。预期得到的效果如下所示：
>
> ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240128183609298.png)



:::details `现有菜单基础增加菜单项`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    HMENU hMenuPopup;
    HMENU hMenuPopupSub;

    WORD arrMenuTemplate[] = {
        // MENUITEMTEMPLATEHEADER结构
        0,
        0,
        // 多个MENUITEMTEMPLATE结构，一行一个
        // 第1个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'编', L'辑', 0,
        MF_STRING, 40030, L'剪', L'切', L'(', L'&', L'T', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'X', 0,
        MF_STRING, 40031, L'复', L'制', L'(', L'&', L'C', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'C', 0,
        MF_STRING, 40032, L'粘', L'贴', L'(', L'&', L'P', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'V', 0,
        MF_SEPARATOR, 0, 0,
        MF_STRING, 40033, L'红', L'色', L'(', L'&', L'R', L')', 0,
        MF_STRING, 40034, L'绿', L'色', L'(', L'&', L'G', L')', 0,
        MF_STRING | MF_HILITE, 40035, L'蓝', L'色', L'(', L'&', L'B', L')', 0,

        // 第2个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'视', L'图', 0,
        MF_STRING, 40036, L'大', L'图', L'标', L'(', L'&', L'D', L')', 0,
        MF_STRING | MF_HILITE, 40037, L'小', L'图', L'标', L'(', L'&', L'S', L')', 0,

        // 第3个弹出菜单, 开始和结束都需要MF_HILITE标志，说明这是最后一个菜单
        MF_STRING | MF_POPUP | MF_HELP | MF_HILITE, L'帮', L'助', 0,
        MF_STRING | MF_HILITE, 40038, L'关', L'于', L'H', L'e', L'l', L'l', L'o', L'W', 
            L'i', L'n', L'd', L'o', L'w', L's', L'(', L'&', L'A', L')', 0
    };
    if (uMsg == WM_CREATE)
    {
        //自己新建出来默认菜单
        hMenu = CreateMenu();
        hMenuPopup = CreateMenu(); 
        AppendMenu(hMenuPopup,MF_STRING,ID_FILE_NEW,TEXT("新建"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_OPEN, TEXT("打开"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_SAVE, TEXT("保存"));
        AppendMenu(hMenu,MF_STRING|MF_POPUP,(UINT_PTR)hMenuPopup,TEXT("文件"));
        hMenuPopup = CreateMenu();
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_CUT, TEXT("剪切"));
        AppendMenu(hMenuPopup,MF_STRING, ID_EDIT_COPY,TEXT("复制"));
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_PASTE,TEXT("粘贴"));
        AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("编辑"));
        AppendMenu(hMenu, MF_STRING | MF_RIGHTJUSTIFY, (UINT_PTR)hMenuPopup, TEXT("帮助"));
        SetMenu(hwnd, hMenu);
        //基于默认菜单加添加
        hMenu = GetMenu(hwnd);
        hMenuPopup = CreateMenu();
        AppendMenu(hMenuPopup,MF_STRING, 66,TEXT("大图标"));
        AppendMenu(hMenuPopup, MF_STRING, 77, TEXT("小图标"));
        AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("视图"));
        DrawMenuBar(hwnd);
        
        //在指定的主菜单项加弹出式菜单项
        hMenu = GetMenu(hwnd);
        hMenuPopup = GetSubMenu(hMenu,1);
        AppendMenu(hMenuPopup, MF_SEPARATOR, NULL, NULL);
        AppendMenu(hMenuPopup,MF_STRING,88,TEXT("红色(&R)"));
        AppendMenu(hMenuPopup,MF_STRING,89,TEXT("绿色(&G)"));
        AppendMenu(hMenuPopup,MF_STRING,90,TEXT("蓝色(&B)"));
        AppendMenu(hMenuPopup,MF_SEPARATOR,NULL,NULL);
        hMenuPopupSub = CreateMenu();
        AppendMenu(hMenuPopupSub,MF_STRING,91,TEXT("大写字母(&U)"));
        AppendMenu(hMenuPopupSub,MF_STRING,92,TEXT("小写字母(&L)"));
        AppendMenu(hMenuPopup,MF_STRING | MF_POPUP,(UINT_PTR)hMenuPopupSub,TEXT("更改大小写"));

        return 0;
    }
    else if (uMsg == WM_CHAR)
    {
        //点击某一个字符直接更新菜单为内存菜单
        hMenu = LoadMenuIndirect(arrMenuTemplate);
        SetMenu(hwnd, hMenu);
    }
    else if (uMsg == WM_COMMAND)
    {
        if (LOWORD(wParam) == ID_FILE_NEW)
        {
            MessageBox(hwnd, TEXT("按下了 新建"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_FILE_OPEN)
        {
            MessageBox(hwnd, TEXT("按下了 打开"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_EDIT_CUT)
        {
            MessageBox(hwnd, TEXT("按下了 剪切"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == 66)
        {
            MessageBox(hwnd, TEXT("按下了 大图标"), TEXT("提示"), MB_OK);
        }
        return 0;
    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E5%86%8D%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E5%BC%B9%E5%87%BA%E5%AD%90%E8%8F%9C%E5%8D%95%E9%A1%B9%E5%88%97%E8%A1%A8%E7%9A%84%E5%AD%90%E8%8F%9C%E5%8D%95%E9%A1%B9.gif)

:::



:::details `GetSubMenu/GetMenuItemInfo 函数说明 `

`GetSubMenu`或`GetMenultemInfo`函数可以获取弹出菜单或子菜单项的句柄︰

```c
/// <summary>
/// 获取弹出菜单或子菜单项的句柄
/// </summary>
/// <param name="hMenu">菜单句柄(可以是主菜单句柄、弹出菜单句柄等)</param>
/// <param name="nPos">从0开始的相对位置</param>
/// <returns></returns>
HMENU WINAPI GetSubMenu(HMENU hMenu,  int nPos);
```

- 主菜单中最左侧的主菜单项位置为0，往右增加
- 弹出菜单中最顶部的菜单项位置为0，往下增加，分隔符也计算在内。



在上面的示例中，主菜单中"文件"的位置为0，"编辑"的位置为1，因此使用`GetSubMenu(hMenu,1)`获取的是"编辑"的弹出菜单句柄。

:::





可以看出，之前使用的`AppendMenu`函数把菜单项放到了最后，不能指定所放位置。`InsertMenu`函数也可以添加菜单项，但是可以指定插入的位置。



:::details `InsertMenu`

```c
/// <summary>
/// 指定插入的位置 插入菜单项
/// </summary>
/// <param name="hMenu">菜单句柄(可以是主菜单句柄、弹出菜单句柄等)</param>
/// <param name="uPosition">新菜单项插入的位置，受uFlags参数的影响</param>
/// <param name="uFlags">菜单选项</param>
/// <param name="uIDNewItem">菜单项ID或弹出菜单句柄</param>
/// <param name="lpNewltem">菜单名称或位图句柄</param>
/// <returns></returns>
BOOL InsertMenu(HMENU hMenu,UINT uPosition,UINT uFlags,UINT_PTR uIDNewItem,LPCTSTR lpNewltem);
```

- 参数uFlags除了可以指定为AppendMenu函数的uFlags参数的那些选项，还可以是下表所示的值。

|     宏常量      |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
| `MF_BYCOMMAND`  | 默认值,表示uPosition参数指定的是某菜单项的ID，新菜单项将在其后 |
| `MF_BYPOSITION` | 表示uPosition参数指定的是新菜单项从O开始的相对位置，如果uPosition为-1，则新菜单项将插入菜单的末尾 |

除此之外，AppendMenu和InsertMenu函数的用法完全相同。

:::



:::details `InsertMenu 示例:`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    HMENU hMenuPopup;
    HMENU hMenuPopupSub;
    WORD arrMenuTemplate[] = {
        // MENUITEMTEMPLATEHEADER结构
        0,
        0,
        // 多个MENUITEMTEMPLATE结构，一行一个
        // 第1个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'编', L'辑', 0,
        MF_STRING, 40030, L'剪', L'切', L'(', L'&', L'T', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'X', 0,
        MF_STRING, 40031, L'复', L'制', L'(', L'&', L'C', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'C', 0,
        MF_STRING, 40032, L'粘', L'贴', L'(', L'&', L'P', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'V', 0,
        MF_SEPARATOR, 0, 0,
        MF_STRING, 40033, L'红', L'色', L'(', L'&', L'R', L')', 0,
        MF_STRING, 40034, L'绿', L'色', L'(', L'&', L'G', L')', 0,
        MF_STRING | MF_HILITE, 40035, L'蓝', L'色', L'(', L'&', L'B', L')', 0,

        // 第2个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'视', L'图', 0,
        MF_STRING, 40036, L'大', L'图', L'标', L'(', L'&', L'D', L')', 0,
        MF_STRING | MF_HILITE, 40037, L'小', L'图', L'标', L'(', L'&', L'S', L')', 0,

        // 第3个弹出菜单, 开始和结束都需要MF_HILITE标志，说明这是最后一个菜单
        MF_STRING | MF_POPUP | MF_HELP | MF_HILITE, L'帮', L'助', 0,
        MF_STRING | MF_HILITE, 40038, L'关', L'于', L'H', L'e', L'l', L'l', L'o', L'W', 
            L'i', L'n', L'd', L'o', L'w', L's', L'(', L'&', L'A', L')', 0
    };
    if (uMsg == WM_CREATE)
    {
        //自己新建出来默认菜单
        hMenu = CreateMenu();
        hMenuPopup = CreateMenu(); 
        AppendMenu(hMenuPopup,MF_STRING,ID_FILE_NEW,TEXT("新建"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_OPEN, TEXT("打开"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_SAVE, TEXT("保存"));
        AppendMenu(hMenu,MF_STRING|MF_POPUP,(UINT_PTR)hMenuPopup,TEXT("文件"));
        hMenuPopup = CreateMenu();
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_CUT, TEXT("剪切"));
        AppendMenu(hMenuPopup,MF_STRING, ID_EDIT_COPY,TEXT("复制"));
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_PASTE,TEXT("粘贴"));
        AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("编辑"));
        AppendMenu(hMenu, MF_STRING | MF_RIGHTJUSTIFY, (UINT_PTR)hMenuPopup, TEXT("帮助"));
        SetMenu(hwnd, hMenu);
        //基于默认菜单加添加
        hMenu = GetMenu(hwnd);
        hMenuPopup = CreateMenu();
        AppendMenu(hMenuPopup,MF_STRING, 66,TEXT("大图标"));
        AppendMenu(hMenuPopup, MF_STRING, 77, TEXT("小图标"));
        //AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("视图"));
        //改用 InsertMenu
        InsertMenu(hMenu,2,MF_STRING|MF_POPUP|MF_BYPOSITION, (UINT_PTR)hMenuPopup, TEXT("视图"));
        DrawMenuBar(hwnd); 
        //在指定的主菜单项加弹出式菜单项
        hMenu = GetMenu(hwnd);
        hMenuPopup = GetSubMenu(hMenu,1);
        AppendMenu(hMenuPopup, MF_SEPARATOR, NULL, NULL);
        AppendMenu(hMenuPopup,MF_STRING,88,TEXT("红色(&R)"));
        AppendMenu(hMenuPopup,MF_STRING,89,TEXT("绿色(&G)"));
        AppendMenu(hMenuPopup,MF_STRING,90,TEXT("蓝色(&B)"));
        AppendMenu(hMenuPopup,MF_SEPARATOR,NULL,NULL);
        hMenuPopupSub = CreateMenu();
        AppendMenu(hMenuPopupSub,MF_STRING,91,TEXT("大写字母(&U)"));
        AppendMenu(hMenuPopupSub,MF_STRING,92,TEXT("小写字母(&L)"));
        AppendMenu(hMenuPopup,MF_STRING | MF_POPUP,(UINT_PTR)hMenuPopupSub,TEXT("更改大小写"));

        return 0;
    }
    else if (uMsg == WM_CHAR)
    {
        //点击某一个字符直接更新菜单为内存菜单
        hMenu = LoadMenuIndirect(arrMenuTemplate);
        SetMenu(hwnd, hMenu);
    }
    else if (uMsg == WM_COMMAND)
    {
        if (LOWORD(wParam) == ID_FILE_NEW)
        {
            MessageBox(hwnd, TEXT("按下了 新建"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_FILE_OPEN)
        {
            MessageBox(hwnd, TEXT("按下了 打开"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_EDIT_CUT)
        {
            MessageBox(hwnd, TEXT("按下了 剪切"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == 66)
        {
            MessageBox(hwnd, TEXT("按下了 大图标"), TEXT("提示"), MB_OK);
        }
        return 0;
    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

AppendMenu函数总是把菜单项放到最后，现在InsertMenu函数的uPosition参数指定为2表示放在第3个的位置。效果如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E6%8F%92%E5%85%A5%E8%8F%9C%E5%8D%95%E9%A1%B9%E5%8F%AF%E4%BB%A5%E6%8E%A7%E5%88%B6%E8%8F%9C%E5%8D%95%E9%A1%B9%E4%BD%8D%E7%BD%AE-17064517904951.gif)

:::



:::details  `GetMenuItemID 获取一个菜单项ID`

```c
/// <summary>
/// 获取一个菜单项的ID
/// </summary>
/// <param name="hMenu">菜单句柄(可以是主菜单句柄、弹出菜单句柄等)</param>
/// <param name="nPos">相对位置</param>
/// <returns>函数执行成功，返回值是指定菜单项的ID</returns>
UINT GetMenultemID(HMENU hMenu,int nPos);
```

:::



:::details `GetMenuString 获取一个菜单项的文本字符串`

```c

/// <summary>
/// 获取一个菜单项的文本字符串
/// </summary>
/// <param name="hMenu">菜单句柄(可以是主菜单句柄、弹出菜单句柄等)</param>
/// <param name="ulDltem">菜单项ID或相对位置</param>
/// <param name="lpString">在lpString中返回菜单项的名称</param>
/// <param name="nMaxCount">lpString缓冲区的大小，以字符为单位</param>
/// <param name="uFlag">MF_BYCOMMAND或MF_BYPOSITION</param>
/// <returns></returns>
int GetMenuString(HMENU hMenu,UINT ulDltem,LPTSTR lpString,int nMaxCount, UINT uFlag);
```

:::



:::details `ModifyMenu 函数说明`

```c
/// <summary>
/// 修改一个菜单项
/// </summary>
/// <param name="hMnu">菜单句柄(可以是主菜单句柄、弹出菜单句柄等)</param>
/// <param name="uPosition">菜单项ID或相对位置</param>
/// <param name="uFlags">菜单选项</param>
/// <param name="ulDNewltem">菜单项ID或弹出菜单句柄</param>
/// <param name="lpNewltem">菜单名称或位图句柄</param>
/// <returns></returns>
BOOL WINAPI ModifyMenu(HMENU hMnu, UINT uPosition,UINT uFlags,UINT_PTR ulDNewltem, LPCTSTR lpNewltem);
```

:::



:::details `DeleteMenu/RemoveMenu 函数说明`

```c
BOOL WINAPI DeleteMenu(HMENU hMenu, UINTuPosition, UINT uFlags);
BOOL WINAPl RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags);
```

- 参数uFlags可以是MF_BYCOMMAND或MF_BYPOSITION.

:::



**针对系统菜单的操作**





:::details `GetSystemMenu 函数说明`

```c
/// <summary>
/// 获取系统菜单
/// </summary>
/// <param name="hWnd">窗口句柄</param>
/// <param name="bRevert">TRUE或FALSE</param>
/// <returns></returns>
HMENU GetSystemMenu(HWND hWnd,BOOL bRevert);
```

- 如果`bRevert`参数设置为`FALSE`，则表示获取系统菜单的句柄。可以利用这个句柄对系统菜单中的菜单项进行修改，或者向系统菜单添加新的菜单项，所有预定义系统菜单项的ID都大于0xF000。如果程序需要向系统菜单添加菜单项，则菜单项ID必须小于0xF000.

- 如果`bRevert`参数为FALSE，则`GetSystemMenu`函数返回值是系统菜单的句柄
- 如果`bRevert`参数为TRUE，则返回值为NULL。

:::





前面说过，`WM_SYSCOMMAND`消息的`wParam & OxFFF0`包含请求的系统命合类型，例如`SC_CLOSE` `SC_MOVE`。如果在系统菜单中添加了菜单项，那么WM_SYSCOMMAND消息的`LOWORD(wParam)`就是菜单项ID.





例如，下面对系统菜单的操作∶

```c
//灰化系统菜单的关闭菜单项
ModifyMenu(GetSystemMenu(hwnd, FALSE),SC_CLOSE,MF_GRAYED, SC_CLOSE,TEXT("关闭(&C)\tAlt+F4"));

//移除系统菜单的关闭菜单项
RemoveMenu(GetSystemMenu(hwnd, FALSE), SC_CLOSE,MF_BYCOMMAND);

//在系统菜单后面添加一个“打开"菜单项
AppendMenu(GetSystemMenu(hwnd, FALSE),MF_STRING,ID_FILE_NEW,TEXT("打开(&O)"));

//恢复系统菜单
GetSystemMenu(hwnd，TRUE);
```

