# 菜单和其他资源

资源是添加到程序可执行文件中的二进制数据，包括标准资源和自定义资源。标准资源包括菜单、图标、光标、位图、加速键（快捷键)、字符串表、程序版本信息、HTML和对话框等，自定义资源可以是程序所需的任何格式的数据。这里我们主要聊一聊菜单资源





## 菜单和快捷键

菜单通常是一个程序必不可少的组成部分，这里以记事本程序为例说明一下与菜单有关的术语。



- 记事本程序的菜单栏位于标题栏下方，这样的菜单栏称为程序的**主菜单或顶级菜单**

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616090057592.png)

- 主菜单中有文件、编辑、格式、查看、帮助等菜单项，这些菜单项称为**主菜单项**

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616090201905.png)

- 单击每一个主菜单项还可以弹出下一级菜单，这称为**弹出菜单**

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616090254223.png)

- 单击主菜单项通常用于弹出子菜单项列表，单击子菜单项时系统才会发送命令消息，这些子菜单项也称为命今项。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616090654082.png)

- 有的子菜单项中还包含下一级子菜单项列表，这样的子菜单项右边通常附带一个三角箭头。

  ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616090802804.png)

- 另外，点击标题栏左侧的小图标可以弹出一个系统菜单项列表，在某些程序窗口的客户区中单击鼠标右键也可以弹出一个子菜单项列表，这些都属于弹出菜单。

  ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240616091038979.png)



## 为程序添加菜单栏

要为程序添加菜单，需要先添加菜单资源。最简单的方法是通过VS的资源视图添加。右击`HelloWindows项目`→添加→资源，打开添加资源对话框，选择Menu并单击新建，如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127161844858-17063435260871-17185003700051.png)

可以看到VS自动为我们添加了`HelloWindows.rc`资源脚本文件，在该资源脚本文件中添加了Menu类型的ID为IDR_MENU1的菜单资源。选中左侧资源视图中的IDR_MENU1，打开VS软件右侧的属性对话框。属性对话框中显示了菜单资源IDR_MENU1的相关属性，如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127161946974-17063435882172-17185004576422.png)

修改菜单资源ID为IDR_MENU。现在可以给菜单资源添加若干个主菜单项了。我们在"请在此处键入"编辑框中输入主菜单项"文件"，然后在"文件"菜单项的下一级依次输入子菜单项"新建"  "打开" "保存" "另存为"，在子菜单项"另存为"下面的编辑框中右键插入分隔符，然后继续添加子菜单项"退出"，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127162148657.png)

:::tip 

单击主菜单项。比如说单击主菜单项"文件"的作用是弹出子菜单项列表，而不是执行程序命令。

因此主菜单项"文件"是没有菜单项ID(或者说命今ID)的。

:::



我们依次将子菜单项新建、打开、保存、另存为、退出 的菜单项ID，修改为见名知义的名字：`ID_FILE_NEW` `ID_FILE_OPEN`  `ID_FILE_SAVE   ID_FILE_SAVEAS `  `ID_FILE_EXIT`。



继续在主菜单项"文件" 右边的"请在此处键入"编辑框中添加主菜单项"编辑"，以及子菜单项"剪切"  "复制" "粘贴";然后添加主菜单项"帮助"及子菜单项"关于HelloWindows"。



分别设置子菜单项剪切、复制、粘贴和关于HelloWindows的ID为`ID_EDIT_CUT`  `ID_EDIT_COPY`  `ID_EDIT_PASTE`和`ID_HELP_ABOUT`，然后按Ctrl+S组合键保存资源脚本文件`HelloWindows.rc`，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127162748287-17063440696684.png)

可以看到VS软件自动为我们创建了`HelloWindows.rc`和`resource.h`两个文件。



:::details `.rc .h` 这两个文件的用途

`HelloWindows.rc`是资源脚本文件，除了VS的可视化资源编辑视图(资源编辑器），我们也可以通过自己编写资源脚本文件来添加资源。切换到解决方案资源管理器视图，用鼠标右键单击资源文件下面的`HelloWindows.rc`并**查看代码**，`HelloWindows.rc`文件的主要内容如下所示:

```c
// Microsoft Visual C++ generated resource script.
/
#include "resource.h"
IDR_MENU MENUEX
BEGIN
    POPUP "文件",            65535,MFT_STRING,MFS_ENABLED
    BEGIN
        MENUITEM "新建",              ID_FILE_NEW,MFT_STRING,MFS_ENABLED
        MENUITEM "打开",              ID_FILE_OPEN,MFT_STRING,MFS_ENABLED
        MENUITEM "保存",      ID_FILE_SAVE,MFT_STRING|MFT_MENUBREAK,MFS_CHECKED
        MENUITEM "另存为",             ID_FILE_SAVEAS,MFT_STRING,MFS_ENABLED
        MENUITEM MFT_SEPARATOR
        MENUITEM "退出(&X)",           ID_FILE_EXIT,MFT_STRING,MFS_ENABLED
    END
    POPUP "编辑",             65535,MFT_STRING,MFS_GRAYED
    BEGIN
        MENUITEM "剪切",              ID_EDIT_CUT,MFT_STRING,MFS_ENABLED
        MENUITEM "复制",              ID_EDIT_COPY,MFT_STRING,MFS_ENABLED
        MENUITEM "粘贴",              ID_EDIT_PASTE,MFT_STRING,MFS_ENABLED
    END
    POPUP "帮助",             65535,MFT_STRING|MFT_RIGHTJUSTIFY,MFS_ENABLED
    BEGIN
        MENUITEM "关于HelloWindows(&A)",   ID_HELP_ABOUT,MFT_STRING,MFS_ENABLED
    END
END
```



资源脚本文件`HelloWindows.rc`中包含了`resource.h`头文件，`resource.h`头文件中实则为对菜单资源和子菜单项的ID定义等。这是因为资源在程序中的引用往往用一个数值来表示，但是直接使用数值不直观，往往用#define语句将数值定义为容易记忆和理解的宏常量，便于开发引用。



针对本次的`HelloWindow.rc` 对应的`resource.h`头文件的主要内容如下所示

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 HelloWindows.rc 使用
//
#define IDR_MENU                        101
#define IDR_ACC                         102
#define ID_FILE_NEW                     40010
#define ID_FILE_OPEN                    40011
#define ID_FILE_SAVE                    40012
#define ID_FILE_SAVEAS                  40013
#define ID_FILE_EXIT                    40014
#define ID_EDIT_CUT                     40015
#define ID_EDIT_COPY                    40016
#define ID_EDIT_PASTE                   40017
#define ID_HELP_ABOUT                   40018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40042
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

:::



正是有VS整合的资源视图的存在，让我们编写`HelloWorld.rc` 资源脚本文件的工作可视化，变得简单。但实际开发时，可能需要手撕`HellWorld.rc`文件，所以我们仍然需要对`HelloWorld.rc` 定义菜单资源的格式有所学习。





:::details `菜单的定义`

在资源脚本文件中菜单的定义格式如下：

```c
菜单ID MENU
BEGIN
	菜单定义
END
```

"菜单ID MENU"语句用来指定菜单资源的ID。菜单ID是一个16位的整数，范围是1～65535，本例中定义的菜单ID是IDR_MENU(101)  当然了，菜单ID也可以用字符串来表示，例如下面的定义∶

```
MainMenu MENU
BEGIN
	菜单定义
END
```

> 表示菜单资源的ID是字符串类型的`"MainMenu"`



菜单的具体定义语句包含在BEGIN和END关键字之内，这两个关键字也可以用`{}`代替。

:::



:::details `弹出菜单的定义`

弹出菜单的定义方式如下︰

```c
POPUP 菜单文字[,选项列表]
	BEGIN
		子菜单项定义
	END
```

菜单文字指主菜单项名称字符串，BEGIN和END关键字中的内容定义弹出菜单的每一个子菜单项。主菜单通常由多个主菜单项及下面的弹出菜单组成，本例中主菜单由"文件" "编辑" 和"帮助"3个主菜单项及下面的弹出菜单组成。弹出菜单的定义也可以嵌套，以达到单击子菜单项弹出下一级子菜单项列表的目的，子弹出菜单的定义同样需要`POPUP BEGIN和END`关键字。



针对弹出菜单，常用的选项值如下:

- GRAYED——菜单项是灰化的
- DISABLED——菜单项是禁用的
- ENABLED ——菜单项是可用的

:::





:::details `子菜单项的定义`

子菜单项的定义方式如下:

```c
MENUITEM 菜单文字 命今ID [,选项列表]
```

- 菜单文字指子菜单项名称字符串。有时候在字符串的后面需要加一个带下划线的字母，例如"打开(O)"，可以在字母前面加`"&"`符号，`即"打开(&O)"`。这时带&的字母称为访问键，例如本例中当"文件"弹出菜单打开的时候按下O键，那么就相当于用鼠标单击了子菜单项"打开"，在同一个弹出菜单中不同的子菜单项所用的访问键必须不同。
- 另外，要使加速键的提示信息显示在子菜单项的右边，例如子菜单项"打开"可以使用Ctrl +O组合键，可以加一个\t(表示插入一个Tab字符),然后写上"Ctrl + O"，即`"打开(&O)\tCtrl + O"`，这样\t后面的字符会右对齐显示。
- 命今ID用于区分不同的子菜单项。当单击子菜单项的时候，系统会向窗口过程发送WM_COMMAND消息，消息的`LOWORD(wParam)`就是这个命今ID，通过命今ID可以区分用户到底单击了哪一个子菜单项，以作出不同的处理。
- 选项列表用来定义子菜单项的各种属性，常用的值如下表所示。

| 子菜单选项列表项 |                             含义                             |
| :--------------: | :----------------------------------------------------------: |
|    `CHECKED`     | 表示在菜单项前面打上选定标志(对钩)，也就是复选标志。选定标志还包括类似单选按钮的圆圈标志，但是在菜单资源中设置选定标志以后，菜单项前面显示的是复选标志对钩，而不是单选标志圆圈 |
|     `GRAYED`     |                       表示菜单项是灰的                       |
|    `INACTIVE`    |                      表示菜单项是禁用的                      |
|   `MENUNBREAK`   | 这个菜单项和以后的菜单项放到新的一行（主菜单中的菜单项)或一列(子菜单项)中，行与行之间没有分隔线，列与列之间也没有分隔线，没有这个选项的话，保存、另存为、退出这些应该都会直接再打开下面。![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127182254986.png) |
|  `MENUBARBREAK`  | 表示将这个菜单项和以后的菜单项放到新的一行(主菜单中的菜单项)或一列(子菜单项)中，行与行之间没有分隔线，列与列之间有分隔线。![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127182233009.png) |

:::



:::details `菜单之间的分割线定义`

子菜单项之间的分隔线的定义方式如下:

```c
MENUITEM SEPARATOR
```

分隔线不需要命今ID和属性选项。实际开发中我们这样写

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127214605577.png)

:::



接下来，我们为各子菜单项设置访问键。

- 为子菜单项新建、打开、保存、剪切、复制、粘贴分别设置加速键提示信息
- 在主菜单项"文件"中子菜单项"保存"的前面设置一个复选标记，并把该子菜单项及以后的子菜单项放到新的一列中。
- 禁用弹出主菜单项"编辑"

实际上，这些属性的设置完全可以通过VS资源编辑器的属性对话框来设置，在此只是为了练习一下书写资源脚本文件。

```c
IDR_MENU MENU
BEGIN
    POPUP "文件",                            
    BEGIN
        MENUITEM "新建(&N)\tCtrl+N",             ID_FILE_NEW
        MENUITEM "打开(&O)\tCtrl+O",             ID_FILE_OPEN
        MENUITEM "保存(&S)\tCtrl+S",             ID_FILE_SAVE,MENUBREAK,CHECKED
        MENUITEM "另存为(&A)",                    ID_FILE_SAVEAS
        MENUITEM  SEPARATOR
        MENUITEM "退出(&X)",                     ID_FILE_EXIT
    END
    POPUP "编辑", GRAYED
    BEGIN
        MENUITEM "剪切(&T)\tCtrl+X",              ID_EDIT_CUT
        MENUITEM "复制(&C)\tCtrl+C",              ID_EDIT_COPY
        MENUITEM "粘贴(&P)\tCtrl+V",              ID_EDIT_PASTE
    END
    POPUP "帮助"                 
    BEGIN
        MENUITEM "关于HelloWindows(&A)",          ID_HELP_ABOUT
    END
END
```

除此之外，VS的属性对话框中还有Right Justify (右对齐）和Right Order (从右到左显示）等菜单项属性。我发现Right Order属性一般在设置子菜单项"`新建"`为`Right Order`属性以后，资源脚本文件会发生变化。

```c
IDR_MENU MENUEX
BEGIN
    POPUP "文件",                             65535,MFT_STRING,MFS_ENABLED
    BEGIN
        MENUITEM "新建(&N)\tCtrl+N",              ID_FILE_NEW,MFT_STRING,MFS_ENABLED
        MENUITEM "打开(&O)\tCtrl+O",              ID_FILE_OPEN,MFT_STRING,MFS_ENABLED
        MENUITEM "保存(&S)\tCtrl+S",              ID_FILE_SAVE,MFT_STRING | MFT_MENUBREAK,MFS_CHECKED
        MENUITEM "另存为(&A)",                    ID_FILE_SAVEAS,MFT_STRING,MFS_ENABLED
        MENUITEM MFT_SEPARATOR
        MENUITEM "退出(&X)",                      ID_FILE_EXIT,MFT_STRING, MFS_ENABLED
    END
    POPUP "编辑",                             65535,MFT_STRING,MFS_GRAYED
    BEGIN
        MENUITEM "剪切(&T)\tCtrl+X",              ID_EDIT_CUT,MFT_STRING,MFS_ENABLED
        MENUITEM "复制(&C)\tCtrl+C",              ID_EDIT_COPY,MFT_STRING,MFS_ENABLED
        MENUITEM "粘贴(&P)\tCtrl+V",              ID_EDIT_PASTE,MFT_STRING,MFS_ENABLED
    END
    POPUP "帮助",                             65535,MFT_STRING | MFT_RIGHTJUSTIFY,MFS_ENABLED
    BEGIN
        MENUITEM "关于HelloWindows(&A)",          ID_HELP_ABOUT,MFT_STRING,MFS_ENABLED
    END
END
```

菜单的定义格式变为`IDR_MENU MENUEX`，这是扩展菜单的定义语句，各菜单项的属性值也变为另一种写法。

- 其中`MFT_*`表示类型标志，`MFS_*`表示状态标志。

基本上，换汤不换药，这里先不做延伸讨论。现在起，我们讨论如何给窗口使用我们配置好的菜单。



:::details `方案1:设置WNDCLASSEX结构的IpszMenuName字段`

第一种方法是设置WNDCLASSEX结构的`IpszMenuName`字段，该字段是LPCTSTR类型，可以使用MAKEINTRESOURCE宏，例如:

```c
wndclass.lpszMenuName = MAKEINTRESOURCE(IDR_MENU);
```

`MAKEINTRESOURCE`宏在`WinUser.h`头文件中定义如下:

```c
#define MAKEINTRESOURCEA(i) ((LPSTR)((ULONG_PTR)((WORD)(i))))
#define MAKEINTRESOURCEW(i) ((LPWSTR)((ULONG_PTR)((WORD)(i))))
#ifdef UNICODE
#define MAKEINTRESOURCE  MAKEINTRESOURCEW
#else
#define MAKEINTRESOURCE  MAKEINTRESOURCEA
#endif // !UNICODE
```

:::



:::details `方案2:在创建窗口的CreateWindowEx函数中指定hMenu参数`

第二种方法是在创建窗口的`CreateWindowEx`函数中指定`hMenu`参数，例如如下演示代码:

```c
    HMENU hMenu;
    hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, hMenu, hInstance, NULL);
```

:::



:::details `LoadMenu 函数说明`

```c
/// <summary>
/// 与应用程序实例关联的可执行模块中加载指定的菜单资源
/// </summary>
/// <param name="hInstance">要加载的菜单资源所属的模块句柄</param>
/// <param name="lpMenuName">菜单资源名称</param>
/// <returns></returns>
HMENU  LoadMenu(HINSTANCE hInstance,LPCTSTR lpMenuName);
```

- HMENU是菜单句柄类型，函数执行成功，返回值是菜单资源的句柄。

:::



:::details `方案3:使用SetMenu函数为指定窗口设置菜单`

第三种方法是使用`SetMenu`函数为指定窗口设置菜单

```c
  HMENU hMenu;
   TCHAR szBuf[64] = { 0 };
   if (uMsg == WM_CREATE)
   {
       hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));
       SetMenu(hwnd, hMenu);
   	   return 0; 
   }
```

- `g_hInstance`是一个全局变量，表示可执行模块句柄，在`WinMain`函数中赋值︰`g_hInstance = hInstance;`

:::



:::details `SetMenu 函数说明`

```c
/// <summary>
/// 给窗口设置菜单
/// </summary>
/// <param name="hWnd">窗口句柄</param>
/// <param name="hMenu">菜单句柄，设置为NULL表示删除窗口的当前菜单</param>
/// <returns></returns>
BOOL SetMenu(HWND hWnd,HMENU hMenu);
```

:::

添加菜单以后的`HelloWindows`程序运行效果如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E8%8F%9C%E5%8D%95%E8%B5%84%E6%BA%90.gif)



> 给窗口添加菜单Demo实现



:::details `resource.h`

```
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 HelloWindows.rc 使用
//
#define IDR_MENU                        101
#define IDR_ACC                         102
#define ID_FILE_NEW                     40010
#define ID_FILE_OPEN                    40011
#define ID_FILE_SAVE                    40012
#define ID_FILE_SAVEAS                  40013
#define ID_FILE_EXIT                    40014
#define ID_EDIT_CUT                     40015
#define ID_EDIT_COPY                    40016
#define ID_EDIT_PASTE                   40017
#define ID_HELP_ABOUT                   40018
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40042
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

:::



:::details `HelloWindows.rc`

```c
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MENU MENUEX
BEGIN
    POPUP "文件",                             65535,MFT_STRING,MFS_ENABLED
    BEGIN
        MENUITEM "新建(&N)\tCtrl+N",              ID_FILE_NEW,MFT_STRING,MFS_ENABLED
        MENUITEM "打开(&O)\tCtrl+O",              ID_FILE_OPEN,MFT_STRING,MFS_ENABLED
        MENUITEM "保存(&S)\tCtrl+S",              ID_FILE_SAVE,MFT_STRING | MFT_MENUBREAK,MFS_CHECKED
        MENUITEM "另存为(&A)",                     ID_FILE_SAVEAS,MFT_STRING,MFS_ENABLED
        MENUITEM MFT_SEPARATOR
        MENUITEM "退出(&X)",                      ID_FILE_EXIT,MFT_STRING,MFS_ENABLED
    END
    POPUP "编辑",                             65535,MFT_STRING,MFS_GRAYED
    BEGIN
        MENUITEM "剪切(&T)\tCtrl+X",              ID_EDIT_CUT,MFT_STRING,MFS_ENABLED
        MENUITEM "复制(&C)\tCtrl+C",              ID_EDIT_COPY,MFT_STRING,MFS_ENABLED
        MENUITEM "粘贴(&P)\tCtrl+V",              ID_EDIT_PASTE,MFT_STRING,MFS_ENABLED
    END
    POPUP "帮助",                             65535,MFT_STRING | MFT_RIGHTJUSTIFY,MFS_ENABLED
    BEGIN
        MENUITEM "关于HelloWindows(&A)",          ID_HELP_ABOUT,MFT_STRING,MFS_ENABLED
    END
END


#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
```

:::



:::details `HelloWindows.cpp`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    TCHAR szBuf[64] = { 0 };
    if (uMsg == WM_CREATE)
    {
         hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));
        SetMenu(hwnd, hMenu);
        return 0;
    }
    else if (uMsg == WM_COMMAND)
    {
        if (ID_FILE_NEW == LOWORD(wParam))
        {// 新建
            wsprintf(szBuf, TEXT("您点击了 新建 菜单项，命令ID：%d\n"), ID_FILE_NEW);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }
        else if (ID_EDIT_CUT == LOWORD(wParam))
        {// 剪切
            wsprintf(szBuf, TEXT("您点击了 剪切 菜单项，命令ID：%d\n"), ID_EDIT_CUT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);

        }
        else if (ID_HELP_ABOUT == LOWORD(wParam))
        {// 关于HelloWindows
            wsprintf(szBuf, TEXT("您点击了 关于HelloWindows 菜单项，命令ID：%d\n"), ID_HELP_ABOUT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);

        }
        else if (ID_FILE_EXIT == LOWORD(wParam))
        {// 退出
            wsprintf(szBuf, TEXT("您点击了 退出 菜单项，命令ID：%d\n"), ID_FILE_EXIT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
            SendMessage(hwnd, WM_CLOSE, 0, 0);

        }
        else if (ID_FILE_OPEN == LOWORD(wParam))
        {//打开
            wsprintf(szBuf, TEXT("您点击了打开 菜单项 ，命令ID：%d\n"), ID_FILE_EXIT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }
    }
    else if (uMsg == WM_SYSCOMMAND)
    {
        if ((wParam & 0xFFF0) == SC_CLOSE)
        {
            MessageBox(hwnd, TEXT("您点击了 系统菜单 关闭 菜单项"), TEXT("提示"), MB_OK);
            SendMessage(hwnd, WM_CLOSE, 0, 0);
        }
        else
        {
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
        return 0;

    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

- 在Debug下可以看到生成了HelloWindows.res文件，这是资源编译器编译资源脚本文件
  `HelloWindows.rc`后得到的二进制资源文件。
- 最后，`目标文件*.obj`和`资源文件*.res`最后通过链接器链接成可执行文件。
- `资源文件*.res`也可以通过VS的资源编辑器进行编辑。资源虽然被一起打包到可执行文件中，但是资源不在可执行文件的数据区，在程序中无法使用变量或地址直接对资源进行引用。号在，Windows提供了各种函数对资源进行加载。例如`LoadMenu  Loadlcon LoadCursor LoadAccelerators`等，这些函数加载的资源通常不需要释放，程序退出时由系统释放.程序自己创建的对象在不需要的时候通常需要释放，而程序或系统中定义的资源通常不需要释放。
- 当用户单击某一子菜单项(命今项)时，则系统会向拥有该菜单的窗口发送`WM_COMMAND`消息,果单击的是系统菜单的子菜单项，则发送`WM_SYSCOMMAND`消息，程序通常不需要处理`WM_SYSCOMMAND`消息，而是交给`DefWindowProc`函数执行默认处理。

:::



## 快捷键

键盘快捷键也称为加速键，一个加速键是一个或几个按键的组合。加速键用于激活特定的子菜单项命令，通过使用加速键不需要费力移动鼠标就能激活子菜单项。完成鼠标点击指定菜单项的工作。



前面为`HelloWindow`s程序制作菜单资源的时候，已经为子菜单项新建、打开、保存、剪切、复制、粘贴设置了加速键提示信息，还需要添加加速键资源。把加速键和菜单命合建立一对一关联。





打开VS资源视图，用鼠标右键单击`HelloWindows`项目，然后选择添加→资源,打开添加资源对话框，选择Accelerator，单击新建，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127185908046.png)

可以看到，VS自动在`HelloWindows.rc`资源脚本文件中添加了类型为Accelerator的加速键表IDR_ACCELERATOR1。选中左侧的IDR_ACCELERATOR1，打开右侧的属性对话框，可以修改加速键表的ID。



单击资源编辑器中ID一列的ID_ACCELERATOR40032两次，出现下拉框,可以看到刚添加的子菜单项的ID都在里面。选择ID_FILE_NEW，子菜单项新建的快捷键是Ctrl +N，因此选择第二列的修饰符为Ctrl，第三列是按键的虚拟键码或ASClI码，直接输入字母N，然后第四列的类型选择虚拟键码VIRTKEY，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127190224248.png)



同样的方法，为其他子菜单项添加快捷键关联，但是为剪切、复制、粘贴的按键类型选择ASCII(第四列的类型)，最后如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127190311568.png)

按Ctrl +S组合键保存HelloWindows.rc文件。打开HelloWindows.rc文件，看一下新添加的加速键资源

```c
...
IDR_ACC ACCELERATORS
BEGIN
    "N",            ID_FILE_NEW,            VIRTKEY, CONTROL, NOINVERT
    "O",            ID_FILE_OPEN,           VIRTKEY, CONTROL, NOINVERT
    "S",            ID_FILE_SAVE,           VIRTKEY, CONTROL, NOINVERT
    "^X",           ID_EDIT_CUT,            ASCII,  NOINVERT
    "^C",           ID_EDIT_COPY,           ASCII,  NOINVERT
    "^P",           ID_EDIT_PASTE,          ASCII,  NOINVERT
    "A",            ID_HELP_ABOUT,          VIRTKEY, CONTROL, NOINVERT
END
...
```

resource.h头文件的部分内容如下所示

```c{2}
#define IDR_MENU 101
#define IDR_ACC 102
#define ID_FILE_NEW 40010
```





:::details `快捷键的定义`

与菜单的定义相比，快捷键的定义要简单得多，语法如下∶

```c
加速键ID ACCELERATORS
BEGIN
    键名,菜单命今ID[,类型][,修饰符]
    ...
END
```

- 加速键lD同样可以是一个字符串或1～65535之间的数字。

- 加速键的具体定义内容包含在BEGIN和END (或{}）关键字之内，中间是各个加速键的定义，每个加速键占据一行。

- 键名，表示加速键对应的按键，有3种方式定义。

  - "大写字母"类型指定为VIRTKEY，表示字母键。

  - "大写字母"类型指定为ASCll码值，表示Ctrl键加上字母键。

  - 大写字母或小写字母或ASCIl码值，类型指定为ASCIl，表示字母键。

  - > 建议使用方式1，不建议指定类型为ASCll。

```c
例1∶
    "a",ID_HELP_ABOUT, ASCII,NOINVERT //例1中，只有按下小写字母a可以,
例2∶
    "A"，ID_HELP_ABOUT,ASCII,NOINVERT//例2只有按下大写字母A才可以,(同时按下Shift或CapsLock键)
例3∶
    "A",ID_HELP_ABOUT,VIRTKEY,NOINVERT //例3按下小写字母a或大写字母A 都可以
```

- 菜单命今ID。如果想把加速键和子菜单项关联起来，就需要指定为关联菜单项的命今ID
- 类型。可以是VIRTKEY或ASCIl，分别用来表示"键名"字段定义的是虚拟键码还是ASCII码。
- 修饰符。可以是Control Shift或Alt中的一个或多个，如果指定多个，则中间用逗号隔开，表示加速键是键名指定的按键加上这些键的组合键。

现在我们手动为"帮助"主菜单项下面的"关于HelloWindows"添加Ctrl + Shift ＋A快捷键

```c{9}
IDR_ACC ACCELERATORS
BEGIN
    "N",            ID_FILE_NEW,            VIRTKEY, CONTROL, NOINVERT
    "O",            ID_FILE_OPEN,           VIRTKEY, CONTROL, NOINVERT
    "S",            ID_FILE_SAVE,           VIRTKEY, CONTROL, NOINVERT
    "^X",           ID_EDIT_CUT,            ASCII,  NOINVERT
    "^C",           ID_EDIT_COPY,           ASCII,  NOINVERT
    "^P",           ID_EDIT_PASTE,          ASCII,  NOINVERT
    "A",            ID_HELP_ABOUT,          VIRTKEY, SHIFT, CONTROL, NOINVERT
END
```



:::



在一个资源脚本文件中，可以定义多个主菜单或多个加速键表，也可以定义其他各种各样的资源，例如图标、光标、位图等，这就涉及如何为这些资源取ID值的问题，取值的时候要掌握的原则如下。

- 对于同类别内的多个资源项，各项的ID必须为不同的值。假设定义了两个子菜单项，那么它们的ID就必须用不同的数值来表示，否则系统将无法分辨。
- 对于不同类别的资源，资源项ID在数值上可以是相同的，例如某子菜单项的ID为40010，那么也可以同时有ID为40010的位图或图标等，Windows可以按类别分清每一项。



**有两种加速键表**

- 系统维护一个可以用于所有应用程序的系统范围的加速键表，应用程序无法修改系统加速键表。例如`"Alt ＋空格"` 打开系统菜单，`"Alt + F4"`关闭程序，`"Ctrl + Esc"`打开系统开始菜单`，"Alt + PrintScreen"`将活动窗口中的图像复制到剪贴板，按键`"PrintScreen"`将屏幕上的图像复制到剪贴板等。
- 系统还**为每个应用程序维护加速键表**。应用程序可以定义任意数量的加速键表，并随时更换**活动**加速键表。
- 如果应用程序也定义了在系统加速键表中定义的加速键，则应用程序定义的加速键将覆盖系统的加速键，请避免这种做法。





要处理用户按下的加速键，程序需要在消息循环中调用`TranslateAccelerator`函数。该函数会监视消息队列中的`WM_KEYDOWN`和`WM_KEYUP`消息，以检查是否有与加速键表中相匹配的击键组合。如果有，就会将其转换为`WM_COMMAND`或`WM_SYSCOMMAND`(按下的是系统菜单中的加速键)消息，然后将该消息发送到窗口的窗口过程。





要调用`TranslateAccelerator`函数，就要先调用`LoadAccelerators`函数加载加速键表。



:::details `Load/TranslateAccelerators 函数说明`

```c
/// <summary>
/// 让应用加载指定的快捷键
/// </summary>
/// <param name="hInstance">要加载的加速键表所属的模块句柄</param>
/// <param name="lpTableName">要加载的加速键表的名称，可以使用MAKEINTRESOURCE宏</param>
/// <returns></returns>
HACCEL LoadAccelerators(HINSTANCE hInstance,LPCTSTR lpTableName);
```

- HACCEL是加速键表句柄类型，函数执行成功，返回指定的加速键表句柄。



`TranslateAccelerator`函数原型如下:

```c

/// <summary>
/// 在消息循环中，翻译快捷键的消息
/// </summary>
/// <param name="hWnd">要处理哪个窗口的消息</param>
/// <param name="hAccTable">LoadAccelerators函数加载或CreateAcceleratorTable函数创建的加速键表句柄</param>
/// <param name="lpMsg">消息结构</param>
/// <returns></returns>
int WINAPI TranslateAccelerator(HWND hWnd,HACCEL hAccTable,LPMSG lpMsg);
```

如果有消息被转换，则系统将`WM_COMMAND`或`WM_SYSCOMMAND`消息发送到窗口的窗口过程。窗口过程处理完`WM_COMMAND`或`WM_SYSCOMMAND`消息以后，`TranslateAccelerator`函数返回非零值，否则返回值为0。



如果`TranslateAccelerator`函数返回非零值，就不应该再调用`TranslateMessage`和`DispatchMessage`函数(因为消息已经处理)，而是应该继续下一次`GetMessage`消息的获取。消息循环的写法通常按如下方式:

```c
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
```

消息结构(MSG)有一个`hwnd`字段，为什么`TranslateAccelerator`函数还有一个`hWnd`参数呢?

- MSG结构由`GetMessage`函数填充。当`GetMessage`的第2个参数是NULL时，该函数获取属于应用程序主线程的所有窗口的消息，当`GetMessage`函数返回时，MSG结构的`hwnd`字段是将会得到该消息的窗口的窗口句柄。
- 然而，当`TranslateAccelerator`函数将键盘消息转换成WM_COMMAND或WM_SYSCOMMAND消息时，它将`msg.hwnd`字段替换成`TranslateAccelerator`函数第1个参数所指定的窗口句柄，于是Windows会将所有加速键消息发送给指定的窗口。
- 如果程序有多个窗口，则每个窗口都有可能收到键盘消息。
- 如果不是这种设计，就需要在每个窗口的窗口过程中处理加速键消息。所以一般把所有的加速键消息都发送到主窗口，集中在主窗口的窗口过程中处理`WM_COMMAND`或`WM_SYSCOMMAND`消息，这有利于精简代码。

:::





:::details `WM_COMMAND消息的wParam和lParam参数`



WM_COMMAND消息的`wParam`和`lParam`参数如下表所示:

|  `HIWORD(wParam)`  | `LOWORD(wParam)` |     `lParam`     |
| :----------------: | :--------------: | :--------------: |
| 子窗口控件的通知码 |  子窗口控件的ID  | 子窗口控件的句柄 |

通常，不在乎是菜单命今项还是加速键发送过来的WM_COMMAND消息，也就是不用区分`HIWORD(wParam)`，只需要区分`LOWORD(wParam)`**来根据不同的菜单项lD作出不同的处理**。







当用户单击了系统菜单中的命今项或按下了系统菜单的加速键，又或者单击了最小化、最大化、恢复、关闭按钮时，窗口过程会收到`WM_SYSCOMMAND`消息。程序通常不应该处理`WM_SYSCOMMAND`消息，而是交给`DefWindowProc`函数执行默认处理。





WM_SYSCOMMAND消息的`wParam`参数包含请求的系统命今类型，常见的值如下表所示:

|    常量宏     |            含义            |
| :-----------: | :------------------------: |
| `SC_MINIMIZE` |         最小化窗口         |
| `SC_MAXIMIZE` |         最大化窗口         |
| `SC_RESTORE`  | 将窗口恢复到正常位置和大小 |
|  `SC_CLOSE`   |          关闭窗口          |
|   `SC_SIZE`   |        调整窗口大小        |
|   `SC_MOVE`   |          移动窗口          |
| `SC_HSCROLL`  |          水平滚动          |
| `SC_VSCROLL`  |          垂直滚动          |
|  `SC_HOTKEY`  |        全局热键消息        |

可以看到系统命令类型实际上使用的是`LOWORD(wParam)`。请注意，wParam参数的最低4位由系统内部使用，因此如果想测试wParam参数的值，则应该使用`wParam&OxFFFO`来得到正确的结果。如果程序需要处理`WM_SYSCOMMAND`消息，则在处理完感兴趣的系统命今以后，其余部分必须转交给`DefWindowProc`函数执行默认处理。





如果用户使用鼠标选择系统菜单命今项，`lParam`参数的低位字表示鼠标光标的X坐标，高位字表示Y坐标（屏幕坐标)，可以使用`GET_X_LPARAM(IParam)`和`GET_Y_LPARAM(IParam)`宏来分别提取鼠标光标的X和Y坐标。

:::



> 为应用程序窗口添加快捷键Demo



:::details `HelloWindows.rc`

```c
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MENU MENUEX
BEGIN
    POPUP "文件",                             65535,MFT_STRING,MFS_ENABLED
    BEGIN
        MENUITEM "新建(&N)\tCtrl+N",              ID_FILE_NEW,MFT_STRING,MFS_ENABLED
        MENUITEM "打开(&O)\tCtrl+O",              ID_FILE_OPEN,MFT_STRING,MFS_ENABLED
        MENUITEM "保存(&S)\tCtrl+S",              ID_FILE_SAVE,MFT_STRING | MFT_MENUBREAK,MFS_CHECKED
        MENUITEM "另存为(&A)",                     ID_FILE_SAVEAS,MFT_STRING,MFS_ENABLED
        MENUITEM MFT_SEPARATOR
        MENUITEM "退出(&X)",                      ID_FILE_EXIT,MFT_STRING,MFS_ENABLED
    END
    POPUP "编辑",                             65535,MFT_STRING,MFS_GRAYED
    BEGIN
        MENUITEM "剪切(&T)\tCtrl+X",              ID_EDIT_CUT,MFT_STRING,MFS_ENABLED
        MENUITEM "复制(&C)\tCtrl+C",              ID_EDIT_COPY,MFT_STRING,MFS_ENABLED
        MENUITEM "粘贴(&P)\tCtrl+V",              ID_EDIT_PASTE,MFT_STRING,MFS_ENABLED
    END
    POPUP "帮助",                             65535,MFT_STRING | MFT_RIGHTJUSTIFY,MFS_ENABLED
    BEGIN
        MENUITEM "关于HelloWindows(&A)",          ID_HELP_ABOUT,MFT_STRING,MFS_ENABLED
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDR_ACC ACCELERATORS
BEGIN
    "N",            ID_FILE_NEW,            VIRTKEY, CONTROL, NOINVERT
    "O",            ID_FILE_OPEN,           VIRTKEY, CONTROL, NOINVERT
    "S",            ID_FILE_SAVE,           VIRTKEY, CONTROL, NOINVERT
    "^X",           ID_EDIT_CUT,            ASCII,  NOINVERT
    "^C",           ID_EDIT_COPY,           ASCII,  NOINVERT
    "^P",           ID_EDIT_PASTE,          ASCII,  NOINVERT
    "A",            ID_HELP_ABOUT,          VIRTKEY, SHIFT, CONTROL, NOINVERT
END

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

```

:::



:::details `resource.h`

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 HelloWindows.rc 使用
//
#define IDR_MENU                        101
#define IDR_ACC                         102
#define ID_FILE_NEW                     40010
#define ID_FILE_OPEN                    40011
#define ID_FILE_SAVE                    40012
#define ID_FILE_SAVEAS                  40013
#define ID_FILE_EXIT                    40014
#define ID_EDIT_CUT                     40015
#define ID_EDIT_COPY                    40016
#define ID_EDIT_PASTE                   40017
#define ID_HELP_ABOUT                   40018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40042
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240127213849581.png)

:::



:::details `HelloWindows.cpp`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);

    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    //加载加速键表
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        //监视WM_KEYDOWN WM_KEYUP消息，把和加速键表匹配的消息 转为WM_COMMAND或者WM_SYSCOMMAND消息
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    TCHAR szBuf[64] = { 0 };
    if (uMsg == WM_CREATE)
    {
         hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));
        SetMenu(hwnd, hMenu);
        return 0;
    }
    else if (uMsg == WM_COMMAND)
    {
        if (ID_FILE_NEW == LOWORD(wParam))
        {// 新建
            wsprintf(szBuf, TEXT("您点击了 新建 菜单项，命令ID：%d\n"), ID_FILE_NEW);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }
        else if (ID_EDIT_CUT == LOWORD(wParam))
        {// 剪切
            wsprintf(szBuf, TEXT("您点击了 剪切 菜单项，命令ID：%d\n"), ID_EDIT_CUT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }
        else if (ID_HELP_ABOUT == LOWORD(wParam))
        {// 关于HelloWindows
            wsprintf(szBuf, TEXT("您点击了 关于HelloWindows 菜单项，命令ID：%d\n"), ID_HELP_ABOUT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }
        else if (ID_FILE_EXIT == LOWORD(wParam))
        {// 退出
            wsprintf(szBuf, TEXT("您点击了 退出 菜单项，命令ID：%d\n"), ID_FILE_EXIT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
            SendMessage(hwnd, WM_CLOSE, 0, 0);
        }
        else if (ID_FILE_OPEN == LOWORD(wParam))
        {//打开
            wsprintf(szBuf, TEXT("您点击了打开 菜单项 ，命令ID：%d\n"), ID_FILE_EXIT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }
    }
    else if (uMsg == WM_SYSCOMMAND)
    {
        if ((wParam & 0xFFF0) == SC_CLOSE)
        {
            MessageBox(hwnd, TEXT("您点击了 系统菜单 关闭 菜单项"), TEXT("提示"), MB_OK);
            SendMessage(hwnd, WM_CLOSE, 0, 0);
        }
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

:::

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E4%BD%BF%E7%94%A8%E5%BF%AB%E9%80%9F%E9%94%AE%E7%82%B9%E5%87%BB%E8%8F%9C%E5%8D%95%E9%A1%B9.gif)

## 菜单的查询 创建 添加 修改和删除

前面的菜单资源（也叫菜单模板）是通过资源编辑器或编写资源脚本文件创建的。应用程序还可以随时动态创建菜单模板，调用`LoadMenulndirect`函数加载菜单模板得到菜单句柄，然后可以通过调用`SetMenu`函数为窗口设置新的菜单。



:::details `LoadMenuIndirect 函数说明`

```c
/// <summary>
/// 加载菜单模板得到菜单句柄
/// </summary>
/// <param name="lpMenuTemplate">指向菜单模板或扩展菜单模板的指针</param>
/// <returns></returns>
HMENU LoadMenuIndirect(const MENUTEMPLATE* lpMenuTemplate);
```

- 参数lpMenuTemplate是指向菜单模板或扩展菜单模板的指针。
- 菜单模板由一个`MENUITEMTEMPLATEHEADER`结构和一个或多个连续的`MENUITEMTEMPLAT`E结构组成。
- 扩展菜单模板由一个`MENUEX_TEMPLATE_HEADER`结构和一个或多个连续的`MENUEX_TEMPLATE_ITEM`结构组成。
- `MENUITEMTEMPLATEHEADER`或`MENUEX_TEMPLATE_HEADER`结构定义菜单模板的头部，`MENUITEMTEMPLATE`或`MENUEX_TEMPLATE_ITEM`结构定义子菜单项。一个菜单模板由一个头部和一个或多个子菜单项组成。



`MENUITEMTEMPLATEHEADER`结构在`WinUser.h`头文件中定义如下:

```c
typedef struct {
    WORD versionNumber; //菜单模板版本号，必须为0
    WORD offset; //通常设置为0
}MENUITEMTEMPLATEHEADER，*PMENUITEMTEMPLATEHEADER;
```

`MENUITEMTEMPLATE`结构在`WinUser.h`头文件中定义如下:

```c
typedef struct 
{
	WORD mtOption;//菜单选项
	WORD mtlD; //菜单ID
	WCHAR mtString[1]; //菜单名称
}MENUITEMTEMPLATE，*PMENUITEMTEMPLATE;
```

- `mtOption字段`指定菜单选项，常用的值如下表所示。

|      常量宏       |                             含义                             |
| :---------------: | :----------------------------------------------------------: |
|    `MF_POPUP`     |                           弹出菜单                           |
|   `MF_CHECKED`    |                     菜单项旁边有复选按钮                     |
|    `MF_GRAYED`    |                   菜单项处于灰化或禁用状态                   |
|  `MF_MENUBREAK`   |            该菜单项及后面的菜单项位于新行或新列中            |
| `MF_MENUBARBREAK` |  该菜单项及后面的菜单项位于新行或新列中，列与列之间有分隔线  |
| `MF_RIGHTJUSTIFY` |               该菜单项和以后的菜单项是右对齐的               |
|  `MF_OWNERDRAW`   | 默认情况下，菜单项都是由系统负责绘制的，指定MF_OWNERDRAW选项表示该菜单项由程序自己负责绘制 |

此外，可用的菜单选项还有`MF_STRING MF_POPUP MF_HILITE`等。

- `mtID`字段指定菜单项ID，弹出菜单不需要指定该字段。

- `mtString`字段指定菜单名称，是`WCHAR`类型数组。请注意，不管程序使用Unicode还是ANSI字符集，程序资源中的字符串都是使用Unicode编码。

:::



> 先举一个动态菜单模板的例子，下例中当用户按下一个按键的时候就切换菜单栏。



:::details `resource.h`

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 HelloWindows.rc 使用
//
#define IDR_MENU                        101
#define IDR_ACC                         102
#define ID_FILE_NEW                     40010
#define ID_FILE_OPEN                    40011
#define ID_FILE_SAVE                    40012
#define ID_FILE_SAVEAS                  40013
#define ID_FILE_EXIT                    40014
#define ID_EDIT_CUT                     40015
#define ID_EDIT_COPY                    40016
#define ID_EDIT_PASTE                   40017
#define ID_HELP_ABOUT                   40018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40042
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

:::



:::details `HelloWindows.rc`

```c
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MENU MENUEX
BEGIN
    POPUP "文件",                             65535,MFT_STRING,MFS_ENABLED
    BEGIN
        MENUITEM "新建(&N)\tCtrl+N",              ID_FILE_NEW,MFT_STRING,MFS_ENABLED
        MENUITEM "打开(&O)\tCtrl+O",              ID_FILE_OPEN,MFT_STRING,MFS_ENABLED
        MENUITEM "保存(&S)\tCtrl+S",              ID_FILE_SAVE,MFT_STRING | MFT_MENUBREAK,MFS_CHECKED
        MENUITEM "另存为(&A)",                    ID_FILE_SAVEAS,MFT_STRING,MFS_ENABLED
        MENUITEM MFT_SEPARATOR
        MENUITEM "退出(&X)",                      ID_FILE_EXIT,MFT_STRING,MFS_ENABLED
    END
    POPUP "编辑",                             65535,MFT_STRING,MFS_GRAYED
    BEGIN
        MENUITEM "剪切(&T)\tCtrl+X",              ID_EDIT_CUT,MFT_STRING,MFS_ENABLED
        MENUITEM "复制(&C)\tCtrl+C",              ID_EDIT_COPY,MFT_STRING,MFS_ENABLED
        MENUITEM "粘贴(&P)\tCtrl+V",              ID_EDIT_PASTE,MFT_STRING,MFS_ENABLED
    END
    POPUP "帮助",                             65535,MFT_STRING | MFT_RIGHTJUSTIFY,MFS_ENABLED
    BEGIN
        MENUITEM "关于HelloWindows(&A)",          ID_HELP_ABOUT,MFT_STRING,MFS_ENABLED
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDR_ACC ACCELERATORS
BEGIN
    "N",            ID_FILE_NEW,            VIRTKEY, CONTROL, NOINVERT
    "O",            ID_FILE_OPEN,           VIRTKEY, CONTROL, NOINVERT
    "S",            ID_FILE_SAVE,           VIRTKEY, CONTROL, NOINVERT
    "^X",           ID_EDIT_CUT,            ASCII,  NOINVERT
    "^C",           ID_EDIT_COPY,           ASCII,  NOINVERT
    "^P",           ID_EDIT_PASTE,          ASCII,  NOINVERT
    "A",            ID_HELP_ABOUT,          VIRTKEY, SHIFT, CONTROL, NOINVERT
END

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
```

:::



:::details `HelloWindows.cpp`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"

// 全局变量
HINSTANCE g_hInstance;

// 函数声明，窗口过程
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    WORD arrMenuTemplate[] = {
        // MENUITEMTEMPLATEHEADER结构
        0,
        0,
        // 多个MENUITEMTEMPLATE结构，一行一个
        // 第1个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'编', L'辑', 0,
        MF_STRING, 40030, L'剪', L'切', L'(', L'&', L'T', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'X', 0,
        MF_STRING, 40031, L'复', L'制', L'(', L'&', L'C', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'C', 0,
        MF_STRING, 40032, L'粘', L'贴', L'(', L'&', L'P', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'V', 0,
        MF_SEPARATOR, 0, 0,
        MF_STRING, 40033, L'红', L'色', L'(', L'&', L'R', L')', 0,
        MF_STRING, 40034, L'绿', L'色', L'(', L'&', L'G', L')', 0,
        MF_STRING | MF_HILITE, 40035, L'蓝', L'色', L'(', L'&', L'B', L')', 0,
        // 第2个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'视', L'图', 0,
        MF_STRING, 40036, L'大', L'图', L'标', L'(', L'&', L'D', L')', 0,
        MF_STRING | MF_HILITE, 40037, L'小', L'图', L'标', L'(', L'&', L'S', L')', 0,
        // 第3个弹出菜单, 开始和结束都需要MF_HILITE标志，说明这是最后一个菜单
        MF_STRING | MF_POPUP | MF_HELP | MF_HILITE, L'帮', L'助', 0,
        MF_STRING | MF_HILITE, 40038, L'关', L'于', L'H', L'e', L'l', L'l', L'o', L'W', 
            L'i', L'n', L'd', L'o', L'w', L's', L'(', L'&', L'A', L')', 0
    };
    if (uMsg == WM_CREATE)
    {
        //窗口初始化时，直接注入.rc资源中的菜单
        hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));
        SetMenu(hwnd, hMenu);
        return 0;
    }
    else if (uMsg == WM_CHAR)
    {
        //点击某一个字符直接更新菜单为内存菜单
        hMenu = LoadMenuIndirect(arrMenuTemplate);
        SetMenu(hwnd, hMenu);
    }
    else if (uMsg == WM_COMMAND)
    {
        if (LOWORD(wParam) == 40030)
        {
            MessageBox(hwnd, TEXT("按下了 剪切"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == 40036)
        {
            MessageBox(hwnd, TEXT("按下了 大图标"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == 40038)
        {
            MessageBox(hwnd, TEXT("按下了 关于HelloWindows"), TEXT("提示"), MB_OK);
        }
        return 0;
    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```



:::



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E5%8A%A0%E8%BD%BD%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%8F%9C%E5%8D%95.gif)



动态菜单解决了什么样的需求？

- 有的收费软件，在用户注册成为正式版前，会让一些菜单项灰化，不可单击，或者干脆没有相应的菜单项。但是程序内部仍然实现了这个菜单项对应的功能。**只要我们设法启用灰化的菜单项，或添加相应的菜单项即可。**

- 此外，有时候可能需要在一个程序去控制其他目标程序，这时需要向目标程序发送`WM_COMMAND`消息，发送之前假定我们已经知道其`菜单命今ID`了。基于这种思想，我们很轻松的就可以调用系统挂载好的菜单。比如NX二次开发中，我们可以通过`UF_MB_ask_button_id()` 查到菜单项命令ID,从而发送WM_COMMAND消息，即可打开菜单项对应的功能了。



还可以通过调用`CreateMenu`函数创建一个空的菜单。



:::details `CreateMenu AppendMenu 函数说明`

通过调用`CreateMenu`函数创建一个空的菜单。该函数返回一个菜单句柄，然后调用`AppendMenu`或`InsertMenu`函数（或新版本的`InsertMenultem`）向返回的菜单句柄添加菜单项。



```c
/// <summary>
/// 创建一个空的菜单
/// </summary>
/// <returns>返回菜单句柄</returns>
HMENU CreateMenu(void);



/// <summary>
/// 往菜单中追加菜单项
/// </summary>
/// <param name="hMenu">菜单句柄(可以是主菜单句柄、弹出菜单句柄等)</param>
/// <param name="uFlags">菜单选项</param>
/// <param name="uIDNewItem">菜单项ID或弹出菜单句柄</param>
/// <param name="lpNewltem">菜单名称或位图句柄</param>
/// <returns></returns>
BOOL WINAPI AppendMenu(HMENU hMenu,UINT uFlags, UINT_PTR uIDNewItem,LPCTSTR lpNewltem);
```

- 参数`uFlags`指定菜单选项，可以是下表所示的值的组合。

|       常量        |                             含义                             |
| :---------------: | :----------------------------------------------------------: |
|    `MF_POPUP`     | 该菜单项用于弹出菜单。`uIDNewltem`参数被指定为弹出菜单的句句柄，就是说要想添加一个可以弹出菜单的菜单项，需要准备一个弹出菜单句柄； `lpNewItem`参数被指定为指向菜单名称字符串的指针 |
|    `MF_STRING`    | 菜单项是文本字符串，`lpNewItem`参数被指定为指向菜单名称字符串的指针 |
|    `MF_BITMAP`    |     使用位图作为菜单项，lpNewItem参数被指定为位图的句柄      |
|   `MF_CHECKED`    |                 在菜单项旁边显示一个复选标志                 |
|  `MF_UNCHECKED`   |             菜单项旁边没有复选标志，这是默认情况             |
|   `MF_DISABLED`   |                          禁用菜单项                          |
|   `MF_ENABLED`    |                          启用菜单项                          |
|    `MF_GRAYED`    |                          灰化菜单项                          |
|  `MF_MENUBREAK`   |            该菜单项及后面的菜单项位于新行或新列中            |
| `MF_MENUBARBREAK` |  该菜单项及后面的菜单项位于新行或新列中，列与列之间有分隔线  |
|  `MF_OWNERDRAE`   |  该菜单项由程序自己负责绘制,lpNewItem参数可以指向自定义数据  |
|  `MF_SEPARATOR`   |          分隔符，uIDNewItem和lpNewItem参数将被忽略           |

如果uFlags参数没有指定MF_POPUP标志，那么ulDNewltem参数表示菜单项ID

:::





> OK，我们假设程序窗口没有菜单栏，现在需要全新添加主菜单项及其弹出菜单。我们可以通过API的形式直接新建出来菜单。



:::details `演示菜单的新建-无菜单，从0到1新建。`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    HMENU hMenuPopup;
    WORD arrMenuTemplate[] = {
        // MENUITEMTEMPLATEHEADER结构
        0,
        0,
        // 多个MENUITEMTEMPLATE结构，一行一个
        // 第1个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'编', L'辑', 0,
        MF_STRING, 40030, L'剪', L'切', L'(', L'&', L'T', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'X', 0,
        MF_STRING, 40031, L'复', L'制', L'(', L'&', L'C', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'C', 0,
        MF_STRING, 40032, L'粘', L'贴', L'(', L'&', L'P', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'V', 0,
        MF_SEPARATOR, 0, 0,
        MF_STRING, 40033, L'红', L'色', L'(', L'&', L'R', L')', 0,
        MF_STRING, 40034, L'绿', L'色', L'(', L'&', L'G', L')', 0,
        MF_STRING | MF_HILITE, 40035, L'蓝', L'色', L'(', L'&', L'B', L')', 0,

        // 第2个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'视', L'图', 0,
        MF_STRING, 40036, L'大', L'图', L'标', L'(', L'&', L'D', L')', 0,
        MF_STRING | MF_HILITE, 40037, L'小', L'图', L'标', L'(', L'&', L'S', L')', 0,

        // 第3个弹出菜单, 开始和结束都需要MF_HILITE标志，说明这是最后一个菜单
        MF_STRING | MF_POPUP | MF_HELP | MF_HILITE, L'帮', L'助', 0,
        MF_STRING | MF_HILITE, 40038, L'关', L'于', L'H', L'e', L'l', L'l', L'o', L'W', 
            L'i', L'n', L'd', L'o', L'w', L's', L'(', L'&', L'A', L')', 0
    };

    if (uMsg == WM_CREATE) //在这里，自己新建主菜单项以及弹出菜单。
    {
        hMenu = CreateMenu(); //主菜单句柄
        hMenuPopup = CreateMenu(); //第一个弹出菜单
        AppendMenu(hMenuPopup,MF_STRING,ID_FILE_NEW,TEXT("新建"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_OPEN, TEXT("打开"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_SAVE, TEXT("保存"));
       
        // 把第1个弹出菜单添加到主菜单，TEXT("文件")是菜单名称
        AppendMenu(hMenu,MF_STRING|MF_POPUP,(UINT_PTR)hMenuPopup,TEXT("文件"));

        hMenuPopup = CreateMenu(); //第二个弹出菜单
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_CUT, TEXT("剪切"));
        AppendMenu(hMenuPopup,MF_STRING, ID_EDIT_COPY,TEXT("复制"));
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_PASTE,TEXT("粘贴"));

       // 把第2个弹出菜单添加到主菜单，TEXT("编辑")是菜单名称
        AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("编辑"));
        SetMenu(hwnd, hMenu);
        return 0;
    }
    else if (uMsg == WM_CHAR)
    {
        //点击某一个字符直接更新菜单为内存菜单
        hMenu = LoadMenuIndirect(arrMenuTemplate);
        SetMenu(hwnd, hMenu);
    }
    else if (uMsg == WM_COMMAND)
    {
        if (LOWORD(wParam) == ID_FILE_NEW)
        {
            MessageBox(hwnd, TEXT("按下了 新建"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_FILE_OPEN)
        {
            MessageBox(hwnd, TEXT("按下了 打开"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_EDIT_CUT)
        {
            MessageBox(hwnd, TEXT("按下了 剪切"), TEXT("提示"), MB_OK);
        }
        return 0;
    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E8%87%AA%E5%B7%B1%E6%9D%A5%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95.gif)



可以看到，我们用代码分别创建两个弹出菜单句柄，并为之添加子菜单项，然后把弹出菜单添加到主菜单(同时指定菜单名称)，最后调用`SetMenu`函数显示到菜单栏。

:::



> 我们接着再来假设一种情况，假设设程序窗口已经有菜单栏，现在需要添加一个主菜单项及弹出菜单。HelloWindows程序主菜单中已经有文件、编辑和帮助这3个弹出菜单，我想再添加"视图"主菜单项，和“大图标""小图标"子菜单项。



:::details `有菜单,则全量更新菜单`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;    
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    HMENU hMenuPopup;

    WORD arrMenuTemplate[] = {
        // MENUITEMTEMPLATEHEADER结构
        0,
        0,

        // 多个MENUITEMTEMPLATE结构，一行一个
        // 第1个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'编', L'辑', 0,
        MF_STRING, 40030, L'剪', L'切', L'(', L'&', L'T', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'X', 0,
        MF_STRING, 40031, L'复', L'制', L'(', L'&', L'C', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'C', 0,
        MF_STRING, 40032, L'粘', L'贴', L'(', L'&', L'P', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'V', 0,
        MF_SEPARATOR, 0, 0,
        MF_STRING, 40033, L'红', L'色', L'(', L'&', L'R', L')', 0,
        MF_STRING, 40034, L'绿', L'色', L'(', L'&', L'G', L')', 0,
        MF_STRING | MF_HILITE, 40035, L'蓝', L'色', L'(', L'&', L'B', L')', 0,

        // 第2个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'视', L'图', 0,
        MF_STRING, 40036, L'大', L'图', L'标', L'(', L'&', L'D', L')', 0,
        MF_STRING | MF_HILITE, 40037, L'小', L'图', L'标', L'(', L'&', L'S', L')', 0,

        // 第3个弹出菜单, 开始和结束都需要MF_HILITE标志，说明这是最后一个菜单
        MF_STRING | MF_POPUP | MF_HELP | MF_HILITE, L'帮', L'助', 0,
        MF_STRING | MF_HILITE, 40038, L'关', L'于', L'H', L'e', L'l', L'l', L'o', L'W', 
            L'i', L'n', L'd', L'o', L'w', L's', L'(', L'&', L'A', L')', 0
    };

    if (uMsg == WM_CREATE)
    {
        //自己新建出来默认菜单
        hMenu = CreateMenu();
        hMenuPopup = CreateMenu(); 
        AppendMenu(hMenuPopup,MF_STRING,ID_FILE_NEW,TEXT("新建"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_OPEN, TEXT("打开"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_SAVE, TEXT("保存"));
        AppendMenu(hMenu,MF_STRING|MF_POPUP,(UINT_PTR)hMenuPopup,TEXT("文件"));
        hMenuPopup = CreateMenu();
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_CUT, TEXT("剪切"));
        AppendMenu(hMenuPopup,MF_STRING, ID_EDIT_COPY,TEXT("复制"));
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_PASTE,TEXT("粘贴"));
        AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("编辑"));
        AppendMenu(hMenu, MF_STRING | MF_RIGHTJUSTIFY, (UINT_PTR)hMenuPopup, TEXT("帮助"));
        SetMenu(hwnd, hMenu);

        //基于默认菜单加添加
        hMenu = GetMenu(hwnd);
        hMenuPopup = CreateMenu();
        AppendMenu(hMenuPopup,MF_STRING, 66,TEXT("大图标"));
        AppendMenu(hMenuPopup, MF_STRING, 77, TEXT("小图标"));
        AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("视图"));
        DrawMenuBar(hwnd);
        return 0;
    }
    else if (uMsg == WM_CHAR)
    {
        //点击某一个字符直接更新菜单为内存菜单
        hMenu = LoadMenuIndirect(arrMenuTemplate);
        SetMenu(hwnd, hMenu);
    }
    else if (uMsg == WM_COMMAND)
    {
        if (LOWORD(wParam) == ID_FILE_NEW)
        {
            MessageBox(hwnd, TEXT("按下了 新建"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_FILE_OPEN)
        {
            MessageBox(hwnd, TEXT("按下了 打开"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_EDIT_CUT)
        {
            MessageBox(hwnd, TEXT("按下了 剪切"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == 66)
        {
            MessageBox(hwnd, TEXT("按下了 大图标"), TEXT("提示"), MB_OK);
        }
        return 0;

    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E8%87%AA%E5%B7%B1%E6%9D%A5%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95-17064380416391-17064380426142.gif)



"视图"菜单项出现在右边，这是因为当初为“帮助"菜单项设置了右对齐，`AppendMenu`函数总是添加菜单项到指定主菜单或弹出菜单的末尾。在菜单更改以后需要调用`DrawMenuBar`函数强制刷新菜单栏。

:::



> 我们继续讨论，假设程序窗口已经有菜单栏，现在需要在一个弹出菜单中添加几个子菜单项。`HelloWindows`程序主菜单中已经有文件、编辑和帮助3个弹出菜单，我想在"编辑"菜单项中添加"红色" "绿色" "蓝色"子菜单项，再添加一个可以弹出子菜单项列表的子菜单项"更改大小写”，下面有"大写字母"和"小写字母"。预期得到的效果如下所示：
>
> ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240128183609298.png)



:::details `现有菜单基础增加菜单项`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    HMENU hMenuPopup;
    HMENU hMenuPopupSub;

    WORD arrMenuTemplate[] = {
        // MENUITEMTEMPLATEHEADER结构
        0,
        0,
        // 多个MENUITEMTEMPLATE结构，一行一个
        // 第1个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'编', L'辑', 0,
        MF_STRING, 40030, L'剪', L'切', L'(', L'&', L'T', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'X', 0,
        MF_STRING, 40031, L'复', L'制', L'(', L'&', L'C', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'C', 0,
        MF_STRING, 40032, L'粘', L'贴', L'(', L'&', L'P', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'V', 0,
        MF_SEPARATOR, 0, 0,
        MF_STRING, 40033, L'红', L'色', L'(', L'&', L'R', L')', 0,
        MF_STRING, 40034, L'绿', L'色', L'(', L'&', L'G', L')', 0,
        MF_STRING | MF_HILITE, 40035, L'蓝', L'色', L'(', L'&', L'B', L')', 0,

        // 第2个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'视', L'图', 0,
        MF_STRING, 40036, L'大', L'图', L'标', L'(', L'&', L'D', L')', 0,
        MF_STRING | MF_HILITE, 40037, L'小', L'图', L'标', L'(', L'&', L'S', L')', 0,

        // 第3个弹出菜单, 开始和结束都需要MF_HILITE标志，说明这是最后一个菜单
        MF_STRING | MF_POPUP | MF_HELP | MF_HILITE, L'帮', L'助', 0,
        MF_STRING | MF_HILITE, 40038, L'关', L'于', L'H', L'e', L'l', L'l', L'o', L'W', 
            L'i', L'n', L'd', L'o', L'w', L's', L'(', L'&', L'A', L')', 0
    };
    if (uMsg == WM_CREATE)
    {
        //自己新建出来默认菜单
        hMenu = CreateMenu();
        hMenuPopup = CreateMenu(); 
        AppendMenu(hMenuPopup,MF_STRING,ID_FILE_NEW,TEXT("新建"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_OPEN, TEXT("打开"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_SAVE, TEXT("保存"));
        AppendMenu(hMenu,MF_STRING|MF_POPUP,(UINT_PTR)hMenuPopup,TEXT("文件"));
        hMenuPopup = CreateMenu();
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_CUT, TEXT("剪切"));
        AppendMenu(hMenuPopup,MF_STRING, ID_EDIT_COPY,TEXT("复制"));
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_PASTE,TEXT("粘贴"));
        AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("编辑"));
        AppendMenu(hMenu, MF_STRING | MF_RIGHTJUSTIFY, (UINT_PTR)hMenuPopup, TEXT("帮助"));
        SetMenu(hwnd, hMenu);
        //基于默认菜单加添加
        hMenu = GetMenu(hwnd);
        hMenuPopup = CreateMenu();
        AppendMenu(hMenuPopup,MF_STRING, 66,TEXT("大图标"));
        AppendMenu(hMenuPopup, MF_STRING, 77, TEXT("小图标"));
        AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("视图"));
        DrawMenuBar(hwnd);
        
        //在指定的主菜单项加弹出式菜单项
        hMenu = GetMenu(hwnd);
        hMenuPopup = GetSubMenu(hMenu,1);
        AppendMenu(hMenuPopup, MF_SEPARATOR, NULL, NULL);
        AppendMenu(hMenuPopup,MF_STRING,88,TEXT("红色(&R)"));
        AppendMenu(hMenuPopup,MF_STRING,89,TEXT("绿色(&G)"));
        AppendMenu(hMenuPopup,MF_STRING,90,TEXT("蓝色(&B)"));
        AppendMenu(hMenuPopup,MF_SEPARATOR,NULL,NULL);
        hMenuPopupSub = CreateMenu();
        AppendMenu(hMenuPopupSub,MF_STRING,91,TEXT("大写字母(&U)"));
        AppendMenu(hMenuPopupSub,MF_STRING,92,TEXT("小写字母(&L)"));
        AppendMenu(hMenuPopup,MF_STRING | MF_POPUP,(UINT_PTR)hMenuPopupSub,TEXT("更改大小写"));

        return 0;
    }
    else if (uMsg == WM_CHAR)
    {
        //点击某一个字符直接更新菜单为内存菜单
        hMenu = LoadMenuIndirect(arrMenuTemplate);
        SetMenu(hwnd, hMenu);
    }
    else if (uMsg == WM_COMMAND)
    {
        if (LOWORD(wParam) == ID_FILE_NEW)
        {
            MessageBox(hwnd, TEXT("按下了 新建"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_FILE_OPEN)
        {
            MessageBox(hwnd, TEXT("按下了 打开"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_EDIT_CUT)
        {
            MessageBox(hwnd, TEXT("按下了 剪切"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == 66)
        {
            MessageBox(hwnd, TEXT("按下了 大图标"), TEXT("提示"), MB_OK);
        }
        return 0;
    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E5%86%8D%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E5%BC%B9%E5%87%BA%E5%AD%90%E8%8F%9C%E5%8D%95%E9%A1%B9%E5%88%97%E8%A1%A8%E7%9A%84%E5%AD%90%E8%8F%9C%E5%8D%95%E9%A1%B9.gif)

:::



:::details `GetSubMenu/GetMenuItemInfo 函数说明 `

`GetSubMenu`或`GetMenultemInfo`函数可以获取弹出菜单或子菜单项的句柄︰

```c
/// <summary>
/// 获取弹出菜单或子菜单项的句柄
/// </summary>
/// <param name="hMenu">菜单句柄(可以是主菜单句柄、弹出菜单句柄等)</param>
/// <param name="nPos">从0开始的相对位置</param>
/// <returns></returns>
HMENU WINAPI GetSubMenu(HMENU hMenu,  int nPos);
```

- 主菜单中最左侧的主菜单项位置为0，往右增加
- 弹出菜单中最顶部的菜单项位置为0，往下增加，分隔符也计算在内。



在上面的示例中，主菜单中"文件"的位置为0，"编辑"的位置为1，因此使用`GetSubMenu(hMenu,1)`获取的是"编辑"的弹出菜单句柄。

:::





可以看出，之前使用的`AppendMenu`函数把菜单项放到了最后，不能指定所放位置。`InsertMenu`函数也可以添加菜单项，但是可以指定插入的位置。



:::details `InsertMenu`

```c
/// <summary>
/// 指定插入的位置 插入菜单项
/// </summary>
/// <param name="hMenu">菜单句柄(可以是主菜单句柄、弹出菜单句柄等)</param>
/// <param name="uPosition">新菜单项插入的位置，受uFlags参数的影响</param>
/// <param name="uFlags">菜单选项</param>
/// <param name="uIDNewItem">菜单项ID或弹出菜单句柄</param>
/// <param name="lpNewltem">菜单名称或位图句柄</param>
/// <returns></returns>
BOOL InsertMenu(HMENU hMenu,UINT uPosition,UINT uFlags,UINT_PTR uIDNewItem,LPCTSTR lpNewltem);
```

- 参数uFlags除了可以指定为AppendMenu函数的uFlags参数的那些选项，还可以是下表所示的值。

|     宏常量      |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
| `MF_BYCOMMAND`  | 默认值,表示uPosition参数指定的是某菜单项的ID，新菜单项将在其后 |
| `MF_BYPOSITION` | 表示uPosition参数指定的是新菜单项从O开始的相对位置，如果uPosition为-1，则新菜单项将插入菜单的末尾 |

除此之外，AppendMenu和InsertMenu函数的用法完全相同。

:::



:::details `InsertMenu 示例:`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    HMENU hMenuPopup;
    HMENU hMenuPopupSub;
    WORD arrMenuTemplate[] = {
        // MENUITEMTEMPLATEHEADER结构
        0,
        0,
        // 多个MENUITEMTEMPLATE结构，一行一个
        // 第1个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'编', L'辑', 0,
        MF_STRING, 40030, L'剪', L'切', L'(', L'&', L'T', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'X', 0,
        MF_STRING, 40031, L'复', L'制', L'(', L'&', L'C', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'C', 0,
        MF_STRING, 40032, L'粘', L'贴', L'(', L'&', L'P', L')', L'\t', L'C', L't', L'r',
            L'l', L'+', L'V', 0,
        MF_SEPARATOR, 0, 0,
        MF_STRING, 40033, L'红', L'色', L'(', L'&', L'R', L')', 0,
        MF_STRING, 40034, L'绿', L'色', L'(', L'&', L'G', L')', 0,
        MF_STRING | MF_HILITE, 40035, L'蓝', L'色', L'(', L'&', L'B', L')', 0,

        // 第2个弹出菜单, 最后一个子菜单项需要MF_HILITE标志
        MF_STRING | MF_POPUP, L'视', L'图', 0,
        MF_STRING, 40036, L'大', L'图', L'标', L'(', L'&', L'D', L')', 0,
        MF_STRING | MF_HILITE, 40037, L'小', L'图', L'标', L'(', L'&', L'S', L')', 0,

        // 第3个弹出菜单, 开始和结束都需要MF_HILITE标志，说明这是最后一个菜单
        MF_STRING | MF_POPUP | MF_HELP | MF_HILITE, L'帮', L'助', 0,
        MF_STRING | MF_HILITE, 40038, L'关', L'于', L'H', L'e', L'l', L'l', L'o', L'W', 
            L'i', L'n', L'd', L'o', L'w', L's', L'(', L'&', L'A', L')', 0
    };
    if (uMsg == WM_CREATE)
    {
        //自己新建出来默认菜单
        hMenu = CreateMenu();
        hMenuPopup = CreateMenu(); 
        AppendMenu(hMenuPopup,MF_STRING,ID_FILE_NEW,TEXT("新建"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_OPEN, TEXT("打开"));
        AppendMenu(hMenuPopup, MF_STRING, ID_FILE_SAVE, TEXT("保存"));
        AppendMenu(hMenu,MF_STRING|MF_POPUP,(UINT_PTR)hMenuPopup,TEXT("文件"));
        hMenuPopup = CreateMenu();
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_CUT, TEXT("剪切"));
        AppendMenu(hMenuPopup,MF_STRING, ID_EDIT_COPY,TEXT("复制"));
        AppendMenu(hMenuPopup, MF_STRING, ID_EDIT_PASTE,TEXT("粘贴"));
        AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("编辑"));
        AppendMenu(hMenu, MF_STRING | MF_RIGHTJUSTIFY, (UINT_PTR)hMenuPopup, TEXT("帮助"));
        SetMenu(hwnd, hMenu);
        //基于默认菜单加添加
        hMenu = GetMenu(hwnd);
        hMenuPopup = CreateMenu();
        AppendMenu(hMenuPopup,MF_STRING, 66,TEXT("大图标"));
        AppendMenu(hMenuPopup, MF_STRING, 77, TEXT("小图标"));
        //AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopup, TEXT("视图"));
        //改用 InsertMenu
        InsertMenu(hMenu,2,MF_STRING|MF_POPUP|MF_BYPOSITION, (UINT_PTR)hMenuPopup, TEXT("视图"));
        DrawMenuBar(hwnd); 
        //在指定的主菜单项加弹出式菜单项
        hMenu = GetMenu(hwnd);
        hMenuPopup = GetSubMenu(hMenu,1);
        AppendMenu(hMenuPopup, MF_SEPARATOR, NULL, NULL);
        AppendMenu(hMenuPopup,MF_STRING,88,TEXT("红色(&R)"));
        AppendMenu(hMenuPopup,MF_STRING,89,TEXT("绿色(&G)"));
        AppendMenu(hMenuPopup,MF_STRING,90,TEXT("蓝色(&B)"));
        AppendMenu(hMenuPopup,MF_SEPARATOR,NULL,NULL);
        hMenuPopupSub = CreateMenu();
        AppendMenu(hMenuPopupSub,MF_STRING,91,TEXT("大写字母(&U)"));
        AppendMenu(hMenuPopupSub,MF_STRING,92,TEXT("小写字母(&L)"));
        AppendMenu(hMenuPopup,MF_STRING | MF_POPUP,(UINT_PTR)hMenuPopupSub,TEXT("更改大小写"));

        return 0;
    }
    else if (uMsg == WM_CHAR)
    {
        //点击某一个字符直接更新菜单为内存菜单
        hMenu = LoadMenuIndirect(arrMenuTemplate);
        SetMenu(hwnd, hMenu);
    }
    else if (uMsg == WM_COMMAND)
    {
        if (LOWORD(wParam) == ID_FILE_NEW)
        {
            MessageBox(hwnd, TEXT("按下了 新建"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_FILE_OPEN)
        {
            MessageBox(hwnd, TEXT("按下了 打开"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == ID_EDIT_CUT)
        {
            MessageBox(hwnd, TEXT("按下了 剪切"), TEXT("提示"), MB_OK);
        }
        else if (LOWORD(wParam) == 66)
        {
            MessageBox(hwnd, TEXT("按下了 大图标"), TEXT("提示"), MB_OK);
        }
        return 0;
    }
    else if (uMsg == WM_DESTROY)
    {
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

AppendMenu函数总是把菜单项放到最后，现在InsertMenu函数的uPosition参数指定为2表示放在第3个的位置。效果如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E6%8F%92%E5%85%A5%E8%8F%9C%E5%8D%95%E9%A1%B9%E5%8F%AF%E4%BB%A5%E6%8E%A7%E5%88%B6%E8%8F%9C%E5%8D%95%E9%A1%B9%E4%BD%8D%E7%BD%AE-17064517904951.gif)

:::



:::details  `GetMenuItemID 获取一个菜单项ID`

```c
/// <summary>
/// 获取一个菜单项的ID
/// </summary>
/// <param name="hMenu">菜单句柄(可以是主菜单句柄、弹出菜单句柄等)</param>
/// <param name="nPos">相对位置</param>
/// <returns>函数执行成功，返回值是指定菜单项的ID</returns>
UINT GetMenultemID(HMENU hMenu,int nPos);
```

:::



:::details `GetMenuString 获取一个菜单项的文本字符串`

```c

/// <summary>
/// 获取一个菜单项的文本字符串
/// </summary>
/// <param name="hMenu">菜单句柄(可以是主菜单句柄、弹出菜单句柄等)</param>
/// <param name="ulDltem">菜单项ID或相对位置</param>
/// <param name="lpString">在lpString中返回菜单项的名称</param>
/// <param name="nMaxCount">lpString缓冲区的大小，以字符为单位</param>
/// <param name="uFlag">MF_BYCOMMAND或MF_BYPOSITION</param>
/// <returns></returns>
int GetMenuString(HMENU hMenu,UINT ulDltem,LPTSTR lpString,int nMaxCount, UINT uFlag);
```

:::



:::details `ModifyMenu 函数说明`

```c
/// <summary>
/// 修改一个菜单项
/// </summary>
/// <param name="hMnu">菜单句柄(可以是主菜单句柄、弹出菜单句柄等)</param>
/// <param name="uPosition">菜单项ID或相对位置</param>
/// <param name="uFlags">菜单选项</param>
/// <param name="ulDNewltem">菜单项ID或弹出菜单句柄</param>
/// <param name="lpNewltem">菜单名称或位图句柄</param>
/// <returns></returns>
BOOL WINAPI ModifyMenu(HMENU hMnu, UINT uPosition,UINT uFlags,UINT_PTR ulDNewltem, LPCTSTR lpNewltem);
```

:::



:::details `DeleteMenu/RemoveMenu 函数说明`

```c
BOOL WINAPI DeleteMenu(HMENU hMenu, UINTuPosition, UINT uFlags);
BOOL WINAPl RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags);
```

- 参数uFlags可以是MF_BYCOMMAND或MF_BYPOSITION.

:::



**针对系统菜单的操作**





:::details `GetSystemMenu 函数说明`

```c
/// <summary>
/// 获取系统菜单
/// </summary>
/// <param name="hWnd">窗口句柄</param>
/// <param name="bRevert">TRUE或FALSE</param>
/// <returns></returns>
HMENU GetSystemMenu(HWND hWnd,BOOL bRevert);
```

- 如果`bRevert`参数设置为`FALSE`，则表示获取系统菜单的句柄。可以利用这个句柄对系统菜单中的菜单项进行修改，或者向系统菜单添加新的菜单项，所有预定义系统菜单项的ID都大于0xF000。如果程序需要向系统菜单添加菜单项，则菜单项ID必须小于0xF000.

- 如果`bRevert`参数为FALSE，则`GetSystemMenu`函数返回值是系统菜单的句柄
- 如果`bRevert`参数为TRUE，则返回值为NULL。

:::





前面说过，`WM_SYSCOMMAND`消息的`wParam & OxFFF0`包含请求的系统命合类型，例如`SC_CLOSE` `SC_MOVE`。如果在系统菜单中添加了菜单项，那么WM_SYSCOMMAND消息的`LOWORD(wParam)`就是菜单项ID.





例如，下面对系统菜单的操作∶

```c
//灰化系统菜单的关闭菜单项
ModifyMenu(GetSystemMenu(hwnd, FALSE),SC_CLOSE,MF_GRAYED, SC_CLOSE,TEXT("关闭(&C)\tAlt+F4"));

//移除系统菜单的关闭菜单项
RemoveMenu(GetSystemMenu(hwnd, FALSE), SC_CLOSE,MF_BYCOMMAND);

//在系统菜单后面添加一个“打开"菜单项
AppendMenu(GetSystemMenu(hwnd, FALSE),MF_STRING,ID_FILE_NEW,TEXT("打开(&O)"));

//恢复系统菜单
GetSystemMenu(hwnd，TRUE);
```



##  图标资源



:::details `图标是什么`



图标在系统中随处可见，系统使用图标来表示文件、文件夹、快捷方式、应用程序和文档等对象。除了可以使用系统预定义的IDI_前缀的那些标准图标，程序也可以自定义图标。



- 小图标通常用于窗口标题栏左侧和任务栏，可以使用`SM_CXSMICON`和`SM_CYSMICON`参数调用`GetSystemMetrics`函数获取小图标的尺寸，通常是16 16;



- 大图标通常用于可执行文件和快捷方式，可以使用`SM_CXICON`和`SM_CYICON`参数调用`GetSystemMetrics`函数获取大图标的尺寸，通常是32 32。

  

图标文件的后缀名是`.ico`，每个图标通常含有多张内容相同的图片，每一张图片具有不同的尺寸和颜色数，Windows会根据需要显示不同尺寸的图标。



图标文件(`.ico文件`）使用类似.bmp文件格式的结构来保存，但图标的文件头中包含了一些信息以指定文件中含有多少个图标文件以及相关的信息。



:::



为程序设置图标很简单，`Loadlcon`或`Loadlmage`函数可以从应用程序实例中加载指定的图标资源

```c
#define IDI_EAGLE 103
```

```c
wndclass.hIcon = Loadlcon(hInstance,MAKEINTRESOURCE(IDI_EAGLE));
```



如果需要动态更换图标，可以指定`GCLP_HICON`参数调用`SetClassLong`或`SetClassLongPtr`函数

```c
SetClassLongPtr(hwnd, GCLP_HICON,(LONG)Loadlcon(g_hInstance, MAKEINTRESoURCE(IDI_EAGLE)));
```



要动态更换图标，也可以发送`WM_SETICON`消息，例如,效果和上面的调用是一样的。

```c
SendMessage(hwnd,WM_SETICON,ICON_BIG,(LPARAM)Loadlcon(g_hInstance,MAKEINTRESOURCE
(IDI_EAGLE)));
```

## 光标资源

除了可以使用系统预定义的那些`IDC_`前缀开头的标准光标，程序也可以自定义光标。光标文件的后缀名是.cur，系统也支持动态光标，动态光标文件的后缀名是.ani。





为程序设置光标，`LoadCursor`或`LoadImage`函数可以从应用程序实例中加载指定的光标资源

```c
wndclass.hCursor = LoadCursor(hIlnstance,MAKEINTRESOURCE(IDC_POINT));
```

编译运行程序，可以看到当鼠标在客户区中的时候，鼠标光标变成了黑色箭头形状。



要加载动态光标，也可以使用`LoadCursorFromFile`函数从文件中加载，例如︰

```c
wndclass.hCursor = LoadCursorFromFile(TEXT("MacCursorlpoint.cur")); //普通光标
wndclass.hCursor = LoadCursorFromFile(TEXT("LittleNinjalninjanormal.ani")); //动态光标
```



`SetSystemCursor`函数可以使用指定的光标替换掉系统光标



:::details `SetSystemCursor 函数说明`

```c
BOOL WINAPI SetSystemCursor(
_In_HCURSOR hcur， //用这个光标替换掉系统光标
_In_ DWORD id); //系统光标ID
```

- 参数id指定哪个系统光标将被替换，可以是下表所示的值之一。这些值和讲解注册窗口类时的那些IDC_开头的系统预定义光标一一对应。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240221193518728.png)

可以看到，参数id指定的是系统光标的资源ID，而IDC_开头的这些常量则是被MAKEINTRESOURCE宏转换为了字符串类型。如果需要使用`OCR_`开头的常量，在包含Windows.h头文件之前必须定义常量OEMRESOURCE，例如`#define OEMRESOURCE 1`。



调用SetSystemCursor函数以后，系统会调用DestroyCursor函数销毁参数hcur指定的光标资源。因此单纯通过调用LoadCursor函数加载光标，并将得到的光标句柄用于SetSystemCursor函数无法达到目的，还需要调用CopyCursor(hcur)宏复制光标得到光标副本，然后把光标副本传递给SetSystemCursor函数

```c
SetSystemCursor(CopyCursor(LoadCursor(g_hInstance,MAKEINTRESOURCE(IDCPOINT))),OCR_
NORMAL);

SetSystemCursor(CopyCursor(LoadCursorFromFile(TEXT("LittleNinjalIninjanormal.ani")))，OCR_NORMAL);
```

这不是永久的，重后计算机后，被替换的光标会被恢复。

:::





如果需要动态更换光标，可以指定GCLP_HCURSOR参数调用`SetClassLong`或`SetClassLongPtr`函数，例如下面的代码

```c
SetClassLongPtr(hwnd,GCLP_HCURSOR,(LONG)LoadCursor(g_hInstance,MAKEINTRESOURCE(IDC_
POINT)));

SetClassLongPtr(hwnd, GCLP_HCURSOR,(LONG)LoadCursorFromFile(TEXT("LittleNinja
lninjanormal.ani")));
```

## 字符串表资源

程序中用到的字符串，也可以在资源脚本文件中定义，不过使用起来可能比直接在程序源文件中定义稍微复杂一点，但是一个程序如果需要更改为另一种语言版本，那么直接修改一下资源脚本文件中的字符串资源，然后重新编译即可。如果字符串定义在程序源文件中，修改起来就不那么直观了。





:::details `示例:实现中英互换`

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"

// 全局变量
HINSTANCE g_hInstance;
UINT g_uLanguage;

// 函数声明，窗口过程
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID ShowMenu(HWND hwnd, UINT uLanguage);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;

    g_hInstance = hInstance;

    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_FEATHER));
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);

    HMENU hMenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDR_MENU));
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, hMenu, hInstance, NULL);

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_CREATE:
        g_uLanguage = 10000;
        return 0;

    case WM_COMMAND:
        // 此处没有实现多语言
        switch (LOWORD(wParam))
        {
        case ID_FILE_NEW:
            MessageBox(hwnd, TEXT("按下了 新建"), TEXT("提示"), MB_OK);
            break;
        case ID_EDIT_CUT:
            MessageBox(hwnd, TEXT("按下了 剪切"), TEXT("提示"), MB_OK);
            break;
        case ID_HELP_ABOUT:
            MessageBox(hwnd, TEXT("按下了 关于HelloWindows"), TEXT("提示"), MB_OK);
            break;
        case ID_FILE_EXIT:
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;
        case ID_LANGUAGE_CHINESE:
            g_uLanguage = 10000;
            ShowMenu(hwnd, g_uLanguage);
            break;
        case ID_LANGUAGE_ENGLISH:
            g_uLanguage = 20000;
            ShowMenu(hwnd, g_uLanguage);
            break;
        }
        return 0;

    case WM_INITMENUPOPUP:
        if (g_uLanguage == 10000)
            CheckMenuRadioItem(GetSubMenu(GetMenu(hwnd), 2), ID_LANGUAGE_CHINESE,
                ID_LANGUAGE_ENGLISH, ID_LANGUAGE_CHINESE, MF_BYCOMMAND);
        else
            CheckMenuRadioItem(GetSubMenu(GetMenu(hwnd), 2), ID_LANGUAGE_CHINESE,
                ID_LANGUAGE_ENGLISH, ID_LANGUAGE_ENGLISH, MF_BYCOMMAND);
        return 0;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

VOID ShowMenu(HWND hwnd, UINT uLanguage)
{
    HMENU hMenu, hMenuPopup, hMenuTemp, hMenuPopupTemp;
    TCHAR szBuf[256] = { 0 };
    UINT uID;

    hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));   // 菜单资源的主菜单
    hMenuTemp = CreateMenu();                                   // 主菜单
    for (int i = 0; i < GetMenuItemCount(hMenu); i++)
    {
        hMenuPopup = GetSubMenu(hMenu, i);                      // 菜单资源的每个弹出菜单
        hMenuPopupTemp = CreateMenu();                          // 每个弹出菜单
        for (int j = 0; j < GetMenuItemCount(hMenuPopup); j++)
        {
            uID = GetMenuItemID(hMenuPopup, j);
            GetMenuString(hMenuPopup, j, szBuf, _countof(szBuf), MF_BYPOSITION);
            // 判断是不是分隔线
            if (_tcslen(szBuf) != 0)
            {
                // 子菜单项的ID从40010开始，子菜单项字符串的ID就是：uID - 40000 + uLanguage
                LoadString(g_hInstance, uID - 40000 + uLanguage, szBuf, _countof(szBuf));
                AppendMenu(hMenuPopupTemp, MF_STRING, uID, szBuf);
            }
            else
            {
                AppendMenu(hMenuPopupTemp, MF_SEPARATOR, 0, NULL);
            }
        }
        // 每个弹出菜单添加到主菜单
        LoadString(g_hInstance, uLanguage + i, szBuf, _countof(szBuf));
        AppendMenu(hMenuTemp, MF_STRING | MF_POPUP, (UINT_PTR)hMenuPopupTemp, szBuf);
    }

    SetMenu(hwnd, hMenuTemp);
    DrawMenuBar(hwnd);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E6%9B%B4%E6%94%B9%E8%AF%AD%E8%A8%80.gif)

对于简体中文，主菜单中的菜单项字符串ID从10000开始，子菜单项字符串ID从10010开始;对于英语，主菜单中的菜单项字符串ID从20000开始，子菜单项字符串ID从20010开始。

```c
#define IDS_FILE                        10000
#define IDS_EDIT                        10001
#define IDS_LANGUAGE                    10002
#define IDS_HELP                        10003

#define IDS_FILE_NEW                    10010
#define IDS_FILE_OPEN                   10011
#define IDS_FILE_SAVE                   10012
#define IDS_FILE_SAVEAS                 10013
#define IDS_FILE_EXIT                   10014
#define IDS_EDIT_CUT                    10015
#define IDS_EDIT_COPY                   10016
#define IDS_EDIT_PASTE                  10017
#define IDS_HELP_ABOUT                  10018
#define IDS_EDIT_RED                    10019
#define IDS_EDIT_GREEN                  10020
#define IDS_EDIT_BLUE                   10021
#define IDS_LANGUAGE_CHINESE            10022
#define IDS_LANGUAGE_ENGLISH            10023

#define IDS_FILE_E                      20000
#define IDS_EDIT_E                      20001
#define IDS_LANGUAGE_E                  20002
#define IDS_HELP_E                      20003

#define IDS_FILE_NEW_E                  20010
#define IDS_FILE_OPEN_E                 20011
#define IDS_FILE_SAVE_E                 20012
#define IDS_FILE_SAVEAS_E               20013
#define IDS_FILE_EXIT_E                 20014
#define IDS_EDIT_CUT_E                  20015
#define IDS_EDIT_COPY_E                 20016
#define IDS_EDIT_PASTE_E                20017
#define IDS_HELP_ABOUT_E                20018
#define IDS_EDIT_RED_E                  20019
#define IDS_EDIT_GREEN_E                20020
#define IDS_EDIT_BLUE_E                 20021
#define IDS_LANGUAGE_CHINESE_E          20022
#define IDS_LANGUAGE_ENGLISH_E          20023

```

:::



## 程序版本信息资源

什么是版本信息呢?在我的电脑上，devenv.exe是VS的主程序文件，用鼠标右键单击该文件，选择属性，打开devenv.exe属性对话框。在详细信息选项卡可以看到以下信息，如下图所示。





![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240221195638338.png)



要添加版本信息资源，只需要选择Version类型的资源，单击“新建"按钮，然后根据需要进行修改即可，直接编译程序，生成的程序文件就会有版本信息。



:::details `一个带版本信息资源的rc文件`

```c
VS_VERSION_INFO VERSIONINFO
FILEVERSION     1,0,0,1
PRODUCTVERSION  1,0,0,1
FILEFLAGSMASK   0x3fL
#ifdef _DEBUG
    FILEFLAGS   0x3L
#else
    FILEFLAGS   0x2L
#endif
FILEOS          0x40004L
FILETYPE        0x1L
FILESUBTYPE     0x0L

BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "080404b0"
        BEGIN
            VALUE "CompanyName", "Windows程序设计研究中心"
            VALUE "FileDescription", "程序版本信息示例程序"
            VALUE "FileVersion", "1.1"
            VALUE "InternalName", "HelloWin.exe"
            VALUE "LegalCopyright", "Copyright (C) 2019"
            VALUE "OriginalFilename", "HelloWin.exe"
            VALUE "ProductName", "HelloWindows"
            VALUE "ProductVersion", "1.1"
        END
    END

    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x804, 1200
    END
END

```

前面的FILEVERSIONPRODUCTVERSIONFILEFLAGSMASK.
FILEFLAGS FILEOS·FILETYPE·FILESUBTYPE属于版本信息的固定属性，具体含义如下表所示。

|      宏常量      |                             含义                             |
| :--------------: | :----------------------------------------------------------: |
|  `FILEVERSION`   |                          文件版本号                          |
| `PRODUCTVERSION` |                          产品版本号                          |
| `FILEFLAGSMASK`  |                指定FILEFLAGS属性中哪些位有效                 |
|   `FILEFLAGS`    | 文件版本标志;VS_FF_DEBUG(Ox00ooo001)调试版本、VS_FF_PRERELEASE(Oxooo00002)预发行版本、VS_FF_PATCHED(Ox00000004)补丁版本、VS_FF_PRIVATEBUILD(Oxooo00008)内部版本、VS_FF_SPECIALBUILD(Ox00000020)特殊版本等 |
|     `FILEOS`     | 适用的操作系统，可以是VOS_UNKNOWN(Oxo0oo000o0) VOS_NT(Ox0004000o) VOS_WINCE (Ox000500o0) VOS_NT_WINDOWS32(Ox00040004)等 |
|    `FILETYPE`    | 文件类型，可以是VFT_UNKNOWN; VFT_APP;  VFT_DLL;VFT_DRV;VFT_FONT;VFT_VXD;VFT_STATIC_LIB等 |
|  `FILESUBTYPE`   |                         文件的子类型                         |

:::





语言和字符集是在变量类型信息块中定义的，其值是将语言ID和字符集ID组合成一个十六进制格式



> 字符串类型信息块的定义格式如下∶

```c
BLOCK "stringFilelnfo"
BEGIN
	BLOCK“语言集"
    BEGIN
        VALUE"字符串名称"，"字符串"
        ...
    END
END
```



在语言和字符集的字符串类型信息块的定义中，可以定义多条字符串类型的版本信息。这些版本信息的字符串名称有12种，如下表所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240221200845576.png)





如果想要获取一个可执行文件的版本信息，需要使用 GetFileVersionInfoSize. GetFileVersionInfor VerQueryValue共3个函数。首先调用GetFileVersionInfoSize函数检测可执行文件中有没有版本信息资源，函数返回版本信息资源的字节长度;如果检测到文件中有版本信息资源,调用GetFileVersionInfo函数将版本信息读取到一个缓冲区中;然后调用VerQueryValue从缓冲区中分别获取每一项的信息。





## 自定义资源





通过自定义资源，可以在可执行文件中添加任何格式的数据，可以是二进制数据，也可以是一个磁盘文件。自定义资源的用途非常广泛，例如稍微复杂一点的程序除了有一个主程序，还有动态链接库文件。可以把`.dll`文件打包到可执行文件中，用户运行程序的时候把它们释放到本地;



可以把病毒木马程序嵌入可执行文件中，用户运行程序的时候,释放出来并执行;程序运行过程中，可能需要一些数据，可以作为自定义资源嵌入可执行文件中，需要的时候随时加载，等等。







:::details `嵌入音频自定义资源`



```
IDR_WAVE WAVE"站着等你三千年.wav"
#define IDR_WAVE 108
```

现在，我们已经为程序添加了一首歌曲资源，在程序运行以后，将这首歌曲加载到内存中并播放︰

```c
#include <Windows.h>
#include <tchar.h>
#include "resource.h"

#pragma comment(lib, "Winmm.lib")

// 全局变量
HINSTANCE g_hInstance;

// 函数声明，窗口过程
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;

    g_hInstance = hInstance;

    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_FEATHER));
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);

    HMENU hMenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDR_MENU));
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, hMenu, hInstance, NULL);

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRSRC hResBlock;
    HANDLE hRes;
    LPVOID lpMusic;

    switch (uMsg)
    {
    case WM_CREATE:
        hResBlock = FindResource(g_hInstance, MAKEINTRESOURCE(IDR_WAVE), TEXT("WAVE"));
        hRes = LoadResource(g_hInstance, hResBlock);
        lpMusic = LockResource(hRes);
        PlaySound((LPCTSTR)lpMusic, NULL, SND_MEMORY | SND_ASYNC | SND_LOOP);
        return 0;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

编译运行程序，歌声响起来。当然也可以先释放到本地再进行播放，只需要一个创建文件的函数调用即可。如果自定义数据比较重要，就需要数据加密,否则很容易被他人提取出原始资源文件。

:::







:::details `FindResource/FindResourceEx 函数说明`



FindResource或FindResourceEx函数可以获取模块中具有指定类型和名称的资源∶

```c
HRSRC WINAPI FindResource(
_In_opt_ HMODULE hModule， //模块句柄
_In_ LPCTSTR lpName, //资源名称，通常使用MAKEINTRESOURCE
_In_ LPCTSTR lpType); //资源类型名称
```

```c
hResBlock = FindResource(g_hlnstance,MAKEINTRESOURCE(IDR_WAVE)，TEXT("WAV"));
```

把FindResource函数返回的资源信息块的句柄hResBlock作为参数调用LoadResource函数，即可得到资源的句柄︰

```c
HGLOBAL WINAPI LoadResource(
_In_opt_ HMODULE hModule, //模块句柄
_In_ HRSRC hResInfo); // FindResource或FindResourceEx函数返回的资源信息块句柄
```

要获取资源的大小，可以在调用FindResource函数以后调用SizeofResource(g_hlnstance, hResBlock);，函数返回值是DWORD类型的资源大小。



在使用资源后不需要手动释放，当不再需要的时候系统会自动释放

:::



## 插入符号



插入符号是窗口客户区中闪烁的水平或垂直短线、实心块或位图，通常表示插入文本或图形的位置，很多人习惯上叫作光标。当窗口具有键盘焦点或处于活动状态时可以创建、显示插入符号;当失去键盘焦点或变为非活动状态时应该销毁插入符号。





`CreateCaret`函数用于为一个窗口创建指定形状的插入符号



:::details `CreateCaret`

```c
BOOL WINAPl CreateCaret(
_In_ HWND hWnd， //拥有插入符号的窗口的句柄
_In_opt_ HBITMAP hBitmap, //位图句柄，用于定义插入符号的形状
_In_ int nWidth， //插入符号的宽度，设置为0表示使用系统定义的窗口边框宽度
_In_ int nHeight);//插入符号的高度，设置为0表示使用系统定义的窗口边框高度
```

- 参数hBitmap用于定义插入符号的形状。如果设置为NULL，则插入符号为黑色实心;如果设置为(HBITMAP)1，则插入符号为厌色网线形状;如果设置为位图句柄，则插入符号是指定的位图。
- 位图句柄可以通过LoadBitmap函数加载。如果hBitmap参数指定为位图句柄，则CreateCaret函数会忽略nWidth和nHeight参数的值。位图有自己的宽度和高度。

:::





插入符号是隐藏的，必须调用`ShowCaret`函数才能使插入符号可见，然后它会自动闪烁

处理窗口重绘消息时通常需要调用`HideCaret`函数隐藏插入符号



:::details `ShowCaret/HideCaret 函数说明`

```c
BOOL WINAPI ShowCaret(_In_opt_ HWND hWnd);
BOOL WINAPl HideCaret(_In_opt_HWND hWnd);
```

重绘消息处理完毕再调用ShowCaret函数显示插入符号。隐藏具有累积效果，如果程序连续3次调用HideCaret函数，那么必须连续调用ShowCaret函数3次才可以再次显示插入符号。

:::





`SetCaretBlinkTime`函数可以修改插入符号的闪烁时间，这会影响到其他程序，即其他程序也会使用修改后的闪烁时间

```c
BOOL WINAPI SetCaretBlinkTime(_In_ UINT uMSeconds); //毫秒
```

`SetCaretPos`函数可以移动插入符号的位置∶

```c
BOOL WINAPl SetCaretPos(
_In_ int x, //插入符号的新X坐标
_In_ int Y  //插入符号的新Y坐标
);
```

当失去键盘焦点或变为非活动状态时应该调用`DestroyCaret`函数销毁插入符号

```c
BOOL WINAPI DestroyCaret(void);
```

`ZeroMemory`宏可以把指定的内存块填充为0(清需)，新申请的内存块通常需要初始化为全0

```c
void ZeroMemory(
[in] PVOID Destination，//指向要填充0的内存块的起始地址的指针
[in] SIZE_TLength); //要填充为0的内存块的大小，以字节为单位
```

- `ZeroMemory`宏的定义如下

```
#define ZeroMemory RtlZeroMemory
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))
```



:::details `示例:`



```c
#include <Windows.h>
#include <tchar.h>

// 函数声明，窗口过程
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("Typer");
    HWND hwnd;
    MSG msg;

    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);

    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}

#define BUFSIZE 65535

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    TEXTMETRIC tm;
    static int cxChar = 0;      // 字符宽度
    static int cxAverChar;      // 平均字符宽度
    static int cyChar;          // 字符高度
    static int cxClient;        // 客户区宽度
    static int cyClient;        // 客户区高度
    static DWORD dwLineLen;     // 一行的长度
    static DWORD dwLines;       // 客户区中的文本行数
    static int nCaretPosX = 0;  // 插入符号的水平位置
    static int nCaretPosY = 0;  // 插入符号的垂直位置
    static int nCh = 0;         // 缓冲区中的字符个数
    static int nCurChar = 0;    // 当前字符的索引
    static PTCHAR pChInputBuf;  // 输入缓冲区
    TCHAR ch;                   // 当前字符
    RECT rect;

    switch (uMsg)
    {
    case WM_CREATE:
        // 获取平均字符宽度和字符高度
        hdc = GetDC(hwnd);
        GetTextMetrics(hdc, &tm);
        cxAverChar = tm.tmAveCharWidth;
        cyChar = tm.tmHeight;
        ReleaseDC(hwnd, hdc);

        // 分配缓冲区以存储键盘输入
        pChInputBuf = new TCHAR[BUFSIZE];
        ZeroMemory(pChInputBuf, BUFSIZE);
        return 0;

    case WM_SIZE:
        cxClient = LOWORD(lParam);
        cyClient = HIWORD(lParam);
        // 计算行的最大宽度和客户区中的最大行数
        dwLineLen = cxClient - cxAverChar;
        dwLines = cyClient / cyChar;
        return 0;

    case WM_SETFOCUS:
        // 拥有键盘焦点以后创建、显示插入符号
        CreateCaret(hwnd, (HBITMAP)1, 10, cyChar);
        ShowCaret(hwnd);
        SetCaretPos(nCaretPosX, nCaretPosY * cyChar);
        return 0;

    case WM_KILLFOCUS:
        // 失去键盘焦点时隐藏并销毁插入符号
        HideCaret(hwnd);
        DestroyCaret();
        return 0;

    case WM_CHAR:
        switch (wParam)
        {
        case '\b':      // 退格 
        case '\n':      // 换行 
        case 0x1B:      // Esc
            return 0;

        case '\t':      // Tab转换为4个空格
            for (int i = 0; i < 4; i++)
                SendMessage(hwnd, WM_CHAR, ' ', 0);
            return 0;

        case '\r':      // 回车
            pChInputBuf[nCh++] = '\r';
            nCaretPosX = 0;
            nCaretPosY += 1;
            break;

        default:        // 显示字符
            HideCaret(hwnd);
            ch = (TCHAR)wParam;
            // 获取字符宽度并显示
            hdc = GetDC(hwnd);
            GetCharWidth32(hdc, (UINT)ch, (UINT)ch, &cxChar);
            TextOut(hdc, nCaretPosX, nCaretPosY * cyChar, &ch, 1);
            ReleaseDC(hwnd, hdc);
            // 保存字符到输入缓冲区
            pChInputBuf[nCh++] = ch;

            // 计算插入符号的新水平、垂直位置
            nCaretPosX += cxChar;
            if ((DWORD)nCaretPosX > dwLineLen)
            {
                nCaretPosX = 0;
                pChInputBuf[nCh++] = '\r';
                nCaretPosY++;
            }
            nCurChar = nCh;
            ShowCaret(hwnd);
            break;
        }
        SetCaretPos(nCaretPosX, nCaretPosY * cyChar);
        return 0;

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_LEFT:   // 此次简单设置为只能移动到当前行的开头
            if (nCaretPosX > 0)
            {
                HideCaret(hwnd);
                ch = pChInputBuf[--nCurChar];
                hdc = GetDC(hwnd);
                GetCharWidth32(hdc, ch, ch, &cxChar);
                ReleaseDC(hwnd, hdc);
                nCaretPosX = max(nCaretPosX - cxChar, 0);
                ShowCaret(hwnd);
            }
            break;

        case VK_RIGHT:
            break;
        }
        SetCaretPos(nCaretPosX, nCaretPosY * cyChar);
        return 0;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        HideCaret(hwnd);
        SetRect(&rect, 0, 0, dwLineLen, cyClient);
        DrawText(hdc, pChInputBuf, -1, &rect, DT_LEFT);
        ShowCaret(hwnd);
        EndPaint(hwnd, &ps);
        return 0;

    case WM_DESTROY:
        delete[] pChInputBuf;
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

本节实现一个简单的打字程序，篇幅关系没有实现文本选择功能，其实这也简单，设置一下文本颜色与背景色就可以了，方向键仅简单演示了左箭头键。程序运行效果如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240216215114816.png)

:::





