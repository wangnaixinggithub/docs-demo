# 鼠标和键盘

## 鼠标

当用户移动鼠标时，系统在屏幕上显示一个称为鼠标光标的位图，鼠标光标中包含一个称为热点的单像素点，热点确定光标的位置。各种系统预定义光标的形状在讲解注册窗口类`WNDCLASSEX`结构的`hCursor`字段时说过。

- `IDC_ARROW`标准箭头光标的热点位于箭头的最上部
- `DC_CROSS` 十字线光标的热点位于十字线的中心。



对于三键鼠标来说，3个按钮分别被称为左键、中键和右键。对鼠标按钮的操作包括单击、双击、移动和拖动。用户行为如下：

- 单击∶按下鼠标按钮，然后松开。
- 双击∶连续两次快速单击鼠标按钮。
- 移动∶改变鼠标光标的位置。
- 拖动︰按下鼠标按钮不放，并移动鼠标光标。



Windows支持带有5个按钮的鼠标，五键鼠标除了左、中、右按钮外，还有`XBUTTON1`和`XBUTTON2`，浏览器中通常会使用这两个按钮实现网页的前进和后退功能。





要为习惯使用左手的用户配置鼠标，程序可以通过调用`SwapMouseButton`函数或`SystemParameterslnfo`函数(使用`SPI_SETMOUSEBUTTONSWAP`标志)来反转鼠标左键和右键，但请注意，鼠标是共享资源，因此反转鼠标左键和右键会影响其他所有程序。





程序通常没有必要提供这个功能，因为控制面板已经为用户提供了习惯左手还是右手，以及后用单击锁定、双击速度、光标移动速度等丰富的功能，具体参见控制面板→鼠标(打开控制面板以后，查看方式选择小图标)



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240613234909255.png)



### 客户区鼠标消息

当用户移动、按下或释放鼠标按钮时，会生成鼠标输入事件。



系统会将鼠标输入事件转换为消息，然后发送到线程的消息队列中。



比如当用户在窗口的客户区内移动光标时，系统会不断发送一系列`WM_MOUSEMOVE`消息。



比如当用户在客户区内按下或释放鼠标按钮时，会发送下表所示的消息之一。



|       宏常量       |      含义      |
| :----------------: | :------------: |
|  `WM_LBUTTONDOWN`  |  按下鼠标左键  |
|   `WM_LBUTTONUP`   | 鼠标左键被释放 |
| `WM_LBUTTONDBLCLK` |  双击鼠标左键  |
|  `WM_MBUTTONDOWN`  |  按下鼠标中键  |
|   `WM_MBUTTONUP`   | 鼠标中键被释放 |
| `WM_MBUTTONDBLCLK` |  双击鼠标中键  |
|  `WM_RBUTTONDOWN`  |  按下鼠标右键  |
|   `WM_RBUTTONUP`   | 鼠标右键被释放 |
| `WM_RBUTTONDBLCLK` |  双击鼠标右键  |

分别是左键、中键和右键的按下、释放和双击消息。鼠标按下和鼠标抬起消息是成对出现的，例如一次鼠标左键单击事件会生成`WM_LBUTTONDOWN`和`WM_LBUTTONUP`消息。





此外，程序可以通过调用`TrackMouseEvent`函数让系统发送另外两条消息。即当鼠标光标悬停在客户区一段时间后发送`WM_MOUSEHOVER`消息，当鼠标光标离开客户区时发送`WM_MOUSELEAVE`消息。



:::details `TrackMouseEvent 函数说明`

```c
/// <summary>
///  激活 WM_MOUSEHOVER、WM_MOUSELEAVE 消息
/// </summary>
/// <param name="lpEventTrack">指向TRACKMOUSEEVENT结构的指针</param>
/// <returns></returns>
BOOL  TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack);
```

参数lpEventTrack是一个指向TRACKMOUSEEVENT结构的指针。

```c
typedef struct tagTRACKMOUSEEVENT 
{
	DWORD cbSize; //结构的大小
    DWORD dwFlags; //标志位
	HWND hwndTrack; //要跟踪的窗口的句柄
	DWORD dwHoverTime; //悬停超时，以毫秒为单位
}TRACKMOUSEEVENT，*LPTRACKMOUSEEVENT;
```

- 参数dwFlags指定标志位，可以是下表所示的值的组合。

|     宏常量      |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
|  `TME_CANCEL`   | 取消先前的跟踪请求，还需要同时指定要取消的跟踪类型，例如，要取消悬停跟踪，需要指定为TME_CANCEL\|TME_HOVER标志 |
|   `TME_HOVER`   | 当鼠标光标悬停在客户区一段时间后发送WM_MOUSEHOVER消息，该消息只会触发一次。如果需要再次发送该消息，则必须重新调用TrackMouseEvent函数 |
|   `TME_LEAVE`   | 当鼠标光标离开客户区时发送WM_MOUSELEAVE消息，该消息产生以后，所有由TrackMouseEvent函数设置的鼠标跟踪请求(悬停和离开）都会被取消。请注意，如果鼠标不在窗口的客户区内，会立即发送WM_MOUSELEAVE消息 |
| `TME_NONCLIENT` | 当鼠标光标在非客户区悬停一段时间或离开时发送非客户区鼠标消息WM_NCMOUSEHOVER或WM_NCMOUSELEAVE消息，用法和前两个类似 |

- 参数dwHoverTime指定悬停超时(如果在dwFlags参数中指定了TME_HOVER),以毫秒为单位，可以设置为HOVER_DEFAULT，表示使用系统默认的悬停超时。

:::



:::details `客户区鼠标消息对应的lparam wparam参数`



客户区鼠标消息的`wParam`参数包含鼠标事件发生时其他鼠标按钮以及Ctrl和Shift键的状态标志。`wParam`参数可以是下表所示的值的组合。



|    宏常量     |       含义        |
| :-----------: | :---------------: |
| `MK_LBUTTON`  |  鼠标左键已按下   |
| `MK_MBUTTON`  |  鼠标中键已按下   |
| `MK_RBUTTON`  |  鼠标右键已按下   |
| `MK_CONTROL`  |   Ctrl键已按下    |
|  `MK_SHIFT`   |   Shift键已按下   |
| `MK_XBUTTON1` | 第一个X按钮已按下 |
| `MK_XBUTTON2` | 第二个X按钮已按下 |

例如，当接收到`WM_LBUTTONDOWN`消息时，如果`wParam & MK_SHIFT`的值为TRUE(非需)，则**表示用户按下左键的同时还按下了Shift键**。





客户区鼠标消息的`IParam`参数表示鼠标事件发生时光标热点的位置，`lParam`参数的低位字表示热热点光标的X坐标，高位字表示Y坐标，相对于客户区左上角。可以按如下方式获取光标热点的X和Y坐标

```c
int xPos,yPos;
xPos = GET_X_LPARAM(IParam);
yPos = GET_Y_LPARAM(IParam);
```

GET_X_LPARAM和GET_Y_LPARAM宏在头文件中定义如下∶

```c
#define GET_×_LPARAM(Ip) ((int)(short)LoWORD(Ip))
#define GET_Y_LPARAM(Ip) ((int)(short)HIWORD(Ip))
```

:::tip 为啥不能用 LOWORD HIWORD 提取光标位置?

鼠标光标的坐标有时候可能是负值，因此不能使用`LOWORD`或`HIWORD`宏来提取光标位置的X坐标和Y坐标。LOWORD和HIWORD宏返回的是WORD类型，而WORD被定义为无符号短整型。

```c
typedef unsigned short WORD;
```



对于鼠标双击消息`WM_LBUTTONDBLCLK`  `WM_MBUTTONDBLCLK`  `WM_RBUTTONDBLCLK` ，在注册窗口时`WNDCLASSEX`结构的style字段，必须指定`CS_DBLCLKS`样式才可以接收鼠标双击消息。鼠标双击消息通常会连续生成4条消息



例如，双击鼠标左键会生成以下消息序列。

- WM_LBUTTONDOWN
- WM_LBUTTONUP
- WM_LBUTTONDBLCLK
- WM_LBUTTONUP

:::

### 非客户区鼠标消息

窗口的非客户区包括标题栏、菜单栏、菜单、边框、滚动条、最小化按钮和最大化按钮等，当在窗口的非客户区内发生鼠标事件时，会生成非客户区鼠标消息，非客户区鼠标消息的名称包含字母NC。





例如，当光标在非客户区中移动时会生成`WM_NCMOUSEMOVE`消息，当光标在非客户区时按下鼠标左键会生成`WM_NCLBUTTONDOWN`消息。





![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240217202238375.png)



除此之外，通过调用`TrackMouseEvent`函数(`dwFlags`参数包含`TME_NONCLIENT`标志)，当鼠标光标在非客户区悬停一段时间或离开时会发送`WM_NCMOUSEHOVER`或`WM_NCMOUSELEAVE`消息。



:::tip  非客户区鼠标消息由`DefWindowProc`函数执行默认处理。



例如，当鼠标光标移动到窗口的边框时，DefWindowProc函数会处理非客户区鼠标消息，将光标更改为双向箭头。如果没有特殊需求，则应用程序不需要自己处理非客户区鼠标消息。如果实在需要处理，则处理完以后还应该转交给DefWindowProc函数。



如下代码没有调用`DefWindowProc` 函数做二次处理，则无法使用系统菜单，无法使用最小化、最大化、关闭按钮，无法打开程序的菜单，无法通过拖拉边框调整窗口大小等。

```c
case WM_NCLBUTTONDOWN:
case WM_NCLBUTTONUP:
case WM_NCLBUTTONDBLCLK:
return 0;
```

:::



:::details 非客户区鼠标消息的`wparam` `lparam` 参数

非客户区鼠标消息的`wParam`参数包含命中测试值。



每当发生鼠标事件时(包括客户区和非客户区鼠标事件)，系统都会先发送WM_NCHITTEST消息，`DefWindowProc`函数会检查鼠标事件发生时的鼠标光标热点坐标以确定是发送客户区还是非客户区鼠标消息，随后还可能发送WM_SYSCOMMAND消息。



`DefWindowProc`函数处理WM_NCHITTEST消息以后的返回值是指明光标热点位置的命中测试值。命中测试值可以是下表所示的值之一。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240217202945669-17081729870272.png)



**例如，如果鼠标事件发生时光标热点位于窗口的客户区中**，则DefWindowProc函数将命中测试值HTCLIENT返回给窗口过程，窗口过程将HTCLIENT返回给系统，系统将光标热点的屏幕坐标转换为客户区坐标，然后发送相应的客户区鼠标消息。



**例如,如果光标热点位于窗口的非客户区中**，则DefWindowProc函数会返回其他命中测试值，窗口过程将其返回给系统，系统将命中测试值放在消息的wParam参数中，将光标热点的屏幕坐标放在lParam参数中，然后发送非客户区鼠标消息。而后继续发送WM_SYSCOMMAND消息。



例如，大家都知道双击程序窗口左上角的系统菜单图标可以关闭程序。

- 双击事件首先产生WM_NCHITTEST消息，鼠标光标位于系统菜单图标之上，所以DefWindowProc函数处理WM_NCHITTEST消息以后返回`HTSYSMENU`。 
- 之后，系统继续发送`WM_NCLBUTTONDBLCLK`消息，其中`wParam`参数等于`HTSYSMENU` 交付到`DefWindowProc`函数。
- 处理`WM_NCLBUTTONDBLCLK`消息之后，然后系统再发送`WM_SYSCOMMAND`消息，其中`wParam`参数等于`SC_CLOSE` ，DefWindowProc函数将处理`WM_SYSCOMMAND`消息，并发送`WM_CLOSE`消息.
- `DefWindowProc`处理WM_CLOSE消息，向窗口过程发送一个`WM_DESTROY`消息，`DefWindowProc`函数不会处理WM_DESTROY消息，这个消息在实际开发中需要我们自己处理。实现关闭程序的整个闭环操作。





非客户区鼠标消息的`IParam`参数包含鼠标光标热点的X坐标和Y坐标。与客户区鼠标消息不同，该坐标是**屏幕坐标**而不是客户区坐标，相对于屏幕左上角。可以使用`GET_X_LPARAM (lParam)`和
`GET_Y_LPARAM (IParam)`宏分别提取光标热点的X和Y坐标。

通过调用`ScreenToClient`和`ClientToScreen`函数可以将屏幕坐标与客户区坐标相互转换。如果一个屏幕坐标点位于窗口客户区的左侧或上方，那么转换成客户区坐标后，X值或Y值会是负数。

:::



### X按钮消息

当用户按下或释放XBUTTON1或XBUTTON2按钮时会发送`WM_XBUTTON*`或`WM_NCXBUTTON*`消息，这些消息的`wParam`参数的高位字包含一个标志，指示用户按下或释放了哪个X按钮。



比如说，当用户在窗口的客户区中按下、释放或双击第一个或第二个X按钮时会`WM_XBUTTONDOWN`   `WM_XBUTTONUP` 或 `WM_XBUTTONDBLCLK`消息。



:::details `X按钮消息在客户区时的wparam参数和lparam参数`



这些消息的`wParam`参数的低位字包含鼠标事件发生时其他鼠标按钮以及Ctrl和Shift键的状态标志，可用的标志和客户区鼠标消息的`wParam`参数相同。



`wParam`参数的高位字指明用户是按下、释放或双击了哪个X按钮。可以是下表所示的值之一。

|   宏常量   |             含义              |
| :--------: | :---------------------------: |
| `XBUTTON1` | 按下、释放或双击了第一个X按钮 |
| `XBUTTON2` | 按下、释放或双击了第二个X按钮 |

在实际开发中，可以通过可以使用以下代码提取`wParam`参数中的信息：

```c
fwKeys = GET_KEYSTATE_WPARAM(wParam);  //其他鼠标按钮以及Ctrl和Shift键的状态标志
fwButton = GET_XBUTTON_WPARAM(wParam);  //按下、释放或双击了哪个X按钮
```

消息的`lParam`参数表示鼠标事件发生时光标热点的位置。

`lParam`参数的低位字表示热点的X坐标，高位字表示Y坐标。相对于客户区左上角。可以使用

`GET_X_LPARAM (lParam)`和`GET_Y_LPARAM (IParam)`宏分别提取光标热点的X和Y坐标。

:::



当用户在窗口的非客户区中按下、释放或双击第一个或第二个X按钮时会发送`WM_NCXBUTTONDOWN` `WM_NCXBUTTONUP`或`WM_NCXBUTTONDBLCLK`消息。





:::details `X按钮消息在非客户区时的wParam参数和lparam参数`



消息的`wParam`参数的低位字包含`DefWindowProc`函数在处理`WM_NCHITTEST`消息时返回的命中测试值，可用的命中测试值与非客户区鼠标消息的`wParam`参数相同。



高位字表示按下了哪个X按钮，即XBUTTON1或XBUTTON2。



在实际开发中，可以通过可以使用以下代码提取`wParam`参数中的信息

```c
nHittest = GET_NCHITTEST_WPARAM(wParam); //命中测试值
fwButton = GET_XBUTTON_WPARAM(wParam); //按下、释放或双击了哪个X按钮
```

消息的`lParam`参数包含鼠标事件发生时光标热点的X坐标和Y坐标，坐标相对于屏幕的左上角。可以使用`GET_X_LPARAM(lParam)`和`GET_Y_LPARAM(lParam)`宏分别提取光标热点的X和Y坐标。





:::tip 处理之后返回值的问题

请注意，对于鼠标左键、中键或右键的客户区鼠标消息，窗口过程处理完以后应返回0。



但是对于X按钮的客户区消息和非客户区消息处理完毕以后应返回TRUE。对于X按钮消息，`DefWindowProc`函数会执行默认处理，处理以后`DefWindowProc`函数会向窗口发送WM_APPCOMMAND消息。DefWindowProc函数还会处理WM_APPCOMMAND消息，关于WM_APPCOMMAND消息参见MSDN。

:::



### 鼠标光标函数

:::details `G/SetCursorPos() 函数说明`

`GetCursorPos`函数可以获取鼠标光标的当前位置

```c
/// <summary>
/// 获取鼠标位置
/// </summary>
/// <param name="lpPoint">在lpPoint结构中返回鼠标光标位置,屏幕坐标</param>
/// <returns></returns>
BOOL  GetCursorPos(LPPOINT lpPoint)
```

`SetCursorPos`函数可以将鼠标光标移动到指定的位置

```c#
/// <summary>
/// 将鼠标光标移动到指定的位置
/// </summary>
/// <param name="x">屏幕坐标-X 屏幕左上角为0,0</param>
/// <param name="Y">屏幕坐标-Y</param>
/// <returns></returns>
BOOL SetCursorPos(int x, int Y)
```

:::



:::details `ShowCursor() 函数说明`

```c
/// <summary>
/// 显示或隐藏鼠标光标
/// </summary>
/// <param name="bShow">设置为TRUE则显示计数加1，设置为FALSE，则显示计数减1</param>
/// <returns></returns>
int ShowCursor(BOOL bShow)
```

:::





:::details `GetCursorlnfo() 函数说明`

```c
/// <summary>
/// 获取鼠标光标的显示或隐藏状态、光标句柄和坐标
/// </summary>
/// <param name="pci">在这个CURSORINFO结构中返回鼠标光标信息</param>
/// <returns></returns>
BOOL GetCursorlnfo(PCURSORINFO pci)
```

pci参数是一个指向CURSORINFO结构的指针，该结构在WinUser.h头文件中定义如下。

```c
typedef struct tagCURSORINFO
{
	DWORD	cbSize; //该结构的大小
	DWORD flags; //光标状态标志，如果是如果是CURSOR_SHOWING(0)表示光标被隐藏，如果是CURSOR_SHOWING(1)表示正在显示
	HCURSOR hCursor;//光标句柄
	POINT ptScreenPos; //接收光标坐标的POINT结构，屏幕坐标
}CURSORINFO，*PCURSORINFO，*LPCURSORINFO;
```

:::



:::details `SetCursor 函数说明`

SetCursor函数可以设置光标的形状

```c

/// <summary>
/// 设置光标的形状
/// </summary>
/// <param name="hCursor">光标的句柄</param>
/// <returns></returns>
HCURSOR SetCursor(HCURSOR hCursor);
```

- 参数hCursor指定光标的句柄，这个句柄可以由`LoadCursorCreateCursor`或`Loadlmage`函数返回。
- 如果hCursor参数设置为NULL，则从屏幕上删除光标。函数返回值是前一个光标的句柄。

例如调用`SetCursor(LoadCursor(NULL,IDC_CROSS));`可以把光标形状设置为系统预定义光标十字线形状。

:::



需要注意的是，鼠标光标是共享资源，仅当鼠标光标位于我们程序的客户区内时，应该调用`SetCursorPos ShowCursor SetCursor`等函数改变鼠标光标，在光标离开客户区之前应该恢复为先前的状态。





:::details `ClipCursor 函数说明`



`ClipCursor`函数可以将鼠标光标的活动范围限制在指定的矩形区域以内:

```c
/// <summary>
/// 以将鼠标光标的活动范围限制在指定的矩形区域以内
/// </summary>
/// <param name="IpRect">屏幕坐标，lpRect设置为NULL,则可以自由移动</param>
/// <returns></returns>
BOOL  ClipCursor(RECT* IpRect)
```

某些加密程序为了防止用户调试自己的程序或者其他非法操作，经常限制用户的鼠标只能在自己程序的窗口范围内活动，例如下面的代码可以实现这个目的。

```c
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rect;
    switch (uMsg)
    {
    case WM_CREATE:
        SetTimer(hwnd, 1, 100, NULL);
        return 0;
    case WM_TIMER:
        GetWindowRect(hwnd,&rect);
        ClipCursor(&rect);
        return 0;
    case WM_DESTROY:
        ClipCursor(NULL);
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

在WM_CREATE消息中调用`SetTimer`函数创建了一个计时器，每隔100ms向窗口过程发送一个WM_TIMER消息。将鼠标光标的活动范围限制在当前窗口矩形内。

:::



### 鼠标捕获

本节实现一个鼠标绘制矩形的示例，用鼠标绘图需要跟踪鼠标光标的位置，跟踪光标通常涉及处理`WM_LBUTTONDOWN`  `WM_MOUSEMOVE`和 `WM_LBUTTONUP`消息。



通过记录WM_LBUTTONDOWN消息的`IParam`参数中提供的光标位置来确定起点，鼠标移动时会不断产生一系列`WM_MOUSEMOVE`消息，通常也应该处理`WM_MOUSEMOVE`消息以实时反映所绘制图形的变化，最后，处理`WM_LBUTTONUP`消息结束绘制。

:::details `实现画一个矩形`

```c{45,75}
#include <Windows.h>
#include <Windowsx.h>
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID DrawFrame(HWND hwnd, POINT ptLeftTop, POINT ptRightBottom);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("DrawRectangle");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    static POINT ptLeftTop, ptRightBottom;  // 矩形的左上角和右下角坐标
    static BOOL bStarting;
    switch (uMsg)
    {
    case WM_LBUTTONDOWN:
        SetCapture(hwnd);
        SetCursor(LoadCursor(NULL, IDC_CROSS));
        // 初始化新矩形的左上角和右下角坐标
        ptLeftTop.x = ptRightBottom.x = GET_X_LPARAM(lParam);
        ptLeftTop.y = ptRightBottom.y = GET_Y_LPARAM(lParam);
        bStarting = TRUE;
        return 0;
    case WM_MOUSEMOVE:
        if (bStarting)
        {
            SetCursor(LoadCursor(NULL, IDC_CROSS));
            // 先擦除上一次WM_MOUSEMOVE消息所画的矩形，WM_MOUSEMOVE消息会不断产生
            DrawFrame(hwnd, ptLeftTop, ptRightBottom);
            // 新矩形的右下角坐标
            ptRightBottom.x = GET_X_LPARAM(lParam);
            ptRightBottom.y = GET_Y_LPARAM(lParam);
            // 绘制新矩形
            DrawFrame(hwnd, ptLeftTop, ptRightBottom);
        }
        return 0;
    case WM_LBUTTONUP:
        if (bStarting)
        {
            // 擦除WM_MOUSEMOVE消息中所画的最后一个矩形
            DrawFrame(hwnd, ptLeftTop, ptRightBottom);
            // 最终矩形的右下角坐标
            ptRightBottom.x = GET_X_LPARAM(lParam);
            ptRightBottom.y = GET_Y_LPARAM(lParam);
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            bStarting = FALSE;
            ReleaseCapture();
            // 绘制最终的矩形
            InvalidateRect(hwnd, NULL, TRUE);
        }
        return 0;
    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        Rectangle(hdc, ptLeftTop.x, ptLeftTop.y, ptRightBottom.x, ptRightBottom.y);
        EndPaint(hwnd, &ps);
        return 0;
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
VOID DrawFrame(HWND hwnd, POINT ptLeftTop, POINT ptRightBottom)
{
    HDC hdc = GetDC(hwnd);
    SelectObject(hdc, GetStockObject(NULL_BRUSH));
    SetROP2(hdc, R2_NOT);
    Rectangle(hdc, ptLeftTop.x, ptLeftTop.y, ptRightBottom.x, ptRightBottom.y);
    SelectObject(hdc, GetStockObject(WHITE_BRUSH));
    ReleaseDC(hwnd, hdc);
}
```

- 用户按下鼠标左键，鼠标光标的当前位置作为要绘制矩形的左上角和右下角坐标。

- 然后不断拖动鼠标产生WM_MOUSEMOVE消息，将矩形的右下角坐标重设为鼠标光标的当前位置，然后画出矩形的边框。

- 当用户释放鼠标时，绘制最终的矩形。

:::



:::tip

这个程序存在一个`缺陷`,在程序窗口的客户区内按下鼠标左键，然后移动鼠标到窗口以外时，程序将停止接收`WM_MOUSEMOVE`消息。现在释放鼠标，由于鼠标落在客户区以外，所以程序没有接收到
`WM_BUTTONUP`消息。再将鼠标移回程序窗口的客户区，窗口过程仍然会认为鼠标按钮处于按下的状态，程序现在不知道该如何运行了。



鼠标按下和鼠标抬起消息是成对出现的，这一点没错，但是，在一个窗口没有接收WM_LBUTTONDOWN消息的情况下，该窗口的窗口过程可能会接收到WM_LBUTTONUP消息，例如用户在其他窗口内按下鼠标，再移动到我们的程序窗口，然后释放，此时就会发生这种情况。





如果用户在程序窗口按下鼠标，然后移动鼠标到另一个窗口再释放，则窗口过程会接收到WM_LBUTTONDOWN消息，但接收不到WM_LBUTTONUP消息。





解决方案1：

把`WM_LBUTTONDOWN`消息中的`SetCapture(hwnd);`注释去掉，把`WM_LBUTTONUP`消息中的`ReleaseCapture();`注释也去掉，程序工作就会正常。下面解释这两个函数。



解决方案2:可以使用`ClipCursor`函数在绘制矩形期间将光标活动区域限制在客户区范围以内。

```c{15,41}
...
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    static POINT ptLeftTop, ptRightBottom;  // 矩形的左上角和右下角坐标
    static BOOL bStarting;
    RECT rectClient;
    switch (uMsg)
    {
    case WM_LBUTTONDOWN:
        GetClientRect(hwnd,&rectClient); //获取客户区坐标
        ClientToScreen(hwnd,LPPOINT(&rectClient));
        ClientToScreen(hwnd,LPPOINT(&rectClient)+1);
        ClipCursor(&rectClient);
        SetCursor(LoadCursor(NULL, IDC_CROSS));
        ptLeftTop.x = ptRightBottom.x = GET_X_LPARAM(lParam);
        ptLeftTop.y = ptRightBottom.y = GET_Y_LPARAM(lParam);
        bStarting = TRUE;
        return 0;
    case WM_MOUSEMOVE:
        if (bStarting)
        {
            SetCursor(LoadCursor(NULL, IDC_CROSS));
            DrawFrame(hwnd, ptLeftTop, ptRightBottom);
            ptRightBottom.x = GET_X_LPARAM(lParam);
            ptRightBottom.y = GET_Y_LPARAM(lParam);
            DrawFrame(hwnd, ptLeftTop, ptRightBottom);
        }
        return 0;
    case WM_LBUTTONUP:
        if (bStarting)
        {
            DrawFrame(hwnd, ptLeftTop, ptRightBottom);
            ptRightBottom.x = GET_X_LPARAM(lParam);
            ptRightBottom.y = GET_Y_LPARAM(lParam);
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            bStarting = FALSE;
            InvalidateRect(hwnd, NULL, TRUE);
        }
        ClipCursor(NULL);
        return 0;
    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        Rectangle(hdc, ptLeftTop.x, ptLeftTop.y, ptRightBottom.x, ptRightBottom.y);
        EndPaint(hwnd, &ps);
        return 0;
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

这样的处理方式也很合理。

有一点需要注意，RECT结构有一个特性，就是**RECT结构通常不包含右边缘和底边缘**，大家可以测试一下，将光标活动区域限制在客户区范围内以后，最右侧和最底部是无法绘制到的。如果需要，则可以在获取客户区的矩形尺寸以后再为其right和bottom字段**额外加1**。

:::



:::details `Set/ReleaseCapture 函数说明`

`SetCapture`函数为指定窗口设置鼠标捕获，然后该窗口可以接收所有鼠标消息，直到调用`ReleaseCapture`函数或为其他窗口设置了鼠标捕获。

```c
/// <summary>
/// 为hWnd窗口捕获鼠标
/// </summary>
/// <param name="hWnd">指定窗口句柄</param>
/// <returns></returns>
HWND SetCapture(HWND hWnd);
```

函数返回值是先前捕获鼠标的窗口的句柄，一次只能有一个窗口来捕获鼠标。



再需要鼠标捕获的时候必须调用`ReleaseCapture`函数释放鼠标捕获。

```c

/// <summary>
/// 释放鼠标捕获
/// </summary>
/// <param name=""></param>
/// <returns></returns>
BOOL ReleaseCapture(void);
```

为指定窗口设置鼠标捕获以后，鼠标消息总是以客户区鼠标消息的形式出现。



即使鼠标位于窗口的非客户区，参数`lParam`表示的鼠标光标也始终相对于客户区。



当鼠标位于客户区之外的左方或上方时，X和Y坐标会是负值。



不要随便为一个程序窗口设置鼠标捕获，通常只有当鼠标在客户区内被按下时，程序才应该捕获鼠标，当释放鼠标按钮时，应该立即停止捕获。

:::





鼠标滚轮

按下或释放鼠标滚轮会发送`WM_MBUTTONDOWN`或`WM_MBUTTONUP`消息。

双击鼠标滚轮会发送`WM_MBUTTONDBLCLK`消息。另外，旋转滚轮会发送`WM_MOUSEWHEEL`消息。



:::tip

需要注意的是，WM_MOUSEWHEEL消息是发送给具有输入焦点的窗口，而不是光标位置下面的窗口。

:::





:::details `鼠标滚轮消息wparam参数和lparam参数`



`WM_MOUSEWHEEL`消息的`wParam`参数的高位字表示本次滚轮旋转的距离，可能是正值或负值。

- 正值表示滚轮向前旋转，远离用户。
-  负值表示滚轮向后旋转，朝向用户。

`WM_MOUSEWHEEL`消息的`wParam`参数的低位字表示鼠标事件发生时其他鼠标按钮以及Ctrl和Shift键的状态标志，可用的标志和客户区鼠标消息的`wParam`参数相同。



在实际开发中，可以使用以下代码获取`wParam`参数中的信息

```c
//其他鼠标按钮以及Ctrl和Shift键的状态标志
fwKeys = GET_KEYSTATE_WPARAM(wparam);
//获取滚轮偏移量参数
iDistance = GET_WHEEL_DELTA_WPARAM(wParam);
```

`WM_MOUSEWHEEL`消息的`lParam`参数包含鼠标事件发生时光标热点的X坐标和Y坐标，**相对于屏幕左上角**。可以使用`GET_X_LPARAM(IParam)`和`GET_Y_LPARAM(IParam)`宏分别提取光标热点的X和Y坐标。





还有一个鼠标滚轮水平滚动的`WM_MOUSEHWHEEL`消息，加了一个H表示Horizontal，其消息参数和WM_MOUSEWHEEL消息的完全相同，在此不再赘述。处理完这两个消息以后应该返回0。

:::



程序可以通过调用`SystemParameterslnfo`函数获取一个`WHEEL_DELTA`值可以滚动的行数

```c
UINT uiScrollLines; //在uiScrollLines中返回一个WHEEL_DELTA值可以滚动的行数
SystemParametersInfo(SPI_GETWHEELSCROLLLINES,0, &uiScrollLines,0);
```

滚动行数的默认值为3，用户可以通过控制面板修改默认值。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240615162551941.png)

常量WHEEL_DELTA在WinUser.h头文件中定义如下

```c
#define WHEEL_DELTA 120
```

则可以推算，滚动一行所需的增量为`WHEEL_DELTA /uiScrollLines` 。





假设WM_MOUSEWHEEL消息中`wParam`参数的高位字值为192，正值表示滚轮向前旋转。远离用户，也就是向上滚动页面，此时应该滚动`192/(WHEEL_DELTA/uiScrollLines)`，默认情况下就是`192/40`等于向上滚动4行。但是192/40还余32，为了提高用户体验，我们可以把这个32记录下来，加到下一次WM_MOUSEWHEEL消息中`wParam`参数的高位字上，当然也可以舍弃这个余下的32。





:::details `接下来，我们为SystemMetrics4程序添加鼠标滚轮垂直滚动条接口`

```c{318-334,190-195}
#include <Windows.h>
#include <tchar.h>
struct
{
    int     m_nIndex;
    PCTSTR   m_pLabel;
    PCTSTR   m_pDesc;
}METRICS[] = {
    SM_CXSCREEN,                    TEXT("SM_CXSCREEN"),                    TEXT("屏幕的宽度"),
    SM_CYSCREEN,                    TEXT("SM_CYSCREEN"),                    TEXT("屏幕的高度"),
    SM_CXFULLSCREEN,                TEXT("SM_CXFULLSCREEN"),                TEXT("全屏窗口的客户区宽度"),
    SM_CYFULLSCREEN,                TEXT("SM_CYFULLSCREEN"),                TEXT("全屏窗口的客户区高度"),
    SM_ARRANGE,                     TEXT("SM_ARRANGE"),                     TEXT("如何排列最小化窗口"),
    SM_CLEANBOOT,                   TEXT("SM_CLEANBOOT"),                   TEXT("系统启动方式"),
    SM_CMONITORS,                   TEXT("SM_CMONITORS"),                   TEXT("监视器的数量"),
    SM_CMOUSEBUTTONS,               TEXT("SM_CMOUSEBUTTONS"),               TEXT("鼠标上的按钮数"),
    SM_CXBORDER,                    TEXT("SM_CXBORDER"),                    TEXT("窗口边框的宽度"),
    SM_CYBORDER,                    TEXT("SM_CYBORDER"),                    TEXT("窗口边框的高度"),
    SM_CXCURSOR,                    TEXT("SM_CXCURSOR"),                    TEXT("光标的宽度"),
    SM_CYCURSOR,                    TEXT("SM_CYCURSOR"),                    TEXT("光标的高度"),
    SM_CXDLGFRAME,                  TEXT("SM_CXDLGFRAME"),                  TEXT("同SM_CXFIXEDFRAME，有标题但不可调整大小的窗口边框的宽度"),
    SM_CYDLGFRAME,                  TEXT("SM_CYDLGFRAME"),                  TEXT("同SM_CYFIXEDFRAME，有标题但不可调整大小的窗口边框的高度"),
    SM_CXDOUBLECLK,                 TEXT("SM_CXDOUBLECLK"),                 TEXT("鼠标双击事件两次点击的X坐标不可以超过这个值"),
    SM_CYDOUBLECLK,                 TEXT("SM_CYDOUBLECLK"),                 TEXT("鼠标双击事件两次点击的Y坐标不可以超过这个值"),
    SM_CXDRAG,                      TEXT("SM_CXDRAG"),                      TEXT("拖动操作开始之前，鼠标指针可以移动的鼠标下方点的任意一侧的像素数"),
    SM_CYDRAG,                      TEXT("SM_CYDRAG"),                      TEXT("拖动操作开始之前，鼠标指针可以移动的鼠标下移点上方和下方的像素数"),
    SM_CXEDGE,                      TEXT("SM_CXEDGE"),                      TEXT("三维边框的宽度"),
    SM_CYEDGE,                      TEXT("SM_CYEDGE"),                      TEXT("三维边框的高度"),
    SM_CXFIXEDFRAME,                TEXT("SM_CXFIXEDFRAME"),                TEXT("同SM_CXDLGFRAME，有标题但不可调整大小的窗口边框的宽度"),
    SM_CYFIXEDFRAME,                TEXT("SM_CYFIXEDFRAME"),                TEXT("同SM_CYDLGFRAME，有标题但不可调整大小的窗口边框的高度"),
    SM_CXFOCUSBORDER,               TEXT("SM_CXFOCUSBORDER"),               TEXT("DrawFocusRect绘制的焦点矩形的左边缘和右边缘的宽度"),
    SM_CYFOCUSBORDER,               TEXT("SM_CYFOCUSBORDER"),               TEXT("DrawFocusRect绘制的焦点矩形的上边缘和下边缘的高度"),
    SM_CXFRAME,                     TEXT("SM_CXFRAME"),                     TEXT("同SM_CXSIZEFRAME，可调大小窗口边框的宽度"),
    SM_CYFRAME,                     TEXT("SM_CYFRAME"),                     TEXT("同SM_CYSIZEFRAME，可调大小窗口边框的高度"),
    SM_CXHSCROLL,                   TEXT("SM_CXHSCROLL"),                   TEXT("水平滚动条中箭头位图的宽度"),
    SM_CYHSCROLL,                   TEXT("SM_CYHSCROLL"),                   TEXT("水平滚动条中箭头位图的高度"),
    SM_CXVSCROLL,                   TEXT("SM_CXVSCROLL"),                   TEXT("垂直滚动条中箭头位图的宽度"),
    SM_CYVSCROLL,                   TEXT("SM_CYVSCROLL"),                   TEXT("垂直滚动条中箭头位图的高度"),
    SM_CXHTHUMB,                    TEXT("SM_CXHTHUMB"),                    TEXT("水平滚动条中滚动框(滑块)的高度"),
    SM_CYVTHUMB,                    TEXT("SM_CYVTHUMB"),                    TEXT("垂直滚动条中滚动框(滑块)的宽度"),
    SM_CXICON,                      TEXT("SM_CXICON"),                      TEXT("图标的默认宽度"),
    SM_CYICON,                      TEXT("SM_CYICON"),                      TEXT("图标的默认高度"),
    SM_CXICONSPACING,               TEXT("SM_CXICONSPACING"),               TEXT("大图标视图中项目的网格单元格宽度"),
    SM_CYICONSPACING,               TEXT("SM_CYICONSPACING"),               TEXT("大图标视图中项目的网格单元格高度"),
    SM_CXMAXIMIZED,                 TEXT("SM_CXMAXIMIZED"),                 TEXT("最大化顶层窗口的默认宽度"),
    SM_CYMAXIMIZED,                 TEXT("SM_CYMAXIMIZED"),                 TEXT("最大化顶层窗口的默认高度"),
    SM_CXMAXTRACK,                  TEXT("SM_CXMAXTRACK"),                  TEXT("具有标题和大小调整边框的窗口可以拖动的最大宽度"),
    SM_CYMAXTRACK,                  TEXT("SM_CYMAXTRACK"),                  TEXT("具有标题和大小调整边框的窗口可以拖动的最大高度"),
    SM_CXMENUCHECK,                 TEXT("SM_CXMENUCHECK"),                 TEXT("菜单项前面复选框位图的宽度"),
    SM_CYMENUCHECK,                 TEXT("SM_CYMENUCHECK"),                 TEXT("菜单项前面复选框位图的高度"),
    SM_CXMENUSIZE,                  TEXT("SM_CXMENUSIZE"),                  TEXT("菜单栏按钮的宽度"),
    SM_CYMENUSIZE,                  TEXT("SM_CYMENUSIZE"),                  TEXT("菜单栏按钮的高度"),
    SM_CXMIN,                       TEXT("SM_CXMIN"),                       TEXT("窗口的最小宽度"),
    SM_CYMIN,                       TEXT("SM_CYMIN"),                       TEXT("窗口的最小高度"),
    SM_CXMINIMIZED,                 TEXT("SM_CXMINIMIZED"),                 TEXT("最小化窗口的宽度"),
    SM_CYMINIMIZED,                 TEXT("SM_CYMINIMIZED"),                 TEXT("最小化窗口的高度"),
    SM_CXMINSPACING,                TEXT("SM_CXMINSPACING"),                TEXT("最小化窗口的网格单元宽度"),
    SM_CYMINSPACING,                TEXT("SM_CYMINSPACING"),                TEXT("最小化窗口的网格单元高度"),
    SM_CXMINTRACK,                  TEXT("SM_CXMINTRACK"),                  TEXT("窗口的最小拖动宽度，用户无法将窗口拖动到小于这些尺寸"),
    SM_CYMINTRACK,                  TEXT("SM_CYMINTRACK"),                  TEXT("窗口的最小拖动高度，用户无法将窗口拖动到小于这些尺寸"),
    SM_CXPADDEDBORDER,              TEXT("SM_CXPADDEDBORDER"),              TEXT("标题窗口的边框填充量"),
    SM_CXSIZE,                      TEXT("SM_CXSIZE"),                      TEXT("窗口标题或标题栏中按钮的宽度"),
    SM_CYSIZE,                      TEXT("SM_CYSIZE"),                      TEXT("窗口标题或标题栏中按钮的高度"),
    SM_CXSIZEFRAME,                 TEXT("SM_CXSIZEFRAME"),                 TEXT("同SM_CXFRAME，可调大小窗口边框的宽度"),
    SM_CYSIZEFRAME,                 TEXT("SM_CYSIZEFRAME"),                 TEXT("同SM_CYFRAME，可调大小窗口边框的厚度"),
    SM_CXSMICON,                    TEXT("SM_CXSMICON"),                    TEXT("小图标的建议宽度"),
    SM_CYSMICON,                    TEXT("SM_CYSMICON"),                    TEXT("小图标的建议高度"),
    SM_CXSMSIZE,                    TEXT("SM_CXSMSIZE"),                    TEXT("小标题按钮的宽度"),
    SM_CYSMSIZE,                    TEXT("SM_CYSMSIZE"),                    TEXT("小标题按钮的高度"),
    SM_CXVIRTUALSCREEN,             TEXT("SM_CXVIRTUALSCREEN"),             TEXT("虚拟屏幕的宽度"),
    SM_CYVIRTUALSCREEN,             TEXT("SM_CYVIRTUALSCREEN"),             TEXT("虚拟屏幕的高度"),
    SM_CYCAPTION,                   TEXT("SM_CYCAPTION"),                   TEXT("标题区域的高度"),
    SM_CYKANJIWINDOW,               TEXT("SM_CYKANJIWINDOW"),               TEXT("屏幕底部的日文汉字窗口的高度"),
    SM_CYMENU,                      TEXT("SM_CYMENU"),                      TEXT("单行菜单栏的高度"),
    SM_CYSMCAPTION,                 TEXT("SM_CYSMCAPTION"),                 TEXT("小标题的高度"),
    SM_DBCSENABLED,                 TEXT("SM_DBCSENABLED"),                 TEXT("User32.dll是否支持DBCS"),
    SM_DEBUG,                       TEXT("SM_DEBUG"),                       TEXT("是否安装了User.exe的调试版本"),
    SM_DIGITIZER,                   TEXT("SM_DIGITIZER"),                   TEXT("设备支持的数字转换器输入类型"),
    SM_IMMENABLED,                  TEXT("SM_IMMENABLED"),                  TEXT("是否启用了输入法管理器／输入法编辑器功能"),
    SM_MAXIMUMTOUCHES,              TEXT("SM_MAXIMUMTOUCHES"),              TEXT("系统中是否有数字化仪"),
    SM_MEDIACENTER,                 TEXT("SM_MEDIACENTER"),                 TEXT("当前操作系统是不是Windows XP Media Center"),
    SM_MENUDROPALIGNMENT,           TEXT("SM_MENUDROPALIGNMENT"),           TEXT("下拉菜单是否与相应的菜单栏项右对齐"),
    SM_MIDEASTENABLED,              TEXT("SM_MIDEASTENABLED"),              TEXT("系统是否启用希伯来语和阿拉伯语"),
    SM_MOUSEHORIZONTALWHEELPRESENT, TEXT("SM_MOUSEHORIZONTALWHEELPRESENT"), TEXT("是否安装了带有水平滚轮的鼠标"),
    SM_MOUSEPRESENT,                TEXT("SM_MOUSEPRESENT"),                TEXT("是否安装了鼠标"),
    SM_MOUSEWHEELPRESENT,           TEXT("SM_MOUSEWHEELPRESENT"),           TEXT("是否安装了带有垂直滚轮的鼠标"),
    SM_NETWORK,                     TEXT("SM_NETWORK"),                     TEXT("是否存在网络"),
    SM_PENWINDOWS,                  TEXT("SM_PENWINDOWS"),                  TEXT("是否安装了Microsoft Windows for Pen Computing扩展"),
    SM_REMOTECONTROL,               TEXT("SM_REMOTECONTROL"),               TEXT("当前终端服务器会话是否被远程控制"),
    SM_REMOTESESSION,               TEXT("SM_REMOTESESSION"),               TEXT("调用进程是否与终端服务客户机会话关联"),
    SM_SAMEDISPLAYFORMAT,           TEXT("SM_SAMEDISPLAYFORMAT"),           TEXT("所有显示器的颜色格式是否相同"),
    SM_SECURE,                      TEXT("SM_SECURE"),                      TEXT("始终返回0"),
    SM_SERVERR2,                    TEXT("SM_SERVERR2"),                    TEXT("系统是否是Windows Server 2003 R2"),
    SM_SHOWSOUNDS,                  TEXT("SM_SHOWSOUNDS"),                  TEXT("用户是否要求应用程序在其他情况下以可视方式呈现信息"),
    SM_SHUTTINGDOWN,                TEXT("SM_SHUTTINGDOWN"),                TEXT("当前会话是否正在关闭"),
    SM_SLOWMACHINE,                 TEXT("SM_SLOWMACHINE"),                 TEXT("计算机是否具有低端(慢速)处理器"),
    SM_STARTER,                     TEXT("SM_STARTER"),                     TEXT("当前操作系统版本"),
    SM_SWAPBUTTON,                  TEXT("SM_SWAPBUTTON"),                  TEXT("鼠标左键和右键的功能是否互换了"),
    SM_TABLETPC,                    TEXT("SM_TABLETPC"),                    TEXT("是否启动了Tablet PC输入服务"),
    SM_XVIRTUALSCREEN,              TEXT("SM_XVIRTUALSCREEN"),              TEXT("虚拟屏幕左侧的坐标"),
    SM_YVIRTUALSCREEN,              TEXT("SM_YVIRTUALSCREEN"),              TEXT("虚拟屏幕顶部的坐标")
};
const int NUMLINES = sizeof(METRICS) / sizeof(METRICS[0]);
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;                          
    TCHAR szClassName[] = TEXT("MyWindow");       
    TCHAR szAppName[] = TEXT("GetSystemMetrics");  
    HWND hwnd;                                   
    MSG msg;                                      
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW | WS_VSCROLL | WS_HSCROLL,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    TEXTMETRIC tm;
    SCROLLINFO si;
    HFONT hFont, hFontOld;
    static int s_iCol1, s_iCol2, s_iCol3, s_iHeight;
    static int s_cxClient, s_cyClient;              
    static int s_cxChar;                            
    int iVertPos, iHorzPos;
    RECT rect = { 0 };
    SIZE size = { 0 };
    int x, y;
    TCHAR szBuf[10];
    int nPaintBeg, nPaintEnd;                       
    UINT uiScrollLines;
    static int iDistancePerLine;                    // 滚动一行所需距离
    static int iDistanceScroll;                     // 本次处理WM_MOUSEWHEEL消息需要滚动多少距离
    switch (uMsg)
    {
    case WM_CREATE:
        hdc = GetDC(hwnd);
        hFont = CreateFont(12, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("宋体"));
        hFontOld = (HFONT)SelectObject(hdc, hFont);
        for (int i = 0; i < NUMLINES; i++)
        {
            GetTextExtentPoint32(hdc, METRICS[i].m_pLabel, _tcslen(METRICS[i].m_pLabel), &size);
            if (size.cx > s_iCol1)
                s_iCol1 = size.cx;
            GetTextExtentPoint32(hdc, METRICS[i].m_pDesc, _tcslen(METRICS[i].m_pDesc), &size);
            if (size.cx > s_iCol2)
                s_iCol2 = size.cx;
            GetTextExtentPoint32(hdc, szBuf,
                wsprintf(szBuf, TEXT("%d"), GetSystemMetrics(METRICS[i].m_nIndex)), &size);
            if (size.cx > s_iCol3)
                s_iCol3 = size.cx;
        }
        s_iHeight = size.cy + 2;
        GetTextMetrics(hdc, &tm);
        s_cxChar = tm.tmAveCharWidth;

        GetClientRect(hwnd, &rect);
        rect.right = s_iCol1 + s_iCol2 + s_iCol3 + GetSystemMetrics(SM_CXVSCROLL);
        AdjustWindowRectEx(&rect, GetWindowLongPtr(hwnd, GWL_STYLE),
            GetMenu(hwnd) != NULL, GetWindowLongPtr(hwnd, GWL_EXSTYLE));
        MoveWindow(hwnd, 0, 0, rect.right - rect.left, rect.bottom - rect.top, TRUE);
        SetWindowPos(hwnd, NULL, 0, 0, rect.right - rect.left, rect.bottom - rect.top,
            SWP_NOZORDER | SWP_NOMOVE);

        SelectObject(hdc, hFontOld);
        DeleteObject(hFont);
        ReleaseDC(hwnd, hdc);
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &uiScrollLines, 0);
        if (uiScrollLines != 0)
            iDistancePerLine = WHEEL_DELTA / uiScrollLines;
        else
            iDistancePerLine = 0;
        return 0;

    case WM_SIZE:
     
        s_cxClient = LOWORD(lParam);
        s_cyClient = HIWORD(lParam);
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_RANGE | SIF_PAGE;
        si.nMin = 0;
        si.nMax = NUMLINES - 1;
        si.nPage = s_cyClient / s_iHeight;
        SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_RANGE | SIF_PAGE;
        si.nMin = 0;
        si.nMax = (s_iCol1 + s_iCol2 + s_iCol3) / s_cxChar - 1;
        si.nPage = s_cxClient / s_cxChar;
        SetScrollInfo(hwnd, SB_HORZ, &si, TRUE);
        return 0;
    case WM_VSCROLL:
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_ALL;
        GetScrollInfo(hwnd, SB_VERT, &si);
        iVertPos = si.nPos;
        switch (LOWORD(wParam))
        {
        case SB_LINEUP:
            si.nPos -= 1;
            break;
        case SB_LINEDOWN:
            si.nPos += 1;
            break;
        case SB_PAGEUP:
            si.nPos -= si.nPage;
            break;
        case SB_PAGEDOWN:
            si.nPos += si.nPage;
            break;
        case SB_THUMBTRACK:
            si.nPos = si.nTrackPos;
            break;
        case SB_TOP:
            si.nPos = 0;
            break;
        case SB_BOTTOM:
            si.nPos = NUMLINES - 1;
            break;
        }
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_POS;
        SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
        GetScrollInfo(hwnd, SB_VERT, &si);
        if (iVertPos != si.nPos)
        {
            ScrollWindow(hwnd, 0, s_iHeight * (iVertPos - si.nPos), NULL, NULL);
            UpdateWindow(hwnd);
        }
        return 0;

    case WM_HSCROLL:
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_ALL;
        GetScrollInfo(hwnd, SB_HORZ, &si);
        iHorzPos = si.nPos;
        switch (LOWORD(wParam))
        {
        case SB_LINELEFT:
            si.nPos -= 1;
            break;
        case SB_LINERIGHT:
            si.nPos += 1;
            break;
        case SB_PAGELEFT:
            si.nPos -= si.nPage;
            break;
        case SB_PAGERIGHT:
            si.nPos += si.nPage;
            break;
        case SB_THUMBTRACK:
            si.nPos = si.nTrackPos;
            break;
        }
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_POS;
        SetScrollInfo(hwnd, SB_HORZ, &si, TRUE);
        GetScrollInfo(hwnd, SB_HORZ, &si);
        if (iHorzPos != si.nPos)
        {
            ScrollWindow(hwnd, s_cxChar * (iHorzPos - si.nPos), 0, NULL, NULL);
            UpdateWindow(hwnd);
        }
        return 0;

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_UP:     // 向上箭头键
            SendMessage(hwnd, WM_VSCROLL, SB_LINEUP, 0);
            break;
        case VK_DOWN:   // 向下箭头键
            SendMessage(hwnd, WM_VSCROLL, SB_LINEDOWN, 0);
            break;
        case VK_PRIOR:  // PageUp键
            SendMessage(hwnd, WM_VSCROLL, SB_PAGEUP, 0);
            break;
        case VK_NEXT:   // PageDown键
            SendMessage(hwnd, WM_VSCROLL, SB_PAGEDOWN, 0);
            break;
        case VK_HOME:   // Home键(或者Fn + PageUp键)
            SendMessage(hwnd, WM_VSCROLL, SB_TOP, 0);
            break;
        case VK_END:    // End键(或者Fn + PageDown键)
            SendMessage(hwnd, WM_VSCROLL, SB_BOTTOM, 0);
            break;

        case VK_LEFT:   // 左箭头键
            SendMessage(hwnd, WM_HSCROLL, SB_LINELEFT, 0);
            break;
        case VK_RIGHT:  // 右箭头键
            SendMessage(hwnd, WM_HSCROLL, SB_LINERIGHT, 0);
            break;
        }
        return 0;
    case WM_MOUSEWHEEL:
        if (iDistancePerLine == 0)
            return 0;
        iDistanceScroll += GET_WHEEL_DELTA_WPARAM(wParam);
        // GET_WHEEL_DELTA_WPARAM(wParam)是正数，滚轮向前旋转，远离用户，向上滚动
        while (iDistanceScroll >= iDistancePerLine)
        {
            SendMessage(hwnd, WM_VSCROLL, SB_LINEUP, 0);
            iDistanceScroll -= iDistancePerLine;
        }
        // GET_WHEEL_DELTA_WPARAM(wParam)是负数，滚轮向后旋转，朝向用户，向下滚动
        while (iDistanceScroll <= -iDistancePerLine)
        {
            SendMessage(hwnd, WM_VSCROLL, SB_LINEDOWN, 0);
            iDistanceScroll += iDistancePerLine;
        }
        return 0;
    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_POS | SIF_PAGE;
        GetScrollInfo(hwnd, SB_VERT, &si);
        iVertPos = si.nPos;
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_POS;
        GetScrollInfo(hwnd, SB_HORZ, &si);
        iHorzPos = si.nPos;
        SetBkMode(hdc, TRANSPARENT);
        hFont = CreateFont(12, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("宋体"));
        hFontOld = (HFONT)SelectObject(hdc, hFont);
        nPaintBeg = max(0, iVertPos + ps.rcPaint.top / s_iHeight);
        nPaintEnd = min(NUMLINES - 1, iVertPos + ps.rcPaint.bottom / s_iHeight);
        for (int i = nPaintBeg; i <= nPaintEnd; i++)
        {
            x = s_cxChar * (-iHorzPos);
            y = s_iHeight * (i - iVertPos);
            TextOut(hdc, x, y, METRICS[i].m_pLabel, _tcslen(METRICS[i].m_pLabel));
            TextOut(hdc, x + s_iCol1, y, METRICS[i].m_pDesc, _tcslen(METRICS[i].m_pDesc));
            TextOut(hdc, x + s_iCol1 + s_iCol2, y, szBuf,
                wsprintf(szBuf, TEXT("%d"), GetSystemMetrics(METRICS[i].m_nIndex)));
        }
        SelectObject(hdc, hFontOld);
        DeleteObject(hFont);
        EndPaint(hwnd, &ps);
        return 0;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

前面说过，滚动行数的默认值为3，用户可以通过控制面板修改其默认值。如果用户更改了系统参数，则系统会向所有顶级窗口广播`WM_SETTINGCHANGE`消息。如果希望把程序做得更友好，则应该处理`WM_SETTINGCHANGE`消息，在该消息中再次调用`SystemParametersInfo(SPI_GETWHEELSCROLLLINES,0, &uiScrollLines,0);`重新计算滚动一行所需的增量。

:::



### 模拟鼠标消息

有两种方法可以很方便地实现模拟鼠标消息，一是使用`SendMessage` / `PostMessage`函数发送鼠标消息，二是使用`mouse_event`模拟鼠标事件。



:::details `mouse_event() 函数说明`

`mouse_event`函数模拟鼠标移动和鼠标按钮单击事件，原型如下∶

```c
/// <summary>
/// 模拟鼠标消息
/// </summary>
/// <param name="dwFlags">控制鼠标移动和按钮单击的标志位</param>
/// <param name="dx">鼠标在X轴的绝对位置或者从上次鼠标事件产生以来移动的相对数量</param>
/// <param name="dy">鼠标在Y轴的绝对位置或者从上次鼠标事件产生以来移动的相对数量</param>
/// <param name="dwData">根据dwFlags参数的设置，具有不同含义</param>
/// <param name="dwExtralnfo">与鼠标事件关联的附加值，可调用GetMessageExtralnfo以获取此额外信息</param>
/// <returns></returns>
VOID mouse_event(DWORD dwFlags,DWORD dx, DWORD dy,DWORD dwData,ULONG_PTR dwExtralnfo);
```

- 参数dwFlags是控制鼠标移动和按钮单击的标志位，该参数可以是下表所示的值的组合。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240217212044960.png)

- 如果参数dwFlags指定了MOUSEEVENTF_ABSOLUTE标志，那么dx和dy参数为鼠标移动的绝对位置。dx和dy的值指定为0～65535(0，,0)映射到屏幕的左上角。(65535,65535)映射到屏幕的右下角。
- 例如，如果希望把鼠标光标移动到离屏幕左上角向右200像素，向下100像素处，那么在1920 1080分辨率的计算机上，应该这样调用mouse_event函数，我用按键1进行测试。

```c
  case WM_CHAR:
      switch (wParam)
      {
      case '1':
          mouse_event(MOUSEEVENTF_ABSOLUTE| MOUSEEVENTF_MOVE,200*65535/1920,100*65535/1080,0,0);
          break;
      default:
          break;
      }
      return 0;
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240217212424299.png)





如果参数dwFlags没有指定MOUSEEVENTF_ABSOLUTE标志，那么dx和dy表示相对于上次鼠标事件产生的位置的移动量，指定为正值表示鼠标向右(或下)移动，负值表示鼠标向左(或上)移动。



但是，**相对移动受指针移动速度和加速级别的设置影响，可以通过控制面板修改这些值**，也可以通过指定SPI_SETMOUSESPEED或SPI_SETMOUSE参数调用SystemParameterslnfo函数修改指针移动速度或加速级别。

```c
mouse_event(MOUSEEVENTF_MOVE,10,0,0,0);
```



微软建议使用SendInput函数代替mouse_event ，但是Sendlnput函数用起来确实有点复杂。



:::



## 键盘

键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上每一个键的开关状态进行扫描。按下一个键时，开关接通，该芯片会产生一个扫描码。扫描码说明了按下的键在键盘上的位置。松开按下的键也会产生一个扫描码，这说明了松开的键在键盘上的位置。扫描码与具体键盘设备相关。





键盘设备驱动程序会去解释扫描码并将其转换（映射)为虚拟键码，**虚拟键码**是系统定义的一个与设备无关的值。转换扫描码以后，将创建一条消息，其中包含虚拟键码和有关按键的其他信息，然后将该消息放入系统的消息队列，系统将这个键盘消息发送到相应线程的消息队列中，最后，线程的消息循环获取该消息并将其分发送给相应的窗口过程进行处理。



### 活动窗口与键盘焦点



:::details `什么是活动窗口？如何将指定窗口置为活动窗口`

活动窗口(Active Window）是用户当前使用的顶级窗口，同一时刻只能有一个程序窗口是活动窗口。系统将其放置在Z顺序的顶部，并突出显示其标题栏和边框。用户可以通过单击顶级窗口，或使用
`Alt +Tab / Alt + Esc`组合键来激活顶级窗口使其成为活动窗口，可以通过调用`GetActiveWindow()`函数获取活动窗口的句柄。还可以通过调用`SetActiveWindow()`函数来激活顶级窗口，类似的函数还有`BringWindowToTop()`  `SwitchToThisWindow()`和`SetForegroundWindow()`

:::



但是在某些系统中，这些函数可能达不到预期的效果。当用户正在使用一个窗口时，Windows不会强制另一个窗口到达前台，仅闪烁窗口的任务栏程序图标以通知用户。





:::tip

桌面上的所有窗口共享键盘，**只有活动窗口或活动窗口的子窗口才可以接收键盘输入**。具有键盘焦点的窗口接收键盘消息，直到键盘焦点变为其他窗口。

:::





当一个窗口被激活时，系统会发送`WM_ACTIVATE`消息。默认窗口过程`DefWindowProc()`会处理这个消息，并将键盘焦点设置为这个活动窗口。





:::details `SetFocus 函数说明`

程序可以通过`SetFocus()`函数为自己的窗口或子窗口设置键盘焦点。

```c
/// <summary>
/// 为自己的窗口或子窗口设置键盘焦点
/// </summary>
/// <param name="hWnd">需要获取键盘焦点的活动窗口</param>
/// <returns>函数执行成功，返回值是以前具有键盘焦点的窗口的句柄</returns>
HWND  SetFocus(HWND hWnd);
```

:::



当键盘焦点从一个窗口更改为另一个窗口时，系统会向失去焦点的窗口发送`WM_KILLFOCUS`消息，然后将`WM_SETFOCUS`消息发送到已获得焦点的窗口。



程序可以通过调用`BlockInput()`函数阻止键盘和鼠标输入



:::details `BlockInput 函数说明`

```c
/// <summary>
/// 让应用程序窗口阻止键盘和鼠标的输入
/// </summary>
/// <param name="fBlocklt"></param>
/// <returns></returns>
BOOL BlockInput(BOOL fBlocklt)
```

`fBlocklt`参数设置为TRUE表示阻止键盘和鼠标输入事件，设置为FALSE表示取消阻止。测试这个函数的时候请注意，因为编译运行程序会使本程序成为活动窗口，键盘和鼠标输入会失效，导致无法关闭本程序，也无法切换到其他程序，这时只能按`Ctrl + Alt +Del`组合键打开任务管理器来结束本进程。

:::



### 系统击键消息和非系统击键消息

按下一个键将产生`WM_KEYDOWN`或`WM_SYSKEYDOWN`消息，释放一个键将产生`WM_KEYUP`或`WM_SYSKEYUP`消息。按键按下和按键抬起消息通常是成对出现的，如果用户按住一个键不放，则系统会生成一系列`WM_KEYDOWN`或`WM_SYSKEYDOWN`消息，直到用户释放按键时，再生成一条`WM_KEYUP`或`WM_SYSKEYUP`消息。



系统区分系统击键和非系统击键

- 系统击键生成系统击键消息 `WM_SYSKEYDOWN`和`WM_SYSKEYUP`
- 非系统击键生成非系统击键消息  `WM_KEYDOWN`和`WM_KEYUP`



比如,当用户按下`F10`键（激活菜单栏)，或键入与Alt键组合的键时，将生成系统击键消息。

再比如 `Alt+F4`组合键用于关闭一个程序。系统击键主要用于访问系统菜单，系统击键消息由默认窗口过程`DefWindowProc`进行处理。程序的窗口过程通常不应该处理系统击键消息。



`DefWindowProc`不会处理非系统击键消息，因此程序窗口过程应该处理感兴趣的非系统击键消息。



:::tip 



对于`WM_KEYDOWN`和`WM_KEYUP`消息，通常只需要处理一个即可，通常都是处理`WM_KEYDOWN`消息，并且通常**只处理那些包含方向键、上档键Shift和功能键(F1～F12)等的虚拟键码的消息**，不处理来自可显示字符键的击键消息。



因为我们知道，消息循环的时候，`TranslateMessage()`函数可以把
WM_KEYDOWN消息转换为字符消息WM_CHAR，这样一来我们就可以在窗口过程中处理字符消息`WM_CHAR`来判断用户是按下了哪个字符按键。即有了`TranslateMessage()`函数的帮助，对于字符按键我们不需要处理WM_KEYDOWN和WM_KEYUP消息，只需要处理字符消息`WM_CHAR`消息。

:::



:::details `WM_SYSKEYDOWN 和 WM_KEYDOWN 的 wparam lParam 参数`



对于系统击键消息`WM_SYSKEYDOWN`和`WM_SYSKEYUP`，非系统击键消息`WM_KEYDOWN`和`WM_KEYUP`来说。

- `wParam`参数包含虚拟键码，用于确定哪个键被按下或释放。
- `lParam参数`是击键消息的一些附加信息，包含消息的重复计数、扫描码、扩展键标志、状态描述码、先前键状态标志、转换状态标志等，程序通常不需要关心这些附加信息。

lParam附加信息说明：

- 0～15当前消息的重复计数，也就是由于用户按住键不放而自动重复击键的次数。对于`WM_KEYUP`和`WM_SYSKEYUP`消息，重复计数始终为1
- 16～23扫描码。扫描码是与具体键盘设备相关的，其值取决于具体的键盘设备，因此程序通常会忽略扫描码，而使用与设备无关的虚拟键码
- 24扩展键标志，如果是扩展键，则值为1，否则为0。对于扩展的101键和102键键盘，扩展键是键盘右侧的Alt和Ctrl，InsDel HomeEnd- PageUp- PageDown和数字小键盘中的箭头键，NumLock键，Break(Ctrl + Pause)键，PrintScrn键，以及数字键盘中的/和Enter键。程序通常忽略扩展键标志
- 25～28保留
- 29状态描述码。状态描述码表示在生成击键消息时Alt键是否已按下。如果Alt键已按下，则该位为1;如果Alt键已释放，则该位为0。对于WM_KEYDOWN和WM_KEYUP消息该位始终为0，对于
  WM_SYSKEYDOWN和WM_SYSKEYUP消息该位始终为1
- 30键先前状态标志。如果在发送消息之前键是按下的，则值为1;如果键是抬起的，则值为0。对于WM_KEYUP和WM_SYSKEYUP消息该位始终为1，对于WM_KEYDOWN和WM_SYSKEYDOWN消息该位始终为0
- 31转换状态标志。转换状态标志表示是因为按下按键还是释放按键而产生的击键消息，对于WM_KEYDOWN和WM_SYSKEYDOWN消息该位始终为0，对于WM_KEYUP和WM_SYSKEYUP消息该位始终为1

:::

### 虚拟键码

如果是针对`WM_KEYDOWN` 消息进行处理，我们比较想知道用户是不是按下了某个键盘上的按键，就需要我们去匹配虚拟键码了。实际上开发，比较常用的是下表列举的虚拟键码。



|   虚拟键码    |  数值  |      含义      |
| :-----------: | :----: | :------------: |
|  `VK_PRIOR`   | `Ox21` |    `PgUp键`    |
|   `VK_NEXT`   | `Ox22` |    `PgDn键`    |
|   `VK_END`    | `Ox23` |    `End键`     |
|   `VK_HOME`   | `Ox24` |    `Home键`    |
|   `VK_LEFT`   | `Ox25` |  `向左箭头键`  |
|    `VK_UP`    | `Ox26` |  `向上箭头键`  |
|  `VK_RIGHT`   | `Ox27` |  `向右箭头键`  |
|   `VK_DOWN`   | `Ox28` |  `向下箭头键`  |
| `VK_SNAPSHOT` | `Ox0c` | `Print Scrn键` |
|  `VK_INSERT`  | `Ox2D` |    `Ins键`     |
|  `VK_DELETE`  | `Ox2E` |    `Del键`     |

`数字键和字母键的虚拟键码就是其ASCII码`，不过通常是在`WM_CHAR`字符消息(而不是`WM_KEYDOWN`击键消息)中处理，如下表所示:



**虚拟键码数值含义**

- 0x30～0x390  0～9键
- 0x41～0x5A   A～Z 键



左Windows键和右Windows键用于打开Windows开始菜单，Application键位于右Ctrl键的左侧，它的作用相当于鼠标右键，用来激活Windows或程序中的右键菜单，如下表所示



**虚拟键码数值含义**

- VK_LWINOx5B	左Windows键
- VK_RWINOx5C   右Windows键
- VK_APPS0x5D    Application键

与数字小键盘中的键相对应的虚拟键码如表所示。



**虚拟键码数值含义**



- VK_NUMPADO～VK_NUMPAD9	0x60～Ox69	数字小键盘0～9键
- VK_MULTIPLY 0x6A    数字小键盘的 `*键`
- VK_ADD Ox6B  数字小键盘的`＋键`
- VK_SUBTRACT 0x6D 数字小键盘的 `- 键`
- VK_DECIMAL 0x6E 数字小键盘的 `. 键`
- VK_DIVIDE Ox6F 数字小键盘的 `/键`



大部分键盘只有12个功能键，不过Windows提供了24个功能键的虚拟键码，程序通常把功能键用作键盘快捷键。



**虚拟键码数值含义**

- VK_F1～VK_F24	0x70～0x87	F1～F24键
- VK_NUMLOCK 0x90 Num Lock键
- VK_SCROLL 0x91  Scroll Lock键



:::tip 说一句鼠标按键的虚拟键码



有关鼠标按钮的虚拟键码如下表所示，但是请注意，击键消息中不会有鼠标按钮的虚拟键码，鼠标按钮的虚拟键码在对应的`鼠标消息`中才可以使用！！！



- VK_LBUTTON	0x01  鼠标左键
- VK_RBUTTON   0x02  鼠标右键
- VK_MBUTTON   0x04 鼠标中键

:::



:::details 非系统击键消息 通过操作键盘让滚动条滚动

```c{288-316}
#include <Windows.h>
#include <tchar.h>
struct
{
    int     m_nIndex;
    PCTSTR   m_pLabel;
    PCTSTR   m_pDesc;
}METRICS[] = {
    SM_CXSCREEN,                    TEXT("SM_CXSCREEN"),                    TEXT("屏幕的宽度"),
    SM_CYSCREEN,                    TEXT("SM_CYSCREEN"),                    TEXT("屏幕的高度"),
    SM_CXFULLSCREEN,                TEXT("SM_CXFULLSCREEN"),                TEXT("全屏窗口的客户区宽度"),
    SM_CYFULLSCREEN,                TEXT("SM_CYFULLSCREEN"),                TEXT("全屏窗口的客户区高度"),
    SM_ARRANGE,                     TEXT("SM_ARRANGE"),                     TEXT("如何排列最小化窗口"),
    SM_CLEANBOOT,                   TEXT("SM_CLEANBOOT"),                   TEXT("系统启动方式"),
    SM_CMONITORS,                   TEXT("SM_CMONITORS"),                   TEXT("监视器的数量"),
    SM_CMOUSEBUTTONS,               TEXT("SM_CMOUSEBUTTONS"),               TEXT("鼠标上的按钮数"),
    SM_CXBORDER,                    TEXT("SM_CXBORDER"),                    TEXT("窗口边框的宽度"),
    SM_CYBORDER,                    TEXT("SM_CYBORDER"),                    TEXT("窗口边框的高度"),
    SM_CXCURSOR,                    TEXT("SM_CXCURSOR"),                    TEXT("光标的宽度"),
    SM_CYCURSOR,                    TEXT("SM_CYCURSOR"),                    TEXT("光标的高度"),
    SM_CXDLGFRAME,                  TEXT("SM_CXDLGFRAME"),                  TEXT("同SM_CXFIXEDFRAME，有标题但不可调整大小的窗口边框的宽度"),
    SM_CYDLGFRAME,                  TEXT("SM_CYDLGFRAME"),                  TEXT("同SM_CYFIXEDFRAME，有标题但不可调整大小的窗口边框的高度"),
    SM_CXDOUBLECLK,                 TEXT("SM_CXDOUBLECLK"),                 TEXT("鼠标双击事件两次点击的X坐标不可以超过这个值"),
    SM_CYDOUBLECLK,                 TEXT("SM_CYDOUBLECLK"),                 TEXT("鼠标双击事件两次点击的Y坐标不可以超过这个值"),
    SM_CXDRAG,                      TEXT("SM_CXDRAG"),                      TEXT("拖动操作开始之前，鼠标指针可以移动的鼠标下方点的任意一侧的像素数"),
    SM_CYDRAG,                      TEXT("SM_CYDRAG"),                      TEXT("拖动操作开始之前，鼠标指针可以移动的鼠标下移点上方和下方的像素数"),
    SM_CXEDGE,                      TEXT("SM_CXEDGE"),                      TEXT("三维边框的宽度"),
    SM_CYEDGE,                      TEXT("SM_CYEDGE"),                      TEXT("三维边框的高度"),
    SM_CXFIXEDFRAME,                TEXT("SM_CXFIXEDFRAME"),                TEXT("同SM_CXDLGFRAME，有标题但不可调整大小的窗口边框的宽度"),
    SM_CYFIXEDFRAME,                TEXT("SM_CYFIXEDFRAME"),                TEXT("同SM_CYDLGFRAME，有标题但不可调整大小的窗口边框的高度"),
    SM_CXFOCUSBORDER,               TEXT("SM_CXFOCUSBORDER"),               TEXT("DrawFocusRect绘制的焦点矩形的左边缘和右边缘的宽度"),
    SM_CYFOCUSBORDER,               TEXT("SM_CYFOCUSBORDER"),               TEXT("DrawFocusRect绘制的焦点矩形的上边缘和下边缘的高度"),
    SM_CXFRAME,                     TEXT("SM_CXFRAME"),                     TEXT("同SM_CXSIZEFRAME，可调大小窗口边框的宽度"),
    SM_CYFRAME,                     TEXT("SM_CYFRAME"),                     TEXT("同SM_CYSIZEFRAME，可调大小窗口边框的高度"),
    SM_CXHSCROLL,                   TEXT("SM_CXHSCROLL"),                   TEXT("水平滚动条中箭头位图的宽度"),
    SM_CYHSCROLL,                   TEXT("SM_CYHSCROLL"),                   TEXT("水平滚动条中箭头位图的高度"),
    SM_CXVSCROLL,                   TEXT("SM_CXVSCROLL"),                   TEXT("垂直滚动条中箭头位图的宽度"),
    SM_CYVSCROLL,                   TEXT("SM_CYVSCROLL"),                   TEXT("垂直滚动条中箭头位图的高度"),
    SM_CXHTHUMB,                    TEXT("SM_CXHTHUMB"),                    TEXT("水平滚动条中滚动框(滑块)的高度"),
    SM_CYVTHUMB,                    TEXT("SM_CYVTHUMB"),                    TEXT("垂直滚动条中滚动框(滑块)的宽度"),
    SM_CXICON,                      TEXT("SM_CXICON"),                      TEXT("图标的默认宽度"),
    SM_CYICON,                      TEXT("SM_CYICON"),                      TEXT("图标的默认高度"),
    SM_CXICONSPACING,               TEXT("SM_CXICONSPACING"),               TEXT("大图标视图中项目的网格单元格宽度"),
    SM_CYICONSPACING,               TEXT("SM_CYICONSPACING"),               TEXT("大图标视图中项目的网格单元格高度"),
    SM_CXMAXIMIZED,                 TEXT("SM_CXMAXIMIZED"),                 TEXT("最大化顶层窗口的默认宽度"),
    SM_CYMAXIMIZED,                 TEXT("SM_CYMAXIMIZED"),                 TEXT("最大化顶层窗口的默认高度"),
    SM_CXMAXTRACK,                  TEXT("SM_CXMAXTRACK"),                  TEXT("具有标题和大小调整边框的窗口可以拖动的最大宽度"),
    SM_CYMAXTRACK,                  TEXT("SM_CYMAXTRACK"),                  TEXT("具有标题和大小调整边框的窗口可以拖动的最大高度"),
    SM_CXMENUCHECK,                 TEXT("SM_CXMENUCHECK"),                 TEXT("菜单项前面复选框位图的宽度"),
    SM_CYMENUCHECK,                 TEXT("SM_CYMENUCHECK"),                 TEXT("菜单项前面复选框位图的高度"),
    SM_CXMENUSIZE,                  TEXT("SM_CXMENUSIZE"),                  TEXT("菜单栏按钮的宽度"),
    SM_CYMENUSIZE,                  TEXT("SM_CYMENUSIZE"),                  TEXT("菜单栏按钮的高度"),
    SM_CXMIN,                       TEXT("SM_CXMIN"),                       TEXT("窗口的最小宽度"),
    SM_CYMIN,                       TEXT("SM_CYMIN"),                       TEXT("窗口的最小高度"),
    SM_CXMINIMIZED,                 TEXT("SM_CXMINIMIZED"),                 TEXT("最小化窗口的宽度"),
    SM_CYMINIMIZED,                 TEXT("SM_CYMINIMIZED"),                 TEXT("最小化窗口的高度"),
    SM_CXMINSPACING,                TEXT("SM_CXMINSPACING"),                TEXT("最小化窗口的网格单元宽度"),
    SM_CYMINSPACING,                TEXT("SM_CYMINSPACING"),                TEXT("最小化窗口的网格单元高度"),
    SM_CXMINTRACK,                  TEXT("SM_CXMINTRACK"),                  TEXT("窗口的最小拖动宽度，用户无法将窗口拖动到小于这些尺寸"),
    SM_CYMINTRACK,                  TEXT("SM_CYMINTRACK"),                  TEXT("窗口的最小拖动高度，用户无法将窗口拖动到小于这些尺寸"),
    SM_CXPADDEDBORDER,              TEXT("SM_CXPADDEDBORDER"),              TEXT("标题窗口的边框填充量"),
    SM_CXSIZE,                      TEXT("SM_CXSIZE"),                      TEXT("窗口标题或标题栏中按钮的宽度"),
    SM_CYSIZE,                      TEXT("SM_CYSIZE"),                      TEXT("窗口标题或标题栏中按钮的高度"),
    SM_CXSIZEFRAME,                 TEXT("SM_CXSIZEFRAME"),                 TEXT("同SM_CXFRAME，可调大小窗口边框的宽度"),
    SM_CYSIZEFRAME,                 TEXT("SM_CYSIZEFRAME"),                 TEXT("同SM_CYFRAME，可调大小窗口边框的厚度"),
    SM_CXSMICON,                    TEXT("SM_CXSMICON"),                    TEXT("小图标的建议宽度"),
    SM_CYSMICON,                    TEXT("SM_CYSMICON"),                    TEXT("小图标的建议高度"),
    SM_CXSMSIZE,                    TEXT("SM_CXSMSIZE"),                    TEXT("小标题按钮的宽度"),
    SM_CYSMSIZE,                    TEXT("SM_CYSMSIZE"),                    TEXT("小标题按钮的高度"),
    SM_CXVIRTUALSCREEN,             TEXT("SM_CXVIRTUALSCREEN"),             TEXT("虚拟屏幕的宽度"),
    SM_CYVIRTUALSCREEN,             TEXT("SM_CYVIRTUALSCREEN"),             TEXT("虚拟屏幕的高度"),
    SM_CYCAPTION,                   TEXT("SM_CYCAPTION"),                   TEXT("标题区域的高度"),
    SM_CYKANJIWINDOW,               TEXT("SM_CYKANJIWINDOW"),               TEXT("屏幕底部的日文汉字窗口的高度"),
    SM_CYMENU,                      TEXT("SM_CYMENU"),                      TEXT("单行菜单栏的高度"),
    SM_CYSMCAPTION,                 TEXT("SM_CYSMCAPTION"),                 TEXT("小标题的高度"),
    SM_DBCSENABLED,                 TEXT("SM_DBCSENABLED"),                 TEXT("User32.dll是否支持DBCS"),
    SM_DEBUG,                       TEXT("SM_DEBUG"),                       TEXT("是否安装了User.exe的调试版本"),
    SM_DIGITIZER,                   TEXT("SM_DIGITIZER"),                   TEXT("设备支持的数字转换器输入类型"),
    SM_IMMENABLED,                  TEXT("SM_IMMENABLED"),                  TEXT("是否启用了输入法管理器／输入法编辑器功能"),
    SM_MAXIMUMTOUCHES,              TEXT("SM_MAXIMUMTOUCHES"),              TEXT("系统中是否有数字化仪"),
    SM_MEDIACENTER,                 TEXT("SM_MEDIACENTER"),                 TEXT("当前操作系统是不是Windows XP Media Center"),
    SM_MENUDROPALIGNMENT,           TEXT("SM_MENUDROPALIGNMENT"),           TEXT("下拉菜单是否与相应的菜单栏项右对齐"),
    SM_MIDEASTENABLED,              TEXT("SM_MIDEASTENABLED"),              TEXT("系统是否启用希伯来语和阿拉伯语"),
    SM_MOUSEHORIZONTALWHEELPRESENT, TEXT("SM_MOUSEHORIZONTALWHEELPRESENT"), TEXT("是否安装了带有水平滚轮的鼠标"),
    SM_MOUSEPRESENT,                TEXT("SM_MOUSEPRESENT"),                TEXT("是否安装了鼠标"),
    SM_MOUSEWHEELPRESENT,           TEXT("SM_MOUSEWHEELPRESENT"),           TEXT("是否安装了带有垂直滚轮的鼠标"),
    SM_NETWORK,                     TEXT("SM_NETWORK"),                     TEXT("是否存在网络"),
    SM_PENWINDOWS,                  TEXT("SM_PENWINDOWS"),                  TEXT("是否安装了Microsoft Windows for Pen Computing扩展"),
    SM_REMOTECONTROL,               TEXT("SM_REMOTECONTROL"),               TEXT("当前终端服务器会话是否被远程控制"),
    SM_REMOTESESSION,               TEXT("SM_REMOTESESSION"),               TEXT("调用进程是否与终端服务客户机会话关联"),
    SM_SAMEDISPLAYFORMAT,           TEXT("SM_SAMEDISPLAYFORMAT"),           TEXT("所有显示器的颜色格式是否相同"),
    SM_SECURE,                      TEXT("SM_SECURE"),                      TEXT("始终返回0"),
    SM_SERVERR2,                    TEXT("SM_SERVERR2"),                    TEXT("系统是否是Windows Server 2003 R2"),
    SM_SHOWSOUNDS,                  TEXT("SM_SHOWSOUNDS"),                  TEXT("用户是否要求应用程序在其他情况下以可视方式呈现信息"),
    SM_SHUTTINGDOWN,                TEXT("SM_SHUTTINGDOWN"),                TEXT("当前会话是否正在关闭"),
    SM_SLOWMACHINE,                 TEXT("SM_SLOWMACHINE"),                 TEXT("计算机是否具有低端(慢速)处理器"),
    SM_STARTER,                     TEXT("SM_STARTER"),                     TEXT("当前操作系统版本"),
    SM_SWAPBUTTON,                  TEXT("SM_SWAPBUTTON"),                  TEXT("鼠标左键和右键的功能是否互换了"),
    SM_TABLETPC,                    TEXT("SM_TABLETPC"),                    TEXT("是否启动了Tablet PC输入服务"),
    SM_XVIRTUALSCREEN,              TEXT("SM_XVIRTUALSCREEN"),              TEXT("虚拟屏幕左侧的坐标"),
    SM_YVIRTUALSCREEN,              TEXT("SM_YVIRTUALSCREEN"),              TEXT("虚拟屏幕顶部的坐标")
};
const int NUMLINES = sizeof(METRICS) / sizeof(METRICS[0]);
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;                          
    TCHAR szClassName[] = TEXT("MyWindow");       
    TCHAR szAppName[] = TEXT("GetSystemMetrics");  
    HWND hwnd;                                   
    MSG msg;                                      
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW | WS_VSCROLL | WS_HSCROLL,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    TEXTMETRIC tm;
    SCROLLINFO si;
    HFONT hFont, hFontOld;
    static int s_iCol1, s_iCol2, s_iCol3, s_iHeight;
    static int s_cxClient, s_cyClient;              
    static int s_cxChar;                            
    int iVertPos, iHorzPos;
    RECT rect = { 0 };
    SIZE size = { 0 };
    int x, y;
    TCHAR szBuf[10];
    int nPaintBeg, nPaintEnd;                       
    UINT uiScrollLines;
    static int iDistancePerLine;                    // 滚动一行所需距离
    static int iDistanceScroll;                     // 本次处理WM_MOUSEWHEEL消息需要滚动多少距离
    switch (uMsg)
    {
    case WM_CREATE:
        hdc = GetDC(hwnd);
        hFont = CreateFont(12, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("宋体"));
        hFontOld = (HFONT)SelectObject(hdc, hFont);
        for (int i = 0; i < NUMLINES; i++)
        {
            GetTextExtentPoint32(hdc, METRICS[i].m_pLabel, _tcslen(METRICS[i].m_pLabel), &size);
            if (size.cx > s_iCol1)
                s_iCol1 = size.cx;
            GetTextExtentPoint32(hdc, METRICS[i].m_pDesc, _tcslen(METRICS[i].m_pDesc), &size);
            if (size.cx > s_iCol2)
                s_iCol2 = size.cx;
            GetTextExtentPoint32(hdc, szBuf,
                wsprintf(szBuf, TEXT("%d"), GetSystemMetrics(METRICS[i].m_nIndex)), &size);
            if (size.cx > s_iCol3)
                s_iCol3 = size.cx;
        }
        s_iHeight = size.cy + 2;
        GetTextMetrics(hdc, &tm);
        s_cxChar = tm.tmAveCharWidth;

        GetClientRect(hwnd, &rect);
        rect.right = s_iCol1 + s_iCol2 + s_iCol3 + GetSystemMetrics(SM_CXVSCROLL);
        AdjustWindowRectEx(&rect, GetWindowLongPtr(hwnd, GWL_STYLE),
            GetMenu(hwnd) != NULL, GetWindowLongPtr(hwnd, GWL_EXSTYLE));
        MoveWindow(hwnd, 0, 0, rect.right - rect.left, rect.bottom - rect.top, TRUE);
        SetWindowPos(hwnd, NULL, 0, 0, rect.right - rect.left, rect.bottom - rect.top,
            SWP_NOZORDER | SWP_NOMOVE);

        SelectObject(hdc, hFontOld);
        DeleteObject(hFont);
        ReleaseDC(hwnd, hdc);
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &uiScrollLines, 0);
        if (uiScrollLines != 0)
            iDistancePerLine = WHEEL_DELTA / uiScrollLines;
        else
            iDistancePerLine = 0;
        return 0;

    case WM_SIZE:
     
        s_cxClient = LOWORD(lParam);
        s_cyClient = HIWORD(lParam);
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_RANGE | SIF_PAGE;
        si.nMin = 0;
        si.nMax = NUMLINES - 1;
        si.nPage = s_cyClient / s_iHeight;
        SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_RANGE | SIF_PAGE;
        si.nMin = 0;
        si.nMax = (s_iCol1 + s_iCol2 + s_iCol3) / s_cxChar - 1;
        si.nPage = s_cxClient / s_cxChar;
        SetScrollInfo(hwnd, SB_HORZ, &si, TRUE);
        return 0;
    case WM_VSCROLL:
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_ALL;
        GetScrollInfo(hwnd, SB_VERT, &si);
        iVertPos = si.nPos;
        switch (LOWORD(wParam))
        {
        case SB_LINEUP:
            si.nPos -= 1;
            break;
        case SB_LINEDOWN:
            si.nPos += 1;
            break;
        case SB_PAGEUP:
            si.nPos -= si.nPage;
            break;
        case SB_PAGEDOWN:
            si.nPos += si.nPage;
            break;
        case SB_THUMBTRACK:
            si.nPos = si.nTrackPos;
            break;
        case SB_TOP:
            si.nPos = 0;
            break;
        case SB_BOTTOM:
            si.nPos = NUMLINES - 1;
            break;
        }
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_POS;
        SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
        GetScrollInfo(hwnd, SB_VERT, &si);
        if (iVertPos != si.nPos)
        {
            ScrollWindow(hwnd, 0, s_iHeight * (iVertPos - si.nPos), NULL, NULL);
            UpdateWindow(hwnd);
        }
        return 0;

    case WM_HSCROLL:
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_ALL;
        GetScrollInfo(hwnd, SB_HORZ, &si);
        iHorzPos = si.nPos;
        switch (LOWORD(wParam))
        {
        case SB_LINELEFT:
            si.nPos -= 1;
            break;
        case SB_LINERIGHT:
            si.nPos += 1;
            break;
        case SB_PAGELEFT:
            si.nPos -= si.nPage;
            break;
        case SB_PAGERIGHT:
            si.nPos += si.nPage;
            break;
        case SB_THUMBTRACK:
            si.nPos = si.nTrackPos;
            break;
        }
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_POS;
        SetScrollInfo(hwnd, SB_HORZ, &si, TRUE);
        GetScrollInfo(hwnd, SB_HORZ, &si);
        if (iHorzPos != si.nPos)
        {
            ScrollWindow(hwnd, s_cxChar * (iHorzPos - si.nPos), 0, NULL, NULL);
            UpdateWindow(hwnd);
        }
        return 0;

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_UP:     // 向上箭头键
            SendMessage(hwnd, WM_VSCROLL, SB_LINEUP, 0);
            break;
        case VK_DOWN:   // 向下箭头键
            SendMessage(hwnd, WM_VSCROLL, SB_LINEDOWN, 0);
            break;
        case VK_PRIOR:  // PageUp键
            SendMessage(hwnd, WM_VSCROLL, SB_PAGEUP, 0);
            break;
        case VK_NEXT:   // PageDown键
            SendMessage(hwnd, WM_VSCROLL, SB_PAGEDOWN, 0);
            break;
        case VK_HOME:   // Home键(或者Fn + PageUp键)
            SendMessage(hwnd, WM_VSCROLL, SB_TOP, 0);
            break;
        case VK_END:    // End键(或者Fn + PageDown键)
            SendMessage(hwnd, WM_VSCROLL, SB_BOTTOM, 0);
            break;

        case VK_LEFT:   // 左箭头键
            SendMessage(hwnd, WM_HSCROLL, SB_LINELEFT, 0);
            break;
        case VK_RIGHT:  // 右箭头键
            SendMessage(hwnd, WM_HSCROLL, SB_LINERIGHT, 0);
            break;
        }
        return 0;
    case WM_MOUSEWHEEL:
        if (iDistancePerLine == 0)
            return 0;
        iDistanceScroll += GET_WHEEL_DELTA_WPARAM(wParam);
        // GET_WHEEL_DELTA_WPARAM(wParam)是正数，滚轮向前旋转，远离用户，向上滚动
        while (iDistanceScroll >= iDistancePerLine)
        {
            SendMessage(hwnd, WM_VSCROLL, SB_LINEUP, 0);
            iDistanceScroll -= iDistancePerLine;
        }
        // GET_WHEEL_DELTA_WPARAM(wParam)是负数，滚轮向后旋转，朝向用户，向下滚动
        while (iDistanceScroll <= -iDistancePerLine)
        {
            SendMessage(hwnd, WM_VSCROLL, SB_LINEDOWN, 0);
            iDistanceScroll += iDistancePerLine;
        }
        return 0;
    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_POS | SIF_PAGE;
        GetScrollInfo(hwnd, SB_VERT, &si);
        iVertPos = si.nPos;
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_POS;
        GetScrollInfo(hwnd, SB_HORZ, &si);
        iHorzPos = si.nPos;
        SetBkMode(hdc, TRANSPARENT);
        hFont = CreateFont(12, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("宋体"));
        hFontOld = (HFONT)SelectObject(hdc, hFont);
        nPaintBeg = max(0, iVertPos + ps.rcPaint.top / s_iHeight);
        nPaintEnd = min(NUMLINES - 1, iVertPos + ps.rcPaint.bottom / s_iHeight);
        for (int i = nPaintBeg; i <= nPaintEnd; i++)
        {
            x = s_cxChar * (-iHorzPos);
            y = s_iHeight * (i - iVertPos);
            TextOut(hdc, x, y, METRICS[i].m_pLabel, _tcslen(METRICS[i].m_pLabel));
            TextOut(hdc, x + s_iCol1, y, METRICS[i].m_pDesc, _tcslen(METRICS[i].m_pDesc));
            TextOut(hdc, x + s_iCol1 + s_iCol2, y, szBuf,
                wsprintf(szBuf, TEXT("%d"), GetSystemMetrics(METRICS[i].m_nIndex)));
        }
        SelectObject(hdc, hFontOld);
        DeleteObject(hFont);
        EndPaint(hwnd, &ps);
        return 0;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

我们把每一个WM_KEYDOWN消息转换为等同的WM_VSCROLL或WM_HSCROLL消息，这是通过给窗口过程发送假冒的WM_VSCROLL或WM_HSCROLL消息来欺骗WindowProc窗口过程实现的，使它认为收到了滚动条消息，这就避免了在WM_KEYDOWN和WM_VSCROLL或WM_HSCROLL消息中存在两份相同的滚动条处理代码。

:::



`SendMessage()`函数使用频率非常高。



:::details `SendMessage 函数说明`

`SendMessage()`函数用于向一个窗口发送消息，不仅可以发送给自己的窗口，还可以发送给其他程序窗口，前提是只要获得了它们的窗口句柄。

```c
/// <summary>
/// 向一个窗口发送消息
/// </summary>
/// <param name="hWnd">要向哪个窗口发送消息，hWnd窗口的窗口过程将接收该消息</param>
/// <param name="Msg">消息类型ID</param>
/// <param name="wParam">消息的wParam参数</param>
/// <param name="lParam">消息的IParam参数</param>
/// <returns></returns>
LRESULT WINAPI SendMessage(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam );
```

如果将`hWnd`参数指定为`HWND_BROADCAST(0xFFFF)`，则会将消息发送到系统中的所有顶级窗口。我们需要根据消息类型构造wParam和lParam参数。函数的返回值是窗口过程中该消息的返回值。





注意，`SendMessage()`函数实质是去调用指定窗口的窗口过程，并且在窗口过程处理完消息之前函数不会返回，即在窗口过程处理完指定的消息以后，Windows才把控制权交还给紧跟着`SendMessage()`调用的下一条语句。阻塞型函数

:::



### 转义状态

在击键消息中，虚拟键码0x41～0x5A对应的是A～Z键，但是通常认为按下A～Z键应该是小写字母a～z，在按下字母键的同时按下了Shift键或`Caps Lock`键，才认为是大写字母A～Z。



例如下面这个代码。

```c
case WM_KEYDOWN:
    if (wParam == 'a')
    {
        MessageBox(hwnd，TEXT("小写字母a")，TEXT("提示")，MB_OK);
    }
    if (wParam == 'A')
    {
        MessageBox(hwnd,TEXT("大写字母A")，TEXT("提示")，MB_OK);
    }
return 0;
```

上面的代码，切换为英文输入法，按下A键，会弹出第二个消息框。不止这一种情况，还有其他情况，例如按下A键时，如果Ctrl键也被按下，那么就是Ctrl +A组合键。这是一个**快捷键**。



键盘快捷键通常和程序菜单一起在程序的资源脚本文件中定义，Windows会把这些键盘快捷键转换为菜单命令消息，程序不必自己去做转换(😄，为了解决菜单项太多每一次不好找到的问题。通过指定一些快捷键来一对一绑定到对应的菜单项，从而提高程序的便捷性)



- 对于产生可显示字符的击键组合，Windows在发送`WM_KEYDOWN`击键消息的同时还发送`WM_CHAR`字符消息。



- 对于有些键不产生字符，如Shift键、功能键、光标移动键等，对于这些键，Windows只产生`WM_KEYDOWN`击键消息。



针对上述的情况，我们在处理`WM_KEYDOWN`击键消息时，我们可能需要知道是否有转义键(Shift键、Ctrl键和Alt键)或切换键(CapsLock键、NumLock键和ScrollLock键)被按下。可以通过调用`GetKeyState`函数获取`WM_KEYDOWN`击键消息发生时一个按键的状态。



:::details `GetKeyState 函数说明`

```c
/// <summary>
/// 获取WM_KEYDOWN击键消息发生时一个按键的状态
/// </summary>
/// <param name="nVirtKey">nVirtKey参数指定虚拟键码</param>
/// <returns></returns>
SHORT GetKeyState(int nVirtKey)
```

返回值反映了指定按键的状态。

- 如果高位为1，则指定按键为按下状态,否则指定按键为释放状态。
- 最低位反映了指定切换键的状态。如果低位为1，则指定切换键为已切换(打开),如果低位为0，则指定切换键为未切换(未打开)。

```c
case WM_KEYDOWN:
if ((wParam == 'A' && GetKeyState(VK_SHIFT) < 0) || (wParam == 'A' && GetKeyState(VK_CAPITAL) & 1))
{
   //GetKeyState(VK_SHIFT) < 0 => 总之，可以理解成返回值是负数的时候，表示被监视的键VK_SHIFT，正在被按着不放
 
    //  GetKeyState(VK_CAPITAL) & 1 => 该值低位为1，则表示CapsLock按下
	MessageBox(hwnd，TEXT("大写字母A")，TEXT("提示")，MB_OK); 
}
return O;
```

通常使用虚拟键码VK_SHIFT VK_CONTROLL和VK_MENU来调用`GetKeyState()`函数。



也可以使用虚拟键码`VK_LSHIFT`  ` VK_RSHIFT`  `VK_LCONTROL`  `VK_RCONTROL`  `VK_LMENU` 或 `VK_RMENU`来调用`GetKeyState()`函数，用于确定是左侧还是右侧的Shift键、Ctrl键或Alt键被按下。



:::





注意，`GetKeyState()`函数并非实时检测键盘状态，它只是反映了到目前为止的键盘状态，用于确定击键消息发生时一个按键的状态。假设需要确定用户是否按下了`Shift + Tab`组合键，可以在处理Tab键的WM_KEYDOWN消息时，调用包含VK_SHIFT参数的`GetKeyState()`函数。如果`GetKeyState`函数的返回值是负的，就可以确定在按下Tab键之前已经按下了Shift键。





如果需要确定某个按键的实时状态，可以使用`GetAsyncKeyState()`函数,即也就是我想在不是击键消息`WM_KEYDOWN`的其他地方也要实时监测到键盘状态。实际开发中,这个函数适用性更广，优先级更高。



:::details `GetAsyncKeyState 函数说明`

```c
/// <summary>
/// 确定某个按键的实时状态
/// </summary>
/// <param name="vKey">虚拟键码</param>
/// <returns></returns>
SHORT GetAsyncKeyState(int vKey)
```

在实际开发中，我们要根据这个函数定义一个宏`KEY_DOWN`，这样可以方便以后的调用。

```c
//VK_NONAME - 表示这个键盘上按键的虚拟键码
#define KEY_DOWN(VK_NONAME) ((GetAsyncKeyState(VK_NONAME) & 0x8000) ? 1:0)
```

常用的虚拟键码清单，即`VK_NONAME` 的取值为下列之一。本人实际开发用过`VK_LBUTTON`

```c
常量名				   对应按键						取值
—————————————————————————————————————————————————————————
VK_LBUTTON             鼠标左键                      0x01
VK_RBUTTON             鼠标右键                      0x02
VK_CANCEL              Ctrl + Break                  0x03
VK_MBUTTON             鼠标中键                      0x04
VK_BACK                Backspace 键       		     0x08
VK_TAB                 Tab 键                        0x09
VK_RETURN              回车键                        0x0D
VK_SHIFT               Shift 键                      0x10
VK_CONTROL             Ctrl 键                       0x11
VK_MENU                Alt 键                        0x12
VK_PAUSE               Pause 键                      0x13
VK_CAPITAL             Caps Lock 键                  0x14
VK_ESCAPE              Esc 键                        0x1B
VK_SPACE               空格键         				 0x20
VK_PRIOR               Page Up 键                    0x21
VK_NEXT                Page Down 键                  0x22
VK_END                 End 键                        0x23
VK_HOME                Home 键                       0x24
VK_LEFT                左箭头键                      0x25
VK_UP                  上箭头键                      0x26
VK_RIGHT               右箭头键                      0x27
VK_DOWN                下箭头键                      0x28
VK_SNAPSHOT            Print Screen 键               0x2C
VK_Insert              Insert 键                     0x2D
VK_Delete              Delete 键                     0x2E
'0' – '9'              数字 0 - 9             0x30 - 0x39
'A' – 'Z'              字母 A - Z             0x41 - 0x5A
VK_LWIN                左WinKey(104键盘才有)         0x5B
VK_RWIN                右WinKey(104键盘才有)         0x5C
VK_APPS                AppsKey(104键盘才有)          0x5D
VK_NUMPAD0            小键盘 0 键                    0x60
VK_NUMPAD1            小键盘 1 键                    0x61
VK_NUMPAD2            小键盘 2 键                    0x62
VK_NUMPAD3            小键盘 3 键                    0x63
VK_NUMPAD4            小键盘 4 键                    0x64
VK_NUMPAD5            小键盘 5 键                    0x65
VK_NUMPAD6            小键盘 6 键                    0x66
VK_NUMPAD7            小键盘 7 键                    0x67
VK_NUMPAD8            小键盘 8 键                    0x68
VK_NUMPAD9            小键盘 9 键                    0x69
VK_F1 - VK_F24        功能键F1 – F24          0x70 - 0x87
VK_NUMLOCK            Num Lock 键                   0x90
VK_SCROLL             Scroll Lock 键                0x91
```



:::









