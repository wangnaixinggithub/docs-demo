# 通用对话框

通用对话框库包含一组用于执行常见应用程序任务的对话框，例如打开文件、选择颜色和打印文档等，通用对话框实现了应用程序用户界面的一致性，例如单击不同程序的文件菜单下的打开文件子菜单项，通常都会弹出相同的打开文件对话框。要弹出打开文件、选择颜色和打印文档等通用对话框用的是不同的函数，在使用这些函数时，基本上都要初始化一个结构的一些字段并将该结构的指针传递给这些函数。函数会创建并显示相应的对话框，当用户关闭对话框时，函数将控制权返还给程序，然后程序可以从先前传递给函数的结构中获取需要的信息。





常见的通用对话框以及创建通用对话框所需的函数和所用结构如下表所示。





| 函数名            | 结构           | 含义                                                         |
| ----------------- | -------------- | ------------------------------------------------------------ |
| `GetOpenFileName` | `OPENFILENAME` | 打开文件用户可以在对话框中输入或选择要打开的文件名，还包括一个文件扩展名列表以过滤显示的文件名 |
| `GetSaveFileName` | `OPENFILENAME` | 保存文件用户可以在对话框中输入或选择用于保存的文件名，还包括一个文件扩展名列表以过滤显示的文件名 |
| `FindText`        | `FINDREPLACE`  | 查找用户可以在对话框中输入要查找的字符串，还可以指定搜索选项，例如搜索方向以及是否区分大小写 |
| `ReplaceText`     | `FINDREPLACE`  | 替换用户可以在对话框中输入要查找的字符串和替换字符串，还可以指定搜索选项，例如是否区分大小写以及替换选项 |
| `ChooseFont`      | `CHOOSEFONT`   | 选择字体用户可以在对话框的字体列表中选择一个字体及其样式、磅值和其他字体属性，例如字体颜色、下划线、删除线 |
| `ChooseColor`     | `CHOOSECOLOR`  | 选择颜色用户可以选择基本颜色或自定义颜色                     |
| `PageSetupDlg`    | `PAGESETUPDLG` | 页面设置用户可以选择页面配置选项，例如纸张方向、大小、来源和边距 |
| `PrintDlg`        | `PRINTDLG`     | 打印显示已安装的打印机及其配置信息，用户可以选择打印作业选项，例如要打印的页面范围和份数，然后开始打印过程 |
|                   |                |                                                              |



:::tip


除“查找"和“替换"对话框以外，其他通用对话框都是模态的。“查找"和"替换"对话框则是非模态对话框，如果使用"查找"和"替换"对话框，还应该在程序的主消息循环中使用lsDialogMessage函数，以确保"查找"和"替换"对话框正确处理键盘输入（例如Tab和Esc键)。

:::



## 通用窗口打开/保存文件



:::details `GetOpenFileName() 函数说明`

```c
// <summary>
/// 打开/保存文件
/// </summary>
/// <param name="lpofn">参数lpofn是一个指向OPENFILENAME结构的指针，调用`GetOpenFileName()`函数前需要初始化该结构的一些字段，当函数返回时会填充该结构的相关字段，结构中包含用户所选择文件的信息。</param>
/// <returns>如果用户输入或选择了一个文件名并单击“打开"按钮，则函数返回值为TRUE。`OPENFILENAME`结构的`lpstrFile`字段指向的缓冲区包含用户选择的文件名(绝对路径)﹔如果用户单击了“取消"按钮或关闭了对话框或发生错误，则返回值为FALSE</returns>
BOOL WINAPI GetOpenFileName(_Inout_ LPOPENFILENAME lpofn)
```

`GetOpenFileName()`函数只是返回用户所选择文件名的信息，至于如何打开这个文件并读写文件内容，还需要用户自己写代码去操作，例如记事本程序在用户单击打开菜单以后会调用`GetOpenFileName()`函数获取到文件的绝对路径，然后额外写代码打开这个文本文件，读取文本内容并显示到多行编辑控件中。





OPENFILENAME 结构定义:

```c
typedef struct tagOFN {
	DWORD lStructSize; //该结构的大小
    HWND hwndOwner; //对话框的拥有者窗口句柄
	HINSTANCE hInstance; //用于自定义对话框，指定包含对话框模板的模块句柄
    LPCTSTR lpstrFilter;//文件扩展名过滤字符串
	LPTSTR lpstrCustomFilter; 
	DWORD nMaxCustFilter;
	DWORD nFilterIndex; //过滤器索引（从1开始)，设置为1表示默认显示第1个过滤器
	LPTSTR lpstrFile; //返回用户所选择的文件名(完整路径)的缓冲区
    DWORD nMaxFile;  //缓冲区的大小，以字符为单位LPTSTR
	LPCTSTR lpstrFileTitle; //返回用户所选择文件的文件名和扩展名(不包括路径)的缓冲区
	DWORD nMaxFileTitle; // lpstrFileTitle缓冲区的大小，以字符为单位
	LPCTSTR lpstrInitialDir; //初始目录字符串指针，对话框显示以后默认显示的目录
    LPCTSTR lpstrTitle; //在对话框标题栏中显示的字符串
	DWORD Flags; //标志位	
	DWORD nFileOffset; // lpstrFile指向的字符串中的文件名部分从0开始的字符偏移量
	DWORD nFileExtension; // lpstrFile指向的字符串中的扩展名部分从0开始的字符偏移量
	LPCTSTR lpstrDefExt;	//默认扩展名字符串
    LPARAM ICustData;
    LPOFNHOOKPROC lpfnHook;
	LPCTSTR lpTemplateName; //自定义对话框模板名称void*pvReserved;
	DWORD dwReserved;
    DWORD FlagsEx;
}OPENFILENAME，*LPOPENFILENAME;
```

常用的字段解释如下

- lStructSize字段指定该结构的大小。
- hwndOwner字段指定对话框的拥有者窗口句柄。
- lpstrFilter字段指定文件扩展名过滤字符串列表，显示在对话框右下角的文件类型组合框中。每一项由两个字符串组成。第1个字符串是过滤器描述字符串，例如"文本文件`"(*.txt)\0"`;第2个字符串指定过滤器模式，例如`"*.txt\0"`。要为一项指定多个过滤器模式，需要使用分号分隔过滤器模式，例如`"*.txt;*.doc;*.docx\0"`，不要在过滤器模式字符串中包含空格。文件扩展名过滤字符串列表的最后一个字符串必须以两个空字符结束。如果lpstrFilter字段为NULL，则对话框不显示任何过滤器，此时可以选择任何扩展名的文件。下面的文件扩展名过滤字符串列表定义了两项

```c
ofn.lpstrFilter = TEXT("文本文件(*.txt, *.doc, *.docx)\0*.txt;*.doc;*.docx\0All(*.*)\0*.*\0");
```

用`""`定义的字符串结尾会自动添加一个`"\0"`，因此双引号内部最后一个字符串后面只需要一个`"\0"`。

- 文件扩展名过滤字符串列表的每一项都有一个索引，从1开始，nFilterlndex字段指定默认显示哪一项，例如设置为1表示默认显示第1个过滤器。`GetOpenFileName()`函数返回后，nFilterIndex字段被设置为用户选择的过滤器的索引。
- lpstrFile字段是返回用户所选择文件名(完整路径)的缓冲区，该缓冲区也用于初始化对话框中编辑控件所显示的文件名。如果不需要初始化，则缓冲区的第1个字符必须设置为NULL.
-   如果Flags字段指定了`OFN_ALLOWMULTISELECT`标志并且用户选择了多个文件，则缓冲区包含当前目录，后跟所有所选文件的文件名。对于资源管理器样式的对话框，目录和每个文件名字符串以NULL分隔，在最后一个文件名后面有一个额外的NULL字符。如果缓冲区太小，则函数返回FALSE，调用`CommDlgExtendedError()`函数获取错误码会返回FNERR_BUFFERTOOSMALL。在这种情况下，lpstrFile缓冲区的前2字节包含所需的大小，以字符为单位。例如图中打开了6个文件。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240707172822827.png)



目录名末尾通常没有`"\"`字符（在根目录下选择多个文件时会包
括`"\"`字符）。如果需要把目录名和每一个文件名拼接成一个带完整路径的文件名，需要做一些处理，具体请看后面的示例程序。

- nMaxFile字段指定lpstrFile缓冲区的大小，以字符为单位。lpstrFileTitle字段是返回用户所选文件的文件名和扩展名的缓冲区。
- nMaxFileTitle字段指定lpstrFileTitle缓冲区的大小，以字符为单位。
- lpstrlnitialDir字段指定初始目录，也就是对话框显示以后默认显示的目录。
- lpstrTitle字段指定在对话框标题栏中显示的字符串。如果该字段为NULL，则系统使用默认标题（“打开"或“另存为(GetSaveFileName)") 。
- Flags字段是标志位，常用的标志如表下方所示。

|         标识宏         |                           标识含义                           |
| :--------------------: | :----------------------------------------------------------: |
|     `OFN_EXPLORER`     | 默认值，对话框使用资源管理器样式的用户界面。如果指定了OFN_ALLOWMULTISELECT多选标志，则必须指定该标志可以使用资源管理器样式的用户界面 |
|  `OFN_FILEMUSTEXIST`   | 用户只能在文件名编辑控件中输入一个已经存在的文件名，如果用户输入了一个当前所选目录中不存在的文件名，则系统会提示文件不存在，使用这个标志的时候必须同时指定OFN_PATHMUSTEXIST标志 |
|  `OFN_PATHMUSTEXIST`   |       用户只能在文件名编辑控件中输入一个已经存在的路径       |
| `OFN_ALLOWMULTISELECT` |                     用户可以选择多个文件                     |
|   `OFN_CREATEPROMPT`   | 如果用户在文件名编辑控件中输入了一个不存在的文件，系统会弹出对话框提示用户是否新建这个文件，如果用户选择了"是"按钮，对话框关闭并且函数返回所指定的名字 |
| `OFN_OVERWRITEPROMPT`  | 保存文件时，如果用户在文件名编辑控件中输入了一个已经存在的文件名，系统会提示用户是否覆盖已经存在的文件 |

- nFileOffset字段返回lpstrFile指向的字符串中的文件名部分从0开始的字符偏移量。
- nFileExtension字段返回lpstrFile指向的字符串中的扩展名部分从0开始的字符偏移量，扩展名是文件名字符串中最后一个点 (.)之后的子字符串。例如对于文件名"C:\dir1\dir2\file.ext"，nFileOffset字段返回13(file.ext)，nFileExtension字段返回18(ext)
- lpstrDefExt字段是默认扩展名字符串。如果用户没有在编辑控件中输入扩展名，则会将默认扩展名附加到文件名字符串中，扩展名字符串不需要包含点(.)。

:::





用于创建保存文件对话框的函数是 `GetSaveFileName()`



:::details `GetSaveFileName 函数说明`

```c
BOOL WINAPI GetSaveFileName(_Inout_ LPOPENFILENAME lpofn);
```

参数lpofn同样是一个指向OPENFILENAME结构的指针。

调用GetSaveFileName()函数前需要初始化该结构的一些字段，当函数返回时会填充该结构的相关字段,结构中包含用户选择的文件的信息。



如果用户输入或选择了一个文件名并单击"保存"按钮，则返回值为TRUE. 



OPENFILENAME结构的lpstrFile字段指向的缓冲区包含用户选择的文件名(完整路径);



如果用户单击了"取消"按钮或关闭了对话框或发生错误，则返回值为FALSE。



保存文件对话框让用户选择一个要保存的文件的绝对路径，函数返回所选择的文件绝对路径的信息。真的要保存文件需要程序额外书写代码。



:::



:::details `示例:`



```c
#include <windows.h>
#include <tchar.h>
#include<iostream>
#include <strsafe.h>
#include "resource.h"

#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
HINSTANCE g_hInstance;



INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    g_hInstance = hInstance;

    // 创建模态对话框
    DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_MAIN), NULL, DialogProc, NULL);

    return 0;
}

INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND hwndList;
    TCHAR szFile[MAX_PATH * 512] = { 0 };   // 返回用户选择的文件名的缓冲区大一点，本程序允许多选
    TCHAR szFileTitle[MAX_PATH] = { 0 };    // 返回用户所选文件的文件名和扩展名的缓冲区

    OPENFILENAME ofn = { 0 };
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwndDlg;
    ofn.lpstrFilter =
        TEXT("文本文件(*.txt, *.doc, *.docx)\0*.txt;*.doc;*.docx\0All(*.*)\0*.*\0");
    ofn.nFilterIndex = 1;                       // 默认选择第1个过滤器
    ofn.lpstrFile = szFile;                     // 返回用户选择的文件名的缓冲区
    ofn.lpstrFile[0] = NULL;                    // 不需要初始化文件名编辑控件
    ofn.nMaxFile = _countof(szFile);
    ofn.lpstrFileTitle = szFileTitle;	        // 返回用户选择的文件的文件名和扩展名的缓冲区
    ofn.nMaxFileTitle = _countof(szFileTitle);
    ofn.lpstrInitialDir = TEXT("E:\\Sort\\");         // 初始目录

    LPTSTR lpStr;
    TCHAR szDir[MAX_PATH] = { 0 };
    TCHAR szBuf[MAX_PATH] = { 0 };



    if (uMsg == WM_INITDIALOG)
    {
        hwndList = GetDlgItem(hwndDlg, IDC_LIST_FILENAME);
        return TRUE;
    }
    else if (uMsg == WM_COMMAND)
    {

        if (wParam == IDC_BTN_OPEN)
        {
            ofn.lpstrTitle = TEXT("请选择要打开的文件");
            ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_CREATEPROMPT | OFN_ALLOWMULTISELECT;
            if (::GetOpenFileName(&ofn))
            {
                // 先清空列表框
                ::SendMessage(hwndList, LB_RESETCONTENT, 0, 0);

                //指针偏移到不是目录的位置,指向第一个文件的位置 
                // E:\\Sort\\物料采购清单(1).txt    多个文件时指向物字符 
                
                lpStr = ofn.lpstrFile + _tcslen(ofn.lpstrFile) + 1;

                //如果直接到末尾了终止符了，则可知用户只选择了一个文件。
                if (lpStr[0] == NULL)
                {
                    // 用户只选择了一个文件，则lpstrFile 存的就是文件的全路径。
                    ::SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)ofn.lpstrFile);
                }
                else
                {
                    // 用户选择了多个文件,
                    ::StringCchCopy(szDir, _countof(szDir), ofn.lpstrFile);

               
                    //把目录和文件名做拼接
                    if (szDir[_tcslen(szDir) - 1] != TEXT('\\'))
                    {
                        ::StringCchCopy(szBuf, _countof(szBuf), szDir);
                        ::StringCchCat(szBuf, _countof(szBuf), lpStr);
                    }
                    //循环，只要不到最后一个位置
                    while (lpStr[0] != NULL)
                    {
                        ::StringCchCopy(szBuf, _countof(szBuf), szDir);
                        ::StringCchCat(szBuf, _countof(szBuf), lpStr);
                        ::SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)szBuf);
                        lpStr += _tcslen(lpStr) + 1; //每次偏移的步长。刚好就是一个完整全路径
                    }

                }
            }
        }
        else if (wParam == IDC_BTN_SAVE)
        {

            ofn.lpstrTitle = TEXT("请选择要保存的文件名");  
            ofn.lpstrDefExt = TEXT("txt");            
            ofn.Flags = OFN_EXPLORER | OFN_OVERWRITEPROMPT;
            if (::GetSaveFileName(&ofn))
            {
                ::SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
                ::SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)ofn.lpstrFile);
            }
        }
        else if (wParam == IDCANCEL)
        {

            EndDialog(hwndDlg, 0);
        }
        return TRUE;
    }
   
    return FALSE;
}
```

:::





:::details `示例:MFC-CFileDialog`

```c

// HelloMFCDlg.cpp: 实现文件
//

#include "pch.h"
#include "framework.h"
#include "HelloMFC.h"
#include "HelloMFCDlg.h"
#include "afxdialogex.h"
#include <strsafe.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


BEGIN_MESSAGE_MAP(CHelloMFCDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BTN_OPEN, &CHelloMFCDlg::OnBnClickedBtnOpen)
	ON_BN_CLICKED(IDC_BTN_SAVE, &CHelloMFCDlg::OnBnClickedBtnSave)
END_MESSAGE_MAP()


CHelloMFCDlg::CHelloMFCDlg(CWnd* pParent /*=nullptr*/)
	: CDialogEx(IDD_HELLOMFC_DIALOG, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}
void CHelloMFCDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}
BOOL CHelloMFCDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);
	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != nullptr)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}
	SetIcon(m_hIcon, TRUE);			
	SetIcon(m_hIcon, FALSE);	
	return TRUE;  
}
void CHelloMFCDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	CDialogEx::OnSysCommand(nID, lParam);
}
void CHelloMFCDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); 
		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}
HCURSOR CHelloMFCDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}




void CHelloMFCDlg::OnBnClickedBtnOpen()
{

	TCHAR szFile[MAX_PATH * 512] = { 0 };   // 返回用户选择的文件名的缓冲区大一点，本程序允许多选
	TCHAR szFileTitle[MAX_PATH] = { 0 };    // 返回用户所选文件的文件名和扩展名的缓冲区
	LPTSTR lpStr;
	TCHAR szDir[MAX_PATH] = { 0 };
	TCHAR szBuf[MAX_PATH] = { 0 };


	CFileDialog cFileDialog(
		TRUE,NULL,NULL, 
		OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_CREATEPROMPT | OFN_ALLOWMULTISELECT, 
		NULL, this, 0, TRUE);

	//配置文件打开对话框，标题
	cFileDialog.m_ofn.lpstrTitle = _T("请选择要打开的文件");
	//配置文件打开对话框，文件过滤器 
	cFileDialog.m_ofn.lpstrFilter = TEXT("文本文件(*.txt, *.doc, *.docx)\0*.txt;*.doc;*.docx\0All(*.*)\0*.*\0");
	//配置文件打开对话框 启用第一个过滤器，过滤器容器索引从1开始
	cFileDialog.m_ofn.nFilterIndex = 1;
	//配置文件打开对话框 初始化打开目录
	cFileDialog.m_ofn.lpstrInitialDir = _T("E:\\Sort\\");
	//配置文件打开对话框 存用户选到的文件全路径 的缓冲区
	cFileDialog.m_ofn.lpstrFile = szFile;
	cFileDialog.m_ofn.lpstrFile[0] = NULL;                   
	cFileDialog.m_ofn.nMaxFile = _countof(szFile);
	//配置文件打开对话框 存用户选到的文件名 的缓冲区
	cFileDialog.m_ofn.lpstrFileTitle = szFileTitle;	        
	cFileDialog.m_ofn.nMaxFileTitle = _countof(szFileTitle);
	cFileDialog.ApplyOFNToShellDialog();

	//以模态形式，启用文件打开对话框
	LRESULT result = cFileDialog.DoModal();

	//查 ListBox控件句柄
	 HWND hwndList = ::GetDlgItem(this->m_hWnd, IDC_LIST_FILENAME);
	if (result == IDOK)
	{

		//清空 ListBox 控件区域内容
		::SendMessage(hwndList, LB_RESETCONTENT, 0, 0);

		//渲染全路径到 ListBox中展示
		lpStr = cFileDialog.m_ofn.lpstrFile + _tcslen(cFileDialog.m_ofn.lpstrFile) + 1;
		if (lpStr[0] == NULL)
		{
			::SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)cFileDialog.m_ofn.lpstrFile);
		}
		else
		{
			::StringCchCopy(szDir, _countof(szDir), cFileDialog.m_ofn.lpstrFile);
			if (szDir[_tcslen(szDir) - 1] != TEXT('\\'))
			{
				::StringCchCopy(szBuf, _countof(szBuf), szDir);
				::StringCchCat(szBuf, _countof(szBuf), lpStr);
			}

			while (lpStr[0] != NULL)
			{
				::StringCchCopy(szBuf, _countof(szBuf), szDir);
				::StringCchCat(szBuf, _countof(szBuf), lpStr);
				::SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)szBuf);
				lpStr += _tcslen(lpStr) + 1; 
			}

		}
	}
}


void CHelloMFCDlg::OnBnClickedBtnSave()
{
	
	HWND hwndList = ::GetDlgItem(this->m_hWnd, IDC_LIST_FILENAME);

	CFileDialog cFileDialog(
		FALSE, _T("txt"), NULL,
		OFN_EXPLORER | OFN_OVERWRITEPROMPT,
		NULL, this, 0, TRUE);

	LRESULT result = cFileDialog.DoModal();

	if (result == IDOK)
	{
		::SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
		::SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)cFileDialog.m_ofn.lpstrFile);
	}

}
```

:::



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E6%89%93%E5%BC%80%E7%AA%97%E5%8F%A3.gif)





## 浏览文件夹与遍历目录

要想让用户选择一个文件夹，可以调用`SHBrowseForFolder()`函数



:::details `SHBrowseForFolder`

```c
PIDLIST_ABSOLUTE SHBrowseForFolder(_in_ BROWSEINFO lpbi);
```

lpbi参数是一个指向BROWSEINFO结构的指针，BROWSEINFO结构在定义如下：

```c
typedef struct _browseinfo {
	HWND	hwndOwner; //对话框的拥有者窗口句柄
	PCIDLIST_ABSOLUTE pidlRoot; //开始浏览的根文件夹的位置，不需要可以设置为NULL
	LPTSTR pszDisplayName;//返回用户选择的文件夹名称的缓冲区
	LPCTSTR lpszTitle; //显示在对话框上部静态控件中的文字
	UINT	ulFlags;//标志位
	BFFCALLBACK lpfn;
	LPARAM	lParam;
	int ilmage;
}BROWSEINFO,*PBROWSEINFO，*LPBROWSEINFO;
```

- ulFlags字段指定标志位，常用的标志如下表所示。

|          标识宏          |                             含义                             |
| :----------------------: | :----------------------------------------------------------: |
|  `BIF_RETURNONLYFSDIRS`  | 如果用户选择不属于文件系统的文件夹(例如网络、家庭组)，则对话框的“确定"按钮将显示为灰色 |
|   `BIF_NEWDIALOGSTYLE`   |         使用新的用户界面，新的用户界面具有多项新功能         |
|      `BIF_EDITBOX`       |      在对话框中包含一个编辑控件，允许用户输入文件夹名称      |
|      `BIF_USENEWUI`      | 使用新用户界面，对话框中包含一个编辑控件，相当于BIF_NEWDIALOGSTYLE |
| `BIF_BROWSEINCLUDEFILES` |          对话框中显示文件和文件夹，通常不设置该标志          |
| `BIF_BROWSEINCLUDEURLS`  | 对话框可以显示URL快捷方式，还必须设置BIF_USENEWUI和BIF_BROWSEINCLUDEFILES标志，通常不设置该标志 |



函数返回值为`PIDLIST_ABSOLUTE`数据结构，定义如下

```c
#define PIDLIST_ABSOLUTE LPITEMIDLIST 

typedef ITEMIDLIST *LPITEMIDLIST
    
typedef struct _ITEMIDLIST
{
	SHITEMID mkid;
} ITEMIDLIST;

typedef struct _SHITEMID
{
	USHORT cb;
	BYTE abID[ 1 ];
}SHITEMID;
```

返回值类型`PIDLIST_ABSOLUTE`指定所选文件夹相对于命名空间根目录的位置。如果用户在对话框中单击了`"取消"`按钮、关闭了对话框或发生了错误，则返回值为NULL。

这个结构，我们可以使用`SHGetPathFromIDList()`函数可以很方便地将它转换成目录名称字符串(绝对路径)

```c

/// <summary>
/// 将结构PIDLIST_ABSOLUTE 转为目录绝对路径
/// </summary>
/// <param name="pid">指向ITEMIDLIST结构的指针</param>
/// <param name="pszPath">返回目录绝对路径的缓冲区</param>
/// <returns></returns>
BOOL SHGetPathFromIDList(PIDLIST_ABSOLUTE pid, LPTSTR pszPath);
```

:::



要遍历一个目录中的子目录或文件，首先调用`FindFirstFile()`函数。该函数返回一个HANDLE类型的查找句柄`hFindFile`，并返回找到的第一个子目录或文件的信息。



如果`FindFirstFile()`函数执行成功，则接下来可以利用`hFindFile`句柄循环调用`FindNextFile()`函数继续查找其他目录或文件，直到`FindNextFile()`函数返回FALSE为止。



最后调用`FindClose()`函数关闭`hFindFile`查找句柄。使用这几个函数查找文件的代码通常如下所示

:::details `FindFirstFile/FindNextFile`

```c
wWIN32_FIND_DATA fd = { 0 };
	//遍历目录
hFindFile = FindFirstFile(szDir, &fd);
if (hFindFile != INVALID_HANDLE_VALUE)
{
	do
	{
		//处理本次找到的文件
	
	} while (FindNextFile(hFindFile, &fd));
	FindClose(hFindFile);
}
```

- `lpFileName`参数指定要查找的文件名。如果文件名中不包含路径，那么将在当前目录中查找，包含路径的话将在指定路径中查找。在文件名中可以使用通配符`"*"`或`"?"`指定查找符合指定特征的文件。下面是文件名格式的几个示例︰

```c
c:\Windows\*.* //在C:\Windows目录中查找所有类型的文件
c.\Windows\System32\*.dll //在C:\Windows\System32目录中查找所有扩展名为.dll的文件
C:\Windows\System.ini //在C:\Windows目录中查找System.ini文件
C:\Windowsla???.* //在C:\Windows目录中查找所有以a开头的长度为4个字符的任何文件
Test.dat //在当前目录中查找Test.dat文件
*.*//在当前目录中查找所有文件
```

- `lpFindFileData`参数是一个指向查找结构`WIN32_FIND_DATA`的指针。该结构返回找到的目录或文件的信息。

```c
typedef struct _WIN32_FIND_DATA 
{
	DWORD dwFileAttributes;//文件系统属性
	FILETIME ftCreationTime; // FILETIME格式的文件创建时间
	FILETIME ftLastAccessTime; //FILETIME格式的最后访问时间
	FILETIME ftLastWriteTime; //FILETIME格式的最后修改时间
	DWORD nFileSizeHigh; //文件大小的高32位DWORD值，以字节为单位
    DWORD nFileSizeLow; //文件大小的低32位DWORD值，以字节为单位
	DWORD dwReserved0; //保留字段
	DWORD dwReservedl; //保留字段
	TCHAR cFileName[MA×_PATH] //文件名称(不包括路径)
	TCHAR cAlternateFileName[14];//该文件的替代名称，8.3文件名格式，通常用不到
} WIN32_FIND_DATA，*PWIN32_FIND_DATA，*LPWIN32_FIND_DATA;
```

- dwFileAttributes字段包含文件系统属性，通过这个字段可以检查找到的究竟是一个子目录还是一个文件，以及其他文件系统属性，常见的属性如下表所示。

|          属性宏           |           含义           |
| :-----------------------: | :----------------------: |
|   FILE_ATTRIBUTE_NORMAL   |         普通文件         |
| FILE_ATTRIBUTE_DIRECTORY  |     找到的是一个目录     |
|  FILE_ATTRIBUTE_READONLY  |         只读文件         |
| FILE_ATTRIBUTE_TEMPORARY  |    用于临时存储的文件    |
|   FILE_ATTRIBUTE_HIDDEN   |      隐藏文件或目录      |
|   FILE_ATTRIBUTE_SYSTEM   | 操作系统使用的文件或目录 |
|  FILE_ATTRIBUTE_ARCHIVE   |      存档文件或目录      |
| FILE_ATTRIBUTE_COMPRESSED |     压缩的文件或目录     |
| FILE_ATTRIBUTE_ENCRYPTED  |    已加密的文件或目录    |

- 参数`lpFindFileData`   如果`FindFirstFile()`函数执行成功，则返回值是在后续调用`FindNextFile()`或`FindClose()`时使用的查找句柄，而`lpFindFileData`参数指向的WIN32_FIND_DATA结构包含找到的第一个目录或文件的信息。如果函数执行失败或无法从`lpFileName`参数指定的搜索字符串中找到目录或文件，则返回值为`INVALID_HANDLE_VALUE(-1)`，这种情况下的`IpFindFileData`参数指向的结构的内容不确定。





`FindNextFile`函数以查找句柄和查找结构为参数继续查找目录或文件

```c
BOOL WINAPl FindNextFile(
_in_ HANDLEhFindFile, //查找句柄
_out_ LPWIN32_FlIND_DATA lpFindFileData //指向查找结构WIN32_FIND_DATA的指针
);
```

如果函数执行成功，则返回值为TRUE，lpFindFileData参数指向的结构包含找到的下一个目录或文件的信息。

如果函数执行失败，则返回值为FALSE，这种情况下的lpFindFileData参数指向的结构的内容不确定。

:::



:::details `示例:`



```c
#include <windows.h>
#include <Shlobj.h>
#include <tchar.h>
#include <strsafe.h>
#include "resource.h"

#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

HINSTANCE g_hInstance;
INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    g_hInstance = hInstance;

    // 创建模态对话框
    DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MAIN), NULL, DialogProc, NULL);
    return 0;
}

INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND hwndList; 
    PIDLIST_ABSOLUTE pItemIdList;   // SHBrowseForFolder函数返回值


    TCHAR szDir[MAX_PATH] = { 0 };  // SHGetPathFromIDList函数返回的目录名称的缓冲区
    HANDLE hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA findData = { 0 };
    TCHAR szSearch[MAX_PATH] = { 0 };
    TCHAR szDirFile[MAX_PATH] = { 0 };

 
    if (uMsg == WM_INITDIALOG)
    {
        hwndList = ::GetDlgItem(hwndDlg, IDC_LIST_FILENAME);
        return TRUE;
    }
    else if (uMsg == WM_COMMAND)
    {
        if (wParam == IDC_BTN_BROWSE)
        {
            BROWSEINFO bi = { 0 };
            bi.hwndOwner = hwndDlg;
            bi.lpszTitle = TEXT("请选择一个文件夹");
            bi.ulFlags = BIF_USENEWUI | BIF_RETURNONLYFSDIRS;
            pItemIdList = SHBrowseForFolder(&bi);


            if (pItemIdList)
            {
                //根据IDList 查当前用户选择目录的全路径
                SHGetPathFromIDList(pItemIdList, szDir);


                //设置STATIC控件文本值
                SetDlgItemText(hwndDlg, IDC_STATIC_DIR, szDir);

               
                if (szDir[_tcslen(szDir) - 1] != TEXT('\\'))
                {
                    StringCchCat(szDir, _countof(szDir), TEXT("\\"));
                }
       
                // 拼接搜索字符串
                StringCchCopy(szSearch, _countof(szSearch), szDir);
                StringCchCat(szSearch, _countof(szSearch), TEXT("*.*"));
               

                hFindFile = ::FindFirstFile(szSearch, &findData);
                if (hFindFile != INVALID_HANDLE_VALUE)
                {

                    //清空 ListBox内容
                    SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
                    do
                    {
                        // 查这个目录下文件  不进行处理子目录。
                        if (!(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                        {
                            StringCchCopy(szDirFile, _countof(szDirFile), szDir);
                            StringCchCat(szDirFile, _countof(szDirFile), findData.cFileName);
                        
                            ::SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)szDirFile);
                        }

                    } while (::FindNextFile(hFindFile, &findData));

                    // 关闭查找句柄
                    ::FindClose(hFindFile);
                }
            }
        }
        else if (wParam == IDCANCEL)
        {
            ::EndDialog(hwndDlg, 0);
        }
    }

    return FALSE;
}
```

:::



:::details `MFC示例：`

```c
#include "pch.h"
#include "framework.h"
#include "HelloMFC.h"
#include "HelloMFCDlg.h"
#include "afxdialogex.h"
#include <strsafe.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

BEGIN_MESSAGE_MAP(CHelloMFCDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BTN_BROWSE, &CHelloMFCDlg::OnBnClickedBtnBrowse)
END_MESSAGE_MAP()


CHelloMFCDlg::CHelloMFCDlg(CWnd* pParent /*=nullptr*/)
	: CDialogEx(IDD_HELLOMFC_DIALOG, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}
void CHelloMFCDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}
BOOL CHelloMFCDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);
	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != nullptr)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}
	SetIcon(m_hIcon, TRUE);			
	SetIcon(m_hIcon, FALSE);	
	return TRUE;  
}
void CHelloMFCDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	CDialogEx::OnSysCommand(nID, lParam);
}
void CHelloMFCDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); 
		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}
HCURSOR CHelloMFCDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}



void CHelloMFCDlg::OnBnClickedBtnBrowse()
{
	// TODO: 在此添加控件通知处理程序代码
	
	HWND hwndList;
	TCHAR szSearch[MAX_PATH];
	CFileFind cFileFinder;
	BOOL bRet = FALSE;


	CFolderPickerDialog  
		cFolderPikerDialog(NULL, BIF_USENEWUI | BIF_RETURNONLYFSDIRS,this,0);
	cFolderPikerDialog.m_ofn.lpstrTitle = TEXT("请选择一个文件夹");
	cFolderPikerDialog.ApplyOFNToShellDialog();
	
	hwndList = ::GetDlgItem(this->m_hWnd, IDC_LIST_FILENAME);
	if (cFolderPikerDialog.DoModal() == IDOK)
	{
		::SetDlgItemText(this->m_hWnd, IDC_STATIC_DIR,cFolderPikerDialog.GetPathName());
		::StringCchCopy(szSearch,_countof(szSearch), cFolderPikerDialog.GetPathName());

		if (szSearch[_tcslen(szSearch) - 1] != TEXT('\\'))
		{
			::StringCchCat(szSearch, _countof(szSearch), TEXT("\\"));
		}

		::StringCchCat(szSearch, _countof(szSearch), TEXT("*"));
		 bRet = cFileFinder.FindFile(szSearch);
		 if (bRet)
		 {
			 ::SendMessage(hwndList, LB_RESETCONTENT,0,0);
			 do
			 {
				 bRet = cFileFinder.FindNextFile();
				 if (!cFileFinder.IsDirectory())
				 {
					 
					 ::SendMessage(hwndList,LB_ADDSTRING,0, (LPARAM) cFileFinder.GetFilePath().GetString());

				 }


			 } while (bRet);
		 }
	}
}
```

:::

## 查找和替换

"查找"和"替换"对话框的样式通常如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20231231231619477.png)



创建查找对话框的函数是`FindText()`，用户可以在对话框中输入要搜索的字符串和相关搜索选项﹔创建替换对话框的函数是`ReplaceText()`,用户可以在对话框中输入要搜索的字符串和替换的字符串，以及控制查找和替换操作的选项。



:::details `FindText/ReplaceText`

```c
HWND WINAPI FindText(_In_ LPFINDREPLACE lpfr);
HwND WINAPI ReplaceText(_Inout_ LPFINDREPLACE lpfr);
```

"查找"和"替换"对话框都是非模态对话框。

如果函数执行成功，则返回值是对话框的窗口句柄，可以通过该句柄与父窗口进行通信,如果函数执行失败，则返回值为NULL。



- 参数`lpfr`是一个指向FINDREPLACE结构的指针，结构的定义如下

```c
typedef struct 
{
	DWORD IStructSize;//该结构的大小
	HWND hwndOwner;//对话框的拥有者窗口句柄，不能为NULL
    HINSTANCE hInstance;
	DWORD Flags; //标志位
	LPTSTR lpstrFindWhat; //"查找内容"编辑控件中的字符串缓冲区，缓冲区大小至少为80个字符
	LPTSTR lpstrReplaceWith;//"替换为"编辑控件中的字符串缓冲区，缓冲区大小至少为80个字符
	WORD wFindWhatLen; //lpstrFindWhat字段指向的缓冲区的长度，以字节为单位
	WORD	wReplaceWithLen; //lpstrReplaceWith字段指向的缓冲区的长度，以字节为单位
	LPARAM	lCustData;
    LPFRHOOKPROC lpfnHook;
    LPCTSTR lpTemplateName;
} FINDREPLACE，*LPFINDREPLACE;
```

- `Flags`字段是标志位，可以是标志的组合（常用的)，如下表所示。



|        标志        |                             含义                             |
| :----------------: | :----------------------------------------------------------: |
|   `FR_FINDNEXT`    |                    单击了"查找下一个"按钮                    |
|    `FR_REPLACE`    |                       点击了"替换"按钮                       |
|  `FR_REFLACEALL`   |                     单击了“全部替换”按钮                     |
|     `FR_DOWN`      | 已选中搜索方向的“向下”单选按钮，指示应从当前位置搜索到文档末尾﹔否则就是已选中“向上”单选按钮，指示应从当前位置搜索到文档开头 |
|   `FR_MATCHCASE`   |                   已选中“匹配大小写”复选框                   |
|   `FR_WHOLEWORD`   |                   已选中“全字匹西配”复选框                   |
|  `FR_HIDEUPDOWN`   |             隐惹搜索方向的“向上”和“向下”单选按钮             |
| `FR_HIDEMATCHCASE` |                    禁用“匹配大小写”复选框                    |
|  `FR_NOMATCHMASE`  |                     禁用“全字匹配”复选框                     |
|  `FR_DIALOGTERM`   |                        对话框正在关闭                        |

在调用`FindText()`和`ReplaceText()`函数后，系统根据FINDREPLACE结构中字段的设置初始化对话框，例如根据Flags字段的值设置对话框中相关控件的选中、禁用或隐藏状态，`lpstrFindWhat`字段指向的缓冲区的内容会显示到"查找内容"编辑控件中，`lpstrReplaceWith`字段指向的缓冲区的内容会显示到“替换为"编辑控件中(查找对话框不需要该字段)。



“查找"和"替换"对话框都是非模态对话框。





在调用`FindText()`和`ReplaceText()`函数后，系统显示对话框后并马上返回，对话框保持显示状态，直到用户关闭对话框。如果用户按下了对话框中的某个按钮则对话框设置`FINDREPLACE`结构的相关字段并通过 "查找替换消息" 通知父窗口的窗口过程，程序中处理查找和替换的功能集中在这个 `"查找替换消息"` 中完成。在该消息中可以根据Flags字段的值确定用户按下了哪个按钮，根据`lpstrFindWhat`字段指向的缓冲区确定"查找内容"编辑控件的内容，根据`lpstrReplaceWith`字段指向的缓冲区确定"替换为"编辑控件的内容。由于对话框必须向父窗口发送消息，因此`hwndOwner`字段必须指定为父窗口的句柄。







"查找替换消息"的ID值是多少呢?和拖动列表消息类似，在调用`FindText()`和`ReplaceText()`前，需要调用
`RegisterWindowMessage(FINDMSGSTRING)`函数以获取"查找替换消息”的ID，"查找替换消息"的IParam参数是指向创建对话框时指定的FINDREPLACE结构的指针。FINDMSGSTRING常量在`commdlg.h`头文件中定义如下∶

```
#define FINDMSGSTRING TEXT("commdlg_FindReplace")
```

在程序的消息循环中使用`IsDialogMessage()`函数以确保对话框正确处理键盘输入（例如Tab键和Esc键)。因此，如果需要使用"查找"和"替换"对话框，不适合使用对话框程序。另外，FINDREPLACE结构和搜索与替换字符串的缓冲区变量应该是全局或静态局部变量这样在下一次消息处理的时候还可以继续使用上次保存的值。

:::



:::details `示例：`



```c
#include <Windows.h>
#include <tchar.h>
#include <strsafe.h>
#include "resource.h"

#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

// 函数声明
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// 全局变量
HWND g_hwndFind;    // 消息循环中会用到这两个全局变量
HWND g_hwndReplace;

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("FindReplaceText");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = MAKEINTRESOURCE(IDR_MENU);
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);

    hwnd = ::CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);

    ::ShowWindow(hwnd, nCmdShow);
    ::UpdateWindow(hwnd);

    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if ((g_hwndFind == NULL || !IsDialogMessage(g_hwndFind, &msg)) &&
            (g_hwndReplace == NULL || !IsDialogMessage(g_hwndReplace, &msg)))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static UINT WM_FINDREPLACE;
    static TCHAR szFindWhat[80] = { 0 };
    static TCHAR szReplaceWith[80] = { 0 };
    static FINDREPLACE fr = { 0 };
    LPFINDREPLACE lpfr;
    TCHAR szBuf[256] = { 0 };


    if (uMsg == WM_CREATE)
    {
        // 获取查找替换消息的ID
        WM_FINDREPLACE = ::RegisterWindowMessage(FINDMSGSTRING);

        // 初始化FINDREPLACE结构，该结构只应该初始化一次
        fr.lStructSize = sizeof(FINDREPLACE);
        fr.hwndOwner = hwnd;
        fr.lpstrFindWhat = szFindWhat;
        fr.lpstrReplaceWith = szReplaceWith;
        fr.wFindWhatLen = sizeof(szFindWhat);
        fr.wReplaceWithLen = sizeof(szReplaceWith);
        //fr.Flags = FR_DOWN | FR_MATCHCASE;
        return 0;
    }
    else if (uMsg == WM_COMMAND)
    {

        if (wParam == ID_EDIT_FIND)
        {
            if (g_hwndFind == NULL && g_hwndReplace == NULL)
            {
                // &掉上次关闭对话框时设置的FR_DIALOGTERM标志值
                fr.Flags &= ~FR_DIALOGTERM;
                g_hwndFind = ::FindText(&fr);
            }

        }
        else if (wParam == ID_EDIT_REPLACE)
        {
            if (g_hwndReplace == NULL && g_hwndFind == NULL)
            {
                // &掉上次关闭对话框时设置的FR_DIALOGTERM标志值
                fr.Flags &= ~FR_DIALOGTERM;
                g_hwndReplace = ::ReplaceText(&fr);
            }
        }

    }
    else if (uMsg == WM_DESTROY)
    {
        ::PostQuitMessage(0);
        return 0;
    }
    else if (uMsg == WM_FINDREPLACE)
    {
        lpfr = (LPFINDREPLACE)lParam;
       
        // 关闭对话框
        if (lpfr->Flags & FR_DIALOGTERM)
        {
            g_hwndFind = NULL;
            g_hwndReplace = NULL;
        }
        // 查找下一个
        else if (lpfr->Flags & FR_FINDNEXT)
        {
            StringCchCopy(szBuf, _countof(szBuf), TEXT("单击了“查找下一个”按钮"));
            if (lpfr->Flags & FR_DOWN)
            {
                ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“向下”单选按钮"));
            }
            else
            {
                ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“向上”单选按钮"));
            }
            if (lpfr->Flags & FR_MATCHCASE)
            {
                ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“匹配大小写”复选框"));
            }
            
            if (lpfr->Flags & FR_WHOLEWORD)
            {
                ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“全字匹配”复选框"));
            }
               
            ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n\n查找内容："));
            ::StringCchCat(szBuf, _countof(szBuf), fr.lpstrFindWhat);
            ::MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }

        // 替换
        else if (lpfr->Flags & FR_REPLACE)
        {
            ::StringCchCopy(szBuf, _countof(szBuf), TEXT("单击了“替换”按钮"));
            if (lpfr->Flags & FR_DOWN)
            {
                ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“向下”单选按钮"));
            }
            else
            {
                ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“向上”单选按钮"));
            }
            if (lpfr->Flags & FR_MATCHCASE)
            {
                ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“匹配大小写”复选框"));
            }
            if (lpfr->Flags & FR_WHOLEWORD)
            {
                ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“全字匹配”复选框"));
            }
            ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n\n查找内容："));
            ::StringCchCat(szBuf, _countof(szBuf), fr.lpstrFindWhat);
            ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n替换内容："));
            ::StringCchCat(szBuf, _countof(szBuf), fr.lpstrReplaceWith);
            ::MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }

        // 全部替换
        else if (lpfr->Flags & FR_REPLACEALL)
        {
            ::StringCchCopy(szBuf, _countof(szBuf), TEXT("单击了“全部替换”按钮"));
            if (lpfr->Flags & FR_DOWN)
            {
                ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“向下”单选按钮"));
            }
            else
            {
                ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“向上”单选按钮"));
            }
            if (lpfr->Flags & FR_MATCHCASE)
            {
                ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“匹配大小写”复选框"));
            }
            if (lpfr->Flags & FR_WHOLEWORD)
            {
                ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“全字匹配”复选框"));
            }

            ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n\n查找内容："));
            ::StringCchCat(szBuf, _countof(szBuf), fr.lpstrFindWhat);
            ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n替换内容："));
            ::StringCchCat(szBuf, _countof(szBuf), fr.lpstrReplaceWith);
            ::MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
        }

        return 0;


    }

    return  ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

:::



:::details `MFC示例：`

这些查找和替换工作，同样MFC对其封装成了`CFindReplaceDialog` .在说明其具体使用之前，我们简单过一下，如何添加定制菜单资源整合到我们对话框中。新建菜单资源很简单这里不讲了。建议ID项和笔者规范取齐。

- 菜单ID IDR_MENU
- 菜单项ID ID_EDIT_FIND
- 菜单项ID ID_EDIT_REPLACE

由于`CFindReplaceDialog` 是一个非模态对话框。为了使我们对话框（父窗口）收到替换请求的通知。 所以我们得做一些额外不可少的整合。这点MSDN中有具体的整合步骤

```
https://learn.microsoft.com/zh-cn/cpp/mfc/reference/cfindreplacedialog-class?view=msvc-170&devlangs=cpp&f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(AFXDLGS%252FCFindReplaceDialog)%3Bk(CFindReplaceDialog)%3Bk(DevLang-C%252B%252B)%3Bk(TargetOS-Windows)%26rd%3Dtrue#create
```

在整合时读者只需注意一点， `OnFindReplace()`函数 的返回值不能是LONG,请修正为LRESULT,以和消息映射宏的函数指针参数匹配上。

```c
#pragma once
#include <winnt.h>


static UINT WM_FINDREPLACE = ::RegisterWindowMessage(FINDMSGSTRING);

class CHelloMFCDlg : public CDialogEx
{
public:
	CHelloMFCDlg(CWnd* pParent = nullptr);	


#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_HELLOMFC_DIALOG };
#endif

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	
protected:
	HICON m_hIcon;
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg LRESULT OnFindReplace(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnEditReplace();
	afx_msg void OnEditFind();

private:
	CMenu m_menu;
};
```

```c

// HelloMFCDlg.cpp: 实现文件
//

#include "pch.h"
#include "framework.h"
#include "HelloMFC.h"
#include "HelloMFCDlg.h"
#include "afxdialogex.h"
#include <strsafe.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CFindReplaceDialog* g_findReplaceDialog = NULL;
TCHAR g_szFindWhat[80] = { 0 };
TCHAR g_szReplaceWith[80] = { 0 };


BEGIN_MESSAGE_MAP(CHelloMFCDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_COMMAND(ID_EDIT_FIND, &CHelloMFCDlg::OnEditFind)
	ON_COMMAND(ID_EDIT_REPLACE, &CHelloMFCDlg::OnEditReplace)
	ON_REGISTERED_MESSAGE(WM_FINDREPLACE, &CHelloMFCDlg::OnFindReplace)
END_MESSAGE_MAP()


CHelloMFCDlg::CHelloMFCDlg(CWnd* pParent /*=nullptr*/)
	: CDialogEx(IDD_HELLOMFC_DIALOG, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CHelloMFCDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}
BOOL CHelloMFCDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();
	
	SetIcon(m_hIcon, TRUE);			
	SetIcon(m_hIcon, FALSE);	
	
	//设置对话框使用我们定制的菜单
	m_menu.LoadMenu(IDR_MENU);
	SetMenu(&m_menu);
	return TRUE;  
}
void CHelloMFCDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	CDialogEx::OnSysCommand(nID, lParam);
}
void CHelloMFCDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); 
		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}
HCURSOR CHelloMFCDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

LRESULT CHelloMFCDlg::OnFindReplace(WPARAM wParam, LPARAM lParam)
{
	TCHAR szBuf[256] = { 0 };
	LPFINDREPLACE lpfr;
	lpfr = (LPFINDREPLACE)lParam;

	if (lpfr->Flags & FR_DIALOGTERM)
	{
		//收到了关闭对话框的指令
		g_findReplaceDialog = NULL;
	}
	else if (lpfr->Flags & FR_FINDNEXT)
	{
		// 查找下一个的指令
		StringCchCopy(szBuf, _countof(szBuf), TEXT("单击了“查找下一个”按钮"));
		if (lpfr->Flags & FR_DOWN)
		{
			::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“向下”单选按钮"));
		}
		else
		{
			::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“向上”单选按钮"));
		}
		if (lpfr->Flags & FR_MATCHCASE)
		{
			::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“匹配大小写”复选框"));
		}

		if (lpfr->Flags & FR_WHOLEWORD)
		{
			::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“全字匹配”复选框"));
		}

		::StringCchCat(szBuf, _countof(szBuf), TEXT("\n\n查找内容："));
		::StringCchCat(szBuf, _countof(szBuf), g_findReplaceDialog->GetFindString());
		::MessageBox(this->m_hWnd, szBuf, TEXT("提示"), MB_OK);
	}
	//替换
	else if (lpfr->Flags & FR_REPLACE)
	{
		::StringCchCopy(szBuf, _countof(szBuf), TEXT("单击了“替换”按钮"));
		if (lpfr->Flags & FR_DOWN)
		{
			::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“向下”单选按钮"));
		}
		else
		{
			::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“向上”单选按钮"));
		}
		if (lpfr->Flags & FR_MATCHCASE)
		{
			::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“匹配大小写”复选框"));
		}
		if (lpfr->Flags & FR_WHOLEWORD)
		{
			::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“全字匹配”复选框"));
		}
		::StringCchCat(szBuf, _countof(szBuf), TEXT("\n\n查找内容："));
		::StringCchCat(szBuf, _countof(szBuf), g_findReplaceDialog->GetFindString());
		::StringCchCat(szBuf, _countof(szBuf), TEXT("\n替换内容："));
		::StringCchCat(szBuf, _countof(szBuf), g_findReplaceDialog->GetReplaceString());
		::MessageBox(this->m_hWnd, szBuf, TEXT("提示"), MB_OK);
	}
	// 全部替换
	else if (lpfr->Flags & FR_REPLACEALL)
	{
		::StringCchCopy(szBuf, _countof(szBuf), TEXT("单击了“全部替换”按钮"));
		if (lpfr->Flags & FR_DOWN)
		{
			::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“向下”单选按钮"));
		}
		else
		{
			::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“向上”单选按钮"));
		}
		if (lpfr->Flags & FR_MATCHCASE)
		{
			::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“匹配大小写”复选框"));
		}
		if (lpfr->Flags & FR_WHOLEWORD)
		{
			::StringCchCat(szBuf, _countof(szBuf), TEXT("\n选中了“全字匹配”复选框"));
		}

		::StringCchCat(szBuf, _countof(szBuf), TEXT("\n\n查找内容："));
		::StringCchCat(szBuf, _countof(szBuf), g_findReplaceDialog->GetFindString());
		::StringCchCat(szBuf, _countof(szBuf), TEXT("\n替换内容："));
		::StringCchCat(szBuf, _countof(szBuf), g_findReplaceDialog->GetReplaceString());
		::MessageBox(this->m_hWnd, szBuf, TEXT("提示"), MB_OK);
	}


	return 0;
}






void CHelloMFCDlg::OnEditFind()
{
	
	if (NULL == g_findReplaceDialog) //只有查找
	{
		g_findReplaceDialog = new CFindReplaceDialog();
		g_findReplaceDialog->Create(TRUE, NULL, NULL, FR_DOWN, this);
		g_findReplaceDialog->m_fr.Flags  &= ~FR_DIALOGTERM;
		g_findReplaceDialog->m_fr.lStructSize = sizeof(FINDREPLACE);
		g_findReplaceDialog->m_fr.hwndOwner = this->m_hWnd;
		g_findReplaceDialog->m_fr.lpstrFindWhat = g_szFindWhat;
		g_findReplaceDialog->m_fr.lpstrReplaceWith = g_szReplaceWith;
		g_findReplaceDialog->m_fr.wFindWhatLen = sizeof(g_szFindWhat);
		g_findReplaceDialog->m_fr.wReplaceWithLen = sizeof(g_szReplaceWith);
		g_findReplaceDialog->ShowWindow(SW_SHOW);
	}



}



void CHelloMFCDlg::OnEditReplace()
{

	if (NULL == g_findReplaceDialog) //含查找和替换
	{
		g_findReplaceDialog = new CFindReplaceDialog();
		g_findReplaceDialog->Create(FALSE, NULL, NULL, FR_DOWN, this);
		g_findReplaceDialog->m_fr.Flags &= ~FR_DIALOGTERM;
		g_findReplaceDialog->m_fr.lStructSize = sizeof(FINDREPLACE);
		g_findReplaceDialog->m_fr.hwndOwner = this->m_hWnd;
		g_findReplaceDialog->m_fr.lpstrFindWhat = g_szFindWhat;
		g_findReplaceDialog->m_fr.lpstrReplaceWith = g_szReplaceWith;
		g_findReplaceDialog->m_fr.wFindWhatLen = sizeof(g_szFindWhat);
		g_findReplaceDialog->m_fr.wReplaceWithLen = sizeof(g_szReplaceWith);
		g_findReplaceDialog->ShowWindow(SW_SHOW);
	}
	
}

```

:::





## 选择字体



字体对话框允许用户选择逻辑字体的属性，例如字体名称、大小、字形、效果（下划线、删除线、字体颜色)以及字符集等。创建字体对话框用的函数是`ChooseFont `:



:::details `ChooseFont`

```c
BOOL WINAPl ChooseFont(_Inout_ LPCHOOSEFONT lpcf);
```

如果用户单击了`"确定"`按钮，则函数返回TRUE，并在`CHOOSEFONT`结构中返回有关用户选择的字体的信息。如果用户单击了`"取消"`按钮、关闭了对话框或发生错误，则返回FALSE。



- `lpcf`参数是一个指向CHOOSEFONT结构的指针，该结构包含函数用于初始化字体对话框的信息，函数在该结构中返回有关用户选择的字体的信息。

:::



:::details `示例:`

```c
#include <windows.h>
#include "resource.h"
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

// 全局变量
HINSTANCE g_hInstance;

// 函数声明
INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    g_hInstance = hInstance;

    // 创建模态对话框
    DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MAIN), NULL, DialogProc, NULL);
    return 0;
}

INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    RECT rect;
    HFONT hFontOld;

    static LOGFONT lf = { 0 };
    static CHOOSEFONT cf = { 0 };
    TCHAR szBuf[256] = { 0 };

    switch (uMsg)
    {
    case WM_INITDIALOG:
        GetObject(GetStockObject(OEM_FIXED_FONT), sizeof(lf), &lf);
        cf.lStructSize = sizeof(CHOOSEFONT);
        cf.hwndOwner = hwndDlg;
        cf.lpLogFont = &lf;
        cf.Flags = CF_EFFECTS | CF_INITTOLOGFONTSTRUCT;
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case ID_EDIT_FONT:
            if (ChooseFont(&cf))
            {
                wsprintf(szBuf, TEXT("字体名称：%s\n  字体大小：%d磅\n  有删除线：%s\n  有下划线：%s\n  字体颜色：%06X\n  "),
                    cf.lpLogFont->lfFaceName,
                    cf.iPointSize / 10,
                    cf.lpLogFont->lfStrikeOut ? TEXT("是") : TEXT("否"),
                    cf.lpLogFont->lfUnderline ? TEXT("是") : TEXT("否"),
                    cf.rgbColors);
                MessageBox(hwndDlg, szBuf, TEXT("提示"), MB_OK);
                InvalidateRect(hwndDlg, NULL, TRUE);
            }
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, 0);
            break;
        }
        return TRUE;

    case WM_PAINT:
        hdc = BeginPaint(hwndDlg, &ps);
        GetClientRect(hwndDlg, &rect);
        hFontOld = (HFONT)SelectObject(hdc, CreateFontIndirect(&lf));
        SetTextColor(hdc, cf.rgbColors);
        SetBkMode(hdc, TRANSPARENT);
        DrawText(hdc, TEXT("Windows中文网"), _countof(TEXT("Windows中文网")),
            &rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);
        EndPaint(hwndDlg, &ps);
        DeleteObject(SelectObject(hdc, hFontOld));
        break;
    }

    return FALSE;
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240710235931367.png)



:::





## 选择颜色

选择颜色对话框的效果如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240710235706044.png)

用户可以从对话框左侧的"基本颜色"或右侧的“自定义颜色"中选择一种颜色。“基本颜色"是系统预定义好的颜色，也可以在“自定义颜色"中单击选择一种颜色，或者输入红、绿、蓝颜色值，也可以输入色调、饱和度、亮度来生成一个颜色值。选择一种颜色后，颜色效果会实时显示在"颜色|纯色(O)”静态控件中。实际上对话框中除几个编辑控件和按钮以外，其他的控件基本上都是静态控件。
创建选择颜色对话框的函数是`ChooseColor `





:::details `ChooseColor`

```c
BOOL WINAPl ChooseColor(_lnout_LPCHOOSECOLOR lpcc);
```

- `lpcc`参数是一个指向CHOOSECOLOR结构的指针，该结构包含用于初始化对话框的信息。当ChooseColor函数返回时，该结构包含用户选择的颜色的信息。

  如果用户单击对话框的"确定"按钮，则返回值为TRUE;如果用户单击了“取消"按钮、关闭了对话框或发生错误，则返回值为FALSE。



:::



:::details `示例:`

```c
#include <windows.h>
#include "resource.h"

#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

// 全局变量
HINSTANCE g_hInstance;

// 函数声明
INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    g_hInstance = hInstance;

    // 创建模态对话框
    DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MAIN), NULL, DialogProc, NULL);
    return 0;
}

INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static CHOOSECOLOR cc = { 0 };
    static COLORREF crCustColors[16] = { 0 };
    TCHAR szBuf[128] = { 0 };

    switch (uMsg)
    {
    case WM_INITDIALOG:
        cc.lStructSize = sizeof(CHOOSECOLOR);
        cc.hwndOwner = hwndDlg;
        cc.rgbResult = RGB(255, 0, 0);
        cc.lpCustColors = crCustColors;
        cc.Flags = CC_FULLOPEN | CC_RGBINIT;
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case ID_EDIT_COLOR:
            if (ChooseColor(&cc))
            {
                wsprintf(szBuf, TEXT("颜色值：%06X"), cc.rgbResult);
                MessageBox(hwndDlg, szBuf, TEXT("提示"), MB_OK);
            }
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, 0);
            break;
        }
        return TRUE;
    }

    return FALSE;
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240711000437624.png)

:::
