子窗口控件



调用`CreateWindow()` / `CreateWindowEx()`函数创建窗口的时候，将窗口样式指定为`WS_CHILD`或`WS_CHILDWINDOW`就可以创建一个子窗口。子窗口的位置可以在父窗口客户区的任何地方，这样的子窗口需要程序注册窗口类并提供窗口过程。程序也可以通过系统预定义的窗口类和窗口过程来创建标准子窗口控件，程序中常见的标准子窗口挫件有按钮、单选按钮、复选按钮、编辑框、组合框、列表框、滚动条控件等，像资源管理器窗口就包含多个子窗口控件，例如工具栏、树视图控件、滚动条控件等。标准子窗口控件也称为通用控件(Common Control) 。





程序可以把窗口类名指定为系统预定义的`相关子窗口控件类名`来调用`CreateWindow()`/ `CreateWindowEx()`函数创建一个子窗口控件(对应形参的`lpClassName`)，子窗口控件和父窗口之间可以互相发送消息来进行通信。子窗口控件在对话框程序中用得更普遍，不需要调用`CreateWindow()`/ `CreateWindowEx()`函数，直接在资源脚本文件中定义子窗口控件即可，也可以通过资源编辑器从工具箱中拖曳子窗口控件到对话框程序界面的合适位置。

​	

**系统预定义的窗口类名字符串含义**

- Button按钮（普通按钮、单选按钮、复选按钮、分组框)
- Edit编辑框
- ListBox列表框
- ComboBox组合框ScrollBar滚动条Static静态控件
- MDIClientMDl 客户窗口



另外，有一些类名是系统内部使用的，例如`ComboLBox (多一个L)`表示组合框内的列表框的类名，`#32770`表示对话框类名等。





## 按钮类

按钮(Button)类有许多样式属性，基于Button类指定不同的样式可以创建普通按钮、单选按钮、复选按钮和分组框等。Button类可以指定的按钮样式如表所示，BS_前缀表示Button Style.



:::details `不同类型的按钮`



|              宏               |                             含义                             |
| :---------------------------: | :----------------------------------------------------------: |
|        `BS_PUSHBUTTON`        |                           普通按钮                           |
|      `BS_DEFPUSHBUTTON`       | 默认按钮，和普通按钮一样，但是有一个较深的轮廓。如果是在对话框程序中，当其他按钮没有键盘焦点时，用户可以通过按下Enter键选择该按钮 |
|      ``BS_RADIOBUTTON``       |                 单选按钮，可以选中、取消选中                 |
|       `BS_AUTOCHECKBOX`       |                         自动单选按钮                         |
|       `BS_RADIOBUTTON`        |                          自动复选框                          |
|     `BS_AUTORADIOBUTTON`      |                 单选按钮，可以选中、取消选中                 |
|         `BS_CHECKBOX`         |                 复选框，可以选中，取消选中。                 |
|       `BS_ATUOCHECKBOX`       |                          自动复选框                          |
|        `BS_ATUO3TATE`         |                        自动三态复选框                        |
| `BS_LEFTTEXT或BS_RIGHTBUTTON` | 对于单选按钮﹑复选框或三态复选框，文本默认显示在按钮右侧，该样式表示显示在按钮左侧 |
|           `BS_TEXT`           |                      按钮矩形内显示文本                      |
|           `BS_LEFT`           |                    左对齐按钮矩形内的文本                    |
|          `BS_RIGHT`           |                    右对齐按钮矩形内的文本                    |
|         `BS_CENTTER`          |                   文本在按钮矩形内水平居中                   |
|           `BS_TOP`            |                     文本在按钮矩形的顶部                     |
|          `BS_BOTTOM`          |                     文本在按钮矩形的底部                     |
|         `BS_VCENTER`          |                   文本在按钮矩形内垂直居中                   |
|           `BS_FLAT`           |        按钮默认具有三维样式,该样式表示按钮是二维样式         |
|         `BS_PUSHLIKE`         |        使单选按钮、复选框或三态复选框看起来像按钮—样         |
|        `BS_OWNERDRAW`         | 自绘按钮，当按钮需要重绘时父窗口会收到WM_DRAWITEM消息，不能将该样式与任何其他按钮样式—起使用 |
|           `BS_ICON`           |                           图标按钮                           |
|          `BS_BITMAP`          |                           位图按钮                           |
|         `BS_GROUPBOX`         | 分组框,用于对其他控件进行分组，由一个矩形和显示在矩形左上角的文本组成 |
|          `BS_NOTIFY`          | 系统可以发送包含`BN_KTLLFOCUS`和`BS_SETFOCUS`通知码的WM_COMMAND消息到其父窗口 |
|       `BS_SPLITBUTTON`        | 拆分按钮。拆分按钮分为两部分，左侧是主要部分，类似于普通或默认按纽﹔右刻有一个向下的小箭头，单击箭头时可以弹出一个菜单。拆分按扭是通用控件版本6中引A的一种出钮，如图所示:![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240114215850442.png) |
|      `BS_DEFSPLITBUTTON`      | 默认拆分按钮，有一个较深的轮廓。如果是在对话框程序中，当其他按钮没有键盘焦点时，用户可以通过按下Eater键选择该按钮 |
|       `BS_COMMANDLTNK`        | 命令链接按钮，左侧有一个篮色箭头指向按钮文本(Windows 7系统中为绿色箭头〉。命令链接按钮是通用控件版本6中引入的一种按钮，如图所示:![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240114215850442.png) |
|      `BS_DEFCOMMANDLINK`      | 默认命令链接按钮，有一个较深的轮廓。如果是在对话框程序中，当其他按钮没有键盘焦点时，用户可以通过按下Enter键选择该按钮 |

以三态复选框与自动三态复选框为例，用户单击三态复选框以后不会自动选中或变灭，程序需要响应单击事件设置选中或变灰状态﹔而如果是自动三态复选框，则单击一次就会自动选中，再单击一次则复选框显示为灰色，第三次单击则会取消选中，如此循环，程序在需要的时候只需要获取其状态即可。

:::







普通按钮、默认按钮、单选按钮和复选框都可以同时指定BS_ICON或BS BITMAP样式，例如`BS_PUSHBUTTON|BS_BITMAP`，或`BS_AUTORADIOBUTTON| BS_BITMAP`，表示在普通按钮上显示一副位图，或单选按钮旁边显示一副位图。





`BS_ICON`或`BS_BITMAP`样式也可以单独使用，表示在普通按钮上显示一个图标或一副位图。指定`BS_ICON`或`BS_BITMAP`样式以后，需要发送`BM_SETIMAGE`消息为其设置图标或位图，后面再详细解释这个消息。





`BS_`前缀的样式是按钮专用样式。除了这些按钮专用样式，因为子窗口控件也是一个窗口，所以大部分用于普通窗口的API函数和窗口样式适用于子窗口控件。例如下表的窗口样式可以用于按钮。



:::details `可用于子窗口的窗口样式`

|               宏                |                             含义                             |
| :-----------------------------: | :----------------------------------------------------------: |
|  `WS_CHILD`或`WS_CHILDWINDOW`   |                         窗口是子窗口                         |
|          `WS_VISIBLE`           | `WS_VISABLE`窗口最初可见，可以通过调用`ShowWindow()`或`SetWindowPos()`函数显示和隐藏窗口 |
|           `WS_GROUP`            | `WS_GROUP`该窗口是一组控件的第一个控件，该组由第一个具有WS_GROUP样式的控件和在其后定义的所有控件组成，直到下一个具有`WS_GROUP`样式的控件(不包括该控件)出现。如果是在对话框程序中，用户可以使用方向键将键盘焦点从组中的一个控件移动到下一个控件。另外，每个组中的第一个控件通常具有`WS_TABSTOP`样式，如果是在对话框程序中，按下Tab键可以将键盘焦点移动到下一个具有`WS_TABSTOP`样式的按件。 |
|          `WS_TABSTOP`           | 该窗口是一个控件，当用户按下Tab键时，该控件可以接收键盘焦点，如果是在对话框程序中，按下Tab键可以将键盘焦点移动到下一个具有`WS_TABSTOP`样式的控件上 |
|           `WS_BORDER`           |                      窗口有一个细线边框                      |
|          `WS_DLGFRAME`          |                   窗口具有对话框样式的边框                   |
| `WS_SIZEBOX` 或 `WS_THICKFRAME` |                     窗口具有大小调整边框                     |
|          `WS_DISABLED`          | 窗口最初被禁用，禁用的窗口无法接收用户的输入,要想启用可以调用`EnableWindow()`函数 |

其中，`WS_CHILD`和`WS_VISIBLE`是必须指定的，`WS_CHILD`表示该窗口是一个子窗口。如果不指定`WS_VISIBLE`样式，则子窗口控件不会显示。
另外，一些扩展窗口样式也可以用于子窗口控件，例如`WS_EX_ACCEPTFILES`表示该子窗口控件可以接受拖放文件。

:::



## 按钮与父窗口通信

按钮可以向其父窗口发送消息，父窗口也可以向按钮发送消息。父窗口可以通过调用`SendMessage()`或`SendDlgltemMessage()`函数发送消息到子窗口控件



:::details `SendMessage 函数说明`

```c
LRESULT	SendMessage(HWND hWnd, UINT Msg,WPARAM wParam,LPARAM lParam);

LRESULT SendDIgItemMessage(HWND hDIg, int nIDDIgltem, UINT Msg, WPARAM	wParam,LPARAM lParam);
```

- `SendDlgltemMessage()`函数的`hDlg`指的是Dialog对话框，该函数通常用于在对话框程序中向子窗口控件发送消息 `hDlg`参数指定父窗口句柄，
- `nIDDIgltem`参数指定子窗口控件ID，每个子窗口控件都有一个ID。调用`CreateWindow/CreateWindowEx`函数创建子窗口控件的时候，第10个参数`hMenu`不再指定为菜单句柄，而是指定为**子窗口控件ID**。

:::



:::tip

对于`BS_ICON`或`BS_BITMAP`样式的按钮。`BM_SETIMAGE`消息用于为按钮设置图标或位图。

- 其中`wParam`参数指定图像类型，可以是IMAGE_ICON(图标)或IMAGE_BITMAP(位图)，
- `lParam`参数可以指定为图像的句柄(HICON或HBITMAP),
- `返回值`是先前与按钮关联的图像的句柄(如果有的话)，否则返回值是NULL

:::



:::tip 



`BM_GETIMAGE`消息用于获取与按钮关联的图标或位图的句柄.

- 其中`wParam`参数指定图像类型，可以是IMAGE_ICON(图标)或IMAGE_BITMAP(位图)
- `lParam`参数没有用到，指定为0即可。
- `返回值`是与按钮关联的图像的句柄（如果有的话),否则返回值是NULL。

:::



:::tip

`BM_SETSTYLE`消息用于设置按钮的样式

- 其中`wParam`参数可以指定为按钮新样式的组合
- `lParam`参数可以指定为TRUE(重绘按钮)或FALSE(不重绘按钮)。当然,通过调用`SetWindowLongPtr()`函数也可以达到同样的目的。

:::

:::tip 

`BM_SETCHECK`消息用于设置单选按钮、复选框或三态复选框的选中状态.

- 其中`wParam`参数可以指定为BST_CHECKED (选中)、BST_UNCHECKED (取消选中)或BST_INDETERMINATE（灰色,表示不确定状态，用于三态复选框)
- `lParam`参数没有用到，指定为0即可。

:::



:::tip

`BM_GETCHECK`消息用于获取单选按钮、复选框或三态复选框的选中状态.

- `wParam`和`lParam`参数没有用到，都指定为0即可
- `返回值`可以是BST_CHECKED (已选中)、BST_UNCHECKED (未选中）或BST_INDETERMINATE(灰色，表示不确定状态，用于三态复选框)。

:::

:::tip

`BM_SETSTATE`消息用于设置普通按钮是否按下的状态.

- `wParam`参数可以指定为TRUE(突出显示，按下状态)或FALSE(取消突出显示，非按下状态)
- `lParam`参数没有用到,指定为0即可。

:::



:::tip

`BM_GETSTATE`消息用于获取普通按钮、单选按钮、复选框或三态复选框的当前状态(选中状态，是否按下和是否具有键盘焦点等)

- `wParam`和`lParam` 参数没有用到，都指定为0即可.
- 返回值可以是BST_CHECKED (已选中)、BST_UNCHECKED(未选中)、BST_INDETERMINATE(灰色，表示不确定状态，用于三态复选框)、BST_PUSHED(普通按钮处于按下状态)、BST_FOCUS(按钮具有键盘焦点)、
  BST_HOT(鼠标悬停在按钮上)、BST_DROPDOWNPUSHED(按钮处于下拉状态，并且仅当按钮具有BTNS_DROPDOWN样式时用于工具栏按钮)。

:::



:::tip

`BM_CLICK`消息可以模拟用户单击按钮

- `lParam`参数都没有用到。该消息会导致系统向按钮的父窗口发送包含BN_CLICKED通知码的WM_COMMAND消息。

:::







调用`CheckDlgButton()`或`CheckRadioButton()`函数等同于发送BM_SETCHECK消息

调用`IsDlgButtonChecked()`函数等同于发送BM_GETCHECK消息



:::details `CheckDlgButton 函数说明`

一组复选按钮中通常可以同时选中多个，而一组单选按钮中通常只能选中一个。`CheckDlgButton()`函数通常用于设置复选框的选中状态。

```c
/// <summary>
/// 设置复选按钮被选中
/// </summary>
/// <param name="hDIg">父窗口句柄</param>
/// <param name="nIDButton">子窗口控件ID</param>
/// <param name="uCheck">/设置选中状态，BST_CHECKED BST_UNCHECKED或BST_INDETERMINATE</param>
/// <returns></returns>
BOOL CheckDlgButton(HWND hDIg,int nIDButton,UINT uCheck);
```

:::



:::details `CheckRadioButton 函数说明` 



`CheckDlgButton()`函数也可以用于设置单选按钮，但是如果在一组单选按钮中选中一个，还需要多次调用`CheckDlgButton()`取消选中其他的，所以设置单选按钮的状态通常使用`CheckRadioButton()`函数，指定一组单选按钮的第一个和最后一个以及需要选中哪一个，函数会自动完成任务。

```c
/// <summary>
/// 设置单选按钮被选中
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDFirstButton">组中第一个单选按钮的ID</param>
/// <param name="nlDLastButton">组中最后一个单选按钮的ID</param>
/// <param name="nlDCheckButton">要设置选中的单选按钮的ID</param>
/// <returns></returns>
BOOL CheckRadioButton(HWND hDlg,int nlDFirstButton,int nlDLastButton,int nlDCheckButton);
```

::: 



:::details `IsDlgButtonChecked 函数说明`

```c
/// <summary>
/// 判断对话框按钮是否被选中
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDButton">子窗口控件ID</param>
/// <returns>函数返回值可以是BST_CHECKED BST_UNCHECKED或BST_INDETERMINATE</returns>
UINT IsDlgButtonChecked(HWND hDlg,int nlDButton);
```

建议使用自动单选按钮，同组的单选按钮会随着用户选中一个而自动取消选中其他单选按钮。在程序中只需要在初始化的时候设置选中哪一个，并在需要查用户选择了哪一个的时候调用`lsDlgButtonChecked()`函数检查每一个单选按钮项的选中状态即可。



同样，复选按钮也不会因为用户的单击而自动变为选中或取消选中等，因此建议使用自动复选按钮，在初始化的时候设置选中哪些，并在需要的时候调用`lsDlgButtonChecked()`函数检查每一个的状态即可。



:::





:::details `用户点击按钮产生的消息 WM_COMAND`

当用户单击按钮时，它会接收键盘焦点，系统会向按钮的父窗口发送包含`BN_CLICKED`通知码的`WM_COMMAND`消息。不过对于自动单选按钮、自动复选框或自动三态复选框通常不需要处理该消息，因为这些按钮可以自动设置其状态。如果是普通按钮，则可能需要处理该消息。



`WM_COMMAND`消息的`wParam`和`IParam`参数的含义。



|                  `HIWORD (wParam) `                   |                      `LOWORD (wParam)`                       | ` HWND(lParam)` |
| :---------------------------------------------------: | :----------------------------------------------------------: | :-------------: |
|            `菜单命今ID`  比如说，`ID_MEUN`            | 菜单项ID，比如说，记事本程序的打开菜单项ID`IDM_FILE_OPEN`,保存菜单项`IDM_FILE_SAVE` |        0        |
|                    加速键(快捷键)                     |                        菜单项ID，同上                        |        0        |
| 子窗口控件**通知码**,比如说`BN_CLICKED`按钮比点击了。 |             控件ID,比如说按钮控件的ID`ID_BUTTON`             |    控件句柄     |

> 通知码，可以类比QT中的发出的信号。
>
> ```c
>    // 为按钮绑定事件 connect(信号的发送者,发送的信号,信号的接受者,处理的函数(槽函数))
>  connect(btn, &QPushButton::clicked, this, &QWidget::close);
> ```
>
> 



`BN_SETFOCUS`: 按钮获得了键盘焦点



`BN_KILLFOCUS`:按钮失去了键盘焦点



`BN_DBLCLK`或`BN_DOUBLECLICKED` :双击按钮





获得键盘焦点的按钮周围会显示一圈虚线，此时按下空格键就相当于单击了按钮。只有具有`BS_NOTIFY`样式的按钮会发送`BN_SETFOCUS`  `BN_KILLFOCUS`和`BN_DBLCLK`通知码，但是无论如何设置按钮样式，单击按钮都会发送`BN_CLICKED`通知码。





:::



:::warning



`BS_GROUPBOX`样式表示分组框，用于对其他控件进行分组，由一个矩形和显示在矩形左上角的文本组成。分组框不会获得键盘焦点，既不处理鼠标或键盘输入，也不会导致系统发送`WM_COMMAND`消息到父窗口。

:::







:::details `对于按钮类的自绘消息WM_DRAWITEM`

对于自绘按钮、组合框和列表框等，程序只需要在必要的时候负责绘制它们的外观即可，系统会正常处理用户和这些控件的交互，例如用户单击控件，系统会向父窗口发送`WM_COMMAND`消息。在介绍自绘菜单的时候说过，`WM_DRAWITEM`消息既用于菜单项，**也用于其他些子窗口控件的自绘**，当菜单项或子窗口控件需要自绘的时候,窗口过程会收到`WM_DRAWITEM`消息。





如果WM_DRAWITEM消息是由子窗口控件发送的，则`wParam`参数是子窗口控件的ID

如果是由菜单项发送的，则`wParam`参数为0。`lParam`参数是一个指向`DRAWITEMSTRUCT`结构的指针

```c
typedef struct tagDRAWITEMSTRUCT
{
	UINT	ctlType;//控件类型，如果是ODT_MENU，表示菜单项
	UINT	CtlID;//该字段不用于菜单项
	UINT	itemID;//菜单项ID
	UINT	itemAction; //所需的绘制操作
	UINT	itemState;//新的状态
	HWND	hwndItem;//菜单句柄
	HDC	hDC;//设备环境句柄
	RECT	rcItem;//绘制区域
	ULONG_PTR	itemData;//程序自定义数据，最初由MENUITEMINFO结构的dwltemData指定的
}DRAWITEMSTRUCT,NEAR *PDRAWITEMSTRUCT，FAR *LPDRAWITEMSTRUCT;
```

:::



:::details `按钮类示例:`



接下来实现一个例子，Buttons程序在窗口客户区中使用系统预定义的Button类调用`CreateWindowEx()`函数分别创建了普通按钮、图标按钮、位图按钮、自绘按钮、一组自动单选按钮、一组自动复选按钮、一组自动三态复选按钮、默认按钮。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6.gif)

:::





:::details `resource.h`

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 Buttons.rc 使用
//
#define IDB_KONGLONG                    101
#define IDI_SMILE                       102

#define IDC_PUSHBUTTON          1000
#define IDC_ICONBUTTON          1001
#define IDC_BITMAPBUTTON        1002
#define IDC_OWNERDRAWBUTTON     1003
#define IDC_GROUPBOX1           1004
#define IDC_AUTORADIOBUTTON1    1005
#define IDC_AUTORADIOBUTTON2    1006
#define IDC_AUTORADIOBUTTON3    1007
#define IDC_GROUPBOX2           1008
#define IDC_AUTOCHECKBOX1       1009
#define IDC_AUTOCHECKBOX2       1010
#define IDC_AUTOCHECKBOX3       1011
#define IDC_GROUPBOX3           1012
#define IDC_AUTO3STATE1         1013
#define IDC_AUTO3STATE2         1014
#define IDC_AUTO3STATE3         1015
#define IDC_DEFPUSHBUTTON       1016

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240114231846364-17052455277211-17052455358562.png)

:::



:::details `main.cpp`

```c
#include <Windows.h>
#include <tchar.h>
#include <strsafe.h>
#include "resource.h"


LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID OnDefPushButton(HWND hwnd);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("Buttons");  
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 300, 600, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
struct
{
    int     m_nStyle;
    PTSTR   m_pText;
}Buttons[] = {
    BS_PUSHBUTTON | BS_NOTIFY | WS_TABSTOP,                 TEXT("普通按钮"), // CtrlID 1000
    BS_ICON | BS_NOTIFY | WS_TABSTOP,                       TEXT("图标按钮"),
    BS_BITMAP | BS_NOTIFY | WS_TABSTOP,                     TEXT("位图按钮"),
    BS_OWNERDRAW,                                           TEXT("自绘按钮"),

    BS_GROUPBOX,                                            TEXT("政治面貌"), // CtrlID 1004
    BS_AUTORADIOBUTTON | BS_NOTIFY | WS_GROUP | WS_TABSTOP, TEXT("中共党员"),
    BS_AUTORADIOBUTTON | BS_NOTIFY,                         TEXT("共青团员"),
    BS_AUTORADIOBUTTON | BS_NOTIFY,                         TEXT("无党派人士"),

    BS_GROUPBOX,                                            TEXT("个人爱好"), // CtrlID 1008
    BS_AUTOCHECKBOX | BS_NOTIFY | WS_GROUP | WS_TABSTOP,    TEXT("看书"),
    BS_AUTOCHECKBOX | BS_NOTIFY,                            TEXT("唱歌"),
    BS_AUTOCHECKBOX | BS_NOTIFY,                            TEXT("听音乐"),

    BS_GROUPBOX,                                            TEXT("荣誉称号"), // CtrlID 1012
    BS_AUTO3STATE | BS_NOTIFY | WS_GROUP | WS_TABSTOP,      TEXT("团队核心"),
    BS_AUTO3STATE | BS_NOTIFY,                              TEXT("技术能手"),
    BS_AUTO3STATE | BS_NOTIFY,                              TEXT("先进个人"),

    BS_DEFPUSHBUTTON | BS_NOTIFY | WS_TABSTOP,              TEXT("默认按钮"), // CtrlID 1016
};
#define NUM (sizeof(Buttons) / sizeof(Buttons[0]))
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND hwndButton[NUM];                // 子窗口控件句柄数组
    int arrPos[NUM] = { 10, 40, 70, 100,         // 每个子窗口控件的起始Y坐标
        130, 150, 180, 210,
        250, 270, 300, 330,
        370, 390, 420, 450,
        490 };
    LPDRAWITEMSTRUCT lpDIS;
    if (WM_CREATE == uMsg)
    {
        // 创建17个子窗口控件
        for (int i = 0; i < NUM; i++)
        {
            hwndButton[i] = ::CreateWindowEx(
                0,
                TEXT("Button"),
                Buttons[i].m_pText,
                WS_CHILD | WS_VISIBLE | Buttons[i].m_nStyle,
                20, arrPos[i],
                150, 25,
                hwnd,
                (HMENU)(1000 + i),
                ((LPCREATESTRUCT)lParam)->hInstance, NULL);
        }
        // 移动3个分组框的位置
        ::MoveWindow(hwndButton[4], 10, arrPos[4], 170, 115, TRUE);
        ::MoveWindow(hwndButton[8], 10, arrPos[8], 170, 115, TRUE);
        ::MoveWindow(hwndButton[12], 10, arrPos[12], 170, 115, TRUE);

        // 为图标按钮、位图按钮设置图标、位图
        HANDLE hImage = ::LoadImage(((LPCREATESTRUCT)lParam)->hInstance, MAKEINTRESOURCE(IDI_SMILE), IMAGE_ICON, 20, 20, LR_DEFAULTCOLOR); //根据resourceID 查图片句柄
        ::SendDlgItemMessage(hwnd, IDC_ICONBUTTON, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hImage); //给按钮设置图标

        HBITMAP hBitMap = ::LoadBitmap(((LPCREATESTRUCT)lParam)->hInstance, MAKEINTRESOURCE(IDB_KONGLONG));// 根据resourceID 查位图句柄
        ::SendDlgItemMessage(hwnd, IDC_BITMAPBUTTON, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitMap);  //给按钮设置位图
        ::SetDlgItemText(hwnd, IDC_DEFPUSHBUTTON, TEXT("获取单选复选状态"));        // 设置默认按钮的文本

        // 单选按钮组、复选按钮组、三态复选按钮组，默认情况下分别选中一项
        ::CheckRadioButton(hwnd, IDC_AUTORADIOBUTTON1, IDC_AUTORADIOBUTTON3, IDC_AUTORADIOBUTTON2);
        ::CheckDlgButton(hwnd, IDC_AUTOCHECKBOX3, BST_CHECKED);
        ::CheckDlgButton(hwnd, IDC_AUTO3STATE2, BST_INDETERMINATE);

        return 0;

    }
    else if (WM_COMMAND == uMsg)
    {

        if (HIWORD(wParam) == BN_CLICKED)
        {
            // 子窗口控件ID常量定义请参见resource.h，可以根据需要在此处理每个控件的点击事件
            if (LOWORD(wParam) == IDC_PUSHBUTTON)
            {
            }
            else if (LOWORD(wParam) == IDC_ICONBUTTON)
            {
            }
            else if (LOWORD(wParam) == IDC_BITMAPBUTTON)
            {
            }
            else if (LOWORD(wParam) == IDC_OWNERDRAWBUTTON)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTORADIOBUTTON1)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTORADIOBUTTON2)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTORADIOBUTTON3)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTOCHECKBOX1)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTOCHECKBOX2)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTOCHECKBOX3)
            {

            }
            else if (LOWORD(wParam) == IDC_AUTO3STATE1)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTO3STATE2)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTO3STATE3)
            {
            }
            else if (LOWORD(wParam) == IDC_DEFPUSHBUTTON)
            {
                OnDefPushButton(hwnd);
            }
        }
        return 0;
    }
    else if (WM_DRAWITEM == uMsg)
    {
        //按钮重绘
        lpDIS = (LPDRAWITEMSTRUCT)lParam;

        // 先把按钮矩形填充为和窗口背景一致的白色，然后画一个黑色圆角矩形
        ::SelectObject(lpDIS->hDC, GetStockObject(NULL_PEN));
        ::SelectObject(lpDIS->hDC, GetStockObject(WHITE_BRUSH));

        ::Rectangle(lpDIS->hDC, 0, 0, lpDIS->rcItem.right + 1, lpDIS->rcItem.bottom + 1);
        ::SelectObject(lpDIS->hDC, GetStockObject(BLACK_BRUSH));
        ::RoundRect(lpDIS->hDC, 0, 0, lpDIS->rcItem.right + 1, lpDIS->rcItem.bottom + 1, 20, 20);

        // 当用户点击按钮的时候，绘制COLOR_HIGHLIGHT颜色的圆角矩形
        if (lpDIS->itemState & ODS_SELECTED)
        {
            SelectObject(lpDIS->hDC, GetSysColorBrush(COLOR_HIGHLIGHT));
            RoundRect(lpDIS->hDC, 0, 0, lpDIS->rcItem.right + 1, lpDIS->rcItem.bottom + 1, 20, 20);
        }
        if (lpDIS->itemState & ODS_FOCUS)
        {
            ::InflateRect(&lpDIS->rcItem, -2, -2);
            ::DrawFocusRect(lpDIS->hDC, &lpDIS->rcItem);
        }
        // 自绘按钮的文本，透明背景的白色文字
        ::SetBkMode(lpDIS->hDC, TRANSPARENT);
        ::SetTextColor(lpDIS->hDC, RGB(255, 255, 255));
        ::DrawText(lpDIS->hDC, TEXT("自绘按钮"), _tcslen(TEXT("自绘按钮")), &lpDIS->rcItem, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        // 恢复设备环境
        ::SelectObject(lpDIS->hDC, GetStockObject(BLACK_PEN));
        ::SelectObject(lpDIS->hDC, GetStockObject(WHITE_BRUSH));
    }
    else if (WM_DESTROY == uMsg)
    {
        PostQuitMessage(0);
        return 0;
    }
    return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

VOID OnDefPushButton(HWND hwnd)
{
    TCHAR szBuf[128] = { 0 };

    //查自动单选按钮 哪一项被选中了
    if (::IsDlgButtonChecked(hwnd, IDC_AUTORADIOBUTTON1) & BST_CHECKED)
    {
        ::StringCchCopy(szBuf, _countof(szBuf), TEXT("政治面貌：中共党员\n"));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTORADIOBUTTON2) & BST_CHECKED)
    {
        ::StringCchCopy(szBuf, _countof(szBuf), TEXT("政治面貌：共青团员\n"));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTORADIOBUTTON3) & BST_CHECKED)
    {
        ::StringCchCopy(szBuf, _countof(szBuf), TEXT("政治面貌：无党派人士\n"));
    }
    //查自动复选按钮中 哪一个自动复选按钮项被选中了
    ::StringCchCat(szBuf, _countof(szBuf), TEXT("个人爱好："));
    if (::IsDlgButtonChecked(hwnd, IDC_AUTOCHECKBOX1) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("看书 "));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTOCHECKBOX2) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("唱歌 "));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTOCHECKBOX3) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("听音乐"));
    }
    ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n"));
    ::StringCchCat(szBuf, _countof(szBuf), TEXT("荣誉称号："));
    //查 自动三态复选按钮 哪一个自动三态复选按钮被选中了
    if (::IsDlgButtonChecked(hwnd, IDC_AUTO3STATE1) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("团队核心 "));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTO3STATE2) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("技术能手 "));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTO3STATE3) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("先进个人"));
    }
    ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n"));
    ::MessageBox(hwnd, szBuf, TEXT("个人简介汇总"), MB_OK);
}
```

在`WM_CREATE`消息中，程序使用系统预定义的Button类调用`CreateWindowEx`函数分别创建了17个子窗口控件，`lpWindowName`参数对于普通重叠窗口或弹出窗口来说是窗口标题，对于按钮来说是显示在按钮上的文本;窗口位置参数x和y指定子窗口左上角的位置，相对于父窗口客户区左上角;宽
度和高度参数nWidth和nHeight指定每个子窗口的宽度和高度;因为创建的是子窗口，所以父窗口参数hWndParent指定为hwnd;对于普通重叠窗口或弹出窗口来说，hMenu参数指定菜单句柄，对于子窗口来说，则用于指定其ID，每个子窗口的ID应该是唯一的，在
`WM_COMMAND`消息中通过子窗口ID来确定是从哪个子窗口发送过来的消息。



然后调用MoveWindow函数改变3个分组框的位置和大小，让每个分组框可以包围相应的组。分组框没有什么实际意义，仅仅提供一种视觉上的分组效果。一个组的界定依靠的是`WS_GROUP`样式，一个组由第一个具有`WS_GROUP`样式的控件和在其后定义的所有控件组成，直到下一个具有`WS_GROUP`样式的控件出现。



然后程序调用`SendDlgltemMessage`函数向图标按钮和位图按钮分别发送`BM_SETIMAGE`消息设置其图像。资源脚本文件中的图标大小是32 32，而按钮大小为150 25，因此加载图标用的是`Loadlmage`函数，该函数可以指定图标的宽度和高度。资源脚本文件中的恐龙位图大小正好是150 25，所以使用`LoadBitmap`函数直接加载即可。最后一个子窗口控件是默认按钮，程序调用`SetDlgltemText`函数改变按钮文本为"获取单选复选状态"。



:::





:::details `SetWindowsText 函数说明`



`SetWindowText`函数可以设置指定程序窗口的窗口标题，也可以设置子窗口控件的文本

```c
/// <summary>
/// 设置指定程序窗口的窗口标题
/// </summary>
/// <param name="hWnd">程序窗口或控件的句柄，其文本将被更改</param>
/// <param name="lpString">新窗口标题或控件文本</param>
/// <returns></returns>
BOOL WINAPI SetWindowText(HWND hWnd,LPCTSTR lpString); 
```

也可以通过发送`WM_SETTEXT`消息达到同样的目的。但如果是设置其他程序中的窗口标题或控件文本，则需要发送`WM_SETTEXT`消息，而不能调用`SetWindowText` 

:::





:::details `GETWindowsText 函数说明`

`GetWindowText`函数用于获取指定程序窗口的窗口标题或子窗口控件的文本

```c

/// <summary>
/// 获取指定窗口的文本标题
/// </summary>
/// <param name="hWnd">程序窗口或控件的句柄</param>
/// <param name="lpString">接收文本的缓冲区</param>
/// <param name="nMaxCount">缓冲区的大小，以字符为单位</param>
/// <returns></returns>
int WINAPI GetWindowText(HWND hWnd,LPTSTR lpString,int nMaxCount);
```

也可以通过发送`WM_GETTEXT`消息达到同样的目的。但如果是获取其他程序中的窗口标题或控件文本，则需要发送`WM_GETTEXT`消息，而不能调用`GetWindowText`



在获取指定程序窗口的窗口标题或子窗口控件的文本前，可以先调用`GetWindowTextLength`函数获取其文本的长度。

```c
int WINAPI GetWindowTextLength(HWND hWnd);
```

也可以通过发送`WM_GETTEXTLENGTH`消息达到同样的目的。但如果是获取其他程序中的窗口标题或控件文本长度，则需要发送`WM_GETTEXTLENGTH`消息，而不能调用`GetWindowTextLength`.

:::





:::details `GetDlgItem 函数说明`

对于子窗口控件，`SetWindowText`和`GetWindowText`函数需要提供子窗口控件句柄，这可能需要先调用`GetDlgltem`函数获取子窗口控件句柄︰

```c
/// <summary>
/// 获取子窗口控件句柄
/// </summary>
/// <param name="hDIg">父窗口句柄</param>
/// <param name="nlDDIgltem">子窗口控件ID</param>
/// <returns></returns>
HWND WINAPI GetDlgItem(HWND hDIg,int nlDDIgltem)
```

:::



:::details `函数说明GetDlgCtrlID 函数说明`

如果已经知道了子窗口控件句柄，可以通过调用`GetDlgCtrlID`函数获取其ID∶

```c
/// <summary>
/// 获取子窗口控件ID
/// </summary>
/// <param name="hwndCtl">子窗口控件句柄</param>
/// <returns></returns>
int WINAPI GetDlgCtrlID(HWND hwndCtl);
```

当然，要获取子窗口控件ID，还可以通过指定GWLP_ID索引调用`GetWindowLongPtr`函数获取。

:::



:::details `G/SetDlgItemText 函数说明`

要获取子窗口控件文本，还有一个更简单的函数︰

```c
/// <summary>
/// 获取对话框文本内容
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDDlgltem">子窗口控件ID</param>
/// <param name="lpString">接收文本的缓冲区</param>
/// <param name="nMaxCount">缓冲区的长度，以字符为单位</param>
/// <returns></returns>
UINT  GetDlgItemText(HWND hDlg,int nlDDlgltem,LPTSTR lpString, int nMaxCount); 
```

要设置子窗口控件文本可以使用SetDlgltemText函数

```c
/// <summary>
/// 设置子窗口控件文本
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nIDDlgltem">子窗口控件ID</param>
/// <param name="lpString">字符串指针</param>
/// <returns></returns>
BOOL WINAPI SetDlgltemText(HWND hDlg, int nIDDlgltem,LPCTSTR lpString); 
```

上面这两个函数实际上也是通过发送`WM_GETTEXT`和`WM_SETTEXT`消息实现的。

:::



再介绍两个函数。要接收鼠标和键盘输入，子窗口必须是可见（显示）并且启用的。如果一个子窗口是可见的，但是没有启用，那么子窗口中的文本是灰色的。如果在创建子窗口的时候没有指定`WS_VISIBLE`样式，则子窗口将不会显示，程序可以通过调用ShowWindow函数来显示∶

```c
ShowWindow(hwndChild,SW_SHOW);
```

程序可以通过调用以下语句来隐藏一个子窗口∶

```c
ShowWindow(hwndChild,SW_HIDE);
```

可以通过调用`IsWindowVisible`函数来判断一个窗口是否可见:

```c
lsWindowVisible(hwnd);
```

可以通过调用EnableWindow函数后用或禁用指定的窗口或子窗口控件。窗口禁用以后无法接收鼠标和键盘输入:

```c
/// <summary>
/// 是否启用窗口
/// </summary>
/// <param name="hWnd">窗口或子窗口控件句柄</param>
/// <param name="bEnable">TRUE表示后用，FALSE表示禁用</param>
/// <returns></returns>
BOOL  EnableWindow(HWND hWnd,BOOL bEnable);
```

可以通过调用lsWindowEnabled函数来判断一个窗口或子窗口控件是否处于启用状态∶

```c
BOOL WINAPI lsWindowEnabled(_ln_ HWND hWnd);
```

## 系统颜色

Windows提供了几十种系统预定义的颜色，用于显示窗口、菜单栏、工具栏、滚动条、按钮等不同的部分。程序可以通过调用`GetSysColor`函数获取这些颜色值，也可以通过调用`SetSysColors`函数改变系统预定义的颜色值，但是这会影响其他程序。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/SysColors.png)



## 控件的子类化与超类化



:::details `G/SetParent 函数说明`



GetParent函数用于获取指定窗口的父窗口句柄︰

```c
HWND  GetParent(HWND hWnd);
```

与之对应的，还有一个`SetParent`函数用于设置一个窗口的父窗口∶

```c
/// <summary>
/// 指定一个窗口为自己的父窗口
/// </summary>
/// <param name="hWndChild">子窗口句柄</param>
/// <param name="hWndNewParent">新父窗口句柄</param>
/// <returns></returns>
HWND WINAPI SetParent(HWND hWndChild,HWND hWndNewParent); 
```

如果函数执行成功，则返回值是前一个父窗口的句柄。如果函数执行失败，则返回值为NULL。

:::





:::details `CallWindowsProc 函数说明`

CallWindowProc函数用于把新窗口过程未处理的消息传递给原窗口过程∶

```c

/// <summary>
/// 用于新窗口过程未处理的消息传递给原窗口过程
/// </summary>
/// <param name="lpPrevWndFunc">原窗口过程</param>
/// <param name="hWnd"></param>
/// <param name="Msg"></param>
/// <param name="wParam"></param>
/// <param name="lParam"></param>
/// <returns></returns>
LRESULT  CallWindowProc(WNDPROC lpPrevWndFunc, HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);
```

:::





重叠窗口中子窗口控件的默认窗口过程无法满足我们的要求，为此调用SetWindowLongPtr函数为子窗口控件设置一个新的窗口过程。拦截控件的部分消息进行处理，这就是**控件的子类化**。





:::details `S/Get/RemoveWindowSubclass 函数说明`

`SetWindowSubclass`函数为需要子类化的窗口设置新的窗口过程

```c
/// <summary>
/// 设置子窗口控件的窗口过程
/// </summary>
/// <param name="hWnd">要子类化的窗口句柄</param>
/// <param name="pfnSubclass">指向新子类窗口过程的指针</param>
/// <param name="uldSubclass">子类ID，该参数与pfnSubclass参数一起唯一标识一个子类</param>
/// <param name="dwRefData">用户自定义数据，传递给新子类窗口过程的dwRefData参数</param>
/// <returns></returns>
BOOL SetWindowSubClass(HWND hWnd, SUBCLASSPROC pfnSubclass,UINT_PTR uldSubclass, DWORD_PTR dwRefData); 
```

`SetWindowSubclass`函数需要引入头文件`CommCtrl.h`，还需要使用导入库`Comctl32.lib`。在引入相关头文件以后，添加以下预编译指令。

```c
#include <Commctrl.h>
#pragma comment(lib, "Comctl32.lib")
```

要获取子类窗口的自定义数据，可以调用`GetWindowSubclass`函数∶

```c
/// <summary>
/// 获取子类窗口的自定义数据
/// </summary>
/// <param name="hWnd"子类窗口句柄></param>
/// <param name="pfnSubclass">子类窗口过程</param>
/// <param name="uldSubclass">子类ID</param>
/// <param name="pdwRefData">在这里返回自定义数据的指针</param>
/// <returns></returns>
BOOL GetWindowSubclass(HWND hWnd,SUBCLASSPROC pfnSubclass, UINT_PTR uldSubclass,DWORD_PTR* pdwRefData);
```

:::





:::details `RemoveWindowSubclass 函数说明`

`RemoveWindowSubclass`函数用于删除一个子类

```c

/// <summary>
/// 删除一个子类
/// </summary>
/// <param name="hWnd">窗口句柄</param>
/// <param name="pfnSubclass"> 子类ID</param>
/// <param name="uldSubclass">子类窗口过程</param>
/// <returns></returns>
BOOL RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass,UINT_PTR uldSubclass); 
```

:::



## 命令链接按钮与拆分按钮



:::tip 命令链接按钮

命今链接按钮是通用控件版本6中引入的一种按钮。指定`BS_COMMANDLINK`样式可以创建一个命今链接按钮，左侧有一个蓝色箭头指向按钮文本，按钮文本下面可以显示一些说明文字作为按钮文本的补充。要设置按钮文本，可以通过调用`SetWindowText/SetDlgltemText`函数或发送`WM_SETTEXT`消息来进行。要设置说明文字，可以通过发送`BCM_SETNOTE`消息来进行，该消息的`wParam`参数没有用到，将`IParam`参数指定为字符串指针。

:::





:::tip 

拆分按钮也是通用控件版本6中引入的一种按钮。指定`BS_SPLITBUTTON`样式可以创建一个拆分按钮。拆分按钮分为两部分，左侧是主要部分，类似于普通或默认按钮﹔右侧有一个下拉箭头，单击箭头通常会弹出一个菜单。单击下拉箭头，系统会发送包含`BCN_DROPDOWN`通知码的`WM_NOTIFY`消息。和其他按钮一样，单击命合链接按钮和拆分按钮的左侧会发送包含`BN_CLICKED`通知码的`WM_COMMAND`消息。

:::



:::details `拆分按钮的WM_NOTIFY消息`



`WM_NOTIFY`消息的`wParam`参数是控件的ID，不过通常不使用这个参数，而是使用`IParam`参数。`lParam`参数通常是一个指向`NMHDR`结构的指针，该结构包含通知码和一些附加信息。



对于其他通知码，`lParam参`数可能是指向一个更大结构的指针，但是这些结构的第一个字段总是NMHDR结构，所以把`lParam`参数强制转换为指向NMHDR结构的指针总是正确的。NMHDR结构定义如下∶

```c
typedef struct tagNMHDR
{
	HWND hwndFrom;//控件的窗口句柄
	UINT_PTR idFrom; // 控件的ID
	UINT code; // 通知码
} NMHDR;
```



处理`WM_NOTIFY`消息的代码通常如下，先把`IParam`参数转换为指向`NMHDR`结构的指针，确定通知码的类型，然后才可以进一步确定`lParam`指向的是什么结构∶

```c
case WM_NOTIFY:
{ 
    switch ((LPNMHDR)IParam)->code)
    {
    case BCN_DROPDOWN:
        // BCN_DROPDOWN通知码的IParam参数是一个指向NMBCDROPDOWN结构的指针把lParam参数转换为指向NMBCDROPDOWN结构的指针，然后使用结构中的字段
            break;
    case 其他通知码:
       //对于其他通知码，lParam参数可能是指向其他数据结构的指针
            break;
}
return 0;
```

如果程序需要发送`WM_NOTIFY`消息，`SendMessage`函数的窗口句柄参数需指定为父窗口句柄，例如:

```c
NMHDR nmh;
nmh.hwndFrom = hwndCtrl;//控件窗口句柄
nmh.idFrom = GetDlgCtrlID(hwndCtrl); //控件ID
nmh.code = 通知码; //通知码
SendMessage(GetParent(hwndCtrl), WM_NOTIFY, nmh.idFrom, (LPARAM)&nmh);
```

`BCN_DROPDOWN`通知码的`IParam`参数是一个指向`NMBCDROPDOWN`结构的指针。

```c
typedef struct tagNMBCDROPDOWN
{
	NMHDR hdr;
	RECT rcButton;// 按钮的矩形区域，相对于自己的客户区左上角
}NMBCDROPDOWN,*LPNMBCDROPDOWN;
```

:::





:::details `示例:`

举一个例子，单击拆分按钮的下拉箭头，系统会发送一个包含
BCN_DROPDOWN通知码的WM_NOTIFY消息。程序处理该消息弹出一个菜单。

```c
#include <Windows.h>
#include <Commctrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker, "\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("CommandLinkAndSplitButton");    
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HINSTANCE hInstance;
    NMBCDROPDOWN* pDropDown;
    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;

        CreateWindowEx(0, TEXT("Button"), TEXT("命令链接按钮"),
            WS_CHILD | WS_VISIBLE | BS_COMMANDLINK, 10, 10, 200, 50, hwnd,
            (HMENU)IDC_COMMANDLINK, hInstance, NULL);
        SendDlgItemMessage(hwnd, 1000, BCM_SETNOTE, 0, (LPARAM)TEXT("这是一个命令链接按钮"));

        CreateWindowEx(0, TEXT("Button"), TEXT("拆分按钮"),
            WS_CHILD | WS_VISIBLE | BS_SPLITBUTTON, 10, 70, 200, 30, hwnd,
            (HMENU)IDC_SPLITBUTTON, hInstance, NULL);
        return 0;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case ID_EDIT_CUT:
            MessageBox(hwnd, TEXT("ID_EDIT_CUT"), TEXT("提示"), MB_OK);
            break;
        case ID_EDIT_COPY:
            MessageBox(hwnd, TEXT("ID_EDIT_COPY"), TEXT("提示"), MB_OK);
            break;
        case ID_EDIT_PASTE:
            MessageBox(hwnd, TEXT("ID_EDIT_PASTE"), TEXT("提示"), MB_OK);
            break;

        case IDC_COMMANDLINK:
            MessageBox(hwnd, TEXT("点击了命令链接按钮"), TEXT("提示"), MB_OK);
            break;
        case IDC_SPLITBUTTON:
            MessageBox(hwnd, TEXT("点击了拆分按钮"), TEXT("提示"), MB_OK);
            break;
        }
        return 0;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case BCN_DROPDOWN:
            pDropDown = (NMBCDROPDOWN*)lParam;
            if (pDropDown->hdr.hwndFrom = GetDlgItem(hwnd, IDC_SPLITBUTTON))
            {
                POINT pt;
                HMENU hMenu;
                pt.x = pDropDown->rcButton.left;
                pt.y = pDropDown->rcButton.bottom;
                // 拆分按钮的矩形客户区坐标转换为屏幕坐标
                ClientToScreen(pDropDown->hdr.hwndFrom, &pt);
                hMenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDR_MENU));
                TrackPopupMenu(GetSubMenu(hMenu, 0), TPM_LEFTALIGN | TPM_TOPALIGN, 
                    pt.x, pt.y, 0, hwnd, NULL);
            }
            break;
        }
        return 0;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240623170905457.png)

:::



## 编辑控件

编辑控件通常叫作编辑框或文本框，是一个矩形窗口，可以用于输入和编辑文本，编辑控件的应用比较广泛。



:::details `编辑控件样式表`

|       样式       |                             含义                             |
| :--------------: | :----------------------------------------------------------: |
|  `ES_MULTILINE`  | 编辑控件默认为单行编辑控件，指定ES_MULTILIE样式表示创建一个多行编辑控件 |
| `ES_AUTOHSCROLL` | 对于单行编辑控件。当用户输入文本时，如果文本字数填满了编辑控件，则无法维续输入。指定该样式以后。在必要时编辑控件会自动水平滚动。这样一来用户输入的文本字数就不受编辑控件的长度影响。对于多行编辑控件，如果没有指定然S_ATOHBSCDOL样式。当用户输入的文本多于可在单行上显示的字数时，文本将自动换行显示到下一行﹔如果指定了ES_AUTOHSCROLL样式，则当用户输入的文本多于可在单行上显示的字数时，控件将自动水平滚动，文字不会换行 |
| `ES_AUTOVSCROLL` | 仅适用于多行编辑控件。如果没有指定该样式。当用户输入的文本行数高于‘编辑控件的高度时，无法继续输入。在指定该样式后，在必要时的编辑控件会自动垂直滚动，这样一来用户输入的文本行数就不受编辑控件的高度影响 |
|    `ES_LEFT`     |                    文本在编辑控件中左对齐                    |
|    `ES_RIGHT`    |                    文本在编辑控件中右对齐                    |
|   `ES_CENTER`    | 文本在编辑控件中居中对齐.右对齐和居中对齐的多行编辑控件不能具有ES_AUTOHSCROLL样式，即不能自动水平滚动，超过一行限制以后会自动换行显示 |
|  `ES_LOWERCASE`  |                输入的所有大写字母都转换为小写                |
|  `ES_UPPERCASE`  |                输入的所有小写字母都转换为大写                |
|   `ES_NUMBER`    |                   只能在编辑控件中输入数字                   |
|  `ES_READONLY`   |        将编辑控件设置为只读模态,不允许编辑其中的文本         |
|  `ES_PASSWORD`   | 将单行编辑控件中的所有字符显示为星号，版本6中显示为黑圆圈〈如果需要显示为其他字符﹐可以通过发送`EM_SETPASSWORDCHAR`消息进行设置，该样式通常用于密码一类的敏感信息 |
|  `ES_NOHIDESEL`  | 默认情况下，当编辑控件失去输入焦点时，所选中的文本会失去突出显示。在指定该样式后，即使编辑控件失去输入焦点，所选中的文本也会突出显示 |
| `ES_WANTRETURN`  | 对于对话框程序中的多行编辑控件，如果没有指定ES_WANTRETURN样式，当用户按下`Enter`键时。不会换行，不过可以按`Ctrl +Enter`组合键进行换行。在指定该样式后，按下`Enter`键就可以换行。 |

默认情况下，编辑控件是没有边框的，可以指定WS_BORDER窗口样式为其添加一个边框。当然，`WS_CHILD |WS_VISIBLE`窗口样式是子窗口控件必不可少的。如果需要为编辑控件添加水平或垂直滚动条，可以指定`WS_HSCROLL`或`WS_VSCROLL`窗口样式。





系统在创建编辑控件时，会自动创建文本缓冲区，并设置其初始大小，默认情况下最大缓冲区大小约为32KB个字符，有时候可能需要限制用户输入。比如有一个用户名文本框，可能想限制用户最多可以输入20个字符，有时候可能需要比32KB更大的缓冲区，可以通过向编辑控件发送`EM_SETLIMITTEXT`(和`EM_LIMITTEXT`相同）消息来设置缓冲区大小，将`wParam`参数指定为最大字符数，没有用到`lParam`参数。



对于单行编辑控件，可以设置的最大字符数为Ox7FFFFFFE(约2G);

对于多行编辑控件，可以设置为系统支持的最大大小，如果`wParam`参数为0，则表示使用可用的最大大小。

:::





对于每个编辑控件，系统维护一个**只读标志**，指示控件的文本是可读可写(默认）或只读，可以通过向控件发送`EM_SETREADONLY`消息来设置文本的可读可写或只读标志，`wParam`参数为TRUE表示只读,FALSE表示可读可写，没有用到`lParam`参数。



确定编辑控件是否为只读，而没有名为`EM_GETREADONLY`的消息，可以使用
`GWL_STYLE`常量调用`GetWindowLongPtr`函数获取控件样式(`ES_READONLY`) 。





:::tip 设置编辑控件的文本



可以通过调用`SetWindowText/SetDlgltemText`函数或发送`WM_SETTEXT`消息来设置编辑控件的文本，这几个设置窗口文本的方法对于所有窗口几乎都适用。当然，还有` GetWindowText / GetDlgltemText`和`WM_GETTEXT`消息。



:::





有时候需要把一个数值型数据显示到编辑控件中，或者从编辑控件中获取一个字符串作为数值型使用，将文本转换为数值或将数值转换为文本需要额外的函数调用。为了简化操作，Windows提供了两个函数来处理这个问题。





:::details `SetDlgltemInt 函数说明`



`S/GetDlgltemInt`函数可以把一个数值型数据显示到编辑控件中

```c
/// <summary>
/// 把一个数值型数据显示到编辑控件中
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDDlgltem">编辑控件ID</param>
/// <param name="uValue">数值型数据</param>
/// <param name="bSigned">指示uValue参数是有符号还是无符号数</param>
/// <returns></returns>
BOOL  SetDlgItemInt(HWND hDlg, int nlDDlgltem,UINT uValue, BOOL bSigned);
```

- 参数`bSigned`指示uValue参数是有符号数还是无符号数。如果该参数为TRUE且uValue小于0，则在编辑控件中的第一个数字之前会添加-个减号﹔如果该参数为FALSE，则把uValue视为无符号数。

```c

/// <summary>
/// 获取一个字符串并返回数值型
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDDlgltem">编辑控件ID</param>
/// <param name="lpTranslated">函数执行成功还是失败，返回TRUE表示成功FALSE表示失败</param>
/// <param name="bSigned">是否检查编辑控件中的字符串开头有没有减号</param>
/// <returns></returns>
UINT  GetDlgltemInt(HWND hDlg, int nlDDlgltem, BOOL* lpTranslated,BOOL bSigned);
```

- 参数`bSigned`表示是否检查编辑控件中的字符串开头有没有减号。如果该参数为TRUE并且在字符串开头发现了减号，则返回有符号整数值，在这种情况下需要把返回值强制转换为int类型;否则返回无符号整数值。
- 因为函数返回值是从编辑控件中获取到的十进制数值，所以通过参数`lpTranslated`表示函数执行结果，返回TRUE表示成功，FALSE表示失败。如果不需要检查函数执行成功还是失败，可以将该参数设置为NULL

:::



除了上面介绍的消息，下表所示的消息也可以用于编辑控件，不过这些消息**通常用于多行编辑控件**。多行编辑控件可以用于实现一个简单的文本编辑器。





:::details `多行文本控件样式表`

|     消息类型      |                             含义                             |
| :---------------: | :----------------------------------------------------------: |
|     `EM_UNDO`     | 撤销最近—次的编辑操作，即除刚刚插入的文本或恢复刚刚已删除的文本，例如:`SendMessage (hwndEdit,EM_UNDO,0,0);` |
|   `EM_CANUNDO`    | 编辑控件的撤销队列是否不为空，即能不能撤销上次的扁辑操作，如果可以，返回TRUE，例如:`bResult = SendMessage(hwndEdit,EM_CANUNDo,0,0) ;` |
| `EM_GETLINECOUNT` | 获取多行编辑控件的总行数，例如:`nCount = SendMessage(hwndEdit，EM_GETLINECOUNT，0，0);` |
|  `EM_LINELENGTH`  | 对于单行编辑控件`wParam`和 `lParam`参数都没有用到，直接返回单行编辑控件中的字符个数，不包含终止空字符；                                                                           对于多行编辑控件。`wParam`指定为一个字符的字符索引（第1行第1个字符索引为0)，没有用到lParam参数，返回指定字符所在行的字符个数，比如说下面的多行编辑控件:![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240123222036685-17191526236041.png) |
|  `EM_LINELENGTH`  | ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240123222209532-17191526582182.png) |
|   `EM_GETLINE`    | 将单行编辑控件中的文本复制到指定的缓冲区并返回复制的字符数，不包含终止空字符; 对于多行编辑控件，则是复制指定行的文本并返回复制的字符数，不包含终止空字符。没有用到wParam参数，lParam参数指定为缓冲区指针;对于多行编辑控件，wParam参数指定为从0开始的行号，lParam参数指定为缓冲区指针。需要注意的是因为返回的文本不包括终止空字符，所以缓冲区应该清零，另外在发送消息前，缓冲区第一个字符必须设置为缓冲区的长度。例如 |
|  `EM_LINEINDEX`   | 获取多行编辑控件中指定行的第1个字符的字符索引，该消息与EM_LINEFROMCHAR消息相反，例如:![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240124190806537.png) |
| `EM_LTHEFEOMCHAR` | 用于多行编辑控件，返回指定字符索引的字符所在行的行索引。该消息与`EM_LINEINDEX`消息相反 |
|  `EM_GETMODIFY`   | 编辑控件的内容是否已经被修改，如果已修改返回TRUE，否则返回FAISE，例如:`bResult = SendMessage(hwndEdit,EM_GETMODIFY，0，0);` |
|    `EM_SETSEL`    | 通过指定一段字符的开始和结束位置〈字符索引〉﹐在编辑控件中选中一段文字，例如: ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240124191504295-17060949052582-17191527733803.png) |
|    `EM_SETSEL`    | 即包括开始位置。但不包括结束位置。                                                                  如果开始位置为0且结束位置为-1，则选中编辑控件中的所有文本.                          如果开始位置为-1，则取消当前选中。                                                                        选中文本以后。控件会在结束位置显示闪烁的光标。如果开始和结束位置为相同的值，则会移动光标到此处，这是设置光标位置的一种方法。 |
|    `EM_GETSEL`    | 返回编辑控件中当前所选中文本的开始和结束位置，例如:`DWORD dwResult;DWORD dwStart, dwEnd;dwResult = SendMessage(hwndEdit，EM_GETSEL，(WPARAM) &dwStart,(LPARAM)dwEnd);` 在dwStart和dwEnd中返回当前选中文本的开始和结束位置（字符索引），结束位置是选中的最后一个字符的索引加1，该消息的返回值是DWORD类型，LOWORD(dwResult) 等于开始位置，HIWORD(dwResult)等于结束位置，如果没有选中文本，则开始和结束位置都是光标的位置。 |
|  `EM_REPLACESEL`  | 将当前选中的文本替换为指定的的文本,例如：`SendMessage(hwndEidt,EM_REPLACESET,TRUE,(LPARAM)szStr)` wParam参教可以指定为TRUE或FALSE，表示是否可以撤销本次替换操作。如果指定为TRUE:则表示可以撤销操作﹔如果指定为FALSE，则表示无法撤销操作；lParam参数指定为要替换的字符串，如果没有选中的文本，则将lParam参数指定的字符串插入光标位置。 |
| `EM_SCROLLCARET`  | 在编辑控件中将光标滚动到可见视图中，在设置选中区域〈或改变了光标位置〉后，这个区域可能落在客户区的外面，用户看不到它。如果希望控件能够滚动已将新位置的内容落在客户区中，可以发送`EM_SCROLLCREAT` 消息，例如:`SendMessage(hwndEdit,EM_SCROLLCREAT,0,0)` |
|     `WM_COPY`     | 复制当前选中的内容到剪贴板(如果样式为ES_PASSWORD，则不支持该消息)，例如:`SendMessage(hwndEdit,WM_COPY,0,0)` |
|     `WM_CUT`      | 删除编辑控件中当前选中的内容，并把当前选中的内容以CF_TEXT格式复制到剪贴板，例如:`SendMessage(hwndEdit,WM_CUT,0,0)` |
|    `WM_PASTE`     | 把剪贴板中CF_TEXT格式的内容插入编辑控件的光标位置,例如:`SendMessage(hWndEdit,WM_PAUSE,0,0)` |
|    `WM_CLEAR`     | 删除编辑控件中当前选中的内容，如果当前没有选中文本，则删除光标右侧的字符，例如:`SendMessage(hwndEdit,WM_CLEAR,0,0)` |
|     `WM_UNDO`     | 撤销最近—次的编辑操作，即删除刚刚插入的任何文本或恢复刚刚已删除的文本，例如:`SendMessage(hwndEdit,WM_UNDO,0,0)` |

> 编辑控件的通知码以WM_COMMAND消息的形式发送给父窗口，常见的通知码如下表所示：



**通知码含义**

- EN_SETFOCUS 编辑控件获得了输入焦点
- EN_KILLFOCUS 编辑控件失去了输入焦点
- EN_UPDATE 编辑控件的内容将变化
- EN_CHANGE 编辑控件的内容已变化。

如果是多行编辑控件，并且是通过程序代码（例如SetWindowText SetDlgltemTextSetDlgltemInt等)改变了多行编辑控件的内容，则不会收到EN_CHANGE和EN_UPDATE这两个通知码。

- EN_ERRSPACE 编辑控件的缓冲区已满
- EN _MAXTEXT  编辑控件已经没有空间完成文本插入
- EN_HSCROLL   编辑控件的水平滚动条被单击
- EN_VSCROLL   编辑控件的垂直滚动条被单击



系统自带的记事本程序实际上用的就是Edit多行编辑控件。如果需要实现一个文本编辑器，那么建议学习功能更加强大的RichEdit富文本控件。本节的知识点几乎能适用于RichEdit控件，RichEdit控件提供了更多的功能。

:::





:::details `单行文本控件示例效果:`

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/WIN32UI%E6%8E%A7%E4%BB%B6%E7%BC%96%E8%BE%91%E6%A1%86.gif)

:::



:::details  `resource.h`

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 EditDemo.rc 使用
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

:::



:::details `main.cpp`

```c
#include <Windows.h>
#include <Commctrl.h>
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker, "\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("EditDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HINSTANCE hInstance;
    static HWND hwndUserName, hwndPassword, hwndAge, hwndRegister;
    static HWND hwndStatic[4];
    static HFONT hFont;
    int cx, cy;
    RECT rect;
    if (WM_CREATE == uMsg)
    {
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        hFont = CreateFont(12, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("宋体"));
        //==========================构建UI布局============================================
        hwndStatic[0] = CreateWindowEx(
            0, TEXT("Static"),
            TEXT("会员注册"), WS_CHILD | WS_VISIBLE | SS_CENTER,
            130, 20, 80, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        // 用户名
        hwndStatic[1] = CreateWindowEx(
            0, TEXT("Static"), TEXT("用户名："),
            WS_CHILD | WS_VISIBLE, 20, 50, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndUserName = CreateWindowEx(
            0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL,
            80, 50, 220, 20, hwnd, (HMENU)(1000), hInstance, NULL);
        // 密码
        hwndStatic[2] = CreateWindowEx(
            0, TEXT("Static"),
            TEXT("密  码："),
            WS_CHILD | WS_VISIBLE, 20, 75, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndPassword = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_PASSWORD,
            80, 75, 180, 20, hwnd, (HMENU)(1001), hInstance, NULL);
        // 年龄
        hwndStatic[3] = CreateWindowEx(
            0, TEXT("Static"), TEXT("年  龄："),
            WS_CHILD | WS_VISIBLE, 20, 100, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndAge = CreateWindowEx(
            0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_NUMBER,
            80, 100, 180, 20, hwnd, (HMENU)(1002), hInstance, NULL);
        // 注册按钮
        hwndRegister = CreateWindowEx(
            0, TEXT("Button"), TEXT("注册"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_NOTIFY | WS_TABSTOP,
            85, 130, 150, 25, hwnd, (HMENU)(1003), hInstance, NULL);
        //==========================构建UI布局============================================



        // 设置所有控件的字体为宋体
        SendMessage(hwndUserName, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndPassword, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndAge, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndRegister, WM_SETFONT, (WPARAM)hFont, FALSE);
        for (int i = 0; i < _countof(hwndStatic); i++)
        {
            SendMessage(hwndStatic[i], WM_SETFONT, (WPARAM)hFont, FALSE);
        }
        // 用户名、密码、年龄分别限制输入20、12、3个字符
        SendMessage(hwndUserName, EM_SETLIMITTEXT, 20, 0);
        SendMessage(hwndPassword, EM_SETLIMITTEXT, 12, 0);
        SendMessage(hwndAge, EM_SETLIMITTEXT, 3, 0);
        // 设置程序窗口大小，客户区所需最小大小为320 * 175
        SetRect(&rect, 0, 0, 320, 175);
        AdjustWindowRectEx(&rect, GetWindowLongPtr(hwnd, GWL_STYLE), GetMenu(hwnd) != NULL, GetWindowLongPtr(hwnd, GWL_EXSTYLE));
        SetWindowPos(hwnd, NULL, 0, 0, rect.right - rect.left, rect.bottom - rect.top, SWP_NOZORDER | SWP_NOMOVE);
    }
    else if (uMsg == WM_SIZE)
    {
        //如果说当前窗口大小被拉大，则对应调整控件的位置
        if (LOWORD(lParam) > 320 && HIWORD(lParam) > 175)
        {
            cx = (LOWORD(lParam) - 320) / 2;
            cy = (HIWORD(lParam) - 175) / 2;
            SetWindowPos(hwndStatic[0], NULL, 130 + cx, 20 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndStatic[1], NULL, 20 + cx, 50 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndStatic[2], NULL, 20 + cx, 75 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndStatic[3], NULL, 20 + cx, 100 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndUserName, NULL, 80 + cx, 50 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndPassword, NULL, 80 + cx, 75 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndAge, NULL, 80 + cx, 100 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndRegister, NULL, 85 + cx, 130 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
        }
        return 0;
    }
    else if (uMsg == WM_DESTROY)
    {
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }
    else if (uMsg == WM_CTLCOLORSTATIC)
    {
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);
    }
    else if (uMsg == WM_COMMAND)
    {
        if (HIWORD(wParam) == BN_CLICKED)
        {
            if (LOWORD(wParam) == 1003)
            {
                int nLen;
                LPTSTR lpUserName, lpPassword;
                TCHAR szBuf[64] = { 0 };

                //查用户输入用户名的字符个数 做校验
                nLen = SendMessage(hwndUserName, EM_LINELENGTH, 0, 0);
                if (nLen < 3)
                {
                    MessageBox(hwnd, TEXT("用户名至少需要3个字符"), TEXT("错误提示"), MB_OK);
                    return 0;
                }
                //根据字符长度，动态分配内存，并初始化。
                lpUserName = new TCHAR[nLen + 1];
                ZeroMemory(lpUserName, (nLen + 1) * sizeof(TCHAR));
                lpUserName[0] = nLen + 1;
                //存用户名编辑框的输入
                SendMessage(hwndUserName, EM_GETLINE, 0, (LPARAM)lpUserName);
               //查用户输入的密码字符个数 做校验
                nLen = SendMessage(hwndPassword, EM_LINELENGTH, 0, 0);
                if (nLen < 3)
                {
                    MessageBox(hwnd, TEXT("密码至少需要3个字符"), TEXT("错误提示"), MB_OK);
                    return 0;
                }
                //同理，存密码编辑框的输入
                lpPassword = new TCHAR[nLen + 1];
                ZeroMemory(lpPassword, (nLen + 1) * sizeof(TCHAR));
                lpPassword[0] = nLen + 1;
                SendMessage(hwndPassword, EM_GETLINE, 0, (LPARAM)lpPassword);
                //进行一个信息输出，年龄直接用更上层的函数也行，底层也是走SendMessage...再string=> int
                wsprintf(szBuf, TEXT("用户名：%s\n密  码：%s\n年  龄：%d"),
                    lpUserName, lpPassword,
                    GetDlgItemInt(hwnd, 1002, NULL, FALSE));
                MessageBox(hwnd, szBuf, TEXT("注册信息"), MB_OK);
                delete[] lpUserName;
                delete[] lpPassword;
            }
        }
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

“会员注册"“用户名""密码"和“年龄"这些文本用的都是Static类静态控件。静态控件后面再讲。因为用不到这些静态控件的ID，所以静态控件的ID我都设置为-1。至于静态控件、编辑控件和按钮控件摆放的位置，读者可以自己设计，这不是重点。在WM_CREATE消息中，创建所有控件以后，发送WM_SETFONT消息设置所有控件的字体;发送EM_SETLIMITTEXT消息设置用户名，且分别限制密码、年龄3个编辑控件输入20 12 3个字符。调用`AdjustWindowRectEx`函数设置程序窗口大小。
在`WM_COMMAND`消息中，要获取用户名和密码字符串，首先发`EM_LINELENGTH`消息确定字符串的长度，然后分配缓冲区，发送EM_GETLINE消息获取字符串，要获取年龄则直接调用`GetDlgItemInt`函数得到无符号数值型，然后通过`wsprintf`函数格式化。当然,使用`GetWindowText / GetDlgltemText或WM_GETTEXT`消息获取编辑控件的文本字符串也完全可以。



:::details WM_CTLCOLORSTATIC 消息

另外需要介绍的是`WM_CTLCOLORSTATIC`消息。默认情况下静态控件有一个灰色背景，而程序客户区的背景是白色，因此应该将静态控件的背景颜色设置为白色。在绘制静态控件以前，系统会发送WM_CTLCOLORSTATIC消息到静态控件的父窗口。该消息的wParam参数是静态控件窗口对应的DC句柄，IParam参数是静态控件的窗口句柄。程序可以调用SetTextColor函数设置文本颜色，调用SetBkColor函数设置文本的背景颜色等，最后返回一个画刷句柄，静态控件会使用这个画刷来擦除背景。本例对WM_CTLCOLORSTATIC消息的处理，仅仅是通过调用GetSysColorBrush函数返回一个白色画刷。



常用的类似消息如下表所示。



**消息类型针对的控件类型**

|          消息          |                          针对的控件                          |
| :--------------------: | :----------------------------------------------------------: |
|  `WM_CTLCOLORSTATIC`   | 静态控件和只读或禁用的编辑控件（正常状态的编辑控件不会收到该消息，而是收到WM_CTLCOLOREDIT消息) |
|   `WM_CTLCOLOREDIT`    |                    非只读或禁用的编辑控件                    |
|    `WM_CTLCOLORBTN`    |   自绘按钮(但是对于自绘按钮，通常处理的是WM_DRAWITEM消息)    |
|  `WM_CTLCOLORLISTBOX`  |                            列表框                            |
| `WM_CTLCOLORSCROLLBAR` |                          滚动条控件                          |
|    `WM_CTLCOLORDLG`    |                            对话框                            |

后面5个消息的wParam和lParam参数的含义和`WM_CTLCOLORSTATIC`消息完全相同

- wParam参数是控件对应的DC句柄，

- IParam参数是控件的窗口句柄。

  例如下面的代码

```c
    else if (uMsg == WM_CTLCOLOREDIT)
    {
        if ((HWND)lParam == hwndUserName)
        {
            //设置编辑框控件文本颜色为白色
            SetTextColor((HDC)wParam, RGB(255, 255, 255));

            //设置编辑框背景为黑色
            SetBkColor((HDC)wParam, RGB(0, 0, 0));
            HBRUSH hbrBkgnd = CreateSolidBrush(RGB(0, 0, 0));
            return (LRESULT)hbrBkgnd;
        }
    }
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%BE%91%E6%A1%86%E9%A2%9C%E8%89%B2-17060989253541.gif)





注意啊，`WM_CTLCOLOR***`消息中调用SetTextColor函数对于禁用编辑控件的设置文本颜色是无效的。

:::



## 列表框

列表框也是经常使用的子窗口控件，包含可供用户选择的项目列表，用户可以从中选择一个或多个项目。如果列表框不够大，显示不了所有列表项，则列表框可以显示一个滚动条。另外，每一个列表项都可以设置一个与之关联的32位数据，称为项目数据，可以设置为指向某些自定义数据的指针。普通的列表框效果如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240623225338787.png)





:::details 列表框控件常用样式



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240623225515764.png)



:::





:::details `WM_COMMAND 消息`

当列表框中发生事件时，系统会以`WM_COMMAND`消息的形式向父窗口发送通知码，常见的通知码如下所示：

|       宏        |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
| `LBN_SETFOCUS`  |                     列表框获取了键盘焦点                     |
| `LBN_KILLFOCUS` |                     列表框失去了键盘焦点                     |
| `LBN_SELCHANGE` | 列表框中的选择已更改，通常是在用户单击一个列表项的时候发生，用户按下方向键改变选择或键盘焦点的时候也会发送该通知码。如果是通过发送LB_SETSEL LB_SETCURSEL LB_SELECTSTRING LB_SELITEMRANGE或 LB_SELITEMRANGEEX消息更改了选择，则不会发送该通知码，即如果是程序代码更改了选中项，就不会收到LBN_SELCHANGE通知码 |
|  `LBN_DBLCLK`   |                   双击列表框中的某个列表项                   |
| `LBN_SELCANCEL` | 取消选中列表框中的某个列表项LBN_ERRSPACE列表框无法分配足够的内存来完成请求 |

:::





列表项的添加、删除、查询等都是通过发送消息来实现的。列表项的位置索引是从0开始的，列表框中第1个列表项的索引为0，第2个列表项的索引为1，以此类推。





:::details `列表框消息`

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240623230115556.png)



总结一下，调用`CreateWindow / CreateWindowEx`函数创建列表框控件后，列表框中还没有列表项，需要发送`LB_ADDSTRING/ LB_INSERTSTRING`消息添加列表项。要删除一个

列表项可以发送`LB_DELETESTRING`消息，要清空列表框可以发送`LB_RESETCONTENT`消息，要获取一个列表项的文本可以发送`LB_GETTEXTLEN` `LB_GETTEXT`消息，可以发送`LB_SETITEMDATA`消息为每个列表项设置一个关联的项目数据，要获取与列表项关联的项目数据可以发送`LB_GETITEMDATA`消息，要获取一个列表项的选中
状态可以发送`LB_GETSEL`消息，根据字符串查找一个列表项可以发送`LB_FINDSTRING/ LB_FINDSTRINGEXACT`消息，获取列表框中的列表项总数可以发送`LB_GETCOUNT`消息。









对于单选列表框∶可以发送`LB_SETCURSEL`或`LB_GETCURSEL`消息来设置或获取当前选中项。另外，`LB_SELECTSTRING`消息也是针对单选列表框的。





对于多选列表框∶要选中或取消选中一个列表项可以发送`LB_SETSEL`消息，要选中或取消选中一片连续的列表项可以发送`LB_SELITEMRANGE`消息，要获取所有选中项的索引可以发送`LB_GETSELCOUNT` `LB_GETSELITEMS`消息。



:::



:::details `拖动列表框`

拖动列表框允许用户将列表项从一个位置拖动到另一个位置，以改变排列顺序。拖动列表框仅用于单选列表框。如果想让一个列表框可以拖动，在创建列表框控件以后，则需要调用`MakeDragList(hwndListBox);`函数将其更改为拖动列表框。



调用`MakeDragList`函数时系统会定义拖动列表消息。当发生拖动事件时，系统会向拖动列表框的父窗口发送拖动列表消息，父窗口必须处理拖动列表消息。拖动列表消息的ID值是多少呢?拖动列表消息的具体值还没有确定，程序可以通过注册消息的方式获取这个值，



调用`RegisterWindowMessage (DRAGLISTMSGSTRING)`;函数会返回一`0xC000`～`0xFFFF`范围内的消息ID，该消息ID在整个系统中是唯一的。`DRAGLISTMSGSTRING`是一个常量，在CommCtrl.h头文件中定义如下∶

```c
#define DRAGLISTMSGSTRING TEXT("commctrl_DragListMsg")
```

有了**拖动列表消息ID**，就可以在窗口过程中处理该消息。例如下面的代码∶

```c
        static UINT WM_DRAGLIST;
        // 更改为拖动列表框
        MakeDragList(hwndListBox);
        WM_DRAGLIST = RegisterWindowMessage(DRAGLISTMSGSTRING);
```

**拖动列表消息**的wParam参数是拖动列表框的控件ID，IParam参数是一个指向DRAGLISTINFO结构的指针，其中包含拖动事件的通知码和其他信息，拖动列表消息的返回值取决于具体的通知码。



`DRAGLISTINFO`结构在CommCtrl.h头文件中定义如下︰

```c
typedef struct tagDRAGLISTINFO
{
UINT uNotification;//通知码，指示拖动事件的类型
HWND hWnd;	//拖动列表框的窗口句柄
POINT ptCursor;//拖动事件发生时鼠标光标的X和Y坐标
}DRAGLISTINFO，*LPDRAGLISTINFO;
```

- `uNotification`字段表示通知码，指示拖动事件的类型，该字段可以是下表项之一。

|       宏        |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
| `DL_BEGINDRAG`  |            用户在列表项上单击了鼠标左键，开始拖动            |
|  `DL_DRAGGING`  | 用户正在拖动列表项，在开始拖动后，只要移动鼠标就会发送DL_DRAGGING通知码 |
| `DL_CANCELDRAG` |         用户通过单击鼠标右键或按Esc键取消了拖动操作          |
|  `DL_DROPPED`   |               用户已释放鼠标左键，拖动操作完成               |

:::



当用户单击一个列表项时，将发送包含`DL_BEGINDRAG`通知码的拖动列表消息，可以通过调用`LBItemFromPt`函数来确定光标下的列表项索引，保存该列表项索引，在拖动操作完成后需要移动该列表项，然后返回TRUE表示开始拖动操作，或返回FALSE表示禁止拖动。



:::details `LBItemFromPt 函数说明`

```c
/// <summary>
/// 确定列表框控件在光标下时的列表项索引
/// </summary>
/// <param name="hLB">列表框控件句柄</param>
/// <param name="pt">点坐标，使用((LPDRAGLISTINFO)lParam)->ptCursor字段</param>
/// <param name="bAutoScroll">是否自动滚动</param>
/// <returns></returns>
int LBItemFromPt(HWND hLB,POINT pt,BOOL bAutoScroll); 
```

::: 



开始拖动以后，只要移动鼠标就会发送`DL_DRAGGING`通知码，可以通过调用`LBltemFromPt`函数来确定光标下的列表项索引，然后可以调用`DrawInsert`函数在光标下列表项的左上方绘制插入图标。处理完该通知码以后的返回值指定了鼠标光标的类型，返回值可以是`DL_STOPCURSOR` ` DL_COPYCURSOR`或`DL_MOVECURSOR`





:::details `DrawInsert 函数说明`

```c
/// <summary>
/// 用于在拖动列表框的父窗口中绘制插入图标∶
/// </summary>
/// <param name="handParent">拖动列表框的父窗口句柄</param>
/// <param name="hLB">拖动列表框的句柄</param>
/// <param name="nltem">在哪个位置显示插入图标，在DL_DRAGGING通知码中可以设置为光标下的列表项索引</param>
void DrawInsert(HWND handParent,HWND hLB, int nItem); 
```

:::



如果用户通过单击鼠标右键或按Esc键取消了拖动操作，则会发送`DL_CANCELDRAG`通知码，程序通常不需要处理该通知码。如果用户通过释放鼠标左键完成了拖动操作，则会发送`DL_DROPPED`通知码，可以通过调用`LBltemFromPt`函数来确定光标下的列表项索引，然后把被拖动的列表项移动到光标下列表项的前面。系统会忽略`DL_CANCELDRAG`和`DL_DROPPED`通知码的返回值，通常可以返回0。





接下来实现一个例子，`ListBoxDemo`程序运行效果如下图所示。

:::details `ListBoxDemo`

```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("ListBoxDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU |
        WS_MINIMIZEBOX, CW_USEDEFAULT, CW_USEDEFAULT, 256, 280, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndListBox, hwndEditText, hwndEditData, hwndAdd, hwndModify, hwndDelete;
    HWND hwndStaticText, hwndStaticData;
    static HFONT hFont;
    static UINT WM_DRAGLIST;
    TCHAR szBuf[64] = { 0 };
    int nIndex, nCount;
    DWORD dwData;
    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        // 列表框控件
        hwndListBox = CreateWindowEx(0, TEXT("ListBox"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | WS_VSCROLL | LBS_NOTIFY,
            20, 20, 200, 116, hwnd, (HMENU)IDC_LISTBOX, hInstance, NULL);

        // 静态控件和编辑框控件，文本：文本编辑框，项目数据：项目数据编辑框
        hwndStaticText = CreateWindowEx(0, TEXT("Static"), TEXT("文本："),
            WS_CHILD | WS_VISIBLE, 20, 144, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndEditText = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL,
            80, 140, 140, 22, hwnd, (HMENU)IDC_EDITTEXT, hInstance, NULL);
        hwndStaticData = CreateWindowEx(0, TEXT("Static"), TEXT("项目数据："),
            WS_CHILD | WS_VISIBLE, 20, 169, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndEditData = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_NUMBER,
            80, 165, 140, 22, hwnd, (HMENU)IDC_EDITDATA, hInstance, NULL);

        // 三个按钮，添加、修改、删除
        hwndAdd = CreateWindowEx(0, TEXT("Button"), TEXT("添加"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_NOTIFY,
            20, 200, 60, 25, hwnd, (HMENU)IDC_BTNADD, hInstance, NULL);
        hwndModify = CreateWindowEx(0, TEXT("Button"), TEXT("修改"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_NOTIFY,
            90, 200, 60, 25, hwnd, (HMENU)IDC_BTNMODIFY, hInstance, NULL);
        hwndDelete = CreateWindowEx(0, TEXT("Button"), TEXT("删除"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_NOTIFY,
            160, 200, 60, 25, hwnd, (HMENU)IDC_BTNDELETE, hInstance, NULL);

        // 更改为拖动列表框
        MakeDragList(hwndListBox);
        WM_DRAGLIST = RegisterWindowMessage(DRAGLISTMSGSTRING);

        // 添加一些列表项
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("汇编语言"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("C语言面向过程"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("C++面向对象"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("Windows程序设计"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("Ollydbg调试工具"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("X64Dbg调试工具"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("IDA静态调试"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("PE Explorer"));
        // 设置项目数据，具体编程中可以根据需要添加所需的项目数据，例如某些自定义数据的指针
        for (int i = 0; i < 8; i++)
            SendMessage(hwndListBox, LB_SETITEMDATA, i, 10000 + i);

        // 限制列表项文本最多可以输入20个字符，项目数据最多可以输入10个数字字符
        SendMessage(hwndEditText, EM_SETLIMITTEXT, 20, 0);
        SendMessage(hwndEditData, EM_SETLIMITTEXT, 10, 0);

        // 设置字体
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("微软雅黑"));
        SendMessage(hwndListBox, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndStaticText, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndStaticData, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndEditText, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndEditData, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndAdd, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndModify, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndDelete, WM_SETFONT, (WPARAM)hFont, FALSE);

        // 禁用添加、修改、删除按钮
        EnableWindow(hwndAdd, FALSE);
        EnableWindow(hwndModify, FALSE);
        EnableWindow(hwndDelete, FALSE);
        return 0;

    case WM_CTLCOLORSTATIC:
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
            // 添加
            if (LOWORD(wParam) == IDC_BTNADD)
            {
                nCount = GetDlgItemText(hwnd, IDC_EDITTEXT, szBuf, _countof(szBuf));
                if (nCount > 0)
                {
                    nIndex = SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)szBuf);
                    if (nIndex >= 0)
                    {
                        dwData = GetDlgItemInt(hwnd, IDC_EDITDATA, NULL, TRUE);
                        SendMessage(hwndListBox, LB_SETITEMDATA, nIndex, dwData);
                        SendMessage(hwndListBox, LB_SETCURSEL, nIndex, 0);
                        EnableWindow(hwndModify, TRUE);
                        EnableWindow(hwndDelete, TRUE);
                    }
                }
            }
            // 修改
            else if (LOWORD(wParam) == IDC_BTNMODIFY)
            {
                nIndex = SendMessage(hwndListBox, LB_GETCURSEL, 0, 0);
                nCount = GetDlgItemText(hwnd, IDC_EDITTEXT, szBuf, _countof(szBuf));
                if (nIndex >= 0 && nCount > 0)
                {
                    SendMessage(hwndListBox, LB_DELETESTRING, nIndex, 0);
                    SendMessage(hwndListBox, LB_INSERTSTRING, nIndex, (LPARAM)szBuf);
                    dwData = GetDlgItemInt(hwnd, IDC_EDITDATA, NULL, TRUE);
                    SendMessage(hwndListBox, LB_SETITEMDATA, nIndex, dwData);
                    SendMessage(hwndListBox, LB_SETCURSEL, nIndex, 0);
                }
            }
            // 删除
            else if (LOWORD(wParam) == IDC_BTNDELETE)
            {
                nIndex = SendMessage(hwndListBox, LB_GETCURSEL, 0, 0);
                if (nIndex >= 0)
                {
                    SendMessage(hwndListBox, LB_DELETESTRING, nIndex, 0);
                    nCount = SendMessage(hwndListBox, LB_GETCOUNT, 0, 0);
                    if (nCount > 0)
                    {
                        if (nIndex < nCount)
                            SendMessage(hwndListBox, LB_SETCURSEL, nIndex, 0);
                        else
                            SendMessage(hwndListBox, LB_SETCURSEL, nIndex - 1, 0);
                    }
                    else
                    {
                        EnableWindow(hwndModify, FALSE);
                        EnableWindow(hwndDelete, FALSE);
                    }
                }
            }
            break;
        // 列表框中的选择已更改
        case LBN_SELCHANGE:
            if (LOWORD(wParam) == IDC_LISTBOX)
            {
                // 获取列表项文本和项目数据，显示到编辑框中
                nIndex = SendMessage(hwndListBox, LB_GETCURSEL, 0, 0);
                SendMessage(hwndListBox, LB_GETTEXT, nIndex, (LPARAM)szBuf);
                SetDlgItemText(hwnd, IDC_EDITTEXT, szBuf);
                dwData = SendMessage(hwndListBox, LB_GETITEMDATA, nIndex, 0);
                SetDlgItemInt(hwnd, IDC_EDITDATA, dwData, TRUE);

                // 启用修改、删除按钮
                EnableWindow(hwndModify, TRUE);
                EnableWindow(hwndDelete, TRUE);
            }
            break;

        // 编辑控件的内容已变化
        case EN_UPDATE:
            // 项目数据编辑框不需要检查有无内容，如果没有内容就是0
            if (LOWORD(wParam) == IDC_EDITTEXT)
            {
                nCount = GetDlgItemText(hwnd, IDC_EDITTEXT, szBuf, _countof(szBuf));
                if (nCount > 0)
                {
                    // 添加按钮
                    EnableWindow(hwndAdd, TRUE);
                    // 修改按钮
                    nIndex = SendMessage(hwndListBox, LB_GETCURSEL, 0, 0);
                    if (nIndex >= 0)
                        EnableWindow(hwndModify, TRUE);
                }
                else
                {
                    // 添加按钮
                    EnableWindow(hwndAdd, FALSE);
                    // 修改按钮
                    EnableWindow(hwndModify, FALSE);
                }
            }
            break;
        }
        return 0;

    case WM_DESTROY:
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }

    if (uMsg == WM_DRAGLIST)
    {
        LPDRAGLISTINFO pDragInfo = (LPDRAGLISTINFO)lParam;
        static int nIndexDrag;
        switch (pDragInfo->uNotification)
        {
        case DL_BEGINDRAG:
            nIndexDrag = LBItemFromPt(hwndListBox, pDragInfo->ptCursor, FALSE);
            return TRUE;

        case DL_DRAGGING:
            nIndex = LBItemFromPt(hwndListBox, pDragInfo->ptCursor, TRUE);
            if (nIndex >= 0)
                DrawInsert(hwnd, hwndListBox, nIndex);
            return DL_MOVECURSOR;

        case DL_DROPPED:
            nIndex = LBItemFromPt(hwndListBox, pDragInfo->ptCursor, FALSE);
            if (nIndex >= 0 && nIndex != nIndexDrag)
            {
                SendMessage(hwndListBox, LB_GETTEXT, nIndexDrag, (LPARAM)szBuf);
                dwData = SendMessage(hwndListBox, LB_GETITEMDATA, nIndexDrag, 0);
                if (nIndexDrag > nIndex)
                {
                    // 先删除再插入
                    SendMessage(hwndListBox, LB_DELETESTRING, nIndexDrag, 0);
                    SendMessage(hwndListBox, LB_INSERTSTRING, nIndex, (LPARAM)szBuf);
                    SendMessage(hwndListBox, LB_SETITEMDATA, nIndex, dwData);
                    SendMessage(hwndListBox, LB_SETCURSEL, nIndex, 0);
                }
                else
                {
                    // 先插入再删除
                    SendMessage(hwndListBox, LB_INSERTSTRING, nIndex, (LPARAM)szBuf);
                    SendMessage(hwndListBox, LB_SETITEMDATA, nIndex, dwData);
                    SendMessage(hwndListBox, LB_SETCURSEL, nIndex, 0);
                    SendMessage(hwndListBox, LB_DELETESTRING, nIndexDrag, 0);
                }
            }
            // 隐藏插入图标
            DrawInsert(hwnd, hwndListBox, -1);
            nIndexDrag = -1;
            return 0;
        }
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624220432615.png)



在`WinMain`函数中调用`CreateWindowEx`的时候，没有指定
`WS_THICKFRAME`和`WS_MAXIMIZEBOX`样式，因此程序窗口不可调整大小，而且最大化按钮失效。程序的列表框是一个拖动列表框，用户可以随意拖动列表项的位置。





在`WM_CREATE`消息中，创建了列表框控件、两个静态控件、两个编辑框控件和3个按钮，项目数据编辑框使用了`ES_NUMBER`样式，用户只能输入数字。初始情况下，3个按钮是禁用的。在`WM_COMMAND`消息中，程序处理了`BN_CLICKED` `LBN_SELCHANGE`和`EN_UPDATE`通知码，分别对应着用户单击3个按钮、列表框中的选择已更改和编辑控件的内容已变化。



`switch (uMsg)`中包含case消息ID。因为case后面需要的是一个常量，所以对于`WM_DRAGLIST`消息的处理单独用了一个if判断，然后在if语句中分别处理`DL_BEGINDRAG` `DL_DRAGGING`和`DL_DROPPED`通知码。

:::



研究一下`LB_DIR`和`LB_ADDFILE`消息。要了解这两个消息，不妨先看一下`DlgDirList`函数。`DlgDirList`函数把指定目录中指定属性的子目录和文件的名称显示到列表框中。





:::details `DlgDirList 函数说明`

```c
/// <summary>
/// 把指定目录中指定属性的子目录和文件的名称显示到列表框中
/// </summary>
/// <param name="hDlg">列表框的父窗口句柄</param>
/// <param name="IpPathSpec">目录名称和文件名的组合，可以是绝对路径或相对路径</param>
/// <param name="nlDListBox">列表框控件ID</param>
/// <param name="nIlDStaticPath">静态控件ID，用于显示当前当前驱动器和目录，可以设置为0</param>
/// <param name="uFileType">指定文件或目录的属性</param>
/// <returns></returns>
int DlgDirList(HWND hDlg,LPTSTR IpPathSpec, int nlDListBox, int nIlDStaticPath,UINT uFileType); 
```

- 参数`lpPathSpec`是包含目录名称和文件名的字符串缓冲区指针，可以是绝对路径或相对路径，例如`"C:\" "C:\Windows\*.*”或"*.*”`。该函数将字符串拆分为目录和文件名，然后在目录中搜索与文件名匹配的文件名称。

  - 如果字符串未指定目录，则在当前目录中搜索。

  - 如果字符串包含文件名，则文件名必须至少包含一个通配符`(?或*)`;如果字符串不包含文件名，则把文件名指定为通配符*。将指定目录中与文件名匹配并且具有`uFileType`参数指定的属性的所有文件名称都添加到列表框中。

- 参数`uFileType`指定文件或目录的属性`，lpPathSpec`目录中具有该属性的文件或目录的名称会被添加到列表框中。该参数可以是下表所示的一个或多个值。




|       宏        |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
| `DDL_READWRITE` |                  可读可写文件，这是默认设置                  |
|  `DDL_ARCHIVE`  |                           存档文件                           |
|  `DDL_HIDDEN`   |                           隐藏文件                           |
| `DDL_READONLY`  |                           只读文件                           |
|  `DDL_SYSTEM`   |                           系统文件                           |
| `DDL_DIRECTORY` | 包括子目录，指定目录中的子目录名称都会显示到列表框中，子目录名称显示为`[子目录名称]` |
|  `DDL_DRIVES`   | 所有映射的驱动器都显示到列表框中，显示为`[-x-]`，其中x是驱动器号 |
| `DDL_EXCLUSIVE` | 仅包含具有指定属性的文件。默认情况下，即使未指定`DDL_READWRITE`，也会列出可读可写文件 |
| `DDL_POSTMSGS`  | 如果设置了该标志，则`DlgDirList`函数使用`PostMessage`函数将消息发送到列表框。如果未设置，则使用`SendMessage`函数 |

:::





:::details `DlgDirSelectEx`



```c
/// <summary>
/// 获取由DlgDirList函数填充的列表框中当前选定的列表项的文本内容
/// </summary>
/// <param name="hDlg">列表框的父窗口句柄</param>
/// <param name="IpString">接收所选列表项文本内容的缓冲区指针</param>
/// <param name="nCount">缓冲区的长度，以字符为单位</param>
/// <param name="nIDListBox">列表框控件ID</param>
/// <returns></returns>
BOOL DlgDirSelectEx(HWND hDlg,LPTSTR IpString, int nCount,int nIDListBox); 
```

:::







:::details `DlgDirList 示例:`

```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("DirList");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HFONT hFont;
    static HWND hwndStaticPath, hwndListBox, hwndEdit;
    TCHAR szPath[] = TEXT("*.*");
    TCHAR szStr[MAX_PATH] = { 0 };  // 存放选中列表项的文本
    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        hwndStaticPath = CreateWindowEx(0, TEXT("Static"), TEXT(""),
            WS_CHILD | WS_VISIBLE, 10, 0, 380, 20, hwnd, (HMENU)IDC_STATICPATH, hInstance, NULL);
        hwndListBox = CreateWindowEx(0, TEXT("ListBox"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | WS_VSCROLL | LBS_NOTIFY,
            10, 25, 200, 240, hwnd, (HMENU)IDC_LISTBOX, hInstance, NULL);
        hwndEdit = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | WS_HSCROLL | WS_VSCROLL | 
            ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE,
            0, 0, 0, 0, hwnd, (HMENU)IDC_EDIT, hInstance, NULL);

        // 列出目录列表
        DlgDirList(hwnd, szPath, IDC_LISTBOX, IDC_STATICPATH, 
            DDL_ARCHIVE | DDL_READONLY | DDL_SYSTEM | DDL_DIRECTORY | DDL_DRIVES);

        // 设置控件字体
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("微软雅黑"));
        SendMessage(hwndStaticPath, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndListBox, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndEdit, WM_SETFONT, (WPARAM)hFont, FALSE);
        return 0;
    case WM_SIZE:
        // 调整列表框和多行编辑控件的大小
        SetWindowPos(hwndListBox, NULL, 0, 0, 200, HIWORD(lParam) - 25, SWP_NOZORDER | SWP_NOMOVE);
        MoveWindow(hwndEdit, 220, 25, LOWORD(lParam) - 220, HIWORD(lParam) - 25, FALSE);
        return 0;
    case WM_COMMAND:
        if (HIWORD(wParam) == LBN_DBLCLK && LOWORD(wParam) == IDC_LISTBOX)
        {
            BOOL bRet;
            HANDLE hFile;
            BYTE byBuf[8192] = { 0 };   // 最多读取8K字节文本
            DWORD dwBytesReaded;        // 实际读取字节数

            // 当前选定的列表项的文本内容，如果当前选择是目录名称，则返回值为TRUE，否则FALSE
            bRet = DlgDirSelectEx(hwnd, szStr, MAX_PATH, IDC_LISTBOX);
            if (bRet)
            {
                // 当前选择是目录名称
                DlgDirList(hwnd, szStr, IDC_LISTBOX, IDC_STATICPATH,
                    DDL_ARCHIVE | DDL_READONLY | DDL_SYSTEM | DDL_DIRECTORY | DDL_DRIVES);
            } 
            else
            {
                // 当前选择是文件
                hFile = CreateFile(szStr, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
                ReadFile(hFile, byBuf, _countof(byBuf) - 2, &dwBytesReaded, NULL);
                // 简单的判断是否是Unicode格式文本
                if (IsTextUnicode(byBuf, dwBytesReaded, 0))
                    SetDlgItemTextW(hwnd, IDC_EDIT, (LPWSTR)byBuf);
                else
                    SetDlgItemTextA(hwnd, IDC_EDIT, (LPSTR)byBuf);
            }
        }
        return 0;
    case WM_CTLCOLORSTATIC:
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);
    case WM_DESTROY:
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624222806339.png)

:::

## 组合框

组合框是编辑控件和列表框组合起来的一种子窗口控件，结合了编辑控件和单选列表框的大部分功能，其用法和编辑控件、列表框类似。编辑控件部分用于显示当前选择的列表项，列表框部分列出了用户可以选择的列表项。有3种样式的组合框，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624222933074.png)



在组合框的列表框中没有选中项的情况下，组合框的编辑控件中不会显示任何内容，但是可以在编辑控件中设置一个提示文本，以提示用户进行选择，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624223032365.png)



:::details `组合框样式`

|           宏            |                             含义                             |
| :---------------------: | :----------------------------------------------------------: |
|      `CBS_SIMPLE`       | 始终显示列表框（前提是组合框必须具有一定高度，高度至少可以容纳编辑控件和一行列表项)，列表框中的当前选中项会显示到编辑控件中，用户也可以在编辑控件中自行输入内容。 |
|     `CBS_DROPDOWN`      | 列表框部分平时是收起的，用户可以通过单击右侧的下拉箭头来展开列表框以选择列表项。选中的列表项会显示到编辑控件中，在编辑控件中用户也可以自行输入内容 |
|   `CBS_DROPDOWNLIST`    | `CBS_DROPDOWNLIST`与`CBS_DROPDOWN`类似，不同之处在于编辑控件部分被静态文本项替换，列表框部分平时也是收起的，用户可以通过单击组合框来展开列表框以选择列表项。选中的列表项会显示到静态文本项中，用户无法在静态文本项中输入内容，只能选择列表框中的列表项。 |
|    `CBS_AUTOHSCROLL`    | 当用户输入文本时，如果文本字数填满了编辑控件，则无法继续输入。在指定该样式后，在必要时编辑控件会自动水平滚动，这样一来用户输入的文本字数就不受编辑控件的长度影响 |
|  `CBS_DISABLENOSCROLL`  | 该样式通常与`WS_vSCROLL`样式一起使用。在指定该样式后，如果列表框中的列表项比较少，则不需要使用滚动条，但还是会显示禁用的垂直滚动条。如果未指定该样式，则不需要使用滚动条时会隐藏滚动条 |
|       `CBS_SORT`        |             按字母顺序对列表框中的列表项进行排序             |
|    `CBS_HASSTRINGS`     |                    默认样式(除自绘组合框)                    |
|  `CBS_OWNERDRAWFIXED`   |          自绘列表框，列表框中的列表项具有相同的高度          |
| `CBS_OWNERDRAWVARIABLE` |             自绘列表框，列表框中的列表项高度可变             |

> 除了上面这些组合框样式，通常还需要指定窗口样式`WS_CHILD | WS_VISIBLE | WS_VSCROLL`



:::



:::details `组合框消息`

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624223647408.png)



对于`CBS_SIMPLE`和`CBS_DROPDOWN`样式的组合框，用户如果在编辑控件中自行输入了内容，那么列表框中的选中项就会自动取消选中，这时获取编辑控件中的文本可以使用
`GetWindowText/GetDlgltemText`函数。



如果没有自行输入内容，既可以使用`GetWindowText/GetDlgltemText`函数，也可以发送`CB_GETLBTEXT`消息。因此对于`CBS_SIMPLE`和`CBS_DROPDOWN`样式的组合框，最好还是使用`GetWindowText/GetDlgltemText`函数获取编辑控件中的文本。



对于`CBS_DROPDOWNLIST`样式的组合框，不存在用户自行输入内容，因此要获取编辑控件中的文本，既可以使用`GetWindowText / GetDlgltemText`函数，也可以发送`CB_GETLBTEXT`消息。



通常可以发送`CB_SETCUEBANNER`消息为组合框设置一个提示文本，提示文本不属于编辑控件的真正内容，即调用`GetWindowText / GetDlgltemText`函数无法获取显示在编辑控件中的提示文本内容，函数返回的字符个数始终为0。



如果组合框的列表框中存在比较长的列表项，可以通过发送`CB_SETDROPPEDWIDTH`消息为具有`CBS_DROPDOWN`或`CBS_DROPDOWNLIST`样式的组合框的列表框设置一个最小宽度。如果需要，可以通过发送`CB_SETITEMDATA`消息为组合框中列表框的每个列表项设置一个项目数据。

:::





:::details `组合框的通知码`

当组合框中发生事件时，系统会以`WM_COMMAND`消息的形式向父窗口发送通知码。常见的通知码如表所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624224557358.png)

:::





## 滚动条控件



前面我们学过在调用`CreateWindowEx`函数创建重叠窗口或弹出窗口时，可以指定`WS_HSCROLL`或`WS_VSCROLL`窗口样式创建一个标准水平或垂直滚动条`ScrollBar`。

标准滚动条显示在客户区的底部或右侧，当程序窗口的输出的内容比较多导致无法在一个客户区范围内显示时，可以滚动标准滚动条以显示超出客户区范围的内容。

标准滚动条在非客户区，属于程序窗口的一部分，因此没有自己的窗口句柄。



除了标准滚动条，还可以通过指定窗口类名`ScrollBar`调用`CreateWindowEx`函数创建一个水平或垂直滚动条控件。







:::details `滚动条控件消息`

滚动条控件可以以任何大小显示在客户区的任何地方，同样需要处理`WM_HSCROLL`或
`WM_VSCROLL`消息，这两个消息的`LOWORD(wParam)`表示用户的滚动请求，如果`LOWORD(wParam)`是SB_THUMBPOSITION或SB_THUMBTRACK，那么

`HIWORD(wParam)`表示滑块的当前位置，在其他情况下HIWORD(wParam)无意义。





如果消息是由滚动条控件发送的，则lParam参数是滚动条控件的句柄;

如果消息是由标准滚动条发送的，则IParam参数为NULL。

通过lParam参数可以区分消息是标准滚动条还是滚动条控件发送的。

:::





滚动条控件内置键盘接不需要像标准滚动条那样处理`WM_KEYDOWN`消息。当用户按上下
左右方向键、PgUp键、PgDn键、Home键、End键时，系统会发送包含相应滚动请求的WM_HSCROLL或WM_VSCROLL消息。滚动条控件的样式很简单，通常就是指定SBS_HORZ或SBS_VERT样式，分别表示创建一个水平或垂直滚动条控件。





标准滚动条的默认范围`0-100`   滚动条控件的默认范围为空。可以通过调用`SetScrollRange`函数把范围改成对程序有意义的值。



通过调用`SetScrollPos`函数设置滑块在滚动条中的位置。



也可以通过调用`SetScrolllnfo`函数设置滚动条的最小和最大滚动范围、页面大小以及滑块位置。





:::details `滚动条控件示例:`

```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("取色调色器V1.0");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_PANDA));;
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | 
        WS_MINIMIZEBOX, CW_USEDEFAULT, CW_USEDEFAULT, 360, 220, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndBtnStart, hwndBtnStop;  // 开始、停止按钮
    static HWND hwndSBHorz[3];              // 3个水平滚动条
    static HWND hwndStaticColor[3];         // 3个静态控件用于实时显示红、绿、蓝颜色值
    static HWND hwndStatic[3];              // 3个静态控件：网页颜色、RGB颜色、点击开始按钮开始取色
    static HWND hwndEdit[2];                // 2个编辑控件：网页颜色、RGB颜色
    static HFONT hFont;

    COLORREF crPrim[3] = { RGB(255, 0, 0), RGB(0, 255, 0), RGB(0, 0, 255) };
    static HBRUSH  hBrush[3];
    static int color[3];                    // 红、绿、蓝颜色值
    static RECT rcColor;                    // 显示颜色结果的小矩形
    HDC hdc;
    PAINTSTRUCT ps;
    int n;
    TCHAR szBuf[24] = { 0 };

    static HDC hdcDesk, hdcMem;
    static HBITMAP hBitmapMem;
    static BOOL bStarting;                  // 开始取色
    POINT pt;                               // 鼠标光标位置
    COLORREF crPixel;                       // 鼠标光标位置处的COLORREF颜色值
    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        // 开始、停止按钮
        hwndBtnStart = CreateWindowEx(0, TEXT("Button"), TEXT("开始"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            10, 130, 50, 22, hwnd, (HMENU)IDC_BTNSTART, hInstance, NULL);
        hwndBtnStop = CreateWindowEx(0, TEXT("Button"), TEXT("停止"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            70, 130, 50, 22, hwnd, (HMENU)IDC_BTNSTOP, hInstance, NULL);

        // 3个水平滚动条
        hwndSBHorz[0] = CreateWindowEx(0, TEXT("ScrollBar"),
            NULL, WS_CHILD | WS_VISIBLE | SBS_HORZ,
            130, 0, 200, 17, hwnd, (HMENU)IDC_SBHORZ1, hInstance, NULL);
        hwndSBHorz[1] = CreateWindowEx(0, TEXT("ScrollBar"),
            NULL, WS_CHILD | WS_VISIBLE | SBS_HORZ,
            130, 20, 200, 17, hwnd, (HMENU)IDC_SBHORZ2, hInstance, NULL);
        hwndSBHorz[2] = CreateWindowEx(0, TEXT("ScrollBar"),
            NULL, WS_CHILD | WS_VISIBLE | SBS_HORZ,
            130, 40, 200, 17, hwnd, (HMENU)IDC_SBHORZ3, hInstance, NULL);

        // 3个静态控件用于实时显示红、绿、蓝颜色值
        hwndStaticColor[0] = CreateWindowEx(0, TEXT("Static"), TEXT("红：0"),
            WS_CHILD | WS_VISIBLE | SS_CENTER,
            130, 60, 60, 20, hwnd, (HMENU)IDC_STATICCOLOR1, hInstance, NULL);
        hwndStaticColor[1] = CreateWindowEx(0, TEXT("Static"), TEXT("绿：0"),
            WS_CHILD | WS_VISIBLE | SS_CENTER,
            200, 60, 60, 20, hwnd, (HMENU)IDC_STATICCOLOR2, hInstance, NULL);
        hwndStaticColor[2] = CreateWindowEx(0, TEXT("Static"), TEXT("蓝：0"),
            WS_CHILD | WS_VISIBLE | SS_CENTER,
            270, 60, 60, 20, hwnd, (HMENU)IDC_STATICCOLOR3, hInstance, NULL);

        // 2个静态控件，网页颜色和RGB颜色，以及2个编辑控件
        hwndStatic[0] = CreateWindowEx(0, TEXT("Static"), TEXT("网页颜色："),
            WS_CHILD | WS_VISIBLE,
            130, 85, 70, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndStatic[1] = CreateWindowEx(0, TEXT("Static"), TEXT("RGB颜色："),
            WS_CHILD | WS_VISIBLE,
            130, 110, 70, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndEdit[0] = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_NOHIDESEL,
            200, 85, 130, 22, hwnd, (HMENU)IDC_EDITWEB, hInstance, NULL);
        hwndEdit[1] = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_NOHIDESEL,
            200, 110, 130, 22, hwnd, (HMENU)IDC_EDITRGB, hInstance, NULL);
        // 静态控件：点击开始按钮开始取色
        hwndStatic[2] = CreateWindowEx(0, TEXT("Static"), TEXT("点击开始按钮开始取色"),
            WS_CHILD | WS_VISIBLE | SS_CENTER,
            180, 145, 150, 20, hwnd, (HMENU)(-1), hInstance, NULL);

        // 设置字体
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("微软雅黑"));
        SendMessage(hwndBtnStart, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndBtnStop, WM_SETFONT, (WPARAM)hFont, FALSE);
        for (int i = 0; i < _countof(hwndStaticColor); i++)
            SendMessage(hwndStaticColor[i], WM_SETFONT, (WPARAM)hFont, FALSE);
        for (int i = 0; i < _countof(hwndStatic); i++)
            SendMessage(hwndStatic[i], WM_SETFONT, (WPARAM)hFont, FALSE);
        for (int i = 0; i < _countof(hwndEdit); i++)
            SendMessage(hwndEdit[i], WM_SETFONT, (WPARAM)hFont, FALSE);

        // 初始化网页颜色、RGB颜色编辑框的内容
        wsprintf(szBuf, TEXT("#%0.2X%0.2X%0.2X"), color[0], color[1], color[2]);
        SetDlgItemText(hwnd, IDC_EDITWEB, szBuf);
        wsprintf(szBuf, TEXT("RGB(%d, %d, %d)"), color[0], color[1], color[2]);
        SetDlgItemText(hwnd, IDC_EDITRGB, szBuf);

        // 创建红绿蓝3个画刷，用于水平滚动条背景和3个实时显示红绿蓝颜色值静态控件的文本颜色
        for (int i = 0; i < _countof(hBrush); i++)
            hBrush[i] = CreateSolidBrush(crPrim[i]);

        // 设置水平滚动条的范围和初始位置
        for (int i = 0; i < _countof(hwndSBHorz); i++)
        {
            SetScrollRange(hwndSBHorz[i], SB_CTL, 0, 255, FALSE);
            SetScrollPos(hwndSBHorz[i], SB_CTL, 0, FALSE);
        }

        // 显示颜色结果的那个小矩形的坐标，调用InvalidateRect函数宣布该区域无效的时候会用到
        SetRect(&rcColor, 130, 135, 170, 175);

        // 桌面设备环境句柄，内存设备环境句柄
        hdcDesk = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
        hdcMem = CreateCompatibleDC(hdcDesk);
        hBitmapMem = CreateCompatibleBitmap(hdcDesk, 120, 120);
        SelectObject(hdcMem, hBitmapMem);

        // 在系统菜单中添加一个关于本程序菜单项
        AppendMenu(GetSystemMenu(hwnd, FALSE), MF_STRING, IDM_ABOUT, TEXT("关于本程序"));

        // 为开始按钮设置键盘焦点
        SetFocus(hwndBtnStart);
        return 0;

    case WM_CTLCOLORSCROLLBAR:
        n = GetWindowLongPtr((HWND)lParam, GWLP_ID) - IDC_SBHORZ1;
        return (LRESULT)hBrush[n];

    case WM_CTLCOLORSTATIC:
        n = GetWindowLongPtr((HWND)lParam, GWLP_ID) - IDC_STATICCOLOR1;
        if (n >= 0 && n <= 2)
            SetTextColor((HDC)wParam, crPrim[n]);
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);

    case WM_HSCROLL:
        n = GetWindowLongPtr((HWND)lParam, GWLP_ID) - IDC_SBHORZ1;
        SetFocus((HWND)lParam);    // 设置键盘焦点以后才可以使用键盘
        switch (LOWORD(wParam))
        {
        case SB_LINELEFT:
            color[n] -= 1;
            break;
        case SB_LINERIGHT:
            color[n] += 1;
            break;
        case SB_PAGELEFT:
            color[n] -= 10;
            break;
        case SB_PAGERIGHT:
            color[n] += 10;
            break;
        case SB_THUMBTRACK:
            color[n] = HIWORD(wParam);
            break;
        case SB_LEFT:
            color[n] = 0;
            break;
        case SB_RIGHT:
            color[n] = 255;
            break;
        }
        color[n] = min(color[n], 255);
        color[n] = max(0, color[n]);
        if (color[n] != GetScrollPos((HWND)lParam, SB_CTL))
        {
            SetScrollPos((HWND)lParam, SB_CTL, color[n], TRUE);
            // 实时显示颜色值的静态控件
            SetDlgItemInt(hwnd, IDC_STATICCOLOR1 + n, color[n], FALSE);
            // 网页颜色、RGB颜色编辑控件
            wsprintf(szBuf, TEXT("#%0.2X%0.2X%0.2X"), color[0], color[1], color[2]);
            SetDlgItemText(hwnd, IDC_EDITWEB, szBuf);
            wsprintf(szBuf, TEXT("RGB(%d, %d, %d)"), color[0], color[1], color[2]);
            SetDlgItemText(hwnd, IDC_EDITRGB, szBuf);
            // 重绘颜色结果小矩形
            InvalidateRect(hwnd, &rcColor, FALSE);
        }
        return 0;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
            if (LOWORD(wParam) == IDC_BTNSTART)
            {
                bStarting = TRUE;
                SetFocus(hwndBtnStop);
                SetTimer(hwnd, 1, 100, NULL);
                SetTimer(hwnd, 2, 1000, NULL);
                SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
                // 把停止按钮改为默认按钮样式，没什么意义，仅仅是提供一种视觉效果
                // 如果是在对话框程序中，当没有其他按钮具有键盘焦点时，用户可以通过按下Enter键选择默认按钮
                SendMessage(hwndBtnStop, BM_SETSTYLE, WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON, FALSE);
                SetWindowText(hwndStatic[2], TEXT("请按空格键停止取色"));
            }
            else if (LOWORD(wParam) == IDC_BTNSTOP)
            {
                bStarting = FALSE;
                SetFocus(hwndBtnStart);
                KillTimer(hwnd, 1);
                KillTimer(hwnd, 2);
                SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
                SendMessage(hwndBtnStop, BM_SETSTYLE, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, FALSE);
                SetWindowText(hwndStatic[2], TEXT("点击开始按钮开始取色"));
            }
            break;

        case EN_SETFOCUS:
            if (LOWORD(wParam) == IDC_EDITWEB)
            {
                SendMessage(hwndEdit[1], EM_SETSEL, -1, -1);
                SendMessage(hwndEdit[0], EM_SETSEL, 0, -1);
                SendMessage(hwndEdit[0], WM_COPY, 0, 0);
                MessageBox(hwnd, TEXT("网页颜色已经复制到剪贴板"), TEXT("提示"), MB_OK);
            }
            else if (LOWORD(wParam) == IDC_EDITRGB)
            {
                SendMessage(hwndEdit[0], EM_SETSEL, -1, -1);
                SendMessage(hwndEdit[1], EM_SETSEL, 0, -1);
                SendMessage(hwndEdit[1], WM_COPY, 0, 0);
                MessageBox(hwnd, TEXT("RGB颜色已经复制到剪贴板"), TEXT("提示"), MB_OK);
            }
            return 0;
        }

        return 0;

    case WM_SYSCOMMAND:
        if (LOWORD(wParam) == IDM_ABOUT)
        {
            MessageBox(hwnd, TEXT("本程序由\n《十年磨一剑：Windows程序设计、加密解密从零基础到行家》作者提供\n\n老王，不负所望!"), TEXT("关于本程序"), MB_OK);
            return 0;
        }
        break;

    case WM_TIMER:
        if (wParam == 1)
        {
            // 获取鼠标光标处的颜色值，然后更新水平滚动条、颜色值静态控件、两个编辑框、颜色结果矩形
            GetCursorPos(&pt);
            crPixel = GetPixel(hdcDesk, pt.x, pt.y);
            color[0] = GetRValue(crPixel);
            color[1] = GetGValue(crPixel);
            color[2] = GetBValue(crPixel);

            SetScrollPos(hwndSBHorz[0], SB_CTL, color[0], TRUE);
            SetScrollPos(hwndSBHorz[1], SB_CTL, color[1], TRUE);
            SetScrollPos(hwndSBHorz[2], SB_CTL, color[2], TRUE);

            SetDlgItemInt(hwnd, IDC_STATICCOLOR1, color[0], FALSE);
            SetDlgItemInt(hwnd, IDC_STATICCOLOR2, color[1], FALSE);
            SetDlgItemInt(hwnd, IDC_STATICCOLOR3, color[2], FALSE);

            wsprintf(szBuf, TEXT("#%0.2X%0.2X%0.2X"), color[0], color[1], color[2]);
            SetDlgItemText(hwnd, IDC_EDITWEB, szBuf);
            wsprintf(szBuf, TEXT("RGB(%d, %d, %d)"), color[0], color[1], color[2]);
            SetDlgItemText(hwnd, IDC_EDITRGB, szBuf);

            InvalidateRect(hwnd, &rcColor, FALSE);

            // 实时显示鼠标光标附近的图像
            hdc = GetDC(hwnd);
            SelectObject(hdcMem, GetStockObject(NULL_PEN));
            Rectangle(hdcMem, 0, 0, 121, 121);
            // 取鼠标光标周围的40*40像素图像，放大3倍
            StretchBlt(hdcMem, 0, 0, 120, 120, hdcDesk, pt.x - 20, pt.y - 20, 40, 40, SRCCOPY);
            DrawIcon(hdcMem, 60 - GetSystemMetrics(SM_CXICON) / 2,
                60 - GetSystemMetrics(SM_CYICON) / 2, LoadCursor(NULL, IDC_CROSS));
            BitBlt(hdc, 0, 0, 120, 120, hdcMem, 0, 0, SRCCOPY);
            ReleaseDC(hwnd, hdc);
        }
        else
        {
            // 之所以1秒调用一次本计时器，而不是100ms
            // 是为了防止其他程序根本得不到键盘焦点，影响用户体验
            // GetActiveWindow() != hwnd或GetForegroundWindow() != hwnd也可以
            if (GetFocus() != hwndBtnStop)
            {
                RECT rect;
                // 保存鼠标光标位置，然后把鼠标光标位置设置到客户区(10, 10)，然后点击
                GetCursorPos(&pt);
                GetClientRect(hwnd, &rect);
                ClientToScreen(hwnd, (LPPOINT)&rect);
                SetCursorPos(rect.left + 10, rect.top + 10);
                mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
                mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
                // 恢复鼠标光标位置
                SetCursorPos(pt.x, pt.y);
            }
        }
        return 0;

    case WM_SETFOCUS:
        if (bStarting)
            SetFocus(hwndBtnStop);
        /*else
            SetFocus(hwndBtnStart);*/
        return 0;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        // 颜色结果矩形
        SelectObject(hdc, CreateSolidBrush(RGB(color[0], color[1], color[2])));
        Rectangle(hdc, rcColor.left, rcColor.top, rcColor.right, rcColor.bottom);
        DeleteObject(SelectObject(hdc, GetStockObject(WHITE_BRUSH)));
        // 鼠标光标周围的图像
        BitBlt(hdc, 1, 0, 121, 120, hdcMem, 0, 0, SRCCOPY);
        EndPaint(hwnd, &ps);
        return 0;

    case WM_DESTROY:
        DeleteObject(hFont);
        for (int i = 0; i < _countof(hBrush); i++)
            DeleteObject(hBrush[i]);
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624225508066.png)





关于`WM_CTLCOLORSCROLLBAR`和`WM_CTLCOLORSTATIC`消息的处理，在讲解编辑控件的时候已经说过。在`WM_CTLCOLORSCROLLBAR`消息中分别为3个水平滚动条返回红、绿、蓝画刷以填充其背景。



在`WM_CTLCOLORSTATIC`消息中调用SetTextColor分别设置红、绿、蓝颜色值静态控件的文本颜色。



文本的背景色默认就是白色，因此不需要调用SetBkColor或SetBkMode函数设置。静态控件默认情况下是灰色背景，因此返回一个GetSysColorBrush(COLOR_WINDOW)白色画刷。



如果不明确静态控件背景、文本背景具体指的是哪个范围，请调用以上函数自行测试。



`WM_HSCROLL`  `WM_COMMAND`和`WM_SYSCOMMAND`消息的处理很简单，用户单击“开始"按钮，调用`SetWindowPos`函数置顶显示本程序。后动2个计时器，一个是100ms触发一次，用于获取鼠标光标处的COLORREF颜色值，然后更新水平滚动条、颜色值静态控件、两个编辑框、颜色结果矩形的显示，并把鼠标光标附近的40像素40像素图像放大3倍以后显示在程序客户区左上角(0,0,120,120)。另一个是1s触发一次，用于让本程序的"停止"按钮实时具有键盘焦点，以响应用户按下空格键停止取色，因为`SetActiveWindow`  `BringWindowToTop` `SwitchToThisWindow`和`SetForegroundWindow`等激活窗口函数的效果不尽如人意，所以本程序采用模拟鼠标单击客户区的方法以激活程序窗口。程序窗口激活以后会收到`WM_SETFOCUS`消息，程序处理该消息，把输入焦点设置为开始或停止按钮。



:::



## 静态控件

静态控件可以用于显示简单图形、文本或图像，也可以通过自绘定制其外观。静态控件必须指定`SS_NOTIFY`样式才能接收鼠键输入并在用户单击或双击时通知其父窗口(`WM_COMMAND`消息)。





:::details `静态控件显示图形需要的样式`



|      样式宏      |                  含义                  |
| :--------------: | :------------------------------------: |
| `SS_BLACKFRAME`  |     创建一个黑色边框的无填充矩形框     |
|  `SS_GRAYFRAME`  |     创建一个灰色边框的无填充矩形框     |
| `SS_WHITEFRAME`  |     创建一个白色边框的无填充矩形框     |
| `SS_ETCHEDFRAME` | 创建一个具有三维外观边框的无填充矩形框 |
| `SS_ETCHEDHORZ`  |       创建一条具有三维外观的横线       |
| `SS_ETCHEDVERT`  |       创建一条具有三维外观的竖线       |
|  `SS_BLACKRECT`  |      创建一个黑色填充的无边框矩形      |
|  `SS_GRAYRECT`   |      创建一个灰色填充的无边框矩形      |
|  `SS_WHITERECT`  |      创建一个白色填充的无边框矩形      |

以上9种样式不能组合使用。调用`CreateWindowEx`函数创建上述9种简单图形。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624230429200.png)

:::





:::details `静态控件中显示文本`

|         宏          |                             含义                             |
| :-----------------: | :----------------------------------------------------------: |
|      `SS_LEFT`      | 在指定的矩形范围内左对齐显示文本。如果一行显示不了，则会自动换行到下一行。如果一个单词的长度超过控件的宽度，则会被裁剪。 |
|     `SS_CENTER`     | 在指定的矩形范围内居中对齐显示文本。如果一行显示不了，则会自动换行到下一行;如果一个单词的长度超过控件的宽度，则会被裁剪。 |
|     `SS_RIGHT`      | 在指定的矩形范围内右对齐显示文本。如果一行显示不了，则会自动换行到下一行。如果一个单词的长度超过控件的宽度，则会被裁剪。 |
|     `SS_SIMPLE`     | 在指定的矩形范围内显示一行左对齐文本。即使控件指定了较高的高度也不会自动换行显示，如果禁用该控件，则控件不会使其文本变灰。 |
| `SS_LEFTNOWORDWRAP` | 与`SS_SIMPLE`类似，也不会自动换行，但是控件的高度会完全显示  |

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240626221141483.png)



`SS_LEFT`  `SS_CENTER`和`SS_RIGHT`样式的文本静态控件都可以自动换行，但前提是控件具有足够的高度，否则超出控件大小范围的部分不会显示。如果需要根据字符串的实际长度和高度来指定静态控件的宽度和高度参数,可以使用相关字符、字符串计算函数，例如
`GetCharWidth32` `GetTextExtentPoint32`等。

:::





:::details `静态控件中显示图像`



`SS_ICON`图标。CreateWindowEx函数的窗口标题参数lpWindowName指定为图标ID值，该样式会忽略CreateWindowEx函数的宽高参数nWidth和nHeight，系统自动调整静态控件的大小以适应图标，图标的大小默认情况下使用GetSystemMetrics (SM_CXICON)和
GetSystemMetrics(SM_CYICON)返回的值，通常是32 32，可以同时指定SS_REALSIZEIMAGE样式以使用图标的实际大小。



即在默认情况下，不管宽高参数nWidth和nHeight指定为多少，也不管图标
的实际大小是多少，系统总认为图标大小为32 32，并调整静态控件大小为32 32，如果指定了SS_REALSIZEIMAGE样式，则会使用图标的实际大小，并把静态控件调整为图标的实际大小



`SS_BITMAP`位图。CreateWindowEx函数的窗口标题参数lpWindowName指定为位图ID值，该样式会忽略CreateWindowEx函数的宽高参数nWidth和nHeight，系统会根据位图的实际大小自动调整静态控件的大小。如果想使用nWidth和nHeight指定的大小，则可以同时指定SS_REALSIZECONTROL样式，系统会自动调整位图(放大或缩小)以适应静态控件的大小。





:::



:::details `示例:`

```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("StaticDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndStatic[6];
    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        hwndStatic[0] = CreateWindowEx(0, TEXT("Static"), TEXT("Panda64"),
            WS_CHILD | WS_VISIBLE | SS_ICON | SS_NOTIFY | SS_REALSIZEIMAGE | SS_CENTERIMAGE,
            10, 10, 100, 100, hwnd, (HMENU)(1001), hInstance, NULL);        
        return 0;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240626222950008.png)

:::

## SysLink控件



`SysLink`控件是Comctl32.dll版本6以后引入的一个子窗口控件，可以用于显示普通文本和超链接。超链接的文本颜色默认情况下是蓝色，带下划线，超链接支持`Href lD`属性。学过`HTML`的读者对于创建超链接的方法应该很熟悉。`Href`支持任何协议，例如`http https ftpmailto`等。



一个SysLink控件中可以有多个超链接。ID为可选属性，它在一个SysLink控件中必须是唯一的。当用户单击超链接时，系统会发送包含NM_CLICK通知码的WM_NOTIFY消息。要区分是哪一个超链接，可以使用其位置索引，索引从0开始。





:::details `LM_S/GETITEM 消息`



普通文本“我喜欢”的颜色是黑色，超链接文本的颜色是蓝色，SysLink控件的背景是灰色的。

超链接的状态和属性可以通过发送`LM_SETITEM`消息来进行设置。wParam参数没有用到。`IParam`参数是一个指向LITEM结构的指针，该结构包含超链接所需的新状态和属性，也用于`LM_GETITEM`消息中获取超链接的状态和属性。LITEM结构定义如下︰

```c
typedef struct tagLITEM
{
    UINT mask; //标志，要设置或获取哪些项目
    int iLink; //超链接的索引
    UINT state; //超链接的状态，和stateMask设置为相同的值
    UINT stateMask; //超链接的状态掩码
    WCHAR szID[MAX_LINKID_TEXT];  //ID，最大字符数MAX_LINKID_TEXT(48)
    WCHAR szUrl[L_MAX_URL_LENGTH]; //URL，最大字符数 
}LITEM,*PLITEM;
```

- mask字段指定要设置或获取哪些项目，可以是下表所示的一个或多个标志的组合。

| 宏              | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| `LIF_ITEMINDEX` | 超链接的索引，因为通常都是通过索引来确定`SysLink`控件中的一个超链接，所以不管是设置还是获取，都需要指定该标志，并为`iLink`字段设置一个值。 |
| `LIF_ITEMID`    | 超链接的ID，对应`szID`字段                                   |
| `LIF_URL`       | 超链接的URL，对应`szUrl`字段                                 |
| `LIF_STATE`     | 超链接的状态，对应`stateMask`字段                            |

- `state`和`stateMask`字段使用相同的值，可用的值如下表所示。

|       宏       |                             含义                             |
| :------------: | :----------------------------------------------------------: |
| `LIS_ENABLED`  | 默认值，该链接可以响应用户输入，除非创建控件的时候指定了WS_DISABLED样式 |
| `LIS_FOCUSED`  | 该链接具有键盘焦点，此时按Enter键会发送包含NM_CLICK通知码的WM_NOTIFY消息 |
| `LIS_VISITED`  |                     该链接已被用户访问过                     |
| `LIS_HOTTRACK` | 当鼠标悬停在控件上时，将以不同的颜色(COLOR_HIGHLIGHT为蓝色)突出显示 |

:::



:::details `WM_NOTIFY 消息`



当用户单击一个超链接时，系统会发送包含`NM_CLICK`通知码的`WM_NOTIFY`消息。

当超链接具有输入焦点时，按下Enter键会发送包含`NM_RETURN`通知码的`WM_NOTIFY`消息。



程序通常用同样的方法处理这两个消息，要区分是哪一个超链接，可以使用其位置索引，索引从0开始。这两个通知码的IParam参数是一个指向NMLINK结构的指针，该结构定义如下:

```c
typedef struct tagNMLINK
{
    NMHDR hdr;//NMHDR结构
    LITEM item; //LITEM结构，包含超链接的状态和属性信息
}NMLINK,*PNMLINK;
```

:::



:::details `示例`

```c
#include <Windows.h>
#include <tchar.h>
#include <strsafe.h>
#include <CommCtrl.h>

#pragma comment(lib, "Comctl32.lib")

#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

// 函数声明
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("SysLinkDemo");
    HWND hwnd;
    MSG msg;

    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);

    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HFONT hFont;
    static HWND hwndSysLink;

    LITEM li = { 0 };
    PNMLINK pnmLink;

    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        hwndSysLink = CreateWindowEx(0, TEXT("SysLink"),
          TEXT("我喜欢<a href=\"http://www.WindowsChs.com/\" ID=\"Windows\" >Windows程序设计</a>\n")
          TEXT("我喜欢<a href=\"http://www.TaoBao.com/\" ID=\"TaoBao\" >淘宝购物</a>\n")
          TEXT("我喜欢<a href=\"http://www.360Buy.com/\" ID=\"360Buy\" >京东商城</a>"),
          WS_CHILD | WS_VISIBLE | WS_TABSTOP | LWS_TRANSPARENT,
          10, 10, 200, 60, hwnd, (HMENU)(1001), hInstance, NULL);
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, DEFAULT_CHARSET, 0, 0, 0, 0, TEXT("微软雅黑"));
        SendMessage(hwndSysLink, WM_SETFONT, (WPARAM)hFont, FALSE);
        return 0;
    case WM_LBUTTONDBLCLK:
        li.mask = LIF_ITEMINDEX | LIF_URL;
        li.iLink = 0;
        StringCchCopy(li.szUrl, L_MAX_URL_LENGTH, TEXT("https://msdn.microsoft.com/"));
        SendMessage(hwndSysLink, LM_SETITEM, 0, (LPARAM)&li);
        return 0;
    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case NM_CLICK:
        case NM_RETURN:
            pnmLink = (PNMLINK)lParam;
            if (pnmLink->hdr.hwndFrom == hwndSysLink)
            {
                if (pnmLink->item.iLink == 0)
                    ShellExecute(NULL, TEXT("open"), pnmLink->item.szUrl, NULL, NULL, SW_SHOW);
                else if (pnmLink->item.iLink == 1)
                    ShellExecute(NULL, TEXT("open"), pnmLink->item.szUrl, NULL, NULL, SW_SHOW);
                else if (pnmLink->item.iLink == 2)
                    ShellExecute(NULL, TEXT("open"), pnmLink->item.szUrl, NULL, NULL, SW_SHOW);
            }
            break;
        }
        return 0;
    case WM_DESTROY:
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240626224553793.png)

在创建SysLink控件时，指定`LWS_TRANSPARENT`透明样式。

在客户区中双击时，程序发送一个`LM_SETITEM`消息，设置第1个超链接的URL为
https://msdn.microsoft.com/。

在`WM_NOTIFY`消息中处理`NM_CLICK`和`NM_RETURN`通知码，根据超链接的索引分别进行处理，`ShellExecute`函数用于打开一个文件或URL。

:::



## 全局热键与特定线程热键



热键，也叫快捷键。当用户在热键控件中输入用于热键的组合键时，组合键的名称会显示在热键控件中，如，组合键包括`修饰键(Ctrl Alt Shift)`和伴随键（数字字母键、方向键、功能键F1～F12)。



用户输入组合键以后，程序可以获取热键控件中的组合键，以设置全局热键或特定于线程的热键。





:::details `HKM_GETHOTKEY 消息`



发送`HKM_GETHOTKEY`消息可以获取热键控件中的修饰键和伴随键，消息的`wParam`和`lParam`参数都没有用到。



该消息返回一个包含修饰键标志和伴随键的虚拟键码的`DWORD`值。

- `LOBYTE(LOWORD(返回值))` 表示热键的伴随键的虚拟键码

- `HIBYTE(LOWORD(返回值))` 表示热键的修饰键标志。



修饰键标志可以是下表所示值的组合。



- `HOTKEYF_SHIFT1` Shift键
- `HOTKEYF_CONTROL2` Ctrl键
- `HOTKEYF_ALT4` Alt键



:::





:::details `HKM_SETHOTKEY 消息`



发送`HKM_SETHOTKEY`消息可以设置热键控件中的修饰键和伴随键。

- `LOBYTE(LOWORD (wParam))`表示热键的伴随键的虚拟键码。
- `HIBYTE(LOWORD (wParam))`表示热键的修饰键标志，`IParam`参数没有用到，该消息始终返回0。





**全局热键与指定的窗口相关联**，不管该窗口是否处于活动状态，按下全局热键以后，系统都会通知该窗口。可以通过发送`WM_SETHOTKEY`消息设置全局热键。



每当用户按下全局热键时，如果发送`WM_SETHOTKEY`消息设置全局热键的窗口处于活动状态，那么将收到`WM_SYSCOMMAND`消息(`wParam等于SC_HOTKEY,lParam等于窗口的句柄`)。如果该窗口没有处于活动状态，那么系统会激活该窗口到前台显示，在调用`WM_SETHOTKEY`消息设置全局热键的应用程序退出之前，热键一直有效。

:::



:::details `WM_SETHOTKEY 消息`



`WM_SETHOTKEY`消息的`LOWORD(wParam)`指定热键的伴随键的虚拟键码。

`HIWORD(wParam)`指定热键的修饰键标志，



因此`LOWORD(HKM_GETHOTKEY)`消息的返回值可以用作`WM_SETHOTKEY`消息的`wParam`参数。`wParam`参数设置为NULL表示删除与窗口关联的全局热键;



`IParam`参数没有用到。



具有`WS_CHILD`窗口样式的窗口不能设置全局热键。该消息的返回值包括



- -1 热键无效(例如VK_ESCAPE-VK_SPACE和VK_TAB等都是无效的热键)
- 0  窗口无效
- 1 成功，没有其他窗口具有相同的热键
- 2 成功，但另一个窗口已具有相同的热键





一个窗口只能关联一个全局热键，如果窗口已经有一个与之关联的全局热键，则新设置的全局热键将替换旧的全局热键。



如果多个窗口具有相同的全局热键，则由全局热键激活的窗口是随机的。



:::tip

发送`WM_SETHOTKEY`消息可以设置一个与指定窗口相关联的全局热键。按下全局热键以后，如果该窗口没有处于活动状态，则系统会激活该窗口。

如果该窗口处于活动状态，则会收到`WM_SYSCOMMAND`消息 (`wParam`等于`SC_HOTKEY`，`IParam`等于窗口的句柄)，所以该消息主要用于将程序窗口调到前台。全局热键也称为**窗口激活热键**。

:::

:::









如果需要在用户按下热键以后执行某种操作，例如QQ程序不管是处于最小化还是活动状态，按下Ctrl + Alt +A组合键都可以打开QQ截图程序，这可以通过调用`RegisterHotKey`函数设置特定于线程的系统范围的热键来实现。



在用户按下`RegisterHotKey`函数指定的热键以后，系统会发送`WM_HOTKEY`消息到线程的消息队列，该热键不会把程序窗口调到前台。程序执行以后会创建一个主线程。如果需要，程序可以通过调用`CreateThread`函数创建其他线程。



:::details `RegisterHotKey 函数说明`

```c
/// <summary>
/// 注册线程级别热键
/// </summary>
/// <param name="hWnd">窗口句柄，将接收由热键生成的WM_HOTKEY消息</param>
/// <param name="id">热键的ID</param>
/// <param name="fsModifiers">修饰键标志</param>
/// <param name="vk">伴随键的虚拟键码</param>
/// <returns>如果函数执行成功，则返回值为非0值﹔如果函数执行失败，则返回值为0。要获取错误信息,请调用GetLastError</returns>
BOOL RegisterHotKey(HWND hWnd, int id,UINT fsModifiers,UINT vk );
```

- hWnd参数指定窗口句柄，该窗口将接收由热键生成的`WM_HOTKEY`消息，热键与`hWnd`指定的窗口相关联。如果设置为NULL，则`WM_HOTKEY`消息将发送到调用该函数的线程的消息队列中，即在这种情况下热键与调用该函数的线程相关联。程序可以在消
  息循环中处理该消息以决定发送给哪个窗口，如同计时器的其他方式的消息循环中的处理代码。
- id参数指定热键的ID，因为一个程序可以通过调用`RegisterHotKey`函数设置多个热键，在`WM_HOTKEY`消息中可以通过id来确定是哪个热键。程序可以指定`O×0000～OxBFFF`范围内的id值，如果是动态链接库，则必须指定`OxCo00～OxFFFF`范围内的id值(一个程序可以同时加载多个动态链接库，为避免与其他动态链接库定义的热键id冲突，动态链接库应使用`GlobalAddAtom`函数来分配一个热键id)。
- fsModifiers参数指定修饰键标志。
  - MOD_ALT1 Alt
  - MOD_CONTROL2 Ctrl
  - MOD_SHIFT4 Shift
    MOD_WIN8 Windows键



特定于线程的系统范围的热键表示在系统中是唯一的。如果系统中其他程序已经注册过相同的热键组合键，则`RegisterHotKey`函数调用
会失败。如果使用相同的`Hwnd`和`id`又创建了一个或多个组合键不同的特定线程热键，则旧热键与新热键都可以工作。

:::



:::details `UnregisterHotKey 函数说明`



如果需要取消注册热键，可以调用UnregisterHotKey函数∶

```c
BOOL WINAPI UnregisterHotKey(_In_opt_HWND hWnd, _In_int id);
```

`WM_HOTKEY`消息的wParam参数是生成消息的热键的id，

- LOWORD(IParam)是以MOD_开头的修饰键标志。
- HIWORD(IParam)是伴随键的虚拟键码。

:::







:::details `示例:`

```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("HotKeyDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 290, 150, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndHotKeyHwnd, hwndBtnSetHwnd;     // 与窗口激活热键相关的热键控件和按钮句柄
    static HWND hwndHotKeyThread, hwndBtnSetThread; // 与特定线程热键相关的热键控件和按钮句柄
    static HFONT hFont;
    DWORD dwHotKey;         // 发送HKM_GETHOTKEY消息获取热键控件的修饰键和伴随键的返回值
    DWORD dwRet;            // 发送WM_SETHOTKEY消息设置窗口激活热键的返回值
    UINT fsModifiers = 0;   // RegisterHotKey函数的fsModifiers参数，修饰键标志

    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        // 2个热键控件
        hwndHotKeyHwnd = CreateWindowEx(0, TEXT("msctls_hotkey32"), NULL,
            WS_CHILD | WS_VISIBLE,
            10, 10, 120, 22, hwnd, (HMENU)IDC_HOTKEYHWND, hInstance, NULL);
        hwndHotKeyThread = CreateWindowEx(0, TEXT("msctls_hotkey32"), NULL,
            WS_CHILD | WS_VISIBLE,
            140, 10, 120, 22, hwnd, (HMENU)IDC_HOTKEYTHREAD, hInstance, NULL);

        // 2个按钮
        hwndBtnSetHwnd = CreateWindowEx(0, TEXT("Button"), TEXT("设置窗口激活热键"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            10, 40, 120, 25, hwnd, (HMENU)IDC_BTNSETHWND, hInstance, NULL);
        hwndBtnSetThread = CreateWindowEx(0, TEXT("Button"), TEXT("注册特定线程热键"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            140, 40, 120, 25, hwnd, (HMENU)IDC_BTNSETTHREAD, hInstance, NULL);

        // 设置字体
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("微软雅黑"));
        SendMessage(hwndHotKeyHwnd, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndHotKeyThread, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndBtnSetHwnd, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndBtnSetThread, WM_SETFONT, (WPARAM)hFont, FALSE);
        return 0;

    case WM_SETFOCUS:
        SetFocus(hwndHotKeyHwnd);
        return 0;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_BTNSETHWND:
            dwHotKey = SendMessage(hwndHotKeyHwnd, HKM_GETHOTKEY, 0, 0);
            if (!HIBYTE(LOWORD(dwHotKey)) || !LOBYTE(LOWORD(dwHotKey)))
            {
                MessageBox(hwnd, TEXT("设置窗口激活热键需要修饰键和伴随键"), TEXT("错误"), MB_OK);
                return 0;
            }
            // 设置窗口激活热键
            dwRet = SendMessage(hwnd, WM_SETHOTKEY, LOWORD(dwHotKey), 0);
            if (dwRet <= 0)
                MessageBox(hwnd, TEXT("窗口激活热键设置失败"), TEXT("错误"), MB_OK);
            else if (dwRet == 1)
                MessageBox(hwnd, TEXT("成功，没有其他窗口具有"), TEXT("成功"), MB_OK);
            else if (dwRet == 2)
                MessageBox(hwnd, TEXT("成功，但另一个窗口已具有"), TEXT("警告"), MB_OK);
            break;

        case  IDC_BTNSETTHREAD:
            dwHotKey = SendMessage(hwndHotKeyThread, HKM_GETHOTKEY, 0, 0);
            if (HIBYTE(LOWORD(dwHotKey)) & HOTKEYF_SHIFT)
                fsModifiers |= MOD_SHIFT;
            if (HIBYTE(LOWORD(dwHotKey)) & HOTKEYF_CONTROL)
                fsModifiers |= MOD_CONTROL;
            if (HIBYTE(LOWORD(dwHotKey)) & HOTKEYF_ALT)
                fsModifiers |= MOD_ALT;
            if (!fsModifiers || !LOBYTE(LOWORD(dwHotKey)))
            {
                MessageBox(hwnd, TEXT("注册特定线程热键需要修饰键和伴随键"), TEXT("错误"), MB_OK);
                return 0;
            }
            // 注册特定线程热键
            if (RegisterHotKey(hwnd, 1, fsModifiers, LOBYTE(LOWORD(dwHotKey))))
                MessageBox(hwnd, TEXT("注册特定线程热键成功"), TEXT("注册成功"), MB_OK);
            else
                MessageBox(hwnd, TEXT("注册特定线程热键失败"), TEXT("注册失败"), MB_OK);
            break;
        }
        return 0;

    case WM_SYSCOMMAND:
        // 如果该窗口处于活动状态则会收到WM_SYSCOMMAND消息
        // 实际编程中很少处理SC_HOTKEY的WM_SYSCOMMAND消息
        if ((wParam & 0xFFF0) == SC_HOTKEY)
        {
            MessageBox(hwnd, TEXT("窗口激活热键消息"), TEXT("消息"), MB_OK);
            return 0;
        }
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    case WM_HOTKEY:
        // 处理特定线程热键消息
        if (wParam == 1)
            MessageBox(hwnd, TEXT("特定线程热键消息"), TEXT("消息"), MB_OK);
        return 0;
    case WM_DESTROY:
        UnregisterHotKey(hwnd, 1);
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240626225700074.png)

:::



## IP地址控件

目前应用最广泛的IP地址是基于IPv4的，一个IP地址的长度为32位，即4字节(DWORD)数据。IP地址中的每字节使用一个十进制数字来表示，每字节的数值范围是0～255，数字之间使用小数点分隔。lPv4的IP地址格式为XXX.XXX.XXX.XXX，这种IP地址表示法称为点分十进制表示法。IP地址控件允许用户以点分十进制表示法输入IP地址。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240626232255359.png)





4个数字是4个域，实际上每个域都是一个编辑控件。当IP地址控件获得、失去键盘焦点时会收到`EN_SETFOCUS`   ` EN_KILLFOCUS`通知码。当IP地址控件中的任何域更改时，都会收到`EN_CHANGE`通知码(通过`WM_COMMAND`消息的形式)，这些通知码通常都不需要处理。



## 图像列表`ImageList_Create`函数





图像列表是具有相同大小的多个图像的集合，每个图像都可以通过其索引来引用，图像列表用于有效管理大量图标或位图。图像列表并不是一个窗口，因此没有窗口类名。



可以通过调用`ImageList_Create`函数创建一个图像列表，函数返回HIMAGELIST图像列表句柄。




:::details `ImageList_Create 函数说明`

```c

/// <summary>
/// 创建图像列表
/// </summary>
/// <param name="cx">每个图像的宽度，以像素为单位</param>
/// <param name="cy"><每个图像的高度，以像素为单位/param>
/// <param name="flags">要创建的图像列表类型标志，设置为0表示默认</param>
/// <param name="clnitial">图像列表最初包含的图像个数</param>
/// <param name="cGrow">当图像列表中的图像个数超过cInitial时，可以动态增长的图像个数，可以设置为0</param>
/// <returns></returns>
HIMAGELIST ImageList_Create(int cx, int cy,UINT flags,int clnitial,int cGrow);
```

- flags参数指定要创建的图像列表的类型 ，可以是下表的组合。

|         宏          |                             含义                             |
| :-----------------: | :----------------------------------------------------------: |
|     `ILC_COLOR`     |              默认情况，使用ILC_COLOR4(4位色DIB)              |
|    `ILC_COLOR24`    |                          24位色DIB                           |
|    `ILC_COLOR32`    |                          32位色DIB                           |
|   `ILC_COLORDDB`    |                     使用设备相关位图DDB                      |
|     `ILC_MASK`      | 使用掩码，包含两个位图，其中一个是用作掩码的单色位图。如果没有指定该标志，则仅包含一个位图。图标或光标通常需要指定该类型，因为图标或光标内含掩码数据 |
| `ILC_CORIGINALSIZE` |                使用所添加的图像的原始实际大小                |
|                     |                                                              |

:::





:::details `ImageList_Destroy 函数说明` 

当不再需要图像列表的时候，可以通过调用`ImageList_Destroy`函数将其销毁︰

```c
/// <summary>
/// 销毁图像列表
/// </summary>
/// <param name="himl"></param>
/// <returns></returns>
BOOL ImageList_Destroy(HIMAGELIST himl)
```

:::



创建图像列表以后，可以添加、删除、替换、合并、绘制和拖动图像。这里主要讲解添加、删除和替换图像。可以通过调用`lmageList_Add`函数把位图添加到图像列表中，通过调用`lmageList_Addlcon`宏把图标或光标添加到图像列表中:



:::details `ImageList_Add 函数说明`

```c
/// <summary>
/// 把位图添加到图像列表中
/// </summary>
/// <param name="himl">图像列表句柄</param>
/// <param name="hbmlmage">要添加的位图句柄</param>
/// <param name="hbmMask">掩码位图的句柄，如果不需要，可以设置为NULL</param>
/// <returns></returns>
int ImageList_Add(HIMAGELIST himl,HBITMAP hbmlmage,HBITMAP hbmMask);  
```

`lmageList_Add`函数可以一次将一个或多个位图添加到图像列表中。



- hbmlmage参数指定要添加到图像列表的位图句柄。假设图像列表的宽高为32像素32像素，如果需要添加10个3232大小的位图，可以把这10个位图制作到一个宽高为320像素32像素的大位图中，函数会根据图像列表和位图的宽度自动计算位图个数。

:::



:::details `ImageList_AddIcon 函数说明`

```c
/// <summary>
/// 将每个图像添加到图像列表中
/// </summary>
/// <param name="himl">图像列表句柄</param>
/// <param name="hicon">要添加的图标或光标句柄，图标或光标文件本身包含掩码数据</param>
/// <returns></returns>
int ImageList_AddIcon(HIMAGELIST himl,HICON hicon); 

```

:::





调用`ImageList_Replace`函数可以用一个新位图替换图像列表中的旧位图，调用`ImageList_Replacelcon`函数可以用一个新图标或光标替换图像列表中的旧图标或光标∶



:::details `ImageList_Replace/ImageList_ReplaceIcon 函数说明`

```c

/// <summary>
/// 用一个新位图替换图像列表中的旧位图
/// </summary>
/// <param name="himl">图像列表句柄</param>
/// <param name="i">要替换的位图的索引</param>
/// <param name="hbmlmage">新位图句柄</param>
/// <param name="hbmMask">新掩码位图句柄</param>
/// <returns></returns>
BOOL ImageList_Replace(HIMAGELIST himl,int i,HBITMAP hbmlmage,HBITMAP hbmMask); 
```



```c
    /// <summary>
    /// 用一个新图标替换图像列表中的旧图标
    /// </summary>
    /// <param name="himl">图像列表句柄</param>
    /// <param name="i">要替换的图标或光标的索引</param>
    /// <param name="hicon">新图标或光标句柄</param>
    /// <returns></returns>
    int ImageList_ReplaceIcon(HIMAGELIST himl,int i,HICON hicon); 
```

:::



要从图像列表中删除图像可以调用`lmageList_Remove`函数



:::details `ImageList_Remove 函数说明`

```c
/// <summary>
/// 删除图像列表中的所有图像
/// </summary>
/// <param name="himl">图像列表句柄</param>
/// <param name="i">图像索引</param>
/// <returns>  如果图像索引参数i设置为-1，则从图像列表中删除所有图像</returns>
BOOL ImageList_Remove(HIMAGELIST himl,int i); 
```

:::



## 工具提示控件

工具提示控件是一个小窗口。当鼠标光标悬停在一个控件或特定区域上时，该窗口会自动弹出，通常用于显示一些提示或帮助信息。在资源管理器中，当用户把鼠标悬停在某一文件上时，会弹出一个工具提示控件，显示该文件的大小、类型和修改日期。







:::details `TTM_ADDTOOL消息`

发送`TTM_ADDTOOL`消息可以为工具提示控件添加"工具"，也可以说是向工具提示控件注册该"工具"。 `wParam`参数没有用到。`IParam`参数是一个指向TOOLINFO结构的指针，该结构包含工具提示控件显示`"工具"`所需的相关信息。

`TOOLINFO`结构中定义如下∶

```c
typedef struct 
{
	UINT cbSize; //该结构的大小
	UINT uFlags; //控制工具提示控件显示的标志
	HWND hwnd; //rect字段指定的边界矩形所属的窗口句柄
	UINT_PTR uld; //工具的窗口句柄或ID
	RECT rect;  //"工具"的边界矩形坐标，如果uFlags字段包含TTF_IDISHWND标志则忽略该字段
	HINSTANCE hinst; //包含字符串资源的模块句柄(如果lpszText字段指定为字符串资源ID)
	LPTSTR lpszText; //"工具"的提示文本字符串指针，或指定为字符串资源ID
	LPARAM lParam; //与"工具"关联的32位自定义数据
	void* lpReserved; //保留，必须设置为NULL
}TOOLINFO, * PTOOLINFO, * LPTOOLINFO;
```

- uFlags字段是控制工具提示控件显示的标志。
- hwnd字段是rect字段指定的边界矩形所属的窗口句柄。如果lpszText字段指定为LPSTR_TEXTCALLBACK，则hwnd是接收TTN_GETDISPINFO通知码(WM_NOTIFY)的窗口句柄。
- uld字段表示“工具”的窗口句柄或ID，取决于uFlags字段是否指定了TTF_IDISHWND标志。
- rect字段指定“工具"的边界矩形坐标，相对于hwnd字段指定的窗口的客户区。如果uFlags包含TTF_IDISHWND标志，则忽略该字段。
- hinst字段指定包含字符串资源的模块句柄（如果lpszText字段指定为字符串资源ID)。
- lpszText字段表示“工具”的提示文本字符串指针，或指定为字符串资源ID。如果该字段设置为LPSTR_TEXTCALLBACK，则工具提示控件会将TTN_GETDISPINFO通知码(WM_NOTIFY)发送到hwnd字段指定的窗口，程序可以处理该通知码以设置提示文本。

:::





:::details `超时时间 TTM_SETDELAYTIME`

鼠标光标必须悬停在`"工具"`上一段时间后工具提示控件扌会弹出，默认的超时时间为鼠标双击的时间，即`GetDoubleClickTime()`函数返回的值，通常为500ms。要指定非默认超时值，可以向工具提示控件发送`TTM_SETDELAYTIME`消息。



`TTM_SETDELAYTIME`消息的`wParam`参数用于指定要设置哪个超时时间值。



`lParam`参数指定超时时间，以毫秒为单位。



:::





:::details `示例:`



```c
#include <Windows.h>
#include <Commctrl.h>
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker, "\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("EditDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HINSTANCE hInstance;
    static HWND hwndUserName, hwndPassword, hwndAge, hwndRegister, hwndTip;
    static HWND hwndStatic[4];
    static HFONT hFont;
    int cx, cy;
    RECT rect;
    TOOLINFO ti = { 0 };
    RECT rcClient;

    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        hFont = CreateFont(12, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("宋体"));

        hwndStatic[0] = CreateWindowEx(0, TEXT("Static"), TEXT("会员注册"),
            WS_CHILD | WS_VISIBLE | SS_CENTER, 130, 20, 80, 20, hwnd, (HMENU)(-1), hInstance, NULL);

        // 用户名
        hwndStatic[1] = CreateWindowEx(0, TEXT("Static"), TEXT("用户名："),
            WS_CHILD | WS_VISIBLE, 20, 50, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndUserName = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL,
            80, 50, 220, 20, hwnd, (HMENU)(1000), hInstance, NULL);

        // 密码
        hwndStatic[2] = CreateWindowEx(0, TEXT("Static"), TEXT("密  码："),
            WS_CHILD | WS_VISIBLE, 20, 75, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndPassword = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_PASSWORD,
            80, 75, 180, 20, hwnd, (HMENU)(1001), hInstance, NULL);

        // 年龄
        hwndStatic[3] = CreateWindowEx(0, TEXT("Static"), TEXT("年  龄："),
            WS_CHILD | WS_VISIBLE, 20, 100, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndAge = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_NUMBER,
            80, 100, 180, 20, hwnd, (HMENU)(1002), hInstance, NULL);

        // 注册按钮
        hwndRegister = CreateWindowEx(0, TEXT("Button"), TEXT("注册"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_NOTIFY | WS_TABSTOP,
            85, 130, 150, 25, hwnd, (HMENU)(1003), hInstance, NULL);

        // 设置所有控件字体
        SendMessage(hwndUserName, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndPassword, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndAge, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndRegister, WM_SETFONT, (WPARAM)hFont, FALSE);
        for (int i = 0; i < _countof(hwndStatic); i++)
            SendMessage(hwndStatic[i], WM_SETFONT, (WPARAM)hFont, FALSE);

        // 用户名、密码、年龄分别限制输入20、12、3个字符
        SendMessage(hwndUserName, EM_SETLIMITTEXT, 20, 0);
        SendMessage(hwndPassword, EM_SETLIMITTEXT, 12, 0);
        SendMessage(hwndAge, EM_SETLIMITTEXT, 3, 0);

        // 设置程序窗口大小，客户区所需最小大小为320 * 175
        SetRect(&rect, 0, 0, 320, 175);
        AdjustWindowRectEx(&rect, GetWindowLongPtr(hwnd, GWL_STYLE),
            GetMenu(hwnd) != NULL, GetWindowLongPtr(hwnd, GWL_EXSTYLE));
        SetWindowPos(hwnd, NULL, 0, 0, rect.right - rect.left, rect.bottom - rect.top,
            SWP_NOZORDER | SWP_NOMOVE);

        //////////////////////////////////////////////////////////////////////////
        // 工具提示控件
        hwndTip = CreateWindowEx(WS_EX_TOPMOST, TEXT("tooltips_class32"), NULL, 
            WS_POPUP | TTS_ALWAYSTIP | TTS_BALLOON,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
            hwnd, NULL, hInstance, NULL);

        // 工具提示控件的标题和图标
        SendMessage(hwndTip, TTM_SETTITLE,
            (WPARAM)LoadIcon(NULL, IDI_INFORMATION), (LPARAM)TEXT("提示信息"));

        // 设置超时时间
        SendMessage(hwndTip, TTM_SETDELAYTIME, TTDT_INITIAL, 100);
        SendMessage(hwndTip, TTM_SETDELAYTIME, TTDT_AUTOPOP, 10000);

        // 添加“工具”
        ZeroMemory(&ti, sizeof(ti));
        ti.cbSize = sizeof(TOOLINFO);
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;

        ti.uId = (UINT_PTR)hwndUserName;
        ti.lpszText = TEXT("请输入用户名，最少3个字符");
        SendMessage(hwndTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

        ti.uId = (UINT_PTR)hwndPassword;
        ti.lpszText = TEXT("请输入密码，最少3个字符");
        SendMessage(hwndTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

        ti.uId = (UINT_PTR)hwndAge;
        ti.lpszText = TEXT("请输入0～120岁的年龄");
        SendMessage(hwndTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

        // 客户区右下角50*50像素的矩形区域定义为“工具”(客户区不随便调整大小的情况下)
        GetClientRect(hwnd, &rcClient);
        SetRect(&rcClient, rcClient.right - 50, rcClient.bottom - 50, rcClient.right, rcClient.bottom);
        ZeroMemory(&ti, sizeof(ti));
        ti.cbSize = sizeof(TOOLINFO);
        ti.uFlags = TTF_SUBCLASS;
        ti.rect = rcClient;
        ti.hwnd = hwnd;
        ti.uId = 1;
        ti.lpszText = TEXT("把程序窗口的客户区右下角50*50像素的矩形区域定义为“工具”");
        SendMessage(hwndTip, TTM_ADDTOOL, 0, (LPARAM)&ti);
        //////////////////////////////////////////////////////////////////////////
        return 0;

    case WM_LBUTTONDBLCLK:
        ZeroMemory(&ti, sizeof(ti));
        ti.cbSize = sizeof(TOOLINFO);
        GetClientRect(hwnd, &ti.rect);
        ti.hwnd = hwnd;
        SendMessage(hwndTip, TTM_NEWTOOLRECT, 0, (LPARAM)&ti);
        return 0;

    case WM_SIZE:
        if (LOWORD(lParam) >= 320 && HIWORD(lParam) >= 175)
        {
            cx = (LOWORD(lParam) - 320) / 2;
            cy = (HIWORD(lParam) - 175) / 2;
            SetWindowPos(hwndStatic[0], NULL, 130 + cx, 20  + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndStatic[1], NULL, 20  + cx, 50  + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndStatic[2], NULL, 20  + cx, 75  + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndStatic[3], NULL, 20  + cx, 100 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndUserName,  NULL, 80  + cx, 50  + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndPassword,  NULL, 80  + cx, 75  + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndAge,       NULL, 80  + cx, 100 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndRegister,  NULL, 85  + cx, 130 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
        }
        return 0;

    case WM_COMMAND:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            if (LOWORD(wParam) == 1003)
            {
                int nLen;
                LPTSTR lpUserName, lpPassword;
                TCHAR szBuf[64] = { 0 };
                nLen = SendMessage(hwndUserName, EM_LINELENGTH, 0, 0);
                if (nLen < 3)
                {
                    MessageBox(hwnd, TEXT("用户名至少需要3个字符"), TEXT("错误提示"), MB_OK);
                    return 0;
                }
                lpUserName = new TCHAR[nLen + 1];
                ZeroMemory(lpUserName, (nLen + 1) * sizeof(TCHAR));
                lpUserName[0] = nLen + 1;
                SendMessage(hwndUserName, EM_GETLINE, 0, (LPARAM)lpUserName);

                nLen = SendMessage(hwndPassword, EM_LINELENGTH, 0, 0);
                if (nLen < 3)
                {
                    MessageBox(hwnd, TEXT("密码至少需要3个字符"), TEXT("错误提示"), MB_OK);
                    return 0;
                }
                lpPassword = new TCHAR[nLen + 1];
                ZeroMemory(lpPassword, (nLen + 1) * sizeof(TCHAR));
                lpPassword[0] = nLen + 1;
                SendMessage(hwndPassword, EM_GETLINE, 0, (LPARAM)lpPassword);

                wsprintf(szBuf, TEXT("用户名：%s\n密  码：%s\n年  龄：%d"), 
                    lpUserName, lpPassword, GetDlgItemInt(hwnd, 1002, NULL, FALSE));
                MessageBox(hwnd, szBuf, TEXT("注册信息"), MB_OK);

                delete[] lpUserName;
                delete[] lpPassword;
            }
        }
        return 0;
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORSTATIC:
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);

    case WM_DESTROY:
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240627215401528.png)

当鼠标光标悬停在用户名、密码或年龄编辑控件(“工具")上时，会弹出相应的提示文本。在用户单击鼠标按钮、鼠标光标离开“工具"或等待几秒后，工具提示控件会消失。

:::



## 跟踪工具提示

`"工具"`提示文本可以是固定的，也可以随鼠标光标的移动而移动，称为跟踪工具提示。要创建跟踪工具提示，发送`TTM_ADDTOOL`消息注册“工具"的时候需要在`TOOLINFO`结构的`uFlags`字段中包含`TTF_TRACK`标志。还需要通过向工具提示控件发送`TTM_TRACKACTIVATE`消息手动激活(显示)或停用（隐藏）跟踪工具提示;跟踪工具提示处于激活状态时，还需要通过向工具提示控件发送`TTM_TRACKPOSITION`消息来指定跟踪工具提示的位置。





接下来实现一个跟踪工具提示的例子，当鼠标光标在客户区中移动时实时显示光标位置处的坐标。



:::details `示例:`

```c
#include <Windows.h>
#include <WindowsX.h>
#include <CommCtrl.h>
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("TrackTool");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndTip;
    static BOOL bTracking = FALSE;
    static int oldX, oldY;
    int newX, newY;
    static TOOLINFO ti = { sizeof(TOOLINFO) };
    TRACKMOUSEEVENT tme = { sizeof(TRACKMOUSEEVENT) };
    POINT pt;
    TCHAR szBuf[24] = { 0 };

    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        // 创建工具提示控件
        hwndTip = CreateWindowEx(WS_EX_TOPMOST, TEXT("tooltips_class32"), NULL,
            WS_POPUP | TTS_ALWAYSTIP,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            hwnd, NULL, hInstance, NULL);

        // 添加跟踪工具，客户区域
        ti.uFlags = TTF_TRACK | TTF_ABSOLUTE;
        ti.hwnd = hwnd;
        ti.uId = 1001;
        GetClientRect(hwnd, &ti.rect);
        SendMessage(hwndTip, TTM_ADDTOOL, 0, (LPARAM)&ti);
        return 0;

    case WM_MOUSEMOVE:
        // 程序可以通过调用TrackMouseEvent函数让系统发送另外两条消息：
        // 当鼠标光标悬停在客户区一段时间后发送WM_MOUSEHOVER消息，
        // 当光标离开客户区时发送WM_MOUSELEAVE消息。
        if (!bTracking)
        {
            tme.dwFlags = TME_LEAVE;
            tme.hwndTrack = hwnd;
            TrackMouseEvent(&tme);

            bTracking = TRUE;
        }

        // 激活跟踪工具提示
        SendMessage(hwndTip, TTM_TRACKACTIVATE, (WPARAM)TRUE, (LPARAM)&ti);

        newX = GET_X_LPARAM(lParam);
        newY = GET_Y_LPARAM(lParam);
        if ((newX != oldX) || (newY != oldY))
        {
            oldX = newX;
            oldY = newY;

            // 更改“工具”的提示文本
            wsprintf(szBuf, TEXT("鼠标的客户区坐标：%d, %d"), newX, newY);
            ti.lpszText = szBuf;
            SendMessage(hwndTip, TTM_SETTOOLINFO, 0, (LPARAM)&ti);

            // 移动跟踪工具提示的位置
            pt = { newX, newY };
            ClientToScreen(hwnd, &pt);
            SendMessage(hwndTip, TTM_TRACKPOSITION, 0, MAKELPARAM(pt.x, pt.y));
        }
        return 0;

    case WM_MOUSELEAVE:
        // 停用跟踪工具提示
        SendMessage(hwndTip, TTM_TRACKACTIVATE, FALSE, (LPARAM)&ti);
        bTracking = FALSE;
        return 0;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

:::

## 列表视图

列表视图控件和列表框控件类似，但是列表视图控件提供了多种排列和显示列表项的方法，比列表框控件更灵活。列表视图控件有图标、小图标、列表、报表（也称详情视图，有列标题）等排列显示方式。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240627221225052.png)



- **图标视图**的每一个列表项通常会显示一个32像素32像素的图标，图标下方显示列表项文本。
- **小图标视图**的每一个列表项通常会显示一个16像素16像素的图标，图标右侧显示列表项文本。
- **列表视图**的每一个列表项通常会显示一个16像素16像素的图标，图标右侧显示列表项文本，列表项按列排序。
- **报表视图**的每一个列表项的最左一列通常会显示一个16像素16像素的图标，图标右侧显示列表项文本，每一个列表项还可以选择显示其他列(也称子项)，用于显示一些附加信息，按列排序，每一列的顶部会显示一个列标题。另外，和列表框控件一样，每个列表项都可以关联一个项目数据。



:::details `列表视图控件样式`

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240627221626739.png)

:::







:::details  `LVM_INSERTCOLUMN/LVM_INSERTITEM消息 添加标题、列表项`



在创建列表视图控件后，可以通过发送`LVM_INSERTITEM`消息添加列表项。如果是`LVS_REPORT`报表视图样式，还必须首先通过发送`LVM_INSERTCOLUMN`消息来添加列标题。





`LVM_INSERTCOLUMN`消息的`wParam`参数指定为列的索引(第一列为0，第二列为1，依次类推)。`lParam`参数是一个指向包含列属性的LVCOLUMN结构的指针。



如果执行成功，则返回新列的索引。如果执行失败，则返回-1。

只有在报表视图中才会显示列标题，在其他视图中即使添加了列也不会显示。

`LVCOLUMN`结构定义如下∶

```c
typedef struct _LVCOLUMN
{
	UINT mask; //掩码标志，指定哪个字段有效
	int fmt; //列标题和列表项子项的文本在列中的对齐方式，但最左一列始终左对齐
	int cx; //列的宽度，以像素为单位
	LPTSTR pszText; //列标题字符串指针，如果获取列信息，则是字符串缓冲区地址
	int cchTextMax; //pszText指向的缓冲区的大小，以字符为单位，如果是设置列信息，则忽略该字段
	int iSubltem; //列的索引，通常和wParam参数使用相同的值
	int ilmage; //图像列表中图像的从O开始的索引，指定的图像将显示在列标题左侧intiorder; lI按从左到右的顺序排列的列偏移，例如，0表示最左边的列，通常不设置
	int cxMin; //列的最小宽度，以像素为单位，通常不设置int cxDefault; ll一般不使用
	int cxldeal; //列的理想宽度，只读（用于获取，而不是设置
}LVCOLUMN, * LPLVCOLUMN;
```

- mask字段是掩码标志，指定哪个字段有效。

|         宏          |       含义        |
| :-----------------: | :---------------: |
|     `LVCF_FMT`      |    fmt字段有效    |
|    `LVCF_WIDTH`     |    cx字段有效     |
|     `LVCF_TEXT`     |  pszText字段有效  |
|   `LVCF_SUBITEM`    | iSubltem字段有效  |
|    `LVCF_IMAGE`     |  ilmage字段有效   |
|    `LVCF_ORDER`     |  iOrder字段有效   |
|   `LVCF_MINWIDTH`   |   cxMin字段有效   |
| `LVCF_DEFAULTWIDTH` | cxDefault字段有效 |
|  `LVCF_IDEALWIDTH`  |  cxldeal字段有效  |

- fmt字段指定列标题和列表项子项的文本在列中的对齐方式。最左列始终`LVCFMT_LEFT`左对齐方式，这无法改变。

|          宏          |         含义         |
| :------------------: | :------------------: |
|    `LVCFMT_LEFT`     |      文本左对齐      |
|    `LVCFMT_RIGHT`    |      文本右对齐      |
|   `LVCFMT_CENTER`    |     文本居中对齐     |
| `LVCFMT_SPLITBUTTON` | 列标题显示为拆分按钮 |

:::



:::details `LVM_SETIMAGELIST消息`

`LVM_SETIMAGELIST`消息用于把图像列表分配给列表视图控件，`wParam`参数指定图像列表的类型。

|       宏       |         含义         |
| :------------: | :------------------: |
| `LVSIL_NORMAL` |   大图标的图像列表   |
| `LVSIL_SMALL`  |   小图标的图像列表   |
| `LVSIL_STATE`  | 带状态图像的图像列表 |


lParam参数指定为图像列表句柄，如果执行成功，则返回值为先前与控件关联的图像列表的句柄。



:::tip

图标视图、平铺视图中的大图标，不一定就是
GetSystemMetrics(SM_CXICON)GetSystemMetrics (SM_CYICON)的大小，还可以设置得更大或更小;



小图标、列表视图、报表视图中的小图标也不一定就是
GetSystemMetrics(SM_CXSMICON) GetSystemMetrics(SM_CYSMICON)的大小，也可以设置得更大或更小。

:::





:::details `LVM_INSERTITEM 消息`

LVM_INSERTITEM消息用于向列表视图控件中添加列表项，wParam参数没有用到，lParam参数是一个指向LVITEM结构的指针。如果执行成功，则返回值为新添加列表项的索引﹔如果执行失败，LVITEM结构在头文件中定义如下∶

```c

typedef struct
{
	UINT mask; //掩码标志，设置或获取哪些字段的值
	int iItem; //新列表项的从O开始的索引，如果该值大于控件中的列表项总数，则插入末尾
	int iSubltem; //列表项的子项的索引，通常设置为0(第一列)
	UINT state;//指定列表项的状态、状态图像和叠加图像，stateMask字段指定该字段的有效位
	UINT stateMask; //指定state字段的有效位
	LPTSTR pszText; //列表项文本字符串指针，如果获取列表项信息，则是字符串缓冲区地址
	int cchTextMax; //pszText缓冲区的大小，以字符为单位，获取列表项信息时需要该字段
	int iImage; //图像列表中图像的从O开始的索引，指定的图像将显示在列表项左侧
	LPARAM lParam;  //与列表项相关联的项目数据
	int ilndent; //列表项缩进数，设置为1表示1个图像宽度，2表示2个图像宽度...
	int iGroupld; //列表项所属组的ID
	UINT cColumns;
	PUINT puColumns;
	int* piColFmt;
	int iGroup; //列表项所属的组索引
}LVITEM,* LPLVITEM;

```

:::



:::details `LVM_GETSELECTIONMARK 消息`

对于单选列表视图控件，可以发送LVM_GETSELECTIONMARK消息获取选中项。wParam和lParam参数都没有用到。如果有选中项，则返回选中列表项的索引﹔如果当前没有选中项，则返回一1。
如果多选列表视图控件，没有获取所有选中列表项索引的相关消息或函数，则可以通过类似下面的代码循环获取每个已选中列表项的信息。

:::



:::details `示例:`

```c
#include <Windows.h>
#include <CommCtrl.h>
#include <tchar.h>
#include <strsafe.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("ListViewDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 465, 250, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndListView;                           // 列表视图控件
    static HWND hwndStatic, hwndComboBox;               // 静态控件、组合框
    static HWND hwndBtnCheck;                           // 获取选中项按钮
    static HIMAGELIST hImagListNormal, hImagListSmall;  // 图像列表
    static HFONT hFont;
    HICON hiconItem;
    LPTSTR arrItemText[] = { TEXT("平面设计"), TEXT("Web开发"), TEXT("Windows程序设计Windows程序设计"),
        TEXT("机械设计"), TEXT("加密解密"), TEXT("大数据") };
    LPTSTR arrPrice[] = { TEXT("15000"), TEXT("16000"), TEXT("19800"),
        TEXT("12000"), TEXT("10000"), TEXT("18000") };
    int nIndex;
    DWORD dwData;
    LVCOLUMN lvc = { 0 };       // 列信息结构
    LVITEM lvi = { 0 };         // 列表项信息结构
    LVTILEINFO lvti = { 0 };    // 平铺视图信息结构
    UINT arrUColumns[] = { 1 }; // 平铺视图要显示的列索引数组
    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        // 列表视图控件
        hwndListView = CreateWindowEx(0, TEXT("SysListView32"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | LVS_SMALLICON | LVS_SHOWSELALWAYS | LVS_EDITLABELS,
            10, 0, 300, 200, hwnd, (HMENU)IDC_LISTVIEW, hInstance, NULL);
        // 静态控件、组合框
        hwndStatic = CreateWindowEx(0, TEXT("Static"), TEXT("视图样式："),
            WS_CHILD | WS_VISIBLE, 320, 10, 100, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndComboBox = CreateWindowEx(0, TEXT("ComboBox"), NULL,
            WS_CHILD | WS_VISIBLE | WS_VSCROLL | CBS_DROPDOWNLIST | CBS_AUTOHSCROLL,
            320, 32, 120, 25, hwnd, (HMENU)IDC_COMBOBOX, hInstance, NULL);
        // 获取选中项按钮
        hwndBtnCheck = CreateWindowEx(0, TEXT("Button"), TEXT("获取选中项"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            320, 70, 100, 25, hwnd, (HMENU)IDC_BTNCHECK, hInstance, NULL);

        // 组合框添加一些列表项，用于更换列表视图控件样式，把样式值存储为每一个列表项的项目数据
        nIndex = SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)TEXT("LV_VIEW_ICON"));
        SendMessage(hwndComboBox, CB_SETITEMDATA, nIndex, LV_VIEW_ICON);
        nIndex = SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)TEXT("LV_VIEW_SMALLICON"));
        SendMessage(hwndComboBox, CB_SETITEMDATA, nIndex, LV_VIEW_SMALLICON);
        nIndex = SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)TEXT("LV_VIEW_LIST"));
        SendMessage(hwndComboBox, CB_SETITEMDATA, nIndex, LV_VIEW_LIST);
        nIndex = SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)TEXT("LV_VIEW_DETAILS"));
        SendMessage(hwndComboBox, CB_SETITEMDATA, nIndex, LV_VIEW_DETAILS);
        nIndex = SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)TEXT("LV_VIEW_TILE"));
        SendMessage(hwndComboBox, CB_SETITEMDATA, nIndex, LV_VIEW_TILE);
        SendMessage(hwndComboBox, CB_SETCURSEL, 1, 0);

        // 设置列表视图控件的扩展样式
        SendMessage(hwndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_CHECKBOXES |
            LVS_EX_FULLROWSELECT | LVS_EX_AUTOCHECKSELECT | LVS_EX_GRIDLINES | LVS_EX_LABELTIP);

        // 图像列表
        hImagListNormal = ImageList_Create(GetSystemMetrics(SM_CXICON),
            GetSystemMetrics(SM_CYICON), ILC_MASK | ILC_COLOR32, 10, 0);
        hImagListSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
            GetSystemMetrics(SM_CYSMICON), ILC_MASK | ILC_COLOR32, 10, 0);
        for (int i = 0; i < 10; i++)
        {
            // 资源文件中定义了10个图标,IDI_ICON1～IDI_ICON10
            hiconItem = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1 + i));
            ImageList_AddIcon(hImagListNormal, hiconItem);
            ImageList_AddIcon(hImagListSmall, hiconItem);
            DestroyIcon(hiconItem);
        }
        SendMessage(hwndListView, LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM)hImagListSmall);

        // 如果是报表视图样式，必须设置列标题
        lvc.mask = LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH | LVCF_IMAGE;
        lvc.iSubItem = 0; lvc.cx = 160; lvc.pszText = TEXT("专业名称"); lvc.iImage = 0;
        SendMessage(hwndListView, LVM_INSERTCOLUMN, 0, (LPARAM)&lvc);
        lvc.iSubItem = 1; lvc.cx = 100; lvc.pszText = TEXT("价格"); lvc.iImage = 1;
        SendMessage(hwndListView, LVM_INSERTCOLUMN, 1, (LPARAM)&lvc);

        // 列表视图控件添加一些列表项
        lvi.mask = LVIF_TEXT | LVIF_IMAGE;
        for (int i = 0; i < _countof(arrItemText); i++)
        {
            lvi.iItem = i; lvi.iSubItem = 0; lvi.pszText = arrItemText[i]; lvi.iImage = i;
            SendMessage(hwndListView, LVM_INSERTITEM, i, (LPARAM)&lvi);

            // 添加一个子项，也就是第2列，索引为1
            lvi.iSubItem = 1; lvi.pszText = arrPrice[i];
            SendMessage(hwndListView, LVM_SETITEM, 0, (LPARAM)&lvi);

            // 设置平铺视图要显示的列
            lvti.cbSize = sizeof(LVTILEINFO);
            lvti.iItem = i;
            lvti.cColumns = 1;
            lvti.puColumns = arrUColumns;
            SendMessage(hwndListView, LVM_SETTILEINFO, 0, (LPARAM)&lvti);
        }

        // 设置静态控件、组合框、按钮字体
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("微软雅黑"));
        SendMessage(hwndStatic, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndComboBox, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndBtnCheck, WM_SETFONT, (WPARAM)hFont, FALSE);
        return 0;

    case WM_COMMAND:
        // 切换列表视图样式
        switch (HIWORD(wParam))
        {
        case CBN_SELCHANGE:
            nIndex = SendMessage(hwndComboBox, CB_GETCURSEL, 0, 0);
            dwData = SendMessage(hwndComboBox, CB_GETITEMDATA, nIndex, 0);
            if (dwData == LV_VIEW_ICON || dwData == LV_VIEW_TILE)
            {
                SendMessage(hwndListView, LVM_SETIMAGELIST, LVSIL_NORMAL, (LPARAM)hImagListNormal);
                SendMessage(hwndListView, LVM_SETVIEW, dwData, 0);
            }
            else
            {
                SendMessage(hwndListView, LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM)hImagListSmall);
                SendMessage(hwndListView, LVM_SETVIEW, dwData, 0);
            }
            break;
        }

        // 获取选中列表项
        if (LOWORD(wParam) == IDC_BTNCHECK)
        {
            // 获取已选中列表项总数
            int nCount = SendMessage(hwndListView, LVM_GETSELECTEDCOUNT, 0, 0);
            if (nCount > 0)
            {
                LPTSTR pBuf = new TCHAR[nCount * 128];
                ZeroMemory(pBuf, sizeof(TCHAR) * nCount * 128);
                TCHAR szText[128] = { 0 };

                lvi.mask = LVIF_TEXT;
                lvi.iSubItem = 0; lvi.pszText = szText; lvi.cchTextMax = _countof(szText);

                // 先搜索出第一个选中项
                int nIndex = SendMessage(hwndListView, LVM_GETNEXTITEM, -1, LVIS_SELECTED);
                // 获取列表项的信息
                lvi.iItem = nIndex;
                SendMessage(hwndListView, LVM_GETITEM, 0, (LPARAM)&lvi);
                StringCchCopy(pBuf, nCount * 128, lvi.pszText);
                StringCchCat(pBuf, nCount * 128, TEXT("\n"));

                for (int i = 0; i < nCount - 1; i++)
                {
                    // 按索引往后搜索
                    nIndex = SendMessage(hwndListView, LVM_GETNEXTITEM, nIndex, LVIS_SELECTED);
                    // 获取列表项的信息
                    lvi.iItem = nIndex;
                    SendMessage(hwndListView, LVM_GETITEM, 0, (LPARAM)&lvi);
                    StringCchCat(pBuf, nCount * 128, lvi.pszText);
                    StringCchCat(pBuf, nCount * 128, TEXT("\n"));
                }
                MessageBox(hwnd, pBuf, TEXT("已选中列表项"), MB_OK);
                delete[] pBuf;
            }
        }
        return 0;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case LVN_ENDLABELEDIT:
            return TRUE;

        case NM_RCLICK:
            MessageBox(hwnd, TEXT("用户鼠标右键单击列表项"), TEXT("提示"), MB_OK);
            break;
        }
        return 0;

    case WM_CTLCOLORSTATIC:
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);

    case WM_DESTROY:
        DeleteObject(hFont);
        ImageList_Destroy(hImagListNormal);
        ImageList_Destroy(hImagListSmall);
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

:::



## 树视图

树视图控件通常用于显示一些具有层次关系的项目，例如文件资源管理器左侧的导航窗格用的就是SysTreeView32树视图控件。每个项目都有一个标签文本和一个可选的图像，每个项目都可以有一个与之关联的项目数据。每个项目都可以包含与之关联的一系列子项(子节点)，具有一个或多个子项的项目称为父项(父节点)。子项显示在其父项下方，并适当缩进以表示它从属于父项。双击父项，可以展开或折叠关联的子项列表。没有父项的项目出现在层次结构的顶部，称为根项(根节点)。每个项目的标签文本实际上是一个编辑控件。



:::details `树视图控件常用的样式` 



|     样式宏常量      |                             含义                             |
| :-----------------: | :----------------------------------------------------------: |
|  `TVS_CHECKBOXES`   | 对视图项前面显示一个复选框。虽然可以显示复选框，但树视图控件并不能多选 |
|  `TVS_EDITLABELS`   | 允许用户编辑树视图项的标签文本，在用户完成对标签文本的编辑后，树视图控件的父窗口会收到包含TVN_ENDLABELEDIT通知码的WM_NOTIFY消息，处理该通知码只需要简单地返回TRUE表示接受编辑，或FALSE表示拒绝编辑. |
|   `TVS_HASLINES`    |     树视图项的前面会显示一个线条，表明项目的层次结构关系     |
|  `TVS_HASBUTTONS`   | 父节点前面显示加号(+)或减号（-)按钮，用户单击按钮可以展开或折叠父项的子项列表。要在树视图控件的根节点中包含按钮，还必须指定TVS_LINESATROOT |
|  `TVS_LINESATROOT`  | 表明项目层次结构关系的线条链接到根节点。如果未指定TVS_HASLINES，则忽略该样式 |
| `TVS_SHOWSELALWAYS` |       当树视图控件失去焦点时，选中的项目也保持选中状态       |
|  `TVS_TRACKSELECT`  | 在树视图控件中后用热跟踪，即当鼠标悬停在树视图项上时，光标形状变为小手 |

:::



:::details `树项目的添加`

创建树视图控件以后，可以通过发送`TVM_INSERTITEM`消息在树视图控件中插入新项。

- `wParam`参数没有用到。

- `lParam`参数是一个指向TVINSERTSTRUCT结构的指针，该结构指定树视图项的属性。

- 如果执行成功，则返回新项的HTREEITEM类型的句柄﹔否则返回NULL.



TVINSERTSTRUCT结构定义如下∶

```c
typedef struct 
{
	HTREEITEM hParent; //父项句柄，如果设置为TVI_ROOT或NULL，表示添加一个根节点
	HTREEITEM hlnsertAfter; //在hInsertAfter指定的项目后面插入新项目
	union {
			TVITEMEX itemex;//TVITEMEX结构，包含要添加的项目的信息
			TVITEM item; //TVITEM结构，包含要添加的项目的信息
		  }DUMMYUNIONNAME;
}TVINSERTSTRUCT，*LPTVINSERTSTRUCT;
```

如果hlnsertAfter字段指定了一个项目句柄，则在hInsertAfter指定的项目后面插入新项目,可以指定为下表所示的值。



|  常量含义   |           说明           |
| :---------: | :----------------------: |
| `TVI_FIRST` |   将项目插入列表的开头   |
| `TVI_LAST`  |   将项目插入列表的末尾   |
| `TVI_ROOT`  |    将项目添加为根节点    |
| `TVI_SORT`  | 按字母顺序将项目插入列表 |

TVITEMEX比TVITEM结构多了几个字段，通常使用TVITEM结构即可，该结构也用于设置、获取树视图项信息的TVM_SETITEM  TVM_GETITEM消息。TVITEM结构定义如下∶

```c
typedef struct tagTVITEM{
	UINT mask;	//掩码标志，指定哪个字段有效
	HTREEITEM hltem; //项目句柄,设置、获取项目信息时需要该字段
	UINT state;
	UINT stateMask; //这两个字段的用法和列表视图控件LVITEM结构的同名字段类似
	LPTSTR pszText; //项目的文本
	int	cchTextMax; //项目的文本缓冲区长度，以字符为单位
	int	ilmage;	//当项目处于非选定状态时使用的图像列表索引
	int	iSelectedlmage; //当项目处于选定状态时使用的图像列表索引
	int	cChildren; //通常不用
	LPARAM lParam; //与项目关联的数据
}TVITEM，*LPTVITEM;
```

mask字段是掩码标志,指定哪个字段有效，可以是以下一个或多个值(见下表)。



**标志含义**

|        宏常量        |            含义             |
| :------------------: | :-------------------------: |
|    `TVIF_HANDLE`     |        hltem字段有效        |
|    `TVIF_STATE `     |  state和stateMask字段有效   |
|     `TVIF_TEXT `     | pszText和cchTextMax字段有效 |
|     `TVIF_IMAGE`     |       ilmage字段有效        |
| `TVIF_SELECTEDIMAGE` |   iSelectedlmage字段有效    |
|   `TVIF_CHILDREN `   |      cChildren字段有效      |
|    `TVIF_PARAM `     |       IParam字段有效        |

总而言之，如果遇到业务开发用到了MFC树，你就记得MFC的树有多个根节点这一句话就行。

:::





:::details `示例:`

下面我们来完成在窗口初始化时，完成树的构建。

>  resource.h

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 TreeViewDemo.rc 使用
//
#define IDB_BMP_BOOK                    101
#define IDB_BMP_WORLD                   102
#define IDB_BMP_GRAPHIC                 103
#define IDB_BMP_PROGRAMMING             104
#define IDB_BMP_AMERICAN                105
#define IDB_BMP_CHINA                   106
#define IDB_BMP_BEIJING                 107
#define IDB_BMP_SHANGHAI                108

#define IDC_TREEVIEW                    1001
#define IDC_STATICSELECTED              1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

> main.cpp

```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("TreeViewDemo");
    HWND hwnd;
    MSG msg;

    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);

    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 280, NULL, NULL, hInstance, NULL);

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndTreeView;               // 树视图控件
    static HTREEITEM htrBook, htrWorld;     // 根节点：图书、世界
    static HTREEITEM htrAmerican, htrChina; // 世界：美国、中国

    static HIMAGELIST hImagList;
    HBITMAP    hbmImage;

    TVINSERTSTRUCT tvi = { 0 };

    if (uMsg == WM_CREATE)
    {
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        // 创建树视图控件
        hwndTreeView = CreateWindowEx(0, TEXT("SysTreeView32"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER |
            TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS |
            TVS_EDITLABELS | TVS_SHOWSELALWAYS | TVS_TRACKSELECT,
            10, 0, 200, 200, hwnd, (HMENU)IDC_TREEVIEW, hInstance, NULL);

        //完成资源位图和图片列表的整合，即新建图像列表
        hImagList = ImageList_Create(24, 24, ILC_COLOR32, 8, 0);
        for (int i = 0; i < 8; i++)
        {
            // 资源文件中定义了8个位图
            hbmImage = (HBITMAP)LoadImage(hInstance, MAKEINTRESOURCE(IDB_BMP_BOOK + i),
                IMAGE_BITMAP, 24, 24, 0);
            ImageList_Add(hImagList, hbmImage, NULL);
            DeleteObject(hbmImage);
        }
        //发送 TVM_SETIMAGELIST 设置图像列表的消息 给这个树控件，完成图像列表的注入
        SendMessage(hwndTreeView, TVM_SETIMAGELIST, TVSIL_NORMAL, (LPARAM)hImagList);


        // ===================为树视图控件添加树项目=============================//
        // 根节点：图书、世界
        tvi.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tvi.hInsertAfter = TVI_LAST;
        tvi.hParent = TVI_ROOT;
        tvi.item.pszText = TEXT("图书"); 
        tvi.item.iImage = tvi.item.iSelectedImage = 0;
        htrBook = (HTREEITEM)SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);
       
        tvi.item.pszText = TEXT("世界"); 
        tvi.item.iImage = tvi.item.iSelectedImage = 1;
        htrWorld = (HTREEITEM)SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);

        // 图书(平面设计、程序设计)
        tvi.hParent = htrBook;
        tvi.item.pszText = TEXT("平面设计"); 
        tvi.item.iImage = tvi.item.iSelectedImage = 2;
        SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);

        tvi.item.pszText = TEXT("程序设计"); 
        tvi.item.iImage = tvi.item.iSelectedImage = 3;
        SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);

        // 世界(美国、中国)
        tvi.hParent = htrWorld;
        tvi.item.pszText = TEXT("美国");
        tvi.item.iImage = tvi.item.iSelectedImage = 4;
        htrAmerican = (HTREEITEM)SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);

        tvi.item.pszText = TEXT("中国"); 
        tvi.item.iImage = tvi.item.iSelectedImage = 5;
        htrChina = (HTREEITEM)SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);

        // 中国(北京市、上海市)
        tvi.hParent = htrChina;
        tvi.item.pszText = TEXT("北京市"); 
        tvi.item.iImage = tvi.item.iSelectedImage = 6;
        SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);
        tvi.item.pszText = TEXT("上海市"); 
        tvi.item.iImage = tvi.item.iSelectedImage = 7;
        SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);
        // ===================为树视图控件添加树项目=============================//
        return 0;
    }
    else if (uMsg == WM_DESTROY)
    {
        //同时，销毁图像列表
        ImageList_Destroy(hImagList);
        PostQuitMessage(0);
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E6%A0%91%E8%A7%86%E5%9B%BE%E6%8E%A7%E4%BB%B6%E6%B7%BB%E5%8A%A0%E6%A0%91%E9%A1%B9%E7%9B%AE.gif)

:::





:::details `选中项的获取TVN_SELCHANGED消息`

要获取选中项很简单，在用户将选中项从一个项目更改为另一个项目后，树视图控件的父窗口会收到包含TVN_SELCHANGED通知码的WM_NOTIFY消息，lParam参数是一个指向NMTREEVIEW结构的指针。NMTREEVIEW结构的itemOld和itemNew字段都是TVITEM结构，包含先前所选项目和新选择项目的信息，但请注意，只有结构的mask hltem state和lParam字段有效。



NMTREEVIEW结构的定义如下∶

```c
typedef struct tagNMTREEVIEW 
{   NMHDR hdr; // NMHDR结构
	UINT action; //导致选择更改的操作类型，可以是∶
 				//TVC_BYKEYBOARD(通过击键)、
 				//TVC_BYMOUSE(通过单击鼠标)或TVC_UNKNOWN(未知)
  TVITEM itemOld; // TVITEM结构，包含先前所选项目的信息
  TVITEM itemNew; // TVITEM结构，包含新选择项目的信息
  POINT ptDrag;//事件发生时鼠标的坐标（相对于客户区)
} NMTREEVIEW，*LPNMTREEVIEW;
```

例如下面处理TVN_SELCHANGED通知码的代码︰

```c
 else if (uMsg == WM_NOTIFY)
 {
     if (TVN_ENDLABELEDIT == ((LPNMHDR)lParam)->code)
     {
         return TRUE;
     }
     else if (TVN_SELCHANGED == ((LPNMHDR)lParam)->code)
     {
         
         pnmTV = (LPNMTREEVIEW)lParam;
         wsprintf(szBuf, TEXT("树子项句柄：0x%X"), (INT)(pnmTV->itemNew.hItem));
         SetDlgItemText(hwnd, IDC_STATICSELECTED, szBuf);// 选中的项目句柄显示到静态控件中
     }
     else if (NM_RCLICK == ((LPNMHDR)lParam)->code)
     {
         MessageBox(hwnd, TEXT("用户鼠标右键单击列表项"), TEXT("提示"), MB_OK);
     }
 

 }
```

如果不是在处理TVN_SELCHANGED通知码的情况下，可以通过发送TVM_GETNEXTITEM消息来获取具有某种特征的树视图项。wParam参数指定要获取的项目，可以是下表所示的值之一。

|       宏常量        |                    含义                    |
| :-----------------: | :----------------------------------------: |
|    `TVGN_CREAT`     |             获取当前选中的项目             |
|    `TVGN_CHILD`     |     获取IParam参数指定的项的第一个子项     |
| `TVGN_NEXTSELECTED` | 获取IParam参数指定的项后面的一个选中的项目 |
|    `TVGN_PARENT`    |       获取IParam参数指定的项的父项目       |
|   `TVGN_PREVIOUS`   |   获取IParam参数指定的项的上一个兄弟项目   |
|     `TVGN_NEXT`     |   获取lParam参数指定的项的下一个兄弟项目   |
|     `TVGN_ROOT`     |       获取树视图控件的最顶部或第一项       |

lParam参数指定为一个项目句柄，如果不需要，可以设置为0。如果执行成功，则返回符合条件项目的句柄。

```c
            HTREEITEM htrSelected;
            htrSelected = (HTREEITEM)SendMessage(hwndTreeView,TVM_GETNEXTITEM,TVGN_CARET,0);
            wsprintf(szBuf, TEXT("项目句柄：0x%X"), (INT)(pnmTV->itemNew.hItem));
            SetDlgItemText(hwnd, IDC_STATICSELECTED, szBuf);
```

:::



::: details `其他消息`

`TVM_DELETEITEM`删除一个树视图项及其所有子项。

- wParam参数没有用到
- lParam参数指定为项目句柄，如果设置为`TVI_ROOT`或`NULL`，则删除所有项目



`TVM_GETCOUNT`获取树视图控件中的项目总数。

- wParam和lParam参数都没有用到



`TVM_SETITEM`设置树视图项的部分或全部属性。

- wParam参数没有用到.

- lParam参数是一个指向包含新项属性的TVITEM结构的指针

`TVM_GETITEM`获取树视图项的部分或全部属性。

- wParam参数没有用到
- lParam参数是一个指向TVITEM结构的指针



:::



:::details `示例2:`

当用户鼠标右键单击树视图项时，树视图控件的父窗口会收到包含NM_RCLICK通知码的`WM_NOTIFY`消息.
- lParam参数是一个指向NMHDR结构的指针。

直接在原来的树基础上，增加窗口过程处理逻辑，即处理选中树选中，右击树项目的逻辑。

```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("TreeViewDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 280, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndTreeView;               // 树视图控件
    static HTREEITEM htrBook, htrWorld;     // 根节点：图书、世界
    static HTREEITEM htrAmerican, htrChina; // 世界：美国、中国
    HWND hwndStatic;
    static HFONT hFont;
    static HIMAGELIST hImagList;
    HBITMAP    hbmImage;
    TVINSERTSTRUCT tvi = { 0 };
    LPNMTREEVIEW pnmTV;
    TCHAR szBuf[64] = { 0 };

    if (uMsg == WM_CREATE)
    {
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        // 创建树视图控件
        hwndTreeView = CreateWindowEx(0, TEXT("SysTreeView32"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER |
            TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS |
            TVS_EDITLABELS | TVS_SHOWSELALWAYS | TVS_TRACKSELECT,
            10, 0, 200, 200, hwnd, (HMENU)IDC_TREEVIEW, hInstance, NULL);

        // 静态控件
        hwndStatic = CreateWindowEx(0, TEXT("Static"), TEXT("已选中："),
            WS_CHILD | WS_VISIBLE | SS_LEFT,
            10, 210, 200, 200, hwnd, (HMENU)IDC_STATICSELECTED, hInstance, NULL);

        // 图像列表
        hImagList = ImageList_Create(24, 24, ILC_COLOR32, 8, 0);
        for (int i = 0; i < 8; i++)
        {
            // 资源文件中定义了8个位图
            hbmImage = (HBITMAP)LoadImage(hInstance, MAKEINTRESOURCE(IDB_BMP_BOOK + i),
                IMAGE_BITMAP, 24, 24, 0);
            ImageList_Add(hImagList, hbmImage, NULL);
            DeleteObject(hbmImage);
        }
        SendMessage(hwndTreeView, TVM_SETIMAGELIST, TVSIL_NORMAL, (LPARAM)hImagList);

        // 为树视图控件添加项目
        // 根节点：图书、世界
        tvi.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tvi.hInsertAfter = TVI_LAST;

        tvi.hParent = TVI_ROOT;
        tvi.item.pszText = TEXT("图书"); tvi.item.iImage = tvi.item.iSelectedImage = 0;
        htrBook = (HTREEITEM)SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);
        tvi.item.pszText = TEXT("世界"); tvi.item.iImage = tvi.item.iSelectedImage = 1;
        htrWorld = (HTREEITEM)SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);

        // 图书(平面设计、程序设计)
        tvi.hParent = htrBook;
        tvi.item.pszText = TEXT("平面设计"); tvi.item.iImage = tvi.item.iSelectedImage = 2;
        SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);
        tvi.item.pszText = TEXT("程序设计"); tvi.item.iImage = tvi.item.iSelectedImage = 3;
        SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);

        // 世界(美国、中国)
        tvi.hParent = htrWorld;
        tvi.item.pszText = TEXT("美国"); tvi.item.iImage = tvi.item.iSelectedImage = 4;
        htrAmerican = (HTREEITEM)SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);
        tvi.item.pszText = TEXT("中国"); tvi.item.iImage = tvi.item.iSelectedImage = 5;
        htrChina = (HTREEITEM)SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);

        // 中国(北京市、上海市)
        tvi.hParent = htrChina;
        tvi.item.pszText = TEXT("北京市"); tvi.item.iImage = tvi.item.iSelectedImage = 6;
        SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);
        tvi.item.pszText = TEXT("上海市"); tvi.item.iImage = tvi.item.iSelectedImage = 7;
        SendMessage(hwndTreeView, TVM_INSERTITEM, 0, (LPARAM)&tvi);

        // 设置静态控件字体
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("楷体"));
        SendMessage(hwndStatic, WM_SETFONT, (WPARAM)hFont, FALSE);
        return 0;
    }
    else if (uMsg == WM_NOTIFY)
    {
        if (TVN_ENDLABELEDIT == ((LPNMHDR)lParam)->code)
        {
            return TRUE;
        }
        else if (TVN_SELCHANGED == ((LPNMHDR)lParam)->code)
        {
            
            pnmTV = (LPNMTREEVIEW)lParam;
            wsprintf(szBuf, TEXT("项目句柄：0x%X"), (INT)(pnmTV->itemNew.hItem));
            SetDlgItemText(hwnd, IDC_STATICSELECTED, szBuf);// 选中的项目句柄显示到静态控件中
        }
        else if (NM_RCLICK == ((LPNMHDR)lParam)->code)
        {
            MessageBox(hwnd, TEXT("用户鼠标右键单击列表项"), TEXT("提示"), MB_OK);
        }
    

    }
    else if (WM_CTLCOLORSTATIC == uMsg)
    {
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);
    }
    else if (WM_DESTROY == uMsg)
    {

        ImageList_Destroy(hImagList);
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E6%A0%91%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0%E5%A4%84%E7%90%86%E9%80%89%E4%B8%AD%E9%A1%B9%E7%9B%AE.gif)

:::







## 状态栏



状态栏是显示在窗口底部的一个子窗口控件，可以在其中显示各种状态信息，状态栏可以分为多个部分以显示不同类型的信息。调用
CreateWindowEx函数创建状态栏的时候，状态栏的窗口过程会自动设置窗口的初始位置和大小，状态栏的宽度与父窗口的客户区宽度相同，高度则基于状态栏DC所选择字体的高度。另外，当父窗口的大小更改时，只需要简单地向状态栏发送一个`WM_SIZE`消息(wParam和lParam参数都设置为0即可)，状态栏就能自动调整大小。





如果只是简单地创建一个状态栏，也可以调用`DrawStatusText`函数



:::details `DrawStatusText 函数说明`

```c
/// <summary>
/// 绘制状态栏信息
/// </summary>
/// <param name="hdc">设备环境句柄</param>
/// <param name="lprc">状态栏所属的矩形区域，相对于父窗口客户区</param>
/// <param name="pszText">状态栏文本字符串，可以使用制表符\t</param>
/// <param name="uFlags">文本绘制标志，可以设置为0，或设置为SBT_NOBORDERS表示不使用边框</param>
void DrawStatusText(HDC hdc,LPCRECT lprc,LPCTSTR pszText,UINT uFlags); 
```

- DrawStatusText函数的pszText字符串中可以使用制表符(\t)，默认情况下，文本在状态栏的指定矩形范围内左对齐，可以在文本中嵌入制表符以使其居中或右对齐。第1个制表符左侧的文本左对齐，第1个制表符右侧的文本居中对齐，第2个制表符字符右侧的文本右对齐。

:::



:::details `为状态进行分栏`



一个状态栏最多可以包含256个部分，每个部分称之为“指示器"，可以通过发送`SB_SETPARTS`消息来为状态栏添加指示器，或者说为状态栏分栏。



`SB_SETPARTS`消息的`wParam`参数指定为指示器的数量。`IParam`参数是一个指定每个指示器右边缘坐标的数值型数组，如果把某个数组元素设置为-1，则表示把状态栏的剩余部分全部分配给该指示器。





在分栏后，通过发送SB_SETTEXT消息为每一栏设置文本。



`wParam`参数的高位字没有用到，`LOBYTE(LOWORD(wParam))`指定为栏的索引号，栏索引从0开始;



`HIBYTE(LOWORD(wParam))`指定绘制类型，通常指定为0即可。如果不需要解析制表符，可以指定`SBT_NOTABPARSING`  `lParam`参数指定为要设置的文本字符串指针。





![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240630105241513.png)



要获取栏目的文本，可以发送`SB_GETTEXTLENGTH`和`SB_GETTEXT`消息。

:::





:::details `示例:`



```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("StatusBarDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 500, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndStatus;
    INT nArrParts[] = { 140, 360, -1 };
    static HDC hdcDesk;
    POINT pt;
    TCHAR szBuf[64] = { 0 };
    COLORREF color;
    SYSTEMTIME stLocal;

    HDC hdc;
    HFONT hFont, hFontOld;
    RECT rect;
    switch (uMsg)
    {
    case WM_SIZE:
        hdc = GetDC(hwnd);
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("微软雅黑"));
        SelectObject(hdc, hFont);
        SetRect(&rect, 0, HIWORD(lParam) - 20, LOWORD(lParam), HIWORD(lParam));
        DrawStatusText(hdc, &rect, TEXT("这是\tDrawStatusText\t函数设置的状态栏"), 0);
        ReleaseDC(hwnd, hdc);
        return 0;
    case WM_DESTROY:
        DeleteDC(hdcDesk);
        KillTimer(hwnd, 1);
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240630105643199.png)



:::





## 进度条控件



进度条控件通常用于一些需要长时间操作的任务以实时显示进度。



:::details `进度条控件常用的样式`

- `PBS_VERTICAL` 进度条从下到上垂直显示进度状态(默认情况下是从左到右)
- `PBS_MARQUEE` 进度指示条的大小不会增加，而是治着进度条的长度方向重复移动

:::





:::details `消息类型含义`



|        宏        |                             含义                             |
| :--------------: | :----------------------------------------------------------: |
|  `PBM_SETRANGE`  | 设置进度条的最小值和最大值（默认情况下范围值为0～100），并重绘以反映新范围 |
| `PBM_SETRANGE32` |                                                              |
|   `PBM_SETPOS`   |           设置进度条的当前位置，并重绘以反映新位置           |
|   `PBM_GETPOS`   |                     获取进度条的当前位置                     |
|  `PBM_SETSTEP`   | 指定进度条的步长增量，步长增量是进度条在收到PBM_STEPIT消息时增加其当前位置的量，默认情况下步长增量为10PBM_STEPIT把进度条的当前位置增加一个步长增量，并重绘以反映新位置 |
|  `PBM_DELTAPOS`  |      把进度条的当前位置增加指定的量，并重绘以反映新位置      |

:::



:::details `示例`



```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("ProgressDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndProgress, hwndStatic;
    TCHAR szBuf[16] = { 0 };
    UINT nPos;

    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        // 进度条控件
        hwndProgress = CreateWindowEx(0, TEXT("msctls_progress32"), NULL,
            WS_CHILD | WS_VISIBLE,
            10, 10, 300, 20, hwnd, (HMENU)IDC_PROGRESS, hInstance, NULL);

        // 静态控件
        hwndStatic = CreateWindowEx(0, TEXT("Static"), TEXT("%0"),
            WS_CHILD | WS_VISIBLE | SS_LEFT,
            320, 10, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);

        // 设置进度条控件的范围
        SendMessage(hwndProgress, PBM_SETRANGE32, 0, 100);

        // 计时器
        SetTimer(hwnd, 1, 100, NULL);
        return 0;

    case WM_TIMER:
        // 获取进度条的当前位置
        nPos = SendMessage(hwndProgress, PBM_GETPOS, 0, 0);
        if (nPos >= 100)
        {
            Sleep(2000);
            nPos = 0;
        }
        else
        {
            nPos++;
        }

        // 设置进度条的当前位置
        SendMessage(hwndProgress, PBM_SETPOS, nPos, 0);
        // 显示进度
        wsprintf(szBuf, TEXT("%%%d"), nPos);
        SetWindowText(hwndStatic, szBuf);
        return 0;

    case WM_CTLCOLORSTATIC:
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240627225831957.png)

:::







## MenuHelp

当用户选择一个菜单项时，很多程序都会在底部的状态栏中。显示该菜单项的帮助提示信息，可以响应`WM_MENUSELECT`消息并从消息参数中获取用户所选择的菜单项ID，根据菜单项ID获取对应的提示信息字符串，然后将其显示到状态栏中。但是还有更简单的，系统提供了一个专用函数MenuHelp，可以在处理`WM_MENUSELECT`或`WM_COMMAND`消息时调用该函数，在指定的状态栏窗口中显示当前菜单项的帮助提示文本。



:::details `MenuHelp 函数说明`

```c
/// <summary>
/// 给菜单加入状态栏提示信息
/// </summary>
/// <param name="uMsg">正在处理的消息，可以是WM_MENUSELECT或WM_COMMAND 消息</param>
/// <param name="wParam">消息的wParam参数</param>
/// <param name="lParam">消息的IParam参数</param>
/// <param name="hMainMenu">程序的主菜单句柄</param>
/// <param name="hInst">包含字符串资源的模块句柄</param>
/// <param name="hwndStatus">状态栏句柄</param>
/// <param name="lpwlDs"></param>
void MenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,HMENU hMainMenu, HINSTANCE hInst, HWND hwndStatus, UINT * lpwlDs);
```

- 通常是在`WM_MENUSELECT`消息中调用`MenuHelp`函数，将函数的前3个参数`uMsg` `wParam` `lParam`设置为窗口过程函数的相应参数即可。
- `WM_MENUSELECT`消息的`IParam`参数就是用户正在浏览的菜单句柄，因此MenuHelp函数的`hMainMenu`参数直接设置为`IParam`即可。
- 要配合`MenuHelp`函数，需要把每个菜单项对应的帮助提示文本定义在字符串表中，函数会自动调用`LoadString`函数载入正确的字符串，参数`hInst`指定为包含字符串资源的模块句柄。
- `hwndStatus`参数指定为状态栏窗口的句柄。

:::



:::details `示例：`

```c
#include <Windows.h>
#include <tchar.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    TCHAR szBuf[64] = { 0 };
    static HWND hwndStatus;
    UINT uArrIDs[] = { 0, ID_FILE };
    switch (uMsg)
    {
    case WM_CREATE:
        hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));
        SetMenu(hwnd, hMenu);

        // 创建状态栏
        hwndStatus = CreateWindowEx(0, TEXT("msctls_statusbar32"), NULL,
            WS_CHILD | WS_VISIBLE,
            0, 0, 0, 0, hwnd, (HMENU)IDC_STATUSBAR, g_hInstance, NULL);
        return 0;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case ID_FILE_NEW:   // 新建
            wsprintf(szBuf, TEXT("您点击了 新建 菜单项，命令ID：%d\n"), ID_FILE_NEW);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
            break;
        case ID_EDIT_CUT:   // 剪切
            wsprintf(szBuf, TEXT("您点击了 剪切 菜单项，命令ID：%d\n"), ID_EDIT_CUT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
            break;
        case ID_HELP_ABOUT: // 关于HelloWindows
            wsprintf(szBuf, TEXT("您点击了 关于HelloWindows 菜单项，命令ID：%d\n"), ID_HELP_ABOUT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
            break;
        case ID_FILE_EXIT:  // 退出
            wsprintf(szBuf, TEXT("您点击了 退出 菜单项，命令ID：%d\n"), ID_FILE_EXIT);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;
        }
        return 0;

    case WM_SYSCOMMAND:
        switch (wParam & 0xFFF0)
        {
        case SC_CLOSE:
            MessageBox(hwnd, TEXT("您点击了 系统菜单 关闭 菜单项"), TEXT("提示"), MB_OK);
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;
        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
        return 0;
    case WM_MENUSELECT:
        MenuHelp(uMsg, wParam, lParam, (HMENU)lParam, g_hInstance, hwndStatus, uArrIDs);
        return 0;

    case WM_SIZE:
        SendMessage(hwndStatus, WM_SIZE, 0, 0);
        return 0;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

:::







## 工具栏



工具栏一般位于菜单栏的下方，包含一个或多个按钮。这些按钮实际上都是一副图像，所以说它们只是仿真按钮，而不是真正的按钮子窗口控件。每个按钮对应于程序菜单中的某个菜单项，为用户提供了一种更直观的方式来访问应用程序的菜单项。当用户按下按钮的时候窗口过程会收到`WM_COMMAND`消息，这是为了和菜单、加速键使用同一份代码来处理用户按下工具栏按钮的操作。在工具栏中，有的按钮按下后会自动弹起;有的按钮按下后保留在"选中"状态，再按一次后恢复弹起状态，按钮的"选中"状态可以是互斥或不互斥的，按钮也可以被灰化或隐藏，所有这些属性和菜单项的属性类似。





:::details `TB_ADDBITMAP 消息`

在创建工具栏后，可以通过发送`TB_ADDBITMAP`消息将一个或多个图像添加到工具栏的按钮图像列表中。

- `wParam`参数指定位图中按钮图像的数量，如果`IParam`参数指定的是系统预定义的位图，则忽略`wParam`参数。

- `lParam`参数是一个指向TBADDBITMAP结构的指针，该结构包含位图资源的ID以及包含位图资源的可执行文件的模块句柄。
- 如果执行成功，则返回第一个新图像的索引。否则返回-1。



`TBADDBITMAP`结构在头文件中定义如下∶

```c
typedef struct tagTBADDBITMAP 
{
    HINSTANCE hInst; //包含位图资源的可执行文件的模块句柄
    UINT_PTR nID; //位图资源的ID
}TBADDBITMAP,*LPTBADDBITMAP;
```

在发送`TB_ADDBITMAP`消息添加图像前，还应该发送`TB_BUTTONSTRUCTSIZE`和`TB_SETBITMAPSIZE`消息到工具栏。



`TB_BUTTONSTRUCTSIZE`指定`TBBUTTON`结构的大小。

- `wParam`参数指定为TBBUTTON结构的大小，以字节为单位。

- `IParam`参数没有用到

`TB_SETBITMAPSIZE`设置要添加到工具栏中的每个位图图像的大小(如果不设置，默认情况下是24像素22像素)。

- `wParam`参数没有用到。
- `LOWORD(IParam)`指定位图图像的宽度，`HIWORD (IParam)`指定位图图像的高度，以像素为单位。

:::





:::details `TB_ADDBUTTONS 消息`



接下来还需要将图像与按钮相关联，在将位图添加到按钮图像列表后，可以通过发送TB_ADDBUTTONS消息把按钮添加到工具栏中。

- 将`wParam`参数设置为要添加的按钮个数。

- `lParam`参数是一个指向TBBUTTON结构数组的指针，其中包含要添加的按钮的信息，数组中的元素个数必须与`wParam`参数指定的按钮数相同。

发送`TB_ADDBUTTONS`消息，一次可以添加多个按钮，也可以通过发送`TB_INSERTBUTTON`消息在工具栏中插入一个按钮。

- wParam参数指定为按钮从O开始的索引; 
- lParam参数是一个指向TBBUTTON结构的指针，其中包含要插入的按钮的信息。TBBUTTON结构在头文件中定义如下︰

```c
typedef struct 
{
	int iBitmap; // 按钮图像的索引
	int idCommand; // 按钮命今ID，通常指定为某个菜单项ID
	BYTE fsState; //按钮状态
	BYTE fsStyle; //按钮样式
	BYTE bReserved[2]; //保留字段
	DWORD_PTR dwData; //自定义数据
	INT_PTR iString; //按钮文本，显示在按钮图像的下边，如果不需要显示按钮文本，则可以设置为-1
}TBBUTTON, * PTBBUTTON, * LPTBBUTTON;
```

:::





:::details `示例:`



```c
#include <Windows.h>
#include <tchar.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#define NUMBTNS 11
HINSTANCE g_hInstance;
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szClassName[] = TEXT("MyWindow");
    TCHAR szAppName[] = TEXT("HelloWindows");
    HWND hwnd;
    MSG msg;
    g_hInstance = hInstance;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szClassName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szClassName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 500, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACC));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HMENU hMenu;
    TCHAR szText[64] = { 0 };
    TCHAR szBuf[128] = { 0 };
    static HWND hwndStatus, hwndToolBar;
    UINT uArrIDs[] = { 0, ID_FILE };
    TBBUTTON tbButtons[NUMBTNS] = {
        { 0, ID_FILE_NEW,    TBSTATE_ENABLED, BTNS_BUTTON, { 0 }, 0, (INT_PTR)TEXT("新建") },
        { 1, ID_FILE_OPEN,   TBSTATE_ENABLED, BTNS_BUTTON, { 0 }, 0, (INT_PTR)TEXT("打开") },
        { 2, ID_FILE_SAVE,   TBSTATE_ENABLED, BTNS_BUTTON, { 0 }, 0, (INT_PTR)TEXT("保存") },
        { 3, ID_FILE_SAVEAS, TBSTATE_ENABLED, BTNS_BUTTON, { 0 }, 0, (INT_PTR)TEXT("另存为") },
        { 4, ID_FILE_EXIT,   TBSTATE_ENABLED, BTNS_BUTTON, { 0 }, 0, (INT_PTR)TEXT("退出") },
        { 0, 0,              TBSTATE_ENABLED, TBSTYLE_SEP, { 0 }, 0, -1 },
        { 5, ID_EDIT_CUT,    TBSTATE_ENABLED, BTNS_BUTTON, { 0 }, 0, (INT_PTR)TEXT("剪切") },
        { 6, ID_EDIT_COPY,   TBSTATE_ENABLED, BTNS_BUTTON, { 0 }, 0, (INT_PTR)TEXT("复制") },
        { 7, ID_EDIT_PASTE,  TBSTATE_ENABLED, BTNS_BUTTON, { 0 }, 0, (INT_PTR)TEXT("粘贴") },
        { 0, 0,              TBSTATE_ENABLED, TBSTYLE_SEP, { 0 }, 0, -1 },
        { 8, ID_HELP_ABOUT,  TBSTATE_ENABLED, BTNS_BUTTON, { 0 }, 0, (INT_PTR)TEXT("关于") } };
    //TBADDBITMAP tbab;
    static HIMAGELIST hImagList;

    switch (uMsg)
    {
    case WM_CREATE:
        hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));
        SetMenu(hwnd, hMenu);

        // 创建状态栏
        hwndStatus = CreateWindowEx(0, TEXT("msctls_statusbar32"), NULL,
            WS_CHILD | WS_VISIBLE,
            0, 0, 0, 0, hwnd, (HMENU)IDC_STATUSBAR, g_hInstance, NULL);

        // 创建工具栏
        hwndToolBar = CreateWindowEx(0, TEXT("ToolbarWindow32"), NULL,
            WS_CHILD | WS_VISIBLE | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS | CCS_ADJUSTABLE,
            0, 0, 0, 0, hwnd, (HMENU)IDC_TOOLBAR, g_hInstance, NULL);

        // 图像列表
        hImagList = ImageList_Create(50, 50, ILC_MASK | ILC_COLOR32, NUMBTNS, 0);
        ImageList_Add(hImagList, LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_BITMAP)), NULL);
        SendMessage(hwndToolBar, TB_SETIMAGELIST, 0, (LPARAM)hImagList);

        // 为工具栏添加图像
        SendMessage(hwndToolBar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
        // 因为上面使用了图像列表，所以下面的代码注释掉
        //SendMessage(hwndToolBar, TB_SETBITMAPSIZE, 0, MAKELPARAM(50, 50));
        //tbab.hInst = g_hInstance;
        //tbab.nID = IDB_BITMAP;      // 工具栏图片已经添加到位图资源
        //SendMessage(hwndToolBar, TB_ADDBITMAP, NUMBTNS - 2, (LPARAM)&tbab);

        // 为工具栏添加按钮
        SendMessage(hwndToolBar, TB_ADDBUTTONS, NUMBTNS, (LPARAM)&tbButtons);
        return 0;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case ID_FILE_NEW:
        case ID_FILE_OPEN:
        case ID_FILE_SAVE:
        case ID_FILE_SAVEAS:
        case ID_FILE_EXIT:
        case ID_EDIT_CUT:
        case ID_EDIT_COPY:
        case ID_EDIT_PASTE:
        case ID_HELP_ABOUT:
            GetMenuString(hMenu, LOWORD(wParam), szText, _countof(szText), MF_BYCOMMAND);
            wsprintf(szBuf, TEXT("您点击了 %s 菜单项，命令ID：%d\n"), szText, LOWORD(wParam));
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
            if (LOWORD(wParam) == ID_FILE_EXIT)
                SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;
        }
        return 0;

    case WM_SYSCOMMAND:
        switch (wParam & 0xFFF0)
        {
        case SC_CLOSE:
            MessageBox(hwnd, TEXT("您点击了 系统菜单 关闭 菜单项"), TEXT("提示"), MB_OK);
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;
        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
        return 0;

    case WM_MENUSELECT:
        MenuHelp(uMsg, wParam, lParam, (HMENU)lParam, g_hInstance, hwndStatus, uArrIDs);
        return 0;

    case WM_SIZE:
        SendMessage(hwndStatus, WM_SIZE, 0, 0);
        SendMessage(hwndToolBar, TB_AUTOSIZE, 0, 0);
        return 0;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case TBN_QUERYINSERT:
        case TBN_QUERYDELETE:
            return TRUE;

        case TBN_GETBUTTONINFO:
            LPNMTOOLBAR lpnmTB;
            lpnmTB = (LPNMTOOLBAR)lParam;
            // 如果不是最后一个按钮
            if (lpnmTB->iItem < NUMBTNS)
            {
                lpnmTB->tbButton = tbButtons[lpnmTB->iItem];
                return TRUE;
            } 
            return FALSE;

        case TTN_NEEDTEXT:
            LPNMTTDISPINFO lpnmTDI;
            lpnmTDI = (LPNMTTDISPINFO)lParam;
            lpnmTDI->hinst = g_hInstance;
            lpnmTDI->lpszText = (LPTSTR)lpnmTDI->hdr.idFrom;
            break;
        }
        return 0;

    case WM_DESTROY:
        ImageList_Destroy(hImagList);
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

:::





## 日期控件

日期控件可以让用户选择年月日。





:::details `日期控件常用的消息`





- `MCM_GETCURSEL`获取当前选定的日期。wParam参数没有用到，IParam参数指定为一个指向接收当前所选日期信息的SYSTEMTIME结构的指针。该消息不能用于MCS_MULTISELECT样式的日期控件。



- `MCM_GETTODAY`获取今天的日期，该消息的用法和MCM_GETCURSEL消息相同



- `MCM_SETCURSEL`设置日期控件的当前选定日期，如果指定的日期不在视图中，控件会更新显示视图。wParam参数没有用到，lParam参数是一个指向要设置为当前所选日期信息的SYSTEMTIME结构的指针。该消息不能用于MCS_MULTISELECT样式的日期控件



- `MCM_SETTODAY`设置今天的日期，该消息的用法和MCM_SETCURSEL消息相同



- `MCM_GETMINREQRECT`根据当前字体、控件样式等计算日期控件所需的最小容量。wParam参数没有用到，IParam参数是一个指向接收边界矩形信息的RECT结构的指针，矩形坐标相对于父窗口客户区的左上角。



:::





:::details `示例:`



```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("MonthDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndMonthCal, hwndBtnGetDate;
    RECT rect;
    SYSTEMTIME st;
    TCHAR szBuf[64] = { 0 };
    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        // 日期控件
        hwndMonthCal = CreateWindowEx(0, TEXT("SysMonthCal32"), NULL,
            WS_CHILD | WS_VISIBLE | MCS_WEEKNUMBERS,
            0, 0, 0, 0, hwnd, (HMENU)IDC_MONTHCAL, hInstance, NULL);

        // 根据日期控件所需的最小大小调整其位置
        SendMessage(hwndMonthCal, MCM_GETMINREQRECT, 0, (LPARAM)&rect);
        MoveWindow(hwndMonthCal, 10, 0, rect.right, rect.bottom, FALSE);

        // 获取日期按钮
        hwndBtnGetDate = CreateWindowEx(0, TEXT("Button"), TEXT("获取日期"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            270, 0, 80, 25, hwnd, (HMENU)IDC_BTNGETDATE, hInstance, NULL);
        return 0;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_BTNGETDATE:
            SendMessage(hwndMonthCal, MCM_GETCURSEL, 0, (LPARAM)&st);
            wsprintf(szBuf, TEXT("%d年%0.2d月%0.2d日"), st.wYear, st.wMonth, st.wDay);
            MessageBox(hwnd, szBuf, TEXT("提示"), MB_OK);
            break;
        }
        return 0;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E6%97%A5%E6%9C%9F%E6%8E%A7%E4%BB%B6.gif)

:::



## Tab选项卡控件



通过使用选项卡控件，当用户单击不同的选项卡时，可以显示不同的页面(子窗口或对话框)。





程序具有4个选项卡，选项卡的文本称为文本标签。选项卡是指包含文本标签的那个矩形区域。当用户单击不同的选项卡时，下方会显示不同的子窗口，子窗口通常使用对话框。





当鼠标悬停在选项卡上时，可以选择显示工具提示。每个选项卡的文本标签前面还可以选择显示一个图标，每个选项卡都可以设置一个与之关联的自定义数据。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240630112357935.png)



程序的整个客户区是一个选项卡控件。4个选项卡下面是用于显示不同子窗口的区域，叫作显示区域。显示区域用于显示不同的子窗口，图中框选出来的矩形区域就是显示区域。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240630112502732.png)



:::details `选项卡控件样式`



|        宏        |                             含义                             |
| :--------------: | :----------------------------------------------------------: |
| `TCS_FIXEDWIDTH` | 所有选项卡的宽度相同（默认情况下每个选项卡的宽度会根据图标和文本标签的宽度自动调整)。另外，可以通过发送TCM_SETITEMSIZE消息设置选项卡的宽度和高度<br/>默认情况下所有选项卡显示在一行，如果显示不完全，会在右侧显示一个Up-Down控件以滚动选项卡。 |
| `TCS_MULTILINE`  | 指定该样式以后，如果多个选项卡在一行显示不完全，可以显示为多行 |
|  `TCS_VERTICAL`  |      选项卡显示在程序窗口的左侧，选项卡文本标签垂直显示      |
|  `TCS_TOOLTIPS`  | 选项卡显示工具提示，需要处理`TIN_NEEDTEXT`消息(等于`TTN_GETDISPINFO`) |

:::



:::details `TCM_INSERTITEM 消息`



创建选项卡控件以后，可以通过发送`TCM_INSERTITEM`消息添加选项卡。

`wParam`参数指定为新选项卡中从0开始的索引。

`IParam`参数指定为一个指向TCITEM结构的指针。



该结构指定选项卡的属性。`TCITEM`结构还可以用于`TCM_SETITEM` ` TCM_GETITEM`消息设置、获取指定选项卡的属性，该结构定义如下:

```c
typedef struct
{
	UINT mask; //掩码标志，指定要设置或获取哪些字段的值
	DWORD dwState; //一般不用
	DWORD dwStateMask; //一般不用
	LPTSTR pszText; //选项卡文本标签的字符串指针，如果是获取信息，则是缓冲区地址
	int cchTextMax; //pszText字段指向的缓冲区的大小(字符)，如果不是获取信息，则忽略该字段
	int iImage; //图像列表的索引
	LPARAM lParam;//自定义数据
}TCITEM, * LPTCITEM;
```

:::





:::details `WM_NOTIFY消息`

添加选项卡以后，初始情况下第一个(即索引为0）选项卡处于选中状态。在用户选择了其他选项卡后，选项卡控件的父窗口会收到包含`TCN_SELCHANGE`通知码的`WM_NOTIFY`消息，



- IParam参数是指向NMHDR结构的指针。处理该通知码就是通过发送`TCM_GETCURSEL`消息 (wParam和lParam参数都没有用到)获取选项卡控件的当前选中项，销毁或隐藏不相关的子窗口，并显示需要的子窗口。

:::





:::details `TTN_NEEDTEXT 消息`

选项卡控件指定`TCS_TOOLTIPS`样式以后可以显示工具提示，需要处理`TTN_NEEDTEXT`消息。该消息在学习工具栏按钮工具提示的时候已经详细讲解过了。此处NMTTDISPINFO结构的`hdr.idFrom`字段是选项卡的索引。

:::





:::details `WM_SIZE 消息`

除此之外，还需要处理`WM_SIZE`消息。在`WM_SIZE`消息中，根据父窗口客户区的大小调整选项卡控件的大小。可以根据选项卡控件的大小计算出显示区域的大小，然后利用显示区域的大小调整子窗口的大小。

:::



:::details `示例`

```c
#include <Windows.h>
#include <CommCtrl.h>
#include <tchar.h>
#include <strsafe.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

HWND hwndChild[4];
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK WindowProcChild(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("TabControlDemo");
    HWND hwnd;
    MSG msg;

    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 300, 200, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    RECT rect;
    static HWND hwndTabControl;
    static HFONT hFont;
    TCITEM tci;
    int nIndex;

    WNDCLASSEX wndclass;

    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        // 根据父窗口客户区的大小创建选项卡控件
        GetClientRect(hwnd, &rect);
        hwndTabControl = CreateWindowEx(0, TEXT("SysTabControl32"), NULL,
            WS_CHILD | WS_VISIBLE | TCS_MULTILINE | TCS_TOOLTIPS,
            0, 0, rect.right, rect.bottom, hwnd, (HMENU)IDC_TABCONTROL, hInstance, NULL);

        // 添加选项卡
        tci.mask = TCIF_TEXT;
        tci.pszText = TEXT("平面设计");
        SendMessage(hwndTabControl, TCM_INSERTITEM, 0, (LPARAM)&tci);
        tci.pszText = TEXT("Web开发");
        SendMessage(hwndTabControl, TCM_INSERTITEM, 1, (LPARAM)&tci);
        tci.pszText = TEXT("Windows程序设计");
        SendMessage(hwndTabControl, TCM_INSERTITEM, 2, (LPARAM)&tci);
        tci.pszText = TEXT("加密解密");
        SendMessage(hwndTabControl, TCM_INSERTITEM, 3, (LPARAM)&tci);

        // 为4个选项卡创建对应的4个子窗口
        wndclass.cbSize = sizeof(WNDCLASSEX);
        wndclass.style = CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc = WindowProcChild;
        wndclass.cbClsExtra = 0;
        wndclass.cbWndExtra = 0;
        wndclass.hInstance = hInstance;
        wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName = NULL;
        wndclass.lpszClassName = TEXT("ChildWindow");
        wndclass.hIconSm = NULL;
        RegisterClassEx(&wndclass);
        for (int i = 0; i < 4; i++)
            hwndChild[i] = CreateWindowEx(0, TEXT("ChildWindow"), NULL, WS_CHILD | WS_VISIBLE,
                0, 0, 0, 0, hwnd, NULL, hInstance, NULL);

        // 只显示当前选择的选项卡对应的子窗口(初始情况下索引为0的选项卡为选中状态)
        nIndex = SendMessage(hwndTabControl, TCM_GETCURSEL, 0, 0);
        for (int i = 0; i < 4; i++)
            ShowWindow(hwndChild[i], SW_HIDE);
        ShowWindow(hwndChild[nIndex], SW_SHOW);

        // 设置选项卡控件字体
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("微软雅黑"));
        SendMessage(hwndTabControl, WM_SETFONT, (WPARAM)hFont, FALSE);
        return 0;

    case WM_SIZE:
        // 根据父窗口客户区的大小调整选项卡控件的大小
        MoveWindow(hwndTabControl, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);

        // 根据选项卡控件的窗口矩形大小计算显示区域的大小，然后调整子窗口的大小
        SetRect(&rect, 0, 0, LOWORD(lParam), HIWORD(lParam));
        SendMessage(hwndTabControl, TCM_ADJUSTRECT, FALSE, (LPARAM)&rect);
        for (int i = 0; i < 4; i++)
            MoveWindow(hwndChild[i],    // 注意MoveWindow函数的位置和大小参数的符号
                rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, TRUE);
        return 0;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case TCN_SELCHANGE:
            nIndex = SendMessage(hwndTabControl, TCM_GETCURSEL, 0, 0);
            for (int i = 0; i < 4; i++)
                ShowWindow(hwndChild[i], SW_HIDE);
            ShowWindow(hwndChild[nIndex], SW_SHOW);
            break;

        case TTN_NEEDTEXT:
            LPNMTTDISPINFO lpnmTDI;
            lpnmTDI = (LPNMTTDISPINFO)lParam;
            switch (lpnmTDI->hdr.idFrom)
            {
            case 0:
                StringCchCopy(lpnmTDI->szText, 80, TEXT("这是平面设计的工具提示文本"));
                break;
            case 1:
                StringCchCopy(lpnmTDI->szText, 80, TEXT("这是Web开发的工具提示文本"));
                break;
            case 2:
                StringCchCopy(lpnmTDI->szText, 80, TEXT("这是Windows程序设计的工具提示文本"));
                break;
            case 3:
                StringCchCopy(lpnmTDI->szText, 80, TEXT("这是加密解密的工具提示文本"));
                break;
            }
            break;
        }
        return 0;

    case WM_DESTROY:
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK WindowProcChild(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    RECT rect;
    switch (uMsg)
    {
    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        GetClientRect(hwnd, &rect);
        if (hwnd == hwndChild[0])
            DrawText(hdc, TEXT("平面设计 价格1万"), _tcslen(TEXT("平面设计 价格1万")),
                &rect, DT_SINGLELINE | DT_VCENTER | DT_CENTER);
        else if (hwnd == hwndChild[1])
            DrawText(hdc, TEXT("Web开发 价格2万"), _tcslen(TEXT("Web开发 价格2万")),
                &rect, DT_SINGLELINE | DT_VCENTER | DT_CENTER);
        else if (hwnd == hwndChild[2])
            DrawText(hdc, TEXT("Windows程序设计 价格3万"), _tcslen(TEXT("Windows程序设计 价格3万")),
                &rect, DT_SINGLELINE | DT_VCENTER | DT_CENTER);
        else
            DrawText(hdc, TEXT("加密解密 价格4万"), _tcslen(TEXT("加密解密 价格4万")),
                &rect, DT_SINGLELINE | DT_VCENTER | DT_CENTER);
        EndPaint(hwnd, &ps);
        return 0;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240630113701304.png)

:::
