# 	子窗口控件



调用`CreateWindow()` / `CreateWindowEx()`函数创建窗口的时候，将窗口样式指定为`WS_CHILD`或`WS_CHILDWINDOW`就可以创建一个子窗口。子窗口的位置可以在父窗口客户区的任何地方，这样的子窗口需要程序注册窗口类并提供窗口过程。程序也可以通过系统预定义的窗口类和窗口过程来创建标准子窗口控件，程序中常见的标准子窗口挫件有按钮、单选按钮、复选按钮、编辑框、组合框、列表框、滚动条控件等，像资源管理器窗口就包含多个子窗口控件，例如工具栏、树视图控件、滚动条控件等。标准子窗口控件也称为通用控件(Common Control) 。





程序可以把窗口类名指定为系统预定义的`相关子窗口控件类名`来调用`CreateWindow()`/ `CreateWindowEx()`函数创建一个子窗口控件(对应形参的`lpClassName`)，子窗口控件和父窗口之间可以互相发送消息来进行通信。子窗口控件在对话框程序中用得更普遍，不需要调用`CreateWindow()`/ `CreateWindowEx()`函数，直接在资源脚本文件中定义子窗口控件即可，也可以通过资源编辑器从工具箱中拖曳子窗口控件到对话框程序界面的合适位置。

​	

**系统预定义的窗口类名字符串含义**

- Button按钮（普通按钮、单选按钮、复选按钮、分组框)
- Edit编辑框
- ListBox列表框
- ComboBox组合框ScrollBar滚动条Static静态控件
- MDIClientMDl 客户窗口



另外，有一些类名是系统内部使用的，例如`ComboLBox (多一个L)`表示组合框内的列表框的类名，`#32770`表示对话框类名等。





## 按钮类

按钮(Button)类有许多样式属性，基于Button类指定不同的样式可以创建普通按钮、单选按钮、复选按钮和分组框等。Button类可以指定的按钮样式如表所示，BS_前缀表示Button Style.



:::details `不同类型的按钮`



|              宏               |                             含义                             |
| :---------------------------: | :----------------------------------------------------------: |
|        `BS_PUSHBUTTON`        |                           普通按钮                           |
|      `BS_DEFPUSHBUTTON`       | 默认按钮，和普通按钮一样，但是有一个较深的轮廓。如果是在对话框程序中，当其他按钮没有键盘焦点时，用户可以通过按下Enter键选择该按钮 |
|      ``BS_RADIOBUTTON``       |                 单选按钮，可以选中、取消选中                 |
|       `BS_AUTOCHECKBOX`       |                         自动单选按钮                         |
|       `BS_RADIOBUTTON`        |                          自动复选框                          |
|     `BS_AUTORADIOBUTTON`      |                 单选按钮，可以选中、取消选中                 |
|         `BS_CHECKBOX`         |                 复选框，可以选中，取消选中。                 |
|       `BS_ATUOCHECKBOX`       |                          自动复选框                          |
|        `BS_ATUO3TATE`         |                        自动三态复选框                        |
| `BS_LEFTTEXT或BS_RIGHTBUTTON` | 对于单选按钮﹑复选框或三态复选框，文本默认显示在按钮右侧，该样式表示显示在按钮左侧 |
|           `BS_TEXT`           |                      按钮矩形内显示文本                      |
|           `BS_LEFT`           |                    左对齐按钮矩形内的文本                    |
|          `BS_RIGHT`           |                    右对齐按钮矩形内的文本                    |
|         `BS_CENTTER`          |                   文本在按钮矩形内水平居中                   |
|           `BS_TOP`            |                     文本在按钮矩形的顶部                     |
|          `BS_BOTTOM`          |                     文本在按钮矩形的底部                     |
|         `BS_VCENTER`          |                   文本在按钮矩形内垂直居中                   |
|           `BS_FLAT`           |        按钮默认具有三维样式,该样式表示按钮是二维样式         |
|         `BS_PUSHLIKE`         |        使单选按钮、复选框或三态复选框看起来像按钮—样         |
|        `BS_OWNERDRAW`         | 自绘按钮，当按钮需要重绘时父窗口会收到WM_DRAWITEM消息，不能将该样式与任何其他按钮样式—起使用 |
|           `BS_ICON`           |                           图标按钮                           |
|          `BS_BITMAP`          |                           位图按钮                           |
|         `BS_GROUPBOX`         | 分组框,用于对其他控件进行分组，由一个矩形和显示在矩形左上角的文本组成 |
|          `BS_NOTIFY`          | 系统可以发送包含`BN_KTLLFOCUS`和`BS_SETFOCUS`通知码的WM_COMMAND消息到其父窗口 |
|       `BS_SPLITBUTTON`        | 拆分按钮。拆分按钮分为两部分，左侧是主要部分，类似于普通或默认按纽﹔右刻有一个向下的小箭头，单击箭头时可以弹出一个菜单。拆分按扭是通用控件版本6中引A的一种出钮，如图所示:![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240114215850442.png) |
|      `BS_DEFSPLITBUTTON`      | 默认拆分按钮，有一个较深的轮廓。如果是在对话框程序中，当其他按钮没有键盘焦点时，用户可以通过按下Eater键选择该按钮 |
|       `BS_COMMANDLTNK`        | 命令链接按钮，左侧有一个篮色箭头指向按钮文本(Windows 7系统中为绿色箭头〉。命令链接按钮是通用控件版本6中引入的一种按钮，如图所示:![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240114215850442.png) |
|      `BS_DEFCOMMANDLINK`      | 默认命令链接按钮，有一个较深的轮廓。如果是在对话框程序中，当其他按钮没有键盘焦点时，用户可以通过按下Enter键选择该按钮 |

以三态复选框与自动三态复选框为例，用户单击三态复选框以后不会自动选中或变灭，程序需要响应单击事件设置选中或变灰状态﹔而如果是自动三态复选框，则单击一次就会自动选中，再单击一次则复选框显示为灰色，第三次单击则会取消选中，如此循环，程序在需要的时候只需要获取其状态即可。

:::







普通按钮、默认按钮、单选按钮和复选框都可以同时指定BS_ICON或BS BITMAP样式，例如`BS_PUSHBUTTON|BS_BITMAP`，或`BS_AUTORADIOBUTTON| BS_BITMAP`，表示在普通按钮上显示一副位图，或单选按钮旁边显示一副位图。





`BS_ICON`或`BS_BITMAP`样式也可以单独使用，表示在普通按钮上显示一个图标或一副位图。指定`BS_ICON`或`BS_BITMAP`样式以后，需要发送`BM_SETIMAGE`消息为其设置图标或位图，后面再详细解释这个消息。





`BS_`前缀的样式是按钮专用样式。除了这些按钮专用样式，因为子窗口控件也是一个窗口，所以大部分用于普通窗口的API函数和窗口样式适用于子窗口控件。例如下表的窗口样式可以用于按钮。



:::details `可用于子窗口的窗口样式`

|               宏                |                             含义                             |
| :-----------------------------: | :----------------------------------------------------------: |
|  `WS_CHILD`或`WS_CHILDWINDOW`   |                         窗口是子窗口                         |
|          `WS_VISIBLE`           | `WS_VISABLE`窗口最初可见，可以通过调用`ShowWindow()`或`SetWindowPos()`函数显示和隐藏窗口 |
|           `WS_GROUP`            | `WS_GROUP`该窗口是一组控件的第一个控件，该组由第一个具有WS_GROUP样式的控件和在其后定义的所有控件组成，直到下一个具有`WS_GROUP`样式的控件(不包括该控件)出现。如果是在对话框程序中，用户可以使用方向键将键盘焦点从组中的一个控件移动到下一个控件。另外，每个组中的第一个控件通常具有`WS_TABSTOP`样式，如果是在对话框程序中，按下Tab键可以将键盘焦点移动到下一个具有`WS_TABSTOP`样式的按件。 |
|          `WS_TABSTOP`           | 该窗口是一个控件，当用户按下Tab键时，该控件可以接收键盘焦点，如果是在对话框程序中，按下Tab键可以将键盘焦点移动到下一个具有`WS_TABSTOP`样式的控件上 |
|           `WS_BORDER`           |                      窗口有一个细线边框                      |
|          `WS_DLGFRAME`          |                   窗口具有对话框样式的边框                   |
| `WS_SIZEBOX` 或 `WS_THICKFRAME` |                     窗口具有大小调整边框                     |
|          `WS_DISABLED`          | 窗口最初被禁用，禁用的窗口无法接收用户的输入,要想启用可以调用`EnableWindow()`函数 |

其中，`WS_CHILD`和`WS_VISIBLE`是必须指定的，`WS_CHILD`表示该窗口是一个子窗口。如果不指定`WS_VISIBLE`样式，则子窗口控件不会显示。
另外，一些扩展窗口样式也可以用于子窗口控件，例如`WS_EX_ACCEPTFILES`表示该子窗口控件可以接受拖放文件。

:::



## 按钮与父窗口通信

按钮可以向其父窗口发送消息，父窗口也可以向按钮发送消息。父窗口可以通过调用`SendMessage()`或`SendDlgltemMessage()`函数发送消息到子窗口控件



:::details `SendMessage 函数说明`

```c
LRESULT	SendMessage(HWND hWnd, UINT Msg,WPARAM wParam,LPARAM lParam);

LRESULT SendDIgItemMessage(HWND hDIg, int nIDDIgltem, UINT Msg, WPARAM	wParam,LPARAM lParam);
```

- `SendDlgltemMessage()`函数的`hDlg`指的是Dialog对话框，该函数通常用于在对话框程序中向子窗口控件发送消息 `hDlg`参数指定父窗口句柄，
- `nIDDIgltem`参数指定子窗口控件ID，每个子窗口控件都有一个ID。调用`CreateWindow/CreateWindowEx`函数创建子窗口控件的时候，第10个参数`hMenu`不再指定为菜单句柄，而是指定为**子窗口控件ID**。

:::



:::tip

对于`BS_ICON`或`BS_BITMAP`样式的按钮。`BM_SETIMAGE`消息用于为按钮设置图标或位图。

- 其中`wParam`参数指定图像类型，可以是IMAGE_ICON(图标)或IMAGE_BITMAP(位图)，
- `lParam`参数可以指定为图像的句柄(HICON或HBITMAP),
- `返回值`是先前与按钮关联的图像的句柄(如果有的话)，否则返回值是NULL

:::



:::tip 



`BM_GETIMAGE`消息用于获取与按钮关联的图标或位图的句柄.

- 其中`wParam`参数指定图像类型，可以是IMAGE_ICON(图标)或IMAGE_BITMAP(位图)
- `lParam`参数没有用到，指定为0即可。
- `返回值`是与按钮关联的图像的句柄（如果有的话),否则返回值是NULL。

:::



:::tip

`BM_SETSTYLE`消息用于设置按钮的样式

- 其中`wParam`参数可以指定为按钮新样式的组合
- `lParam`参数可以指定为TRUE(重绘按钮)或FALSE(不重绘按钮)。当然,通过调用`SetWindowLongPtr()`函数也可以达到同样的目的。

:::

:::tip 

`BM_SETCHECK`消息用于设置单选按钮、复选框或三态复选框的选中状态.

- 其中`wParam`参数可以指定为BST_CHECKED (选中)、BST_UNCHECKED (取消选中)或BST_INDETERMINATE（灰色,表示不确定状态，用于三态复选框)
- `lParam`参数没有用到，指定为0即可。

:::



:::tip

`BM_GETCHECK`消息用于获取单选按钮、复选框或三态复选框的选中状态.

- `wParam`和`lParam`参数没有用到，都指定为0即可
- `返回值`可以是BST_CHECKED (已选中)、BST_UNCHECKED (未选中）或BST_INDETERMINATE(灰色，表示不确定状态，用于三态复选框)。

:::

:::tip

`BM_SETSTATE`消息用于设置普通按钮是否按下的状态.

- `wParam`参数可以指定为TRUE(突出显示，按下状态)或FALSE(取消突出显示，非按下状态)
- `lParam`参数没有用到,指定为0即可。

:::



:::tip

`BM_GETSTATE`消息用于获取普通按钮、单选按钮、复选框或三态复选框的当前状态(选中状态，是否按下和是否具有键盘焦点等)

- `wParam`和`lParam` 参数没有用到，都指定为0即可.
- 返回值可以是BST_CHECKED (已选中)、BST_UNCHECKED(未选中)、BST_INDETERMINATE(灰色，表示不确定状态，用于三态复选框)、BST_PUSHED(普通按钮处于按下状态)、BST_FOCUS(按钮具有键盘焦点)、
  BST_HOT(鼠标悬停在按钮上)、BST_DROPDOWNPUSHED(按钮处于下拉状态，并且仅当按钮具有BTNS_DROPDOWN样式时用于工具栏按钮)。

:::



:::tip

`BM_CLICK`消息可以模拟用户单击按钮

- `lParam`参数都没有用到。该消息会导致系统向按钮的父窗口发送包含BN_CLICKED通知码的WM_COMMAND消息。

:::







调用`CheckDlgButton()`或`CheckRadioButton()`函数等同于发送BM_SETCHECK消息

调用`IsDlgButtonChecked()`函数等同于发送BM_GETCHECK消息



:::details `CheckDlgButton 函数说明`

一组复选按钮中通常可以同时选中多个，而一组单选按钮中通常只能选中一个。`CheckDlgButton()`函数通常用于设置复选框的选中状态。

```c
/// <summary>
/// 设置复选按钮被选中
/// </summary>
/// <param name="hDIg">父窗口句柄</param>
/// <param name="nIDButton">子窗口控件ID</param>
/// <param name="uCheck">/设置选中状态，BST_CHECKED BST_UNCHECKED或BST_INDETERMINATE</param>
/// <returns></returns>
BOOL CheckDlgButton(HWND hDIg,int nIDButton,UINT uCheck);
```

:::



:::details `CheckRadioButton 函数说明` 



`CheckDlgButton()`函数也可以用于设置单选按钮，但是如果在一组单选按钮中选中一个，还需要多次调用`CheckDlgButton()`取消选中其他的，所以设置单选按钮的状态通常使用`CheckRadioButton()`函数，指定一组单选按钮的第一个和最后一个以及需要选中哪一个，函数会自动完成任务。

```c
/// <summary>
/// 设置单选按钮被选中
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDFirstButton">组中第一个单选按钮的ID</param>
/// <param name="nlDLastButton">组中最后一个单选按钮的ID</param>
/// <param name="nlDCheckButton">要设置选中的单选按钮的ID</param>
/// <returns></returns>
BOOL CheckRadioButton(HWND hDlg,int nlDFirstButton,int nlDLastButton,int nlDCheckButton);
```

::: 



:::details `IsDlgButtonChecked 函数说明`

```c
/// <summary>
/// 判断对话框按钮是否被选中
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDButton">子窗口控件ID</param>
/// <returns>函数返回值可以是BST_CHECKED BST_UNCHECKED或BST_INDETERMINATE</returns>
UINT IsDlgButtonChecked(HWND hDlg,int nlDButton);
```

建议使用自动单选按钮，同组的单选按钮会随着用户选中一个而自动取消选中其他单选按钮。在程序中只需要在初始化的时候设置选中哪一个，并在需要查用户选择了哪一个的时候调用`lsDlgButtonChecked()`函数检查每一个单选按钮项的选中状态即可。



同样，复选按钮也不会因为用户的单击而自动变为选中或取消选中等，因此建议使用自动复选按钮，在初始化的时候设置选中哪些，并在需要的时候调用`lsDlgButtonChecked()`函数检查每一个的状态即可。



:::





:::details `用户点击按钮产生的消息 WM_COMAND`

当用户单击按钮时，它会接收键盘焦点，系统会向按钮的父窗口发送包含`BN_CLICKED`通知码的`WM_COMMAND`消息。不过对于自动单选按钮、自动复选框或自动三态复选框通常不需要处理该消息，因为这些按钮可以自动设置其状态。如果是普通按钮，则可能需要处理该消息。



`WM_COMMAND`消息的`wParam`和`IParam`参数的含义。



|                  `HIWORD (wParam) `                   |                      `LOWORD (wParam)`                       | ` HWND(lParam)` |
| :---------------------------------------------------: | :----------------------------------------------------------: | :-------------: |
|            `菜单命今ID`  比如说，`ID_MEUN`            | 菜单项ID，比如说，记事本程序的打开菜单项ID`IDM_FILE_OPEN`,保存菜单项`IDM_FILE_SAVE` |        0        |
|                    加速键(快捷键)                     |                        菜单项ID，同上                        |        0        |
| 子窗口控件**通知码**,比如说`BN_CLICKED`按钮比点击了。 |             控件ID,比如说按钮控件的ID`ID_BUTTON`             |    控件句柄     |

> 通知码，可以类比QT中的发出的信号。
>
> ```c
>    // 为按钮绑定事件 connect(信号的发送者,发送的信号,信号的接受者,处理的函数(槽函数))
>  connect(btn, &QPushButton::clicked, this, &QWidget::close);
> ```
>
> 



`BN_SETFOCUS`: 按钮获得了键盘焦点



`BN_KILLFOCUS`:按钮失去了键盘焦点



`BN_DBLCLK`或`BN_DOUBLECLICKED` :双击按钮





获得键盘焦点的按钮周围会显示一圈虚线，此时按下空格键就相当于单击了按钮。只有具有`BS_NOTIFY`样式的按钮会发送`BN_SETFOCUS`  `BN_KILLFOCUS`和`BN_DBLCLK`通知码，但是无论如何设置按钮样式，单击按钮都会发送`BN_CLICKED`通知码。





:::



:::warning



`BS_GROUPBOX`样式表示分组框，用于对其他控件进行分组，由一个矩形和显示在矩形左上角的文本组成。分组框不会获得键盘焦点，既不处理鼠标或键盘输入，也不会导致系统发送`WM_COMMAND`消息到父窗口。

:::







:::details `对于按钮类的自绘消息WM_DRAWITEM`

对于自绘按钮、组合框和列表框等，程序只需要在必要的时候负责绘制它们的外观即可，系统会正常处理用户和这些控件的交互，例如用户单击控件，系统会向父窗口发送`WM_COMMAND`消息。在介绍自绘菜单的时候说过，`WM_DRAWITEM`消息既用于菜单项，**也用于其他些子窗口控件的自绘**，当菜单项或子窗口控件需要自绘的时候,窗口过程会收到`WM_DRAWITEM`消息。





如果WM_DRAWITEM消息是由子窗口控件发送的，则`wParam`参数是子窗口控件的ID

如果是由菜单项发送的，则`wParam`参数为0。`lParam`参数是一个指向`DRAWITEMSTRUCT`结构的指针

```c
typedef struct tagDRAWITEMSTRUCT
{
	UINT	ctlType;//控件类型，如果是ODT_MENU，表示菜单项
	UINT	CtlID;//该字段不用于菜单项
	UINT	itemID;//菜单项ID
	UINT	itemAction; //所需的绘制操作
	UINT	itemState;//新的状态
	HWND	hwndItem;//菜单句柄
	HDC	hDC;//设备环境句柄
	RECT	rcItem;//绘制区域
	ULONG_PTR	itemData;//程序自定义数据，最初由MENUITEMINFO结构的dwltemData指定的
}DRAWITEMSTRUCT,NEAR *PDRAWITEMSTRUCT，FAR *LPDRAWITEMSTRUCT;
```

:::



:::details `按钮类示例:`



接下来实现一个例子，Buttons程序在窗口客户区中使用系统预定义的Button类调用`CreateWindowEx()`函数分别创建了普通按钮、图标按钮、位图按钮、自绘按钮、一组自动单选按钮、一组自动复选按钮、一组自动三态复选按钮、默认按钮。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6.gif)

:::





:::details `resource.h`

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 Buttons.rc 使用
//
#define IDB_KONGLONG                    101
#define IDI_SMILE                       102

#define IDC_PUSHBUTTON          1000
#define IDC_ICONBUTTON          1001
#define IDC_BITMAPBUTTON        1002
#define IDC_OWNERDRAWBUTTON     1003
#define IDC_GROUPBOX1           1004
#define IDC_AUTORADIOBUTTON1    1005
#define IDC_AUTORADIOBUTTON2    1006
#define IDC_AUTORADIOBUTTON3    1007
#define IDC_GROUPBOX2           1008
#define IDC_AUTOCHECKBOX1       1009
#define IDC_AUTOCHECKBOX2       1010
#define IDC_AUTOCHECKBOX3       1011
#define IDC_GROUPBOX3           1012
#define IDC_AUTO3STATE1         1013
#define IDC_AUTO3STATE2         1014
#define IDC_AUTO3STATE3         1015
#define IDC_DEFPUSHBUTTON       1016

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240114231846364-17052455277211-17052455358562.png)

:::



:::details `main.cpp`

```c
#include <Windows.h>
#include <tchar.h>
#include <strsafe.h>
#include "resource.h"


LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID OnDefPushButton(HWND hwnd);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("Buttons");  
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 300, 600, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
struct
{
    int     m_nStyle;
    PTSTR   m_pText;
}Buttons[] = {
    BS_PUSHBUTTON | BS_NOTIFY | WS_TABSTOP,                 TEXT("普通按钮"), // CtrlID 1000
    BS_ICON | BS_NOTIFY | WS_TABSTOP,                       TEXT("图标按钮"),
    BS_BITMAP | BS_NOTIFY | WS_TABSTOP,                     TEXT("位图按钮"),
    BS_OWNERDRAW,                                           TEXT("自绘按钮"),

    BS_GROUPBOX,                                            TEXT("政治面貌"), // CtrlID 1004
    BS_AUTORADIOBUTTON | BS_NOTIFY | WS_GROUP | WS_TABSTOP, TEXT("中共党员"),
    BS_AUTORADIOBUTTON | BS_NOTIFY,                         TEXT("共青团员"),
    BS_AUTORADIOBUTTON | BS_NOTIFY,                         TEXT("无党派人士"),

    BS_GROUPBOX,                                            TEXT("个人爱好"), // CtrlID 1008
    BS_AUTOCHECKBOX | BS_NOTIFY | WS_GROUP | WS_TABSTOP,    TEXT("看书"),
    BS_AUTOCHECKBOX | BS_NOTIFY,                            TEXT("唱歌"),
    BS_AUTOCHECKBOX | BS_NOTIFY,                            TEXT("听音乐"),

    BS_GROUPBOX,                                            TEXT("荣誉称号"), // CtrlID 1012
    BS_AUTO3STATE | BS_NOTIFY | WS_GROUP | WS_TABSTOP,      TEXT("团队核心"),
    BS_AUTO3STATE | BS_NOTIFY,                              TEXT("技术能手"),
    BS_AUTO3STATE | BS_NOTIFY,                              TEXT("先进个人"),

    BS_DEFPUSHBUTTON | BS_NOTIFY | WS_TABSTOP,              TEXT("默认按钮"), // CtrlID 1016
};
#define NUM (sizeof(Buttons) / sizeof(Buttons[0]))
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND hwndButton[NUM];                // 子窗口控件句柄数组
    int arrPos[NUM] = { 10, 40, 70, 100,         // 每个子窗口控件的起始Y坐标
        130, 150, 180, 210,
        250, 270, 300, 330,
        370, 390, 420, 450,
        490 };
    LPDRAWITEMSTRUCT lpDIS;
    if (WM_CREATE == uMsg)
    {
        // 创建17个子窗口控件
        for (int i = 0; i < NUM; i++)
        {
            hwndButton[i] = ::CreateWindowEx(
                0,
                TEXT("Button"),
                Buttons[i].m_pText,
                WS_CHILD | WS_VISIBLE | Buttons[i].m_nStyle,
                20, arrPos[i],
                150, 25,
                hwnd,
                (HMENU)(1000 + i),
                ((LPCREATESTRUCT)lParam)->hInstance, NULL);
        }
        // 移动3个分组框的位置
        ::MoveWindow(hwndButton[4], 10, arrPos[4], 170, 115, TRUE);
        ::MoveWindow(hwndButton[8], 10, arrPos[8], 170, 115, TRUE);
        ::MoveWindow(hwndButton[12], 10, arrPos[12], 170, 115, TRUE);

        // 为图标按钮、位图按钮设置图标、位图
        HANDLE hImage = ::LoadImage(((LPCREATESTRUCT)lParam)->hInstance, MAKEINTRESOURCE(IDI_SMILE), IMAGE_ICON, 20, 20, LR_DEFAULTCOLOR); //根据resourceID 查图片句柄
        ::SendDlgItemMessage(hwnd, IDC_ICONBUTTON, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hImage); //给按钮设置图标

        HBITMAP hBitMap = ::LoadBitmap(((LPCREATESTRUCT)lParam)->hInstance, MAKEINTRESOURCE(IDB_KONGLONG));// 根据resourceID 查位图句柄
        ::SendDlgItemMessage(hwnd, IDC_BITMAPBUTTON, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitMap);  //给按钮设置位图
        ::SetDlgItemText(hwnd, IDC_DEFPUSHBUTTON, TEXT("获取单选复选状态"));        // 设置默认按钮的文本

        // 单选按钮组、复选按钮组、三态复选按钮组，默认情况下分别选中一项
        ::CheckRadioButton(hwnd, IDC_AUTORADIOBUTTON1, IDC_AUTORADIOBUTTON3, IDC_AUTORADIOBUTTON2);
        ::CheckDlgButton(hwnd, IDC_AUTOCHECKBOX3, BST_CHECKED);
        ::CheckDlgButton(hwnd, IDC_AUTO3STATE2, BST_INDETERMINATE);

        return 0;

    }
    else if (WM_COMMAND == uMsg)
    {

        if (HIWORD(wParam) == BN_CLICKED)
        {
            // 子窗口控件ID常量定义请参见resource.h，可以根据需要在此处理每个控件的点击事件
            if (LOWORD(wParam) == IDC_PUSHBUTTON)
            {
            }
            else if (LOWORD(wParam) == IDC_ICONBUTTON)
            {
            }
            else if (LOWORD(wParam) == IDC_BITMAPBUTTON)
            {
            }
            else if (LOWORD(wParam) == IDC_OWNERDRAWBUTTON)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTORADIOBUTTON1)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTORADIOBUTTON2)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTORADIOBUTTON3)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTOCHECKBOX1)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTOCHECKBOX2)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTOCHECKBOX3)
            {

            }
            else if (LOWORD(wParam) == IDC_AUTO3STATE1)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTO3STATE2)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTO3STATE3)
            {
            }
            else if (LOWORD(wParam) == IDC_DEFPUSHBUTTON)
            {
                OnDefPushButton(hwnd);
            }
        }
        return 0;
    }
    else if (WM_DRAWITEM == uMsg)
    {
        //按钮重绘
        lpDIS = (LPDRAWITEMSTRUCT)lParam;

        // 先把按钮矩形填充为和窗口背景一致的白色，然后画一个黑色圆角矩形
        ::SelectObject(lpDIS->hDC, GetStockObject(NULL_PEN));
        ::SelectObject(lpDIS->hDC, GetStockObject(WHITE_BRUSH));

        ::Rectangle(lpDIS->hDC, 0, 0, lpDIS->rcItem.right + 1, lpDIS->rcItem.bottom + 1);
        ::SelectObject(lpDIS->hDC, GetStockObject(BLACK_BRUSH));
        ::RoundRect(lpDIS->hDC, 0, 0, lpDIS->rcItem.right + 1, lpDIS->rcItem.bottom + 1, 20, 20);

        // 当用户点击按钮的时候，绘制COLOR_HIGHLIGHT颜色的圆角矩形
        if (lpDIS->itemState & ODS_SELECTED)
        {
            SelectObject(lpDIS->hDC, GetSysColorBrush(COLOR_HIGHLIGHT));
            RoundRect(lpDIS->hDC, 0, 0, lpDIS->rcItem.right + 1, lpDIS->rcItem.bottom + 1, 20, 20);
        }
        if (lpDIS->itemState & ODS_FOCUS)
        {
            ::InflateRect(&lpDIS->rcItem, -2, -2);
            ::DrawFocusRect(lpDIS->hDC, &lpDIS->rcItem);
        }
        // 自绘按钮的文本，透明背景的白色文字
        ::SetBkMode(lpDIS->hDC, TRANSPARENT);
        ::SetTextColor(lpDIS->hDC, RGB(255, 255, 255));
        ::DrawText(lpDIS->hDC, TEXT("自绘按钮"), _tcslen(TEXT("自绘按钮")), &lpDIS->rcItem, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        // 恢复设备环境
        ::SelectObject(lpDIS->hDC, GetStockObject(BLACK_PEN));
        ::SelectObject(lpDIS->hDC, GetStockObject(WHITE_BRUSH));
    }
    else if (WM_DESTROY == uMsg)
    {
        PostQuitMessage(0);
        return 0;
    }
    return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

VOID OnDefPushButton(HWND hwnd)
{
    TCHAR szBuf[128] = { 0 };

    //查自动单选按钮 哪一项被选中了
    if (::IsDlgButtonChecked(hwnd, IDC_AUTORADIOBUTTON1) & BST_CHECKED)
    {
        ::StringCchCopy(szBuf, _countof(szBuf), TEXT("政治面貌：中共党员\n"));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTORADIOBUTTON2) & BST_CHECKED)
    {
        ::StringCchCopy(szBuf, _countof(szBuf), TEXT("政治面貌：共青团员\n"));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTORADIOBUTTON3) & BST_CHECKED)
    {
        ::StringCchCopy(szBuf, _countof(szBuf), TEXT("政治面貌：无党派人士\n"));
    }
    //查自动复选按钮中 哪一个自动复选按钮项被选中了
    ::StringCchCat(szBuf, _countof(szBuf), TEXT("个人爱好："));
    if (::IsDlgButtonChecked(hwnd, IDC_AUTOCHECKBOX1) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("看书 "));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTOCHECKBOX2) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("唱歌 "));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTOCHECKBOX3) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("听音乐"));
    }
    ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n"));
    ::StringCchCat(szBuf, _countof(szBuf), TEXT("荣誉称号："));
    //查 自动三态复选按钮 哪一个自动三态复选按钮被选中了
    if (::IsDlgButtonChecked(hwnd, IDC_AUTO3STATE1) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("团队核心 "));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTO3STATE2) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("技术能手 "));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTO3STATE3) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("先进个人"));
    }
    ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n"));
    ::MessageBox(hwnd, szBuf, TEXT("个人简介汇总"), MB_OK);
}
```

在`WM_CREATE`消息中，程序使用系统预定义的Button类调用`CreateWindowEx`函数分别创建了17个子窗口控件，`lpWindowName`参数对于普通重叠窗口或弹出窗口来说是窗口标题，对于按钮来说是显示在按钮上的文本;窗口位置参数x和y指定子窗口左上角的位置，相对于父窗口客户区左上角;宽
度和高度参数nWidth和nHeight指定每个子窗口的宽度和高度;因为创建的是子窗口，所以父窗口参数hWndParent指定为hwnd;对于普通重叠窗口或弹出窗口来说，hMenu参数指定菜单句柄，对于子窗口来说，则用于指定其ID，每个子窗口的ID应该是唯一的，在
`WM_COMMAND`消息中通过子窗口ID来确定是从哪个子窗口发送过来的消息。



然后调用MoveWindow函数改变3个分组框的位置和大小，让每个分组框可以包围相应的组。分组框没有什么实际意义，仅仅提供一种视觉上的分组效果。一个组的界定依靠的是`WS_GROUP`样式，一个组由第一个具有`WS_GROUP`样式的控件和在其后定义的所有控件组成，直到下一个具有`WS_GROUP`样式的控件出现。



然后程序调用`SendDlgltemMessage`函数向图标按钮和位图按钮分别发送`BM_SETIMAGE`消息设置其图像。资源脚本文件中的图标大小是32 32，而按钮大小为150 25，因此加载图标用的是`Loadlmage`函数，该函数可以指定图标的宽度和高度。资源脚本文件中的恐龙位图大小正好是150 25，所以使用`LoadBitmap`函数直接加载即可。最后一个子窗口控件是默认按钮，程序调用`SetDlgltemText`函数改变按钮文本为"获取单选复选状态"。



:::





:::details `SetWindowsText 函数说明`



`SetWindowText`函数可以设置指定程序窗口的窗口标题，也可以设置子窗口控件的文本

```c
/// <summary>
/// 设置指定程序窗口的窗口标题
/// </summary>
/// <param name="hWnd">程序窗口或控件的句柄，其文本将被更改</param>
/// <param name="lpString">新窗口标题或控件文本</param>
/// <returns></returns>
BOOL WINAPI SetWindowText(HWND hWnd,LPCTSTR lpString); 
```

也可以通过发送`WM_SETTEXT`消息达到同样的目的。但如果是设置其他程序中的窗口标题或控件文本，则需要发送`WM_SETTEXT`消息，而不能调用`SetWindowText` 

:::





:::details `GETWindowsText 函数说明`

`GetWindowText`函数用于获取指定程序窗口的窗口标题或子窗口控件的文本

```c

/// <summary>
/// 获取指定窗口的文本标题
/// </summary>
/// <param name="hWnd">程序窗口或控件的句柄</param>
/// <param name="lpString">接收文本的缓冲区</param>
/// <param name="nMaxCount">缓冲区的大小，以字符为单位</param>
/// <returns></returns>
int WINAPI GetWindowText(HWND hWnd,LPTSTR lpString,int nMaxCount);
```

也可以通过发送`WM_GETTEXT`消息达到同样的目的。但如果是获取其他程序中的窗口标题或控件文本，则需要发送`WM_GETTEXT`消息，而不能调用`GetWindowText`



在获取指定程序窗口的窗口标题或子窗口控件的文本前，可以先调用`GetWindowTextLength`函数获取其文本的长度。

```c
int WINAPI GetWindowTextLength(HWND hWnd);
```

也可以通过发送`WM_GETTEXTLENGTH`消息达到同样的目的。但如果是获取其他程序中的窗口标题或控件文本长度，则需要发送`WM_GETTEXTLENGTH`消息，而不能调用`GetWindowTextLength`.

:::





:::details `GetDlgItem 函数说明`

对于子窗口控件，`SetWindowText`和`GetWindowText`函数需要提供子窗口控件句柄，这可能需要先调用`GetDlgltem`函数获取子窗口控件句柄︰

```c
/// <summary>
/// 获取子窗口控件句柄
/// </summary>
/// <param name="hDIg">父窗口句柄</param>
/// <param name="nlDDIgltem">子窗口控件ID</param>
/// <returns></returns>
HWND WINAPI GetDlgItem(HWND hDIg,int nlDDIgltem)
```

:::



:::details `函数说明GetDlgCtrlID 函数说明`

如果已经知道了子窗口控件句柄，可以通过调用`GetDlgCtrlID`函数获取其ID∶

```c
/// <summary>
/// 获取子窗口控件ID
/// </summary>
/// <param name="hwndCtl">子窗口控件句柄</param>
/// <returns></returns>
int WINAPI GetDlgCtrlID(HWND hwndCtl);
```

当然，要获取子窗口控件ID，还可以通过指定GWLP_ID索引调用`GetWindowLongPtr`函数获取。

:::



:::details `G/SetDlgItemText 函数说明`

要获取子窗口控件文本，还有一个更简单的函数︰

```c
/// <summary>
/// 获取对话框文本内容
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDDlgltem">子窗口控件ID</param>
/// <param name="lpString">接收文本的缓冲区</param>
/// <param name="nMaxCount">缓冲区的长度，以字符为单位</param>
/// <returns></returns>
UINT  GetDlgItemText(HWND hDlg,int nlDDlgltem,LPTSTR lpString, int nMaxCount); 
```

要设置子窗口控件文本可以使用SetDlgltemText函数

```c
/// <summary>
/// 设置子窗口控件文本
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nIDDlgltem">子窗口控件ID</param>
/// <param name="lpString">字符串指针</param>
/// <returns></returns>
BOOL WINAPI SetDlgltemText(HWND hDlg, int nIDDlgltem,LPCTSTR lpString); 
```

上面这两个函数实际上也是通过发送`WM_GETTEXT`和`WM_SETTEXT`消息实现的。

:::



再介绍两个函数。要接收鼠标和键盘输入，子窗口必须是可见（显示）并且启用的。如果一个子窗口是可见的，但是没有启用，那么子窗口中的文本是灰色的。如果在创建子窗口的时候没有指定`WS_VISIBLE`样式，则子窗口将不会显示，程序可以通过调用ShowWindow函数来显示∶

```c
ShowWindow(hwndChild,SW_SHOW);
```

程序可以通过调用以下语句来隐藏一个子窗口∶

```c
ShowWindow(hwndChild,SW_HIDE);
```

可以通过调用`IsWindowVisible`函数来判断一个窗口是否可见:

```c
lsWindowVisible(hwnd);
```

可以通过调用EnableWindow函数后用或禁用指定的窗口或子窗口控件。窗口禁用以后无法接收鼠标和键盘输入:

```c
/// <summary>
/// 是否启用窗口
/// </summary>
/// <param name="hWnd">窗口或子窗口控件句柄</param>
/// <param name="bEnable">TRUE表示后用，FALSE表示禁用</param>
/// <returns></returns>
BOOL  EnableWindow(HWND hWnd,BOOL bEnable);
```

可以通过调用lsWindowEnabled函数来判断一个窗口或子窗口控件是否处于启用状态∶

```c
BOOL WINAPI lsWindowEnabled(_ln_ HWND hWnd);
```

## 系统颜色

Windows提供了几十种系统预定义的颜色，用于显示窗口、菜单栏、工具栏、滚动条、按钮等不同的部分。程序可以通过调用`GetSysColor`函数获取这些颜色值，也可以通过调用`SetSysColors`函数改变系统预定义的颜色值，但是这会影响其他程序。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/SysColors.png)



## 控件的子类化与超类化



:::details `G/SetParent 函数说明`



GetParent函数用于获取指定窗口的父窗口句柄︰

```c
HWND  GetParent(HWND hWnd);
```

与之对应的，还有一个`SetParent`函数用于设置一个窗口的父窗口∶

```c
/// <summary>
/// 指定一个窗口为自己的父窗口
/// </summary>
/// <param name="hWndChild">子窗口句柄</param>
/// <param name="hWndNewParent">新父窗口句柄</param>
/// <returns></returns>
HWND WINAPI SetParent(HWND hWndChild,HWND hWndNewParent); 
```

如果函数执行成功，则返回值是前一个父窗口的句柄。如果函数执行失败，则返回值为NULL。

:::





:::details `CallWindowsProc 函数说明`

CallWindowProc函数用于把新窗口过程未处理的消息传递给原窗口过程∶

```c

/// <summary>
/// 用于新窗口过程未处理的消息传递给原窗口过程
/// </summary>
/// <param name="lpPrevWndFunc">原窗口过程</param>
/// <param name="hWnd"></param>
/// <param name="Msg"></param>
/// <param name="wParam"></param>
/// <param name="lParam"></param>
/// <returns></returns>
LRESULT  CallWindowProc(WNDPROC lpPrevWndFunc, HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);
```

:::





重叠窗口中子窗口控件的默认窗口过程无法满足我们的要求，为此调用SetWindowLongPtr函数为子窗口控件设置一个新的窗口过程。拦截控件的部分消息进行处理，这就是**控件的子类化**。





:::details `S/Get/RemoveWindowSubclass 函数说明`

`SetWindowSubclass`函数为需要子类化的窗口设置新的窗口过程

```c
/// <summary>
/// 设置子窗口控件的窗口过程
/// </summary>
/// <param name="hWnd">要子类化的窗口句柄</param>
/// <param name="pfnSubclass">指向新子类窗口过程的指针</param>
/// <param name="uldSubclass">子类ID，该参数与pfnSubclass参数一起唯一标识一个子类</param>
/// <param name="dwRefData">用户自定义数据，传递给新子类窗口过程的dwRefData参数</param>
/// <returns></returns>
BOOL SetWindowSubClass(HWND hWnd, SUBCLASSPROC pfnSubclass,UINT_PTR uldSubclass, DWORD_PTR dwRefData); 
```

`SetWindowSubclass`函数需要引入头文件`CommCtrl.h`，还需要使用导入库`Comctl32.lib`。在引入相关头文件以后，添加以下预编译指令。

```c
#include <Commctrl.h>
#pragma comment(lib, "Comctl32.lib")
```

要获取子类窗口的自定义数据，可以调用`GetWindowSubclass`函数∶

```c
/// <summary>
/// 获取子类窗口的自定义数据
/// </summary>
/// <param name="hWnd"子类窗口句柄></param>
/// <param name="pfnSubclass">子类窗口过程</param>
/// <param name="uldSubclass">子类ID</param>
/// <param name="pdwRefData">在这里返回自定义数据的指针</param>
/// <returns></returns>
BOOL GetWindowSubclass(HWND hWnd,SUBCLASSPROC pfnSubclass, UINT_PTR uldSubclass,DWORD_PTR* pdwRefData);
```

:::





:::details `RemoveWindowSubclass 函数说明`

`RemoveWindowSubclass`函数用于删除一个子类

```c

/// <summary>
/// 删除一个子类
/// </summary>
/// <param name="hWnd">窗口句柄</param>
/// <param name="pfnSubclass"> 子类ID</param>
/// <param name="uldSubclass">子类窗口过程</param>
/// <returns></returns>
BOOL RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass,UINT_PTR uldSubclass); 
```

:::



## 命令链接按钮与拆分按钮



:::tip 命令链接按钮

命今链接按钮是通用控件版本6中引入的一种按钮。指定`BS_COMMANDLINK`样式可以创建一个命今链接按钮，左侧有一个蓝色箭头指向按钮文本，按钮文本下面可以显示一些说明文字作为按钮文本的补充。要设置按钮文本，可以通过调用`SetWindowText/SetDlgltemText`函数或发送`WM_SETTEXT`消息来进行。要设置说明文字，可以通过发送`BCM_SETNOTE`消息来进行，该消息的`wParam`参数没有用到，将`IParam`参数指定为字符串指针。

:::





:::tip 

拆分按钮也是通用控件版本6中引入的一种按钮。指定`BS_SPLITBUTTON`样式可以创建一个拆分按钮。拆分按钮分为两部分，左侧是主要部分，类似于普通或默认按钮﹔右侧有一个下拉箭头，单击箭头通常会弹出一个菜单。单击下拉箭头，系统会发送包含`BCN_DROPDOWN`通知码的`WM_NOTIFY`消息。和其他按钮一样，单击命合链接按钮和拆分按钮的左侧会发送包含`BN_CLICKED`通知码的`WM_COMMAND`消息。

:::



:::details `拆分按钮的WM_NOTIFY消息`



`WM_NOTIFY`消息的`wParam`参数是控件的ID，不过通常不使用这个参数，而是使用`IParam`参数。`lParam`参数通常是一个指向`NMHDR`结构的指针，该结构包含通知码和一些附加信息。



对于其他通知码，`lParam参`数可能是指向一个更大结构的指针，但是这些结构的第一个字段总是NMHDR结构，所以把`lParam`参数强制转换为指向NMHDR结构的指针总是正确的。NMHDR结构定义如下∶

```c
typedef struct tagNMHDR
{
	HWND hwndFrom;//控件的窗口句柄
	UINT_PTR idFrom; // 控件的ID
	UINT code; // 通知码
} NMHDR;
```



处理`WM_NOTIFY`消息的代码通常如下，先把`IParam`参数转换为指向`NMHDR`结构的指针，确定通知码的类型，然后才可以进一步确定`lParam`指向的是什么结构∶

```c
case WM_NOTIFY:
{ 
    switch ((LPNMHDR)IParam)->code)
    {
    case BCN_DROPDOWN:
        // BCN_DROPDOWN通知码的IParam参数是一个指向NMBCDROPDOWN结构的指针把lParam参数转换为指向NMBCDROPDOWN结构的指针，然后使用结构中的字段
            break;
    case 其他通知码:
       //对于其他通知码，lParam参数可能是指向其他数据结构的指针
            break;
}
return 0;
```

如果程序需要发送`WM_NOTIFY`消息，`SendMessage`函数的窗口句柄参数需指定为父窗口句柄，例如:

```c
NMHDR nmh;
nmh.hwndFrom = hwndCtrl;//控件窗口句柄
nmh.idFrom = GetDlgCtrlID(hwndCtrl); //控件ID
nmh.code = 通知码; //通知码
SendMessage(GetParent(hwndCtrl), WM_NOTIFY, nmh.idFrom, (LPARAM)&nmh);
```

`BCN_DROPDOWN`通知码的`IParam`参数是一个指向`NMBCDROPDOWN`结构的指针。

```c
typedef struct tagNMBCDROPDOWN
{
	NMHDR hdr;
	RECT rcButton;// 按钮的矩形区域，相对于自己的客户区左上角
}NMBCDROPDOWN,*LPNMBCDROPDOWN;
```

:::





:::details `示例:`

举一个例子，单击拆分按钮的下拉箭头，系统会发送一个包含
BCN_DROPDOWN通知码的WM_NOTIFY消息。程序处理该消息弹出一个菜单。

```c
#include <Windows.h>
#include <Commctrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker, "\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("CommandLinkAndSplitButton");    
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HINSTANCE hInstance;
    NMBCDROPDOWN* pDropDown;
    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;

        CreateWindowEx(0, TEXT("Button"), TEXT("命令链接按钮"),
            WS_CHILD | WS_VISIBLE | BS_COMMANDLINK, 10, 10, 200, 50, hwnd,
            (HMENU)IDC_COMMANDLINK, hInstance, NULL);
        SendDlgItemMessage(hwnd, 1000, BCM_SETNOTE, 0, (LPARAM)TEXT("这是一个命令链接按钮"));

        CreateWindowEx(0, TEXT("Button"), TEXT("拆分按钮"),
            WS_CHILD | WS_VISIBLE | BS_SPLITBUTTON, 10, 70, 200, 30, hwnd,
            (HMENU)IDC_SPLITBUTTON, hInstance, NULL);
        return 0;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case ID_EDIT_CUT:
            MessageBox(hwnd, TEXT("ID_EDIT_CUT"), TEXT("提示"), MB_OK);
            break;
        case ID_EDIT_COPY:
            MessageBox(hwnd, TEXT("ID_EDIT_COPY"), TEXT("提示"), MB_OK);
            break;
        case ID_EDIT_PASTE:
            MessageBox(hwnd, TEXT("ID_EDIT_PASTE"), TEXT("提示"), MB_OK);
            break;

        case IDC_COMMANDLINK:
            MessageBox(hwnd, TEXT("点击了命令链接按钮"), TEXT("提示"), MB_OK);
            break;
        case IDC_SPLITBUTTON:
            MessageBox(hwnd, TEXT("点击了拆分按钮"), TEXT("提示"), MB_OK);
            break;
        }
        return 0;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case BCN_DROPDOWN:
            pDropDown = (NMBCDROPDOWN*)lParam;
            if (pDropDown->hdr.hwndFrom = GetDlgItem(hwnd, IDC_SPLITBUTTON))
            {
                POINT pt;
                HMENU hMenu;
                pt.x = pDropDown->rcButton.left;
                pt.y = pDropDown->rcButton.bottom;
                // 拆分按钮的矩形客户区坐标转换为屏幕坐标
                ClientToScreen(pDropDown->hdr.hwndFrom, &pt);
                hMenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDR_MENU));
                TrackPopupMenu(GetSubMenu(hMenu, 0), TPM_LEFTALIGN | TPM_TOPALIGN, 
                    pt.x, pt.y, 0, hwnd, NULL);
            }
            break;
        }
        return 0;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240623170905457.png)

:::



## 编辑控件

编辑控件通常叫作编辑框或文本框，是一个矩形窗口，可以用于输入和编辑文本，编辑控件的应用比较广泛。



:::details `编辑控件样式表`

|       样式       |                             含义                             |
| :--------------: | :----------------------------------------------------------: |
|  `ES_MULTILINE`  | 编辑控件默认为单行编辑控件，指定ES_MULTILIE样式表示创建一个多行编辑控件 |
| `ES_AUTOHSCROLL` | 对于单行编辑控件。当用户输入文本时，如果文本字数填满了编辑控件，则无法维续输入。指定该样式以后。在必要时编辑控件会自动水平滚动。这样一来用户输入的文本字数就不受编辑控件的长度影响。对于多行编辑控件，如果没有指定然S_ATOHBSCDOL样式。当用户输入的文本多于可在单行上显示的字数时，文本将自动换行显示到下一行﹔如果指定了ES_AUTOHSCROLL样式，则当用户输入的文本多于可在单行上显示的字数时，控件将自动水平滚动，文字不会换行 |
| `ES_AUTOVSCROLL` | 仅适用于多行编辑控件。如果没有指定该样式。当用户输入的文本行数高于‘编辑控件的高度时，无法继续输入。在指定该样式后，在必要时的编辑控件会自动垂直滚动，这样一来用户输入的文本行数就不受编辑控件的高度影响 |
|    `ES_LEFT`     |                    文本在编辑控件中左对齐                    |
|    `ES_RIGHT`    |                    文本在编辑控件中右对齐                    |
|   `ES_CENTER`    | 文本在编辑控件中居中对齐.右对齐和居中对齐的多行编辑控件不能具有ES_AUTOHSCROLL样式，即不能自动水平滚动，超过一行限制以后会自动换行显示 |
|  `ES_LOWERCASE`  |                输入的所有大写字母都转换为小写                |
|  `ES_UPPERCASE`  |                输入的所有小写字母都转换为大写                |
|   `ES_NUMBER`    |                   只能在编辑控件中输入数字                   |
|  `ES_READONLY`   |        将编辑控件设置为只读模态,不允许编辑其中的文本         |
|  `ES_PASSWORD`   | 将单行编辑控件中的所有字符显示为星号，版本6中显示为黑圆圈〈如果需要显示为其他字符﹐可以通过发送`EM_SETPASSWORDCHAR`消息进行设置，该样式通常用于密码一类的敏感信息 |
|  `ES_NOHIDESEL`  | 默认情况下，当编辑控件失去输入焦点时，所选中的文本会失去突出显示。在指定该样式后，即使编辑控件失去输入焦点，所选中的文本也会突出显示 |
| `ES_WANTRETURN`  | 对于对话框程序中的多行编辑控件，如果没有指定ES_WANTRETURN样式，当用户按下`Enter`键时。不会换行，不过可以按`Ctrl +Enter`组合键进行换行。在指定该样式后，按下`Enter`键就可以换行。 |

默认情况下，编辑控件是没有边框的，可以指定WS_BORDER窗口样式为其添加一个边框。当然，`WS_CHILD |WS_VISIBLE`窗口样式是子窗口控件必不可少的。如果需要为编辑控件添加水平或垂直滚动条，可以指定`WS_HSCROLL`或`WS_VSCROLL`窗口样式。





系统在创建编辑控件时，会自动创建文本缓冲区，并设置其初始大小，默认情况下最大缓冲区大小约为32KB个字符，有时候可能需要限制用户输入。比如有一个用户名文本框，可能想限制用户最多可以输入20个字符，有时候可能需要比32KB更大的缓冲区，可以通过向编辑控件发送`EM_SETLIMITTEXT`(和`EM_LIMITTEXT`相同）消息来设置缓冲区大小，将`wParam`参数指定为最大字符数，没有用到`lParam`参数。



对于单行编辑控件，可以设置的最大字符数为Ox7FFFFFFE(约2G);

对于多行编辑控件，可以设置为系统支持的最大大小，如果`wParam`参数为0，则表示使用可用的最大大小。

:::





对于每个编辑控件，系统维护一个**只读标志**，指示控件的文本是可读可写(默认）或只读，可以通过向控件发送`EM_SETREADONLY`消息来设置文本的可读可写或只读标志，`wParam`参数为TRUE表示只读,FALSE表示可读可写，没有用到`lParam`参数。



确定编辑控件是否为只读，而没有名为`EM_GETREADONLY`的消息，可以使用
`GWL_STYLE`常量调用`GetWindowLongPtr`函数获取控件样式(`ES_READONLY`) 。





:::tip 设置编辑控件的文本



可以通过调用`SetWindowText/SetDlgltemText`函数或发送`WM_SETTEXT`消息来设置编辑控件的文本，这几个设置窗口文本的方法对于所有窗口几乎都适用。当然，还有` GetWindowText / GetDlgltemText`和`WM_GETTEXT`消息。



:::





有时候需要把一个数值型数据显示到编辑控件中，或者从编辑控件中获取一个字符串作为数值型使用，将文本转换为数值或将数值转换为文本需要额外的函数调用。为了简化操作，Windows提供了两个函数来处理这个问题。





:::details `SetDlgltemInt 函数说明`



`S/GetDlgltemInt`函数可以把一个数值型数据显示到编辑控件中

```c
/// <summary>
/// 把一个数值型数据显示到编辑控件中
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDDlgltem">编辑控件ID</param>
/// <param name="uValue">数值型数据</param>
/// <param name="bSigned">指示uValue参数是有符号还是无符号数</param>
/// <returns></returns>
BOOL  SetDlgItemInt(HWND hDlg, int nlDDlgltem,UINT uValue, BOOL bSigned);
```

- 参数`bSigned`指示uValue参数是有符号数还是无符号数。如果该参数为TRUE且uValue小于0，则在编辑控件中的第一个数字之前会添加-个减号﹔如果该参数为FALSE，则把uValue视为无符号数。

```c

/// <summary>
/// 获取一个字符串并返回数值型
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDDlgltem">编辑控件ID</param>
/// <param name="lpTranslated">函数执行成功还是失败，返回TRUE表示成功FALSE表示失败</param>
/// <param name="bSigned">是否检查编辑控件中的字符串开头有没有减号</param>
/// <returns></returns>
UINT  GetDlgltemInt(HWND hDlg, int nlDDlgltem, BOOL* lpTranslated,BOOL bSigned);
```

- 参数`bSigned`表示是否检查编辑控件中的字符串开头有没有减号。如果该参数为TRUE并且在字符串开头发现了减号，则返回有符号整数值，在这种情况下需要把返回值强制转换为int类型;否则返回无符号整数值。
- 因为函数返回值是从编辑控件中获取到的十进制数值，所以通过参数`lpTranslated`表示函数执行结果，返回TRUE表示成功，FALSE表示失败。如果不需要检查函数执行成功还是失败，可以将该参数设置为NULL

:::



除了上面介绍的消息，下表所示的消息也可以用于编辑控件，不过这些消息**通常用于多行编辑控件**。多行编辑控件可以用于实现一个简单的文本编辑器。





:::details `多行文本控件样式表`

|     消息类型      |                             含义                             |
| :---------------: | :----------------------------------------------------------: |
|     `EM_UNDO`     | 撤销最近—次的编辑操作，即除刚刚插入的文本或恢复刚刚已删除的文本，例如:`SendMessage (hwndEdit,EM_UNDO,0,0);` |
|   `EM_CANUNDO`    | 编辑控件的撤销队列是否不为空，即能不能撤销上次的扁辑操作，如果可以，返回TRUE，例如:`bResult = SendMessage(hwndEdit,EM_CANUNDo,0,0) ;` |
| `EM_GETLINECOUNT` | 获取多行编辑控件的总行数，例如:`nCount = SendMessage(hwndEdit，EM_GETLINECOUNT，0，0);` |
|  `EM_LINELENGTH`  | 对于单行编辑控件`wParam`和 `lParam`参数都没有用到，直接返回单行编辑控件中的字符个数，不包含终止空字符；                                                                           对于多行编辑控件。`wParam`指定为一个字符的字符索引（第1行第1个字符索引为0)，没有用到lParam参数，返回指定字符所在行的字符个数，比如说下面的多行编辑控件:![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240123222036685-17191526236041.png) |
|  `EM_LINELENGTH`  | ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240123222209532-17191526582182.png) |
|   `EM_GETLINE`    | 将单行编辑控件中的文本复制到指定的缓冲区并返回复制的字符数，不包含终止空字符; 对于多行编辑控件，则是复制指定行的文本并返回复制的字符数，不包含终止空字符。没有用到wParam参数，lParam参数指定为缓冲区指针;对于多行编辑控件，wParam参数指定为从0开始的行号，lParam参数指定为缓冲区指针。需要注意的是因为返回的文本不包括终止空字符，所以缓冲区应该清零，另外在发送消息前，缓冲区第一个字符必须设置为缓冲区的长度。例如 |
|  `EM_LINEINDEX`   | 获取多行编辑控件中指定行的第1个字符的字符索引，该消息与EM_LINEFROMCHAR消息相反，例如:![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240124190806537.png) |
| `EM_LTHEFEOMCHAR` | 用于多行编辑控件，返回指定字符索引的字符所在行的行索引。该消息与`EM_LINEINDEX`消息相反 |
|  `EM_GETMODIFY`   | 编辑控件的内容是否已经被修改，如果已修改返回TRUE，否则返回FAISE，例如:`bResult = SendMessage(hwndEdit,EM_GETMODIFY，0，0);` |
|    `EM_SETSEL`    | 通过指定一段字符的开始和结束位置〈字符索引〉﹐在编辑控件中选中一段文字，例如: ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240124191504295-17060949052582-17191527733803.png) |
|    `EM_SETSEL`    | 即包括开始位置。但不包括结束位置。                                                                  如果开始位置为0且结束位置为-1，则选中编辑控件中的所有文本.                          如果开始位置为-1，则取消当前选中。                                                                        选中文本以后。控件会在结束位置显示闪烁的光标。如果开始和结束位置为相同的值，则会移动光标到此处，这是设置光标位置的一种方法。 |
|    `EM_GETSEL`    | 返回编辑控件中当前所选中文本的开始和结束位置，例如:`DWORD dwResult;DWORD dwStart, dwEnd;dwResult = SendMessage(hwndEdit，EM_GETSEL，(WPARAM) &dwStart,(LPARAM)dwEnd);` 在dwStart和dwEnd中返回当前选中文本的开始和结束位置（字符索引），结束位置是选中的最后一个字符的索引加1，该消息的返回值是DWORD类型，LOWORD(dwResult) 等于开始位置，HIWORD(dwResult)等于结束位置，如果没有选中文本，则开始和结束位置都是光标的位置。 |
|  `EM_REPLACESEL`  | 将当前选中的文本替换为指定的的文本,例如：`SendMessage(hwndEidt,EM_REPLACESET,TRUE,(LPARAM)szStr)` wParam参教可以指定为TRUE或FALSE，表示是否可以撤销本次替换操作。如果指定为TRUE:则表示可以撤销操作﹔如果指定为FALSE，则表示无法撤销操作；lParam参数指定为要替换的字符串，如果没有选中的文本，则将lParam参数指定的字符串插入光标位置。 |
| `EM_SCROLLCARET`  | 在编辑控件中将光标滚动到可见视图中，在设置选中区域〈或改变了光标位置〉后，这个区域可能落在客户区的外面，用户看不到它。如果希望控件能够滚动已将新位置的内容落在客户区中，可以发送`EM_SCROLLCREAT` 消息，例如:`SendMessage(hwndEdit,EM_SCROLLCREAT,0,0)` |
|     `WM_COPY`     | 复制当前选中的内容到剪贴板(如果样式为ES_PASSWORD，则不支持该消息)，例如:`SendMessage(hwndEdit,WM_COPY,0,0)` |
|     `WM_CUT`      | 删除编辑控件中当前选中的内容，并把当前选中的内容以CF_TEXT格式复制到剪贴板，例如:`SendMessage(hwndEdit,WM_CUT,0,0)` |
|    `WM_PASTE`     | 把剪贴板中CF_TEXT格式的内容插入编辑控件的光标位置,例如:`SendMessage(hWndEdit,WM_PAUSE,0,0)` |
|    `WM_CLEAR`     | 删除编辑控件中当前选中的内容，如果当前没有选中文本，则删除光标右侧的字符，例如:`SendMessage(hwndEdit,WM_CLEAR,0,0)` |
|     `WM_UNDO`     | 撤销最近—次的编辑操作，即删除刚刚插入的任何文本或恢复刚刚已删除的文本，例如:`SendMessage(hwndEdit,WM_UNDO,0,0)` |

> 编辑控件的通知码以WM_COMMAND消息的形式发送给父窗口，常见的通知码如下表所示：



**通知码含义**

- EN_SETFOCUS 编辑控件获得了输入焦点
- EN_KILLFOCUS 编辑控件失去了输入焦点
- EN_UPDATE 编辑控件的内容将变化
- EN_CHANGE 编辑控件的内容已变化。

如果是多行编辑控件，并且是通过程序代码（例如SetWindowText SetDlgltemTextSetDlgltemInt等)改变了多行编辑控件的内容，则不会收到EN_CHANGE和EN_UPDATE这两个通知码。

- EN_ERRSPACE 编辑控件的缓冲区已满
- EN _MAXTEXT  编辑控件已经没有空间完成文本插入
- EN_HSCROLL   编辑控件的水平滚动条被单击
- EN_VSCROLL   编辑控件的垂直滚动条被单击



系统自带的记事本程序实际上用的就是Edit多行编辑控件。如果需要实现一个文本编辑器，那么建议学习功能更加强大的RichEdit富文本控件。本节的知识点几乎能适用于RichEdit控件，RichEdit控件提供了更多的功能。

:::





:::details `单行文本控件示例效果:`

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/WIN32UI%E6%8E%A7%E4%BB%B6%E7%BC%96%E8%BE%91%E6%A1%86.gif)

:::



:::details  `resource.h`

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 EditDemo.rc 使用
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

:::



:::details `main.cpp`

```c
#include <Windows.h>
#include <Commctrl.h>
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker, "\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("EditDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HINSTANCE hInstance;
    static HWND hwndUserName, hwndPassword, hwndAge, hwndRegister;
    static HWND hwndStatic[4];
    static HFONT hFont;
    int cx, cy;
    RECT rect;
    if (WM_CREATE == uMsg)
    {
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        hFont = CreateFont(12, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("宋体"));
        //==========================构建UI布局============================================
        hwndStatic[0] = CreateWindowEx(
            0, TEXT("Static"),
            TEXT("会员注册"), WS_CHILD | WS_VISIBLE | SS_CENTER,
            130, 20, 80, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        // 用户名
        hwndStatic[1] = CreateWindowEx(
            0, TEXT("Static"), TEXT("用户名："),
            WS_CHILD | WS_VISIBLE, 20, 50, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndUserName = CreateWindowEx(
            0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL,
            80, 50, 220, 20, hwnd, (HMENU)(1000), hInstance, NULL);
        // 密码
        hwndStatic[2] = CreateWindowEx(
            0, TEXT("Static"),
            TEXT("密  码："),
            WS_CHILD | WS_VISIBLE, 20, 75, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndPassword = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_PASSWORD,
            80, 75, 180, 20, hwnd, (HMENU)(1001), hInstance, NULL);
        // 年龄
        hwndStatic[3] = CreateWindowEx(
            0, TEXT("Static"), TEXT("年  龄："),
            WS_CHILD | WS_VISIBLE, 20, 100, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndAge = CreateWindowEx(
            0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_NUMBER,
            80, 100, 180, 20, hwnd, (HMENU)(1002), hInstance, NULL);
        // 注册按钮
        hwndRegister = CreateWindowEx(
            0, TEXT("Button"), TEXT("注册"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_NOTIFY | WS_TABSTOP,
            85, 130, 150, 25, hwnd, (HMENU)(1003), hInstance, NULL);
        //==========================构建UI布局============================================



        // 设置所有控件的字体为宋体
        SendMessage(hwndUserName, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndPassword, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndAge, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndRegister, WM_SETFONT, (WPARAM)hFont, FALSE);
        for (int i = 0; i < _countof(hwndStatic); i++)
        {
            SendMessage(hwndStatic[i], WM_SETFONT, (WPARAM)hFont, FALSE);
        }
        // 用户名、密码、年龄分别限制输入20、12、3个字符
        SendMessage(hwndUserName, EM_SETLIMITTEXT, 20, 0);
        SendMessage(hwndPassword, EM_SETLIMITTEXT, 12, 0);
        SendMessage(hwndAge, EM_SETLIMITTEXT, 3, 0);
        // 设置程序窗口大小，客户区所需最小大小为320 * 175
        SetRect(&rect, 0, 0, 320, 175);
        AdjustWindowRectEx(&rect, GetWindowLongPtr(hwnd, GWL_STYLE), GetMenu(hwnd) != NULL, GetWindowLongPtr(hwnd, GWL_EXSTYLE));
        SetWindowPos(hwnd, NULL, 0, 0, rect.right - rect.left, rect.bottom - rect.top, SWP_NOZORDER | SWP_NOMOVE);
    }
    else if (uMsg == WM_SIZE)
    {
        //如果说当前窗口大小被拉大，则对应调整控件的位置
        if (LOWORD(lParam) > 320 && HIWORD(lParam) > 175)
        {
            cx = (LOWORD(lParam) - 320) / 2;
            cy = (HIWORD(lParam) - 175) / 2;
            SetWindowPos(hwndStatic[0], NULL, 130 + cx, 20 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndStatic[1], NULL, 20 + cx, 50 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndStatic[2], NULL, 20 + cx, 75 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndStatic[3], NULL, 20 + cx, 100 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndUserName, NULL, 80 + cx, 50 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndPassword, NULL, 80 + cx, 75 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndAge, NULL, 80 + cx, 100 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndRegister, NULL, 85 + cx, 130 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
        }
        return 0;
    }
    else if (uMsg == WM_DESTROY)
    {
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }
    else if (uMsg == WM_CTLCOLORSTATIC)
    {
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);
    }
    else if (uMsg == WM_COMMAND)
    {
        if (HIWORD(wParam) == BN_CLICKED)
        {
            if (LOWORD(wParam) == 1003)
            {
                int nLen;
                LPTSTR lpUserName, lpPassword;
                TCHAR szBuf[64] = { 0 };

                //查用户输入用户名的字符个数 做校验
                nLen = SendMessage(hwndUserName, EM_LINELENGTH, 0, 0);
                if (nLen < 3)
                {
                    MessageBox(hwnd, TEXT("用户名至少需要3个字符"), TEXT("错误提示"), MB_OK);
                    return 0;
                }
                //根据字符长度，动态分配内存，并初始化。
                lpUserName = new TCHAR[nLen + 1];
                ZeroMemory(lpUserName, (nLen + 1) * sizeof(TCHAR));
                lpUserName[0] = nLen + 1;
                //存用户名编辑框的输入
                SendMessage(hwndUserName, EM_GETLINE, 0, (LPARAM)lpUserName);
               //查用户输入的密码字符个数 做校验
                nLen = SendMessage(hwndPassword, EM_LINELENGTH, 0, 0);
                if (nLen < 3)
                {
                    MessageBox(hwnd, TEXT("密码至少需要3个字符"), TEXT("错误提示"), MB_OK);
                    return 0;
                }
                //同理，存密码编辑框的输入
                lpPassword = new TCHAR[nLen + 1];
                ZeroMemory(lpPassword, (nLen + 1) * sizeof(TCHAR));
                lpPassword[0] = nLen + 1;
                SendMessage(hwndPassword, EM_GETLINE, 0, (LPARAM)lpPassword);
                //进行一个信息输出，年龄直接用更上层的函数也行，底层也是走SendMessage...再string=> int
                wsprintf(szBuf, TEXT("用户名：%s\n密  码：%s\n年  龄：%d"),
                    lpUserName, lpPassword,
                    GetDlgItemInt(hwnd, 1002, NULL, FALSE));
                MessageBox(hwnd, szBuf, TEXT("注册信息"), MB_OK);
                delete[] lpUserName;
                delete[] lpPassword;
            }
        }
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

“会员注册"“用户名""密码"和“年龄"这些文本用的都是Static类静态控件。静态控件后面再讲。因为用不到这些静态控件的ID，所以静态控件的ID我都设置为-1。至于静态控件、编辑控件和按钮控件摆放的位置，读者可以自己设计，这不是重点。在WM_CREATE消息中，创建所有控件以后，发送WM_SETFONT消息设置所有控件的字体;发送EM_SETLIMITTEXT消息设置用户名，且分别限制密码、年龄3个编辑控件输入20 12 3个字符。调用`AdjustWindowRectEx`函数设置程序窗口大小。
在`WM_COMMAND`消息中，要获取用户名和密码字符串，首先发`EM_LINELENGTH`消息确定字符串的长度，然后分配缓冲区，发送EM_GETLINE消息获取字符串，要获取年龄则直接调用`GetDlgItemInt`函数得到无符号数值型，然后通过`wsprintf`函数格式化。当然,使用`GetWindowText / GetDlgltemText或WM_GETTEXT`消息获取编辑控件的文本字符串也完全可以。



:::details WM_CTLCOLORSTATIC 消息

另外需要介绍的是`WM_CTLCOLORSTATIC`消息。默认情况下静态控件有一个灰色背景，而程序客户区的背景是白色，因此应该将静态控件的背景颜色设置为白色。在绘制静态控件以前，系统会发送WM_CTLCOLORSTATIC消息到静态控件的父窗口。该消息的wParam参数是静态控件窗口对应的DC句柄，IParam参数是静态控件的窗口句柄。程序可以调用SetTextColor函数设置文本颜色，调用SetBkColor函数设置文本的背景颜色等，最后返回一个画刷句柄，静态控件会使用这个画刷来擦除背景。本例对WM_CTLCOLORSTATIC消息的处理，仅仅是通过调用GetSysColorBrush函数返回一个白色画刷。



常用的类似消息如下表所示。



**消息类型针对的控件类型**

|          消息          |                          针对的控件                          |
| :--------------------: | :----------------------------------------------------------: |
|  `WM_CTLCOLORSTATIC`   | 静态控件和只读或禁用的编辑控件（正常状态的编辑控件不会收到该消息，而是收到WM_CTLCOLOREDIT消息) |
|   `WM_CTLCOLOREDIT`    |                    非只读或禁用的编辑控件                    |
|    `WM_CTLCOLORBTN`    |   自绘按钮(但是对于自绘按钮，通常处理的是WM_DRAWITEM消息)    |
|  `WM_CTLCOLORLISTBOX`  |                            列表框                            |
| `WM_CTLCOLORSCROLLBAR` |                          滚动条控件                          |
|    `WM_CTLCOLORDLG`    |                            对话框                            |

后面5个消息的wParam和lParam参数的含义和`WM_CTLCOLORSTATIC`消息完全相同

- wParam参数是控件对应的DC句柄，

- IParam参数是控件的窗口句柄。

  例如下面的代码

```c
    else if (uMsg == WM_CTLCOLOREDIT)
    {
        if ((HWND)lParam == hwndUserName)
        {
            //设置编辑框控件文本颜色为白色
            SetTextColor((HDC)wParam, RGB(255, 255, 255));

            //设置编辑框背景为黑色
            SetBkColor((HDC)wParam, RGB(0, 0, 0));
            HBRUSH hbrBkgnd = CreateSolidBrush(RGB(0, 0, 0));
            return (LRESULT)hbrBkgnd;
        }
    }
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%BE%91%E6%A1%86%E9%A2%9C%E8%89%B2-17060989253541.gif)





注意啊，`WM_CTLCOLOR***`消息中调用SetTextColor函数对于禁用编辑控件的设置文本颜色是无效的。

:::



## 列表框

列表框也是经常使用的子窗口控件，包含可供用户选择的项目列表，用户可以从中选择一个或多个项目。如果列表框不够大，显示不了所有列表项，则列表框可以显示一个滚动条。另外，每一个列表项都可以设置一个与之关联的32位数据，称为项目数据，可以设置为指向某些自定义数据的指针。普通的列表框效果如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240623225338787.png)





:::details 列表框控件常用样式



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240623225515764.png)



:::





:::details `WM_COMMAND 消息`

当列表框中发生事件时，系统会以`WM_COMMAND`消息的形式向父窗口发送通知码，常见的通知码如下所示：

|       宏        |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
| `LBN_SETFOCUS`  |                     列表框获取了键盘焦点                     |
| `LBN_KILLFOCUS` |                     列表框失去了键盘焦点                     |
| `LBN_SELCHANGE` | 列表框中的选择已更改，通常是在用户单击一个列表项的时候发生，用户按下方向键改变选择或键盘焦点的时候也会发送该通知码。如果是通过发送LB_SETSEL LB_SETCURSEL LB_SELECTSTRING LB_SELITEMRANGE或 LB_SELITEMRANGEEX消息更改了选择，则不会发送该通知码，即如果是程序代码更改了选中项，就不会收到LBN_SELCHANGE通知码 |
|  `LBN_DBLCLK`   |                   双击列表框中的某个列表项                   |
| `LBN_SELCANCEL` | 取消选中列表框中的某个列表项LBN_ERRSPACE列表框无法分配足够的内存来完成请求 |

:::





列表项的添加、删除、查询等都是通过发送消息来实现的。列表项的位置索引是从0开始的，列表框中第1个列表项的索引为0，第2个列表项的索引为1，以此类推。





:::details `列表框消息`

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240623230115556.png)



总结一下，调用`CreateWindow / CreateWindowEx`函数创建列表框控件后，列表框中还没有列表项，需要发送`LB_ADDSTRING/ LB_INSERTSTRING`消息添加列表项。要删除一个

列表项可以发送`LB_DELETESTRING`消息，要清空列表框可以发送`LB_RESETCONTENT`消息，要获取一个列表项的文本可以发送`LB_GETTEXTLEN` `LB_GETTEXT`消息，可以发送`LB_SETITEMDATA`消息为每个列表项设置一个关联的项目数据，要获取与列表项关联的项目数据可以发送`LB_GETITEMDATA`消息，要获取一个列表项的选中
状态可以发送`LB_GETSEL`消息，根据字符串查找一个列表项可以发送`LB_FINDSTRING/ LB_FINDSTRINGEXACT`消息，获取列表框中的列表项总数可以发送`LB_GETCOUNT`消息。









对于单选列表框∶可以发送`LB_SETCURSEL`或`LB_GETCURSEL`消息来设置或获取当前选中项。另外，`LB_SELECTSTRING`消息也是针对单选列表框的。





对于多选列表框∶要选中或取消选中一个列表项可以发送`LB_SETSEL`消息，要选中或取消选中一片连续的列表项可以发送`LB_SELITEMRANGE`消息，要获取所有选中项的索引可以发送`LB_GETSELCOUNT` `LB_GETSELITEMS`消息。



:::



:::details `拖动列表框`

拖动列表框允许用户将列表项从一个位置拖动到另一个位置，以改变排列顺序。拖动列表框仅用于单选列表框。如果想让一个列表框可以拖动，在创建列表框控件以后，则需要调用`MakeDragList(hwndListBox);`函数将其更改为拖动列表框。



调用`MakeDragList`函数时系统会定义拖动列表消息。当发生拖动事件时，系统会向拖动列表框的父窗口发送拖动列表消息，父窗口必须处理拖动列表消息。拖动列表消息的ID值是多少呢?拖动列表消息的具体值还没有确定，程序可以通过注册消息的方式获取这个值，



调用`RegisterWindowMessage (DRAGLISTMSGSTRING)`;函数会返回一`0xC000`～`0xFFFF`范围内的消息ID，该消息ID在整个系统中是唯一的。`DRAGLISTMSGSTRING`是一个常量，在CommCtrl.h头文件中定义如下∶

```c
#define DRAGLISTMSGSTRING TEXT("commctrl_DragListMsg")
```

有了**拖动列表消息ID**，就可以在窗口过程中处理该消息。例如下面的代码∶

```c
        static UINT WM_DRAGLIST;
        // 更改为拖动列表框
        MakeDragList(hwndListBox);
        WM_DRAGLIST = RegisterWindowMessage(DRAGLISTMSGSTRING);
```

**拖动列表消息**的wParam参数是拖动列表框的控件ID，IParam参数是一个指向DRAGLISTINFO结构的指针，其中包含拖动事件的通知码和其他信息，拖动列表消息的返回值取决于具体的通知码。



`DRAGLISTINFO`结构在CommCtrl.h头文件中定义如下︰

```c
typedef struct tagDRAGLISTINFO
{
UINT uNotification;//通知码，指示拖动事件的类型
HWND hWnd;	//拖动列表框的窗口句柄
POINT ptCursor;//拖动事件发生时鼠标光标的X和Y坐标
}DRAGLISTINFO，*LPDRAGLISTINFO;
```

- `uNotification`字段表示通知码，指示拖动事件的类型，该字段可以是下表项之一。

|       宏        |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
| `DL_BEGINDRAG`  |            用户在列表项上单击了鼠标左键，开始拖动            |
|  `DL_DRAGGING`  | 用户正在拖动列表项，在开始拖动后，只要移动鼠标就会发送DL_DRAGGING通知码 |
| `DL_CANCELDRAG` |         用户通过单击鼠标右键或按Esc键取消了拖动操作          |
|  `DL_DROPPED`   |               用户已释放鼠标左键，拖动操作完成               |

:::



当用户单击一个列表项时，将发送包含`DL_BEGINDRAG`通知码的拖动列表消息，可以通过调用`LBItemFromPt`函数来确定光标下的列表项索引，保存该列表项索引，在拖动操作完成后需要移动该列表项，然后返回TRUE表示开始拖动操作，或返回FALSE表示禁止拖动。



:::details `LBItemFromPt 函数说明`

```c
/// <summary>
/// 确定列表框控件在光标下时的列表项索引
/// </summary>
/// <param name="hLB">列表框控件句柄</param>
/// <param name="pt">点坐标，使用((LPDRAGLISTINFO)lParam)->ptCursor字段</param>
/// <param name="bAutoScroll">是否自动滚动</param>
/// <returns></returns>
int LBItemFromPt(HWND hLB,POINT pt,BOOL bAutoScroll); 
```

::: 



开始拖动以后，只要移动鼠标就会发送`DL_DRAGGING`通知码，可以通过调用`LBltemFromPt`函数来确定光标下的列表项索引，然后可以调用`DrawInsert`函数在光标下列表项的左上方绘制插入图标。处理完该通知码以后的返回值指定了鼠标光标的类型，返回值可以是`DL_STOPCURSOR` ` DL_COPYCURSOR`或`DL_MOVECURSOR`





:::details `DrawInsert 函数说明`

```c
/// <summary>
/// 用于在拖动列表框的父窗口中绘制插入图标∶
/// </summary>
/// <param name="handParent">拖动列表框的父窗口句柄</param>
/// <param name="hLB">拖动列表框的句柄</param>
/// <param name="nltem">在哪个位置显示插入图标，在DL_DRAGGING通知码中可以设置为光标下的列表项索引</param>
void DrawInsert(HWND handParent,HWND hLB, int nItem); 
```

:::



如果用户通过单击鼠标右键或按Esc键取消了拖动操作，则会发送`DL_CANCELDRAG`通知码，程序通常不需要处理该通知码。如果用户通过释放鼠标左键完成了拖动操作，则会发送`DL_DROPPED`通知码，可以通过调用`LBltemFromPt`函数来确定光标下的列表项索引，然后把被拖动的列表项移动到光标下列表项的前面。系统会忽略`DL_CANCELDRAG`和`DL_DROPPED`通知码的返回值，通常可以返回0。





接下来实现一个例子，`ListBoxDemo`程序运行效果如下图所示。

:::details `ListBoxDemo`

```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("ListBoxDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU |
        WS_MINIMIZEBOX, CW_USEDEFAULT, CW_USEDEFAULT, 256, 280, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndListBox, hwndEditText, hwndEditData, hwndAdd, hwndModify, hwndDelete;
    HWND hwndStaticText, hwndStaticData;
    static HFONT hFont;
    static UINT WM_DRAGLIST;
    TCHAR szBuf[64] = { 0 };
    int nIndex, nCount;
    DWORD dwData;
    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        // 列表框控件
        hwndListBox = CreateWindowEx(0, TEXT("ListBox"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | WS_VSCROLL | LBS_NOTIFY,
            20, 20, 200, 116, hwnd, (HMENU)IDC_LISTBOX, hInstance, NULL);

        // 静态控件和编辑框控件，文本：文本编辑框，项目数据：项目数据编辑框
        hwndStaticText = CreateWindowEx(0, TEXT("Static"), TEXT("文本："),
            WS_CHILD | WS_VISIBLE, 20, 144, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndEditText = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL,
            80, 140, 140, 22, hwnd, (HMENU)IDC_EDITTEXT, hInstance, NULL);
        hwndStaticData = CreateWindowEx(0, TEXT("Static"), TEXT("项目数据："),
            WS_CHILD | WS_VISIBLE, 20, 169, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndEditData = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_NUMBER,
            80, 165, 140, 22, hwnd, (HMENU)IDC_EDITDATA, hInstance, NULL);

        // 三个按钮，添加、修改、删除
        hwndAdd = CreateWindowEx(0, TEXT("Button"), TEXT("添加"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_NOTIFY,
            20, 200, 60, 25, hwnd, (HMENU)IDC_BTNADD, hInstance, NULL);
        hwndModify = CreateWindowEx(0, TEXT("Button"), TEXT("修改"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_NOTIFY,
            90, 200, 60, 25, hwnd, (HMENU)IDC_BTNMODIFY, hInstance, NULL);
        hwndDelete = CreateWindowEx(0, TEXT("Button"), TEXT("删除"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_NOTIFY,
            160, 200, 60, 25, hwnd, (HMENU)IDC_BTNDELETE, hInstance, NULL);

        // 更改为拖动列表框
        MakeDragList(hwndListBox);
        WM_DRAGLIST = RegisterWindowMessage(DRAGLISTMSGSTRING);

        // 添加一些列表项
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("汇编语言"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("C语言面向过程"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("C++面向对象"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("Windows程序设计"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("Ollydbg调试工具"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("X64Dbg调试工具"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("IDA静态调试"));
        SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)TEXT("PE Explorer"));
        // 设置项目数据，具体编程中可以根据需要添加所需的项目数据，例如某些自定义数据的指针
        for (int i = 0; i < 8; i++)
            SendMessage(hwndListBox, LB_SETITEMDATA, i, 10000 + i);

        // 限制列表项文本最多可以输入20个字符，项目数据最多可以输入10个数字字符
        SendMessage(hwndEditText, EM_SETLIMITTEXT, 20, 0);
        SendMessage(hwndEditData, EM_SETLIMITTEXT, 10, 0);

        // 设置字体
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("微软雅黑"));
        SendMessage(hwndListBox, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndStaticText, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndStaticData, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndEditText, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndEditData, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndAdd, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndModify, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndDelete, WM_SETFONT, (WPARAM)hFont, FALSE);

        // 禁用添加、修改、删除按钮
        EnableWindow(hwndAdd, FALSE);
        EnableWindow(hwndModify, FALSE);
        EnableWindow(hwndDelete, FALSE);
        return 0;

    case WM_CTLCOLORSTATIC:
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
            // 添加
            if (LOWORD(wParam) == IDC_BTNADD)
            {
                nCount = GetDlgItemText(hwnd, IDC_EDITTEXT, szBuf, _countof(szBuf));
                if (nCount > 0)
                {
                    nIndex = SendMessage(hwndListBox, LB_ADDSTRING, 0, (LPARAM)szBuf);
                    if (nIndex >= 0)
                    {
                        dwData = GetDlgItemInt(hwnd, IDC_EDITDATA, NULL, TRUE);
                        SendMessage(hwndListBox, LB_SETITEMDATA, nIndex, dwData);
                        SendMessage(hwndListBox, LB_SETCURSEL, nIndex, 0);
                        EnableWindow(hwndModify, TRUE);
                        EnableWindow(hwndDelete, TRUE);
                    }
                }
            }
            // 修改
            else if (LOWORD(wParam) == IDC_BTNMODIFY)
            {
                nIndex = SendMessage(hwndListBox, LB_GETCURSEL, 0, 0);
                nCount = GetDlgItemText(hwnd, IDC_EDITTEXT, szBuf, _countof(szBuf));
                if (nIndex >= 0 && nCount > 0)
                {
                    SendMessage(hwndListBox, LB_DELETESTRING, nIndex, 0);
                    SendMessage(hwndListBox, LB_INSERTSTRING, nIndex, (LPARAM)szBuf);
                    dwData = GetDlgItemInt(hwnd, IDC_EDITDATA, NULL, TRUE);
                    SendMessage(hwndListBox, LB_SETITEMDATA, nIndex, dwData);
                    SendMessage(hwndListBox, LB_SETCURSEL, nIndex, 0);
                }
            }
            // 删除
            else if (LOWORD(wParam) == IDC_BTNDELETE)
            {
                nIndex = SendMessage(hwndListBox, LB_GETCURSEL, 0, 0);
                if (nIndex >= 0)
                {
                    SendMessage(hwndListBox, LB_DELETESTRING, nIndex, 0);
                    nCount = SendMessage(hwndListBox, LB_GETCOUNT, 0, 0);
                    if (nCount > 0)
                    {
                        if (nIndex < nCount)
                            SendMessage(hwndListBox, LB_SETCURSEL, nIndex, 0);
                        else
                            SendMessage(hwndListBox, LB_SETCURSEL, nIndex - 1, 0);
                    }
                    else
                    {
                        EnableWindow(hwndModify, FALSE);
                        EnableWindow(hwndDelete, FALSE);
                    }
                }
            }
            break;
        // 列表框中的选择已更改
        case LBN_SELCHANGE:
            if (LOWORD(wParam) == IDC_LISTBOX)
            {
                // 获取列表项文本和项目数据，显示到编辑框中
                nIndex = SendMessage(hwndListBox, LB_GETCURSEL, 0, 0);
                SendMessage(hwndListBox, LB_GETTEXT, nIndex, (LPARAM)szBuf);
                SetDlgItemText(hwnd, IDC_EDITTEXT, szBuf);
                dwData = SendMessage(hwndListBox, LB_GETITEMDATA, nIndex, 0);
                SetDlgItemInt(hwnd, IDC_EDITDATA, dwData, TRUE);

                // 启用修改、删除按钮
                EnableWindow(hwndModify, TRUE);
                EnableWindow(hwndDelete, TRUE);
            }
            break;

        // 编辑控件的内容已变化
        case EN_UPDATE:
            // 项目数据编辑框不需要检查有无内容，如果没有内容就是0
            if (LOWORD(wParam) == IDC_EDITTEXT)
            {
                nCount = GetDlgItemText(hwnd, IDC_EDITTEXT, szBuf, _countof(szBuf));
                if (nCount > 0)
                {
                    // 添加按钮
                    EnableWindow(hwndAdd, TRUE);
                    // 修改按钮
                    nIndex = SendMessage(hwndListBox, LB_GETCURSEL, 0, 0);
                    if (nIndex >= 0)
                        EnableWindow(hwndModify, TRUE);
                }
                else
                {
                    // 添加按钮
                    EnableWindow(hwndAdd, FALSE);
                    // 修改按钮
                    EnableWindow(hwndModify, FALSE);
                }
            }
            break;
        }
        return 0;

    case WM_DESTROY:
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }

    if (uMsg == WM_DRAGLIST)
    {
        LPDRAGLISTINFO pDragInfo = (LPDRAGLISTINFO)lParam;
        static int nIndexDrag;
        switch (pDragInfo->uNotification)
        {
        case DL_BEGINDRAG:
            nIndexDrag = LBItemFromPt(hwndListBox, pDragInfo->ptCursor, FALSE);
            return TRUE;

        case DL_DRAGGING:
            nIndex = LBItemFromPt(hwndListBox, pDragInfo->ptCursor, TRUE);
            if (nIndex >= 0)
                DrawInsert(hwnd, hwndListBox, nIndex);
            return DL_MOVECURSOR;

        case DL_DROPPED:
            nIndex = LBItemFromPt(hwndListBox, pDragInfo->ptCursor, FALSE);
            if (nIndex >= 0 && nIndex != nIndexDrag)
            {
                SendMessage(hwndListBox, LB_GETTEXT, nIndexDrag, (LPARAM)szBuf);
                dwData = SendMessage(hwndListBox, LB_GETITEMDATA, nIndexDrag, 0);
                if (nIndexDrag > nIndex)
                {
                    // 先删除再插入
                    SendMessage(hwndListBox, LB_DELETESTRING, nIndexDrag, 0);
                    SendMessage(hwndListBox, LB_INSERTSTRING, nIndex, (LPARAM)szBuf);
                    SendMessage(hwndListBox, LB_SETITEMDATA, nIndex, dwData);
                    SendMessage(hwndListBox, LB_SETCURSEL, nIndex, 0);
                }
                else
                {
                    // 先插入再删除
                    SendMessage(hwndListBox, LB_INSERTSTRING, nIndex, (LPARAM)szBuf);
                    SendMessage(hwndListBox, LB_SETITEMDATA, nIndex, dwData);
                    SendMessage(hwndListBox, LB_SETCURSEL, nIndex, 0);
                    SendMessage(hwndListBox, LB_DELETESTRING, nIndexDrag, 0);
                }
            }
            // 隐藏插入图标
            DrawInsert(hwnd, hwndListBox, -1);
            nIndexDrag = -1;
            return 0;
        }
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624220432615.png)



在`WinMain`函数中调用`CreateWindowEx`的时候，没有指定
`WS_THICKFRAME`和`WS_MAXIMIZEBOX`样式，因此程序窗口不可调整大小，而且最大化按钮失效。程序的列表框是一个拖动列表框，用户可以随意拖动列表项的位置。





在`WM_CREATE`消息中，创建了列表框控件、两个静态控件、两个编辑框控件和3个按钮，项目数据编辑框使用了`ES_NUMBER`样式，用户只能输入数字。初始情况下，3个按钮是禁用的。在`WM_COMMAND`消息中，程序处理了`BN_CLICKED` `LBN_SELCHANGE`和`EN_UPDATE`通知码，分别对应着用户单击3个按钮、列表框中的选择已更改和编辑控件的内容已变化。



`switch (uMsg)`中包含case消息ID。因为case后面需要的是一个常量，所以对于`WM_DRAGLIST`消息的处理单独用了一个if判断，然后在if语句中分别处理`DL_BEGINDRAG` `DL_DRAGGING`和`DL_DROPPED`通知码。

:::



研究一下`LB_DIR`和`LB_ADDFILE`消息。要了解这两个消息，不妨先看一下`DlgDirList`函数。`DlgDirList`函数把指定目录中指定属性的子目录和文件的名称显示到列表框中。





:::details `DlgDirList 函数说明`

```c
/// <summary>
/// 把指定目录中指定属性的子目录和文件的名称显示到列表框中
/// </summary>
/// <param name="hDlg">列表框的父窗口句柄</param>
/// <param name="IpPathSpec">目录名称和文件名的组合，可以是绝对路径或相对路径</param>
/// <param name="nlDListBox">列表框控件ID</param>
/// <param name="nIlDStaticPath">静态控件ID，用于显示当前当前驱动器和目录，可以设置为0</param>
/// <param name="uFileType">指定文件或目录的属性</param>
/// <returns></returns>
int DlgDirList(HWND hDlg,LPTSTR IpPathSpec, int nlDListBox, int nIlDStaticPath,UINT uFileType); 
```

- 参数`lpPathSpec`是包含目录名称和文件名的字符串缓冲区指针，可以是绝对路径或相对路径，例如`"C:\" "C:\Windows\*.*”或"*.*”`。该函数将字符串拆分为目录和文件名，然后在目录中搜索与文件名匹配的文件名称。

  - 如果字符串未指定目录，则在当前目录中搜索。

  - 如果字符串包含文件名，则文件名必须至少包含一个通配符`(?或*)`;如果字符串不包含文件名，则把文件名指定为通配符*。将指定目录中与文件名匹配并且具有`uFileType`参数指定的属性的所有文件名称都添加到列表框中。

- 参数`uFileType`指定文件或目录的属性`，lpPathSpec`目录中具有该属性的文件或目录的名称会被添加到列表框中。该参数可以是下表所示的一个或多个值。




|       宏        |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
| `DDL_READWRITE` |                  可读可写文件，这是默认设置                  |
|  `DDL_ARCHIVE`  |                           存档文件                           |
|  `DDL_HIDDEN`   |                           隐藏文件                           |
| `DDL_READONLY`  |                           只读文件                           |
|  `DDL_SYSTEM`   |                           系统文件                           |
| `DDL_DIRECTORY` | 包括子目录，指定目录中的子目录名称都会显示到列表框中，子目录名称显示为`[子目录名称]` |
|  `DDL_DRIVES`   | 所有映射的驱动器都显示到列表框中，显示为`[-x-]`，其中x是驱动器号 |
| `DDL_EXCLUSIVE` | 仅包含具有指定属性的文件。默认情况下，即使未指定`DDL_READWRITE`，也会列出可读可写文件 |
| `DDL_POSTMSGS`  | 如果设置了该标志，则`DlgDirList`函数使用`PostMessage`函数将消息发送到列表框。如果未设置，则使用`SendMessage`函数 |

:::





:::details `DlgDirSelectEx`



```c
/// <summary>
/// 获取由DlgDirList函数填充的列表框中当前选定的列表项的文本内容
/// </summary>
/// <param name="hDlg">列表框的父窗口句柄</param>
/// <param name="IpString">接收所选列表项文本内容的缓冲区指针</param>
/// <param name="nCount">缓冲区的长度，以字符为单位</param>
/// <param name="nIDListBox">列表框控件ID</param>
/// <returns></returns>
BOOL DlgDirSelectEx(HWND hDlg,LPTSTR IpString, int nCount,int nIDListBox); 
```

:::







:::details `DlgDirList 示例:`

```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("DirList");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HFONT hFont;
    static HWND hwndStaticPath, hwndListBox, hwndEdit;
    TCHAR szPath[] = TEXT("*.*");
    TCHAR szStr[MAX_PATH] = { 0 };  // 存放选中列表项的文本
    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        hwndStaticPath = CreateWindowEx(0, TEXT("Static"), TEXT(""),
            WS_CHILD | WS_VISIBLE, 10, 0, 380, 20, hwnd, (HMENU)IDC_STATICPATH, hInstance, NULL);
        hwndListBox = CreateWindowEx(0, TEXT("ListBox"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | WS_VSCROLL | LBS_NOTIFY,
            10, 25, 200, 240, hwnd, (HMENU)IDC_LISTBOX, hInstance, NULL);
        hwndEdit = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | WS_HSCROLL | WS_VSCROLL | 
            ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE,
            0, 0, 0, 0, hwnd, (HMENU)IDC_EDIT, hInstance, NULL);

        // 列出目录列表
        DlgDirList(hwnd, szPath, IDC_LISTBOX, IDC_STATICPATH, 
            DDL_ARCHIVE | DDL_READONLY | DDL_SYSTEM | DDL_DIRECTORY | DDL_DRIVES);

        // 设置控件字体
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("微软雅黑"));
        SendMessage(hwndStaticPath, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndListBox, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndEdit, WM_SETFONT, (WPARAM)hFont, FALSE);
        return 0;
    case WM_SIZE:
        // 调整列表框和多行编辑控件的大小
        SetWindowPos(hwndListBox, NULL, 0, 0, 200, HIWORD(lParam) - 25, SWP_NOZORDER | SWP_NOMOVE);
        MoveWindow(hwndEdit, 220, 25, LOWORD(lParam) - 220, HIWORD(lParam) - 25, FALSE);
        return 0;
    case WM_COMMAND:
        if (HIWORD(wParam) == LBN_DBLCLK && LOWORD(wParam) == IDC_LISTBOX)
        {
            BOOL bRet;
            HANDLE hFile;
            BYTE byBuf[8192] = { 0 };   // 最多读取8K字节文本
            DWORD dwBytesReaded;        // 实际读取字节数

            // 当前选定的列表项的文本内容，如果当前选择是目录名称，则返回值为TRUE，否则FALSE
            bRet = DlgDirSelectEx(hwnd, szStr, MAX_PATH, IDC_LISTBOX);
            if (bRet)
            {
                // 当前选择是目录名称
                DlgDirList(hwnd, szStr, IDC_LISTBOX, IDC_STATICPATH,
                    DDL_ARCHIVE | DDL_READONLY | DDL_SYSTEM | DDL_DIRECTORY | DDL_DRIVES);
            } 
            else
            {
                // 当前选择是文件
                hFile = CreateFile(szStr, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
                ReadFile(hFile, byBuf, _countof(byBuf) - 2, &dwBytesReaded, NULL);
                // 简单的判断是否是Unicode格式文本
                if (IsTextUnicode(byBuf, dwBytesReaded, 0))
                    SetDlgItemTextW(hwnd, IDC_EDIT, (LPWSTR)byBuf);
                else
                    SetDlgItemTextA(hwnd, IDC_EDIT, (LPSTR)byBuf);
            }
        }
        return 0;
    case WM_CTLCOLORSTATIC:
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);
    case WM_DESTROY:
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624222806339.png)

:::

## 组合框

组合框是编辑控件和列表框组合起来的一种子窗口控件，结合了编辑控件和单选列表框的大部分功能，其用法和编辑控件、列表框类似。编辑控件部分用于显示当前选择的列表项，列表框部分列出了用户可以选择的列表项。有3种样式的组合框，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624222933074.png)



在组合框的列表框中没有选中项的情况下，组合框的编辑控件中不会显示任何内容，但是可以在编辑控件中设置一个提示文本，以提示用户进行选择，如下图所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624223032365.png)



:::details `组合框样式`

|           宏            |                             含义                             |
| :---------------------: | :----------------------------------------------------------: |
|      `CBS_SIMPLE`       | 始终显示列表框（前提是组合框必须具有一定高度，高度至少可以容纳编辑控件和一行列表项)，列表框中的当前选中项会显示到编辑控件中，用户也可以在编辑控件中自行输入内容。 |
|     `CBS_DROPDOWN`      | 列表框部分平时是收起的，用户可以通过单击右侧的下拉箭头来展开列表框以选择列表项。选中的列表项会显示到编辑控件中，在编辑控件中用户也可以自行输入内容 |
|   `CBS_DROPDOWNLIST`    | `CBS_DROPDOWNLIST`与`CBS_DROPDOWN`类似，不同之处在于编辑控件部分被静态文本项替换，列表框部分平时也是收起的，用户可以通过单击组合框来展开列表框以选择列表项。选中的列表项会显示到静态文本项中，用户无法在静态文本项中输入内容，只能选择列表框中的列表项。 |
|    `CBS_AUTOHSCROLL`    | 当用户输入文本时，如果文本字数填满了编辑控件，则无法继续输入。在指定该样式后，在必要时编辑控件会自动水平滚动，这样一来用户输入的文本字数就不受编辑控件的长度影响 |
|  `CBS_DISABLENOSCROLL`  | 该样式通常与`WS_vSCROLL`样式一起使用。在指定该样式后，如果列表框中的列表项比较少，则不需要使用滚动条，但还是会显示禁用的垂直滚动条。如果未指定该样式，则不需要使用滚动条时会隐藏滚动条 |
|       `CBS_SORT`        |             按字母顺序对列表框中的列表项进行排序             |
|    `CBS_HASSTRINGS`     |                    默认样式(除自绘组合框)                    |
|  `CBS_OWNERDRAWFIXED`   |          自绘列表框，列表框中的列表项具有相同的高度          |
| `CBS_OWNERDRAWVARIABLE` |             自绘列表框，列表框中的列表项高度可变             |

> 除了上面这些组合框样式，通常还需要指定窗口样式`WS_CHILD | WS_VISIBLE | WS_VSCROLL`



:::



:::details `组合框消息`

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624223647408.png)



对于`CBS_SIMPLE`和`CBS_DROPDOWN`样式的组合框，用户如果在编辑控件中自行输入了内容，那么列表框中的选中项就会自动取消选中，这时获取编辑控件中的文本可以使用
`GetWindowText/GetDlgltemText`函数。



如果没有自行输入内容，既可以使用`GetWindowText/GetDlgltemText`函数，也可以发送`CB_GETLBTEXT`消息。因此对于`CBS_SIMPLE`和`CBS_DROPDOWN`样式的组合框，最好还是使用`GetWindowText/GetDlgltemText`函数获取编辑控件中的文本。



对于`CBS_DROPDOWNLIST`样式的组合框，不存在用户自行输入内容，因此要获取编辑控件中的文本，既可以使用`GetWindowText / GetDlgltemText`函数，也可以发送`CB_GETLBTEXT`消息。



通常可以发送`CB_SETCUEBANNER`消息为组合框设置一个提示文本，提示文本不属于编辑控件的真正内容，即调用`GetWindowText / GetDlgltemText`函数无法获取显示在编辑控件中的提示文本内容，函数返回的字符个数始终为0。



如果组合框的列表框中存在比较长的列表项，可以通过发送`CB_SETDROPPEDWIDTH`消息为具有`CBS_DROPDOWN`或`CBS_DROPDOWNLIST`样式的组合框的列表框设置一个最小宽度。如果需要，可以通过发送`CB_SETITEMDATA`消息为组合框中列表框的每个列表项设置一个项目数据。

:::





:::details `组合框的通知码`

当组合框中发生事件时，系统会以`WM_COMMAND`消息的形式向父窗口发送通知码。常见的通知码如表所示。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624224557358.png)

:::





## 滚动条控件



前面我们学过在调用`CreateWindowEx`函数创建重叠窗口或弹出窗口时，可以指定`WS_HSCROLL`或`WS_VSCROLL`窗口样式创建一个标准水平或垂直滚动条`ScrollBar`。

标准滚动条显示在客户区的底部或右侧，当程序窗口的输出的内容比较多导致无法在一个客户区范围内显示时，可以滚动标准滚动条以显示超出客户区范围的内容。

标准滚动条在非客户区，属于程序窗口的一部分，因此没有自己的窗口句柄。



除了标准滚动条，还可以通过指定窗口类名`ScrollBar`调用`CreateWindowEx`函数创建一个水平或垂直滚动条控件。







:::details `滚动条控件消息`

滚动条控件可以以任何大小显示在客户区的任何地方，同样需要处理`WM_HSCROLL`或
`WM_VSCROLL`消息，这两个消息的`LOWORD(wParam)`表示用户的滚动请求，如果`LOWORD(wParam)`是SB_THUMBPOSITION或SB_THUMBTRACK，那么

`HIWORD(wParam)`表示滑块的当前位置，在其他情况下HIWORD(wParam)无意义。





如果消息是由滚动条控件发送的，则lParam参数是滚动条控件的句柄;

如果消息是由标准滚动条发送的，则IParam参数为NULL。

通过lParam参数可以区分消息是标准滚动条还是滚动条控件发送的。

:::





滚动条控件内置键盘接不需要像标准滚动条那样处理`WM_KEYDOWN`消息。当用户按上下
左右方向键、PgUp键、PgDn键、Home键、End键时，系统会发送包含相应滚动请求的WM_HSCROLL或WM_VSCROLL消息。滚动条控件的样式很简单，通常就是指定SBS_HORZ或SBS_VERT样式，分别表示创建一个水平或垂直滚动条控件。





标准滚动条的默认范围`0-100`   滚动条控件的默认范围为空。可以通过调用`SetScrollRange`函数把范围改成对程序有意义的值。



通过调用`SetScrollPos`函数设置滑块在滚动条中的位置。



也可以通过调用`SetScrolllnfo`函数设置滚动条的最小和最大滚动范围、页面大小以及滑块位置。





:::details `滚动条控件示例:`

```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("取色调色器V1.0");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_PANDA));;
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | 
        WS_MINIMIZEBOX, CW_USEDEFAULT, CW_USEDEFAULT, 360, 220, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndBtnStart, hwndBtnStop;  // 开始、停止按钮
    static HWND hwndSBHorz[3];              // 3个水平滚动条
    static HWND hwndStaticColor[3];         // 3个静态控件用于实时显示红、绿、蓝颜色值
    static HWND hwndStatic[3];              // 3个静态控件：网页颜色、RGB颜色、点击开始按钮开始取色
    static HWND hwndEdit[2];                // 2个编辑控件：网页颜色、RGB颜色
    static HFONT hFont;

    COLORREF crPrim[3] = { RGB(255, 0, 0), RGB(0, 255, 0), RGB(0, 0, 255) };
    static HBRUSH  hBrush[3];
    static int color[3];                    // 红、绿、蓝颜色值
    static RECT rcColor;                    // 显示颜色结果的小矩形
    HDC hdc;
    PAINTSTRUCT ps;
    int n;
    TCHAR szBuf[24] = { 0 };

    static HDC hdcDesk, hdcMem;
    static HBITMAP hBitmapMem;
    static BOOL bStarting;                  // 开始取色
    POINT pt;                               // 鼠标光标位置
    COLORREF crPixel;                       // 鼠标光标位置处的COLORREF颜色值
    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        // 开始、停止按钮
        hwndBtnStart = CreateWindowEx(0, TEXT("Button"), TEXT("开始"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            10, 130, 50, 22, hwnd, (HMENU)IDC_BTNSTART, hInstance, NULL);
        hwndBtnStop = CreateWindowEx(0, TEXT("Button"), TEXT("停止"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            70, 130, 50, 22, hwnd, (HMENU)IDC_BTNSTOP, hInstance, NULL);

        // 3个水平滚动条
        hwndSBHorz[0] = CreateWindowEx(0, TEXT("ScrollBar"),
            NULL, WS_CHILD | WS_VISIBLE | SBS_HORZ,
            130, 0, 200, 17, hwnd, (HMENU)IDC_SBHORZ1, hInstance, NULL);
        hwndSBHorz[1] = CreateWindowEx(0, TEXT("ScrollBar"),
            NULL, WS_CHILD | WS_VISIBLE | SBS_HORZ,
            130, 20, 200, 17, hwnd, (HMENU)IDC_SBHORZ2, hInstance, NULL);
        hwndSBHorz[2] = CreateWindowEx(0, TEXT("ScrollBar"),
            NULL, WS_CHILD | WS_VISIBLE | SBS_HORZ,
            130, 40, 200, 17, hwnd, (HMENU)IDC_SBHORZ3, hInstance, NULL);

        // 3个静态控件用于实时显示红、绿、蓝颜色值
        hwndStaticColor[0] = CreateWindowEx(0, TEXT("Static"), TEXT("红：0"),
            WS_CHILD | WS_VISIBLE | SS_CENTER,
            130, 60, 60, 20, hwnd, (HMENU)IDC_STATICCOLOR1, hInstance, NULL);
        hwndStaticColor[1] = CreateWindowEx(0, TEXT("Static"), TEXT("绿：0"),
            WS_CHILD | WS_VISIBLE | SS_CENTER,
            200, 60, 60, 20, hwnd, (HMENU)IDC_STATICCOLOR2, hInstance, NULL);
        hwndStaticColor[2] = CreateWindowEx(0, TEXT("Static"), TEXT("蓝：0"),
            WS_CHILD | WS_VISIBLE | SS_CENTER,
            270, 60, 60, 20, hwnd, (HMENU)IDC_STATICCOLOR3, hInstance, NULL);

        // 2个静态控件，网页颜色和RGB颜色，以及2个编辑控件
        hwndStatic[0] = CreateWindowEx(0, TEXT("Static"), TEXT("网页颜色："),
            WS_CHILD | WS_VISIBLE,
            130, 85, 70, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndStatic[1] = CreateWindowEx(0, TEXT("Static"), TEXT("RGB颜色："),
            WS_CHILD | WS_VISIBLE,
            130, 110, 70, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndEdit[0] = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_NOHIDESEL,
            200, 85, 130, 22, hwnd, (HMENU)IDC_EDITWEB, hInstance, NULL);
        hwndEdit[1] = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_NOHIDESEL,
            200, 110, 130, 22, hwnd, (HMENU)IDC_EDITRGB, hInstance, NULL);
        // 静态控件：点击开始按钮开始取色
        hwndStatic[2] = CreateWindowEx(0, TEXT("Static"), TEXT("点击开始按钮开始取色"),
            WS_CHILD | WS_VISIBLE | SS_CENTER,
            180, 145, 150, 20, hwnd, (HMENU)(-1), hInstance, NULL);

        // 设置字体
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("微软雅黑"));
        SendMessage(hwndBtnStart, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndBtnStop, WM_SETFONT, (WPARAM)hFont, FALSE);
        for (int i = 0; i < _countof(hwndStaticColor); i++)
            SendMessage(hwndStaticColor[i], WM_SETFONT, (WPARAM)hFont, FALSE);
        for (int i = 0; i < _countof(hwndStatic); i++)
            SendMessage(hwndStatic[i], WM_SETFONT, (WPARAM)hFont, FALSE);
        for (int i = 0; i < _countof(hwndEdit); i++)
            SendMessage(hwndEdit[i], WM_SETFONT, (WPARAM)hFont, FALSE);

        // 初始化网页颜色、RGB颜色编辑框的内容
        wsprintf(szBuf, TEXT("#%0.2X%0.2X%0.2X"), color[0], color[1], color[2]);
        SetDlgItemText(hwnd, IDC_EDITWEB, szBuf);
        wsprintf(szBuf, TEXT("RGB(%d, %d, %d)"), color[0], color[1], color[2]);
        SetDlgItemText(hwnd, IDC_EDITRGB, szBuf);

        // 创建红绿蓝3个画刷，用于水平滚动条背景和3个实时显示红绿蓝颜色值静态控件的文本颜色
        for (int i = 0; i < _countof(hBrush); i++)
            hBrush[i] = CreateSolidBrush(crPrim[i]);

        // 设置水平滚动条的范围和初始位置
        for (int i = 0; i < _countof(hwndSBHorz); i++)
        {
            SetScrollRange(hwndSBHorz[i], SB_CTL, 0, 255, FALSE);
            SetScrollPos(hwndSBHorz[i], SB_CTL, 0, FALSE);
        }

        // 显示颜色结果的那个小矩形的坐标，调用InvalidateRect函数宣布该区域无效的时候会用到
        SetRect(&rcColor, 130, 135, 170, 175);

        // 桌面设备环境句柄，内存设备环境句柄
        hdcDesk = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
        hdcMem = CreateCompatibleDC(hdcDesk);
        hBitmapMem = CreateCompatibleBitmap(hdcDesk, 120, 120);
        SelectObject(hdcMem, hBitmapMem);

        // 在系统菜单中添加一个关于本程序菜单项
        AppendMenu(GetSystemMenu(hwnd, FALSE), MF_STRING, IDM_ABOUT, TEXT("关于本程序"));

        // 为开始按钮设置键盘焦点
        SetFocus(hwndBtnStart);
        return 0;

    case WM_CTLCOLORSCROLLBAR:
        n = GetWindowLongPtr((HWND)lParam, GWLP_ID) - IDC_SBHORZ1;
        return (LRESULT)hBrush[n];

    case WM_CTLCOLORSTATIC:
        n = GetWindowLongPtr((HWND)lParam, GWLP_ID) - IDC_STATICCOLOR1;
        if (n >= 0 && n <= 2)
            SetTextColor((HDC)wParam, crPrim[n]);
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);

    case WM_HSCROLL:
        n = GetWindowLongPtr((HWND)lParam, GWLP_ID) - IDC_SBHORZ1;
        SetFocus((HWND)lParam);    // 设置键盘焦点以后才可以使用键盘
        switch (LOWORD(wParam))
        {
        case SB_LINELEFT:
            color[n] -= 1;
            break;
        case SB_LINERIGHT:
            color[n] += 1;
            break;
        case SB_PAGELEFT:
            color[n] -= 10;
            break;
        case SB_PAGERIGHT:
            color[n] += 10;
            break;
        case SB_THUMBTRACK:
            color[n] = HIWORD(wParam);
            break;
        case SB_LEFT:
            color[n] = 0;
            break;
        case SB_RIGHT:
            color[n] = 255;
            break;
        }
        color[n] = min(color[n], 255);
        color[n] = max(0, color[n]);
        if (color[n] != GetScrollPos((HWND)lParam, SB_CTL))
        {
            SetScrollPos((HWND)lParam, SB_CTL, color[n], TRUE);
            // 实时显示颜色值的静态控件
            SetDlgItemInt(hwnd, IDC_STATICCOLOR1 + n, color[n], FALSE);
            // 网页颜色、RGB颜色编辑控件
            wsprintf(szBuf, TEXT("#%0.2X%0.2X%0.2X"), color[0], color[1], color[2]);
            SetDlgItemText(hwnd, IDC_EDITWEB, szBuf);
            wsprintf(szBuf, TEXT("RGB(%d, %d, %d)"), color[0], color[1], color[2]);
            SetDlgItemText(hwnd, IDC_EDITRGB, szBuf);
            // 重绘颜色结果小矩形
            InvalidateRect(hwnd, &rcColor, FALSE);
        }
        return 0;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
            if (LOWORD(wParam) == IDC_BTNSTART)
            {
                bStarting = TRUE;
                SetFocus(hwndBtnStop);
                SetTimer(hwnd, 1, 100, NULL);
                SetTimer(hwnd, 2, 1000, NULL);
                SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
                // 把停止按钮改为默认按钮样式，没什么意义，仅仅是提供一种视觉效果
                // 如果是在对话框程序中，当没有其他按钮具有键盘焦点时，用户可以通过按下Enter键选择默认按钮
                SendMessage(hwndBtnStop, BM_SETSTYLE, WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON, FALSE);
                SetWindowText(hwndStatic[2], TEXT("请按空格键停止取色"));
            }
            else if (LOWORD(wParam) == IDC_BTNSTOP)
            {
                bStarting = FALSE;
                SetFocus(hwndBtnStart);
                KillTimer(hwnd, 1);
                KillTimer(hwnd, 2);
                SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
                SendMessage(hwndBtnStop, BM_SETSTYLE, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, FALSE);
                SetWindowText(hwndStatic[2], TEXT("点击开始按钮开始取色"));
            }
            break;

        case EN_SETFOCUS:
            if (LOWORD(wParam) == IDC_EDITWEB)
            {
                SendMessage(hwndEdit[1], EM_SETSEL, -1, -1);
                SendMessage(hwndEdit[0], EM_SETSEL, 0, -1);
                SendMessage(hwndEdit[0], WM_COPY, 0, 0);
                MessageBox(hwnd, TEXT("网页颜色已经复制到剪贴板"), TEXT("提示"), MB_OK);
            }
            else if (LOWORD(wParam) == IDC_EDITRGB)
            {
                SendMessage(hwndEdit[0], EM_SETSEL, -1, -1);
                SendMessage(hwndEdit[1], EM_SETSEL, 0, -1);
                SendMessage(hwndEdit[1], WM_COPY, 0, 0);
                MessageBox(hwnd, TEXT("RGB颜色已经复制到剪贴板"), TEXT("提示"), MB_OK);
            }
            return 0;
        }

        return 0;

    case WM_SYSCOMMAND:
        if (LOWORD(wParam) == IDM_ABOUT)
        {
            MessageBox(hwnd, TEXT("本程序由\n《十年磨一剑：Windows程序设计、加密解密从零基础到行家》作者提供\n\n老王，不负所望!"), TEXT("关于本程序"), MB_OK);
            return 0;
        }
        break;

    case WM_TIMER:
        if (wParam == 1)
        {
            // 获取鼠标光标处的颜色值，然后更新水平滚动条、颜色值静态控件、两个编辑框、颜色结果矩形
            GetCursorPos(&pt);
            crPixel = GetPixel(hdcDesk, pt.x, pt.y);
            color[0] = GetRValue(crPixel);
            color[1] = GetGValue(crPixel);
            color[2] = GetBValue(crPixel);

            SetScrollPos(hwndSBHorz[0], SB_CTL, color[0], TRUE);
            SetScrollPos(hwndSBHorz[1], SB_CTL, color[1], TRUE);
            SetScrollPos(hwndSBHorz[2], SB_CTL, color[2], TRUE);

            SetDlgItemInt(hwnd, IDC_STATICCOLOR1, color[0], FALSE);
            SetDlgItemInt(hwnd, IDC_STATICCOLOR2, color[1], FALSE);
            SetDlgItemInt(hwnd, IDC_STATICCOLOR3, color[2], FALSE);

            wsprintf(szBuf, TEXT("#%0.2X%0.2X%0.2X"), color[0], color[1], color[2]);
            SetDlgItemText(hwnd, IDC_EDITWEB, szBuf);
            wsprintf(szBuf, TEXT("RGB(%d, %d, %d)"), color[0], color[1], color[2]);
            SetDlgItemText(hwnd, IDC_EDITRGB, szBuf);

            InvalidateRect(hwnd, &rcColor, FALSE);

            // 实时显示鼠标光标附近的图像
            hdc = GetDC(hwnd);
            SelectObject(hdcMem, GetStockObject(NULL_PEN));
            Rectangle(hdcMem, 0, 0, 121, 121);
            // 取鼠标光标周围的40*40像素图像，放大3倍
            StretchBlt(hdcMem, 0, 0, 120, 120, hdcDesk, pt.x - 20, pt.y - 20, 40, 40, SRCCOPY);
            DrawIcon(hdcMem, 60 - GetSystemMetrics(SM_CXICON) / 2,
                60 - GetSystemMetrics(SM_CYICON) / 2, LoadCursor(NULL, IDC_CROSS));
            BitBlt(hdc, 0, 0, 120, 120, hdcMem, 0, 0, SRCCOPY);
            ReleaseDC(hwnd, hdc);
        }
        else
        {
            // 之所以1秒调用一次本计时器，而不是100ms
            // 是为了防止其他程序根本得不到键盘焦点，影响用户体验
            // GetActiveWindow() != hwnd或GetForegroundWindow() != hwnd也可以
            if (GetFocus() != hwndBtnStop)
            {
                RECT rect;
                // 保存鼠标光标位置，然后把鼠标光标位置设置到客户区(10, 10)，然后点击
                GetCursorPos(&pt);
                GetClientRect(hwnd, &rect);
                ClientToScreen(hwnd, (LPPOINT)&rect);
                SetCursorPos(rect.left + 10, rect.top + 10);
                mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
                mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
                // 恢复鼠标光标位置
                SetCursorPos(pt.x, pt.y);
            }
        }
        return 0;

    case WM_SETFOCUS:
        if (bStarting)
            SetFocus(hwndBtnStop);
        /*else
            SetFocus(hwndBtnStart);*/
        return 0;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        // 颜色结果矩形
        SelectObject(hdc, CreateSolidBrush(RGB(color[0], color[1], color[2])));
        Rectangle(hdc, rcColor.left, rcColor.top, rcColor.right, rcColor.bottom);
        DeleteObject(SelectObject(hdc, GetStockObject(WHITE_BRUSH)));
        // 鼠标光标周围的图像
        BitBlt(hdc, 1, 0, 121, 120, hdcMem, 0, 0, SRCCOPY);
        EndPaint(hwnd, &ps);
        return 0;

    case WM_DESTROY:
        DeleteObject(hFont);
        for (int i = 0; i < _countof(hBrush); i++)
            DeleteObject(hBrush[i]);
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624225508066.png)





关于`WM_CTLCOLORSCROLLBAR`和`WM_CTLCOLORSTATIC`消息的处理，在讲解编辑控件的时候已经说过。在`WM_CTLCOLORSCROLLBAR`消息中分别为3个水平滚动条返回红、绿、蓝画刷以填充其背景。



在`WM_CTLCOLORSTATIC`消息中调用SetTextColor分别设置红、绿、蓝颜色值静态控件的文本颜色。



文本的背景色默认就是白色，因此不需要调用SetBkColor或SetBkMode函数设置。静态控件默认情况下是灰色背景，因此返回一个GetSysColorBrush(COLOR_WINDOW)白色画刷。



如果不明确静态控件背景、文本背景具体指的是哪个范围，请调用以上函数自行测试。



`WM_HSCROLL`  `WM_COMMAND`和`WM_SYSCOMMAND`消息的处理很简单，用户单击“开始"按钮，调用`SetWindowPos`函数置顶显示本程序。后动2个计时器，一个是100ms触发一次，用于获取鼠标光标处的COLORREF颜色值，然后更新水平滚动条、颜色值静态控件、两个编辑框、颜色结果矩形的显示，并把鼠标光标附近的40像素40像素图像放大3倍以后显示在程序客户区左上角(0,0,120,120)。另一个是1s触发一次，用于让本程序的"停止"按钮实时具有键盘焦点，以响应用户按下空格键停止取色，因为`SetActiveWindow`  `BringWindowToTop` `SwitchToThisWindow`和`SetForegroundWindow`等激活窗口函数的效果不尽如人意，所以本程序采用模拟鼠标单击客户区的方法以激活程序窗口。程序窗口激活以后会收到`WM_SETFOCUS`消息，程序处理该消息，把输入焦点设置为开始或停止按钮。



:::



## 静态控件

静态控件可以用于显示简单图形、文本或图像，也可以通过自绘定制其外观。静态控件必须指定`SS_NOTIFY`样式才能接收鼠键输入并在用户单击或双击时通知其父窗口(`WM_COMMAND`消息)。





:::details `静态控件显示图形需要的样式`



|      样式宏      |                  含义                  |
| :--------------: | :------------------------------------: |
| `SS_BLACKFRAME`  |     创建一个黑色边框的无填充矩形框     |
|  `SS_GRAYFRAME`  |     创建一个灰色边框的无填充矩形框     |
| `SS_WHITEFRAME`  |     创建一个白色边框的无填充矩形框     |
| `SS_ETCHEDFRAME` | 创建一个具有三维外观边框的无填充矩形框 |
| `SS_ETCHEDHORZ`  |       创建一条具有三维外观的横线       |
| `SS_ETCHEDVERT`  |       创建一条具有三维外观的竖线       |
|  `SS_BLACKRECT`  |      创建一个黑色填充的无边框矩形      |
|  `SS_GRAYRECT`   |      创建一个灰色填充的无边框矩形      |
|  `SS_WHITERECT`  |      创建一个白色填充的无边框矩形      |

以上9种样式不能组合使用。调用`CreateWindowEx`函数创建上述9种简单图形。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240624230429200.png)

:::





:::details `静态控件中显示文本`

|         宏          |                             含义                             |
| :-----------------: | :----------------------------------------------------------: |
|      `SS_LEFT`      | 在指定的矩形范围内左对齐显示文本。如果一行显示不了，则会自动换行到下一行。如果一个单词的长度超过控件的宽度，则会被裁剪。 |
|     `SS_CENTER`     | 在指定的矩形范围内居中对齐显示文本。如果一行显示不了，则会自动换行到下一行;如果一个单词的长度超过控件的宽度，则会被裁剪。 |
|     `SS_RIGHT`      | 在指定的矩形范围内右对齐显示文本。如果一行显示不了，则会自动换行到下一行。如果一个单词的长度超过控件的宽度，则会被裁剪。 |
|     `SS_SIMPLE`     | 在指定的矩形范围内显示一行左对齐文本。即使控件指定了较高的高度也不会自动换行显示，如果禁用该控件，则控件不会使其文本变灰。 |
| `SS_LEFTNOWORDWRAP` | 与`SS_SIMPLE`类似，也不会自动换行，但是控件的高度会完全显示  |

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240626221141483.png)



`SS_LEFT`  `SS_CENTER`和`SS_RIGHT`样式的文本静态控件都可以自动换行，但前提是控件具有足够的高度，否则超出控件大小范围的部分不会显示。如果需要根据字符串的实际长度和高度来指定静态控件的宽度和高度参数,可以使用相关字符、字符串计算函数，例如
`GetCharWidth32` `GetTextExtentPoint32`等。

:::





:::details `静态控件中显示图像`



`SS_ICON`图标。CreateWindowEx函数的窗口标题参数lpWindowName指定为图标ID值，该样式会忽略CreateWindowEx函数的宽高参数nWidth和nHeight，系统自动调整静态控件的大小以适应图标，图标的大小默认情况下使用GetSystemMetrics (SM_CXICON)和
GetSystemMetrics(SM_CYICON)返回的值，通常是32 32，可以同时指定SS_REALSIZEIMAGE样式以使用图标的实际大小。



即在默认情况下，不管宽高参数nWidth和nHeight指定为多少，也不管图标
的实际大小是多少，系统总认为图标大小为32 32，并调整静态控件大小为32 32，如果指定了SS_REALSIZEIMAGE样式，则会使用图标的实际大小，并把静态控件调整为图标的实际大小



`SS_BITMAP`位图。CreateWindowEx函数的窗口标题参数lpWindowName指定为位图ID值，该样式会忽略CreateWindowEx函数的宽高参数nWidth和nHeight，系统会根据位图的实际大小自动调整静态控件的大小。如果想使用nWidth和nHeight指定的大小，则可以同时指定SS_REALSIZECONTROL样式，系统会自动调整位图(放大或缩小)以适应静态控件的大小。





:::



:::details `示例:`

```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("StaticDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndStatic[6];
    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        hwndStatic[0] = CreateWindowEx(0, TEXT("Static"), TEXT("Panda64"),
            WS_CHILD | WS_VISIBLE | SS_ICON | SS_NOTIFY | SS_REALSIZEIMAGE | SS_CENTERIMAGE,
            10, 10, 100, 100, hwnd, (HMENU)(1001), hInstance, NULL);        
        return 0;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240626222950008.png)

:::

## SysLink控件



`SysLink`控件是Comctl32.dll版本6以后引入的一个子窗口控件，可以用于显示普通文本和超链接。超链接的文本颜色默认情况下是蓝色，带下划线，超链接支持`Href lD`属性。学过`HTML`的读者对于创建超链接的方法应该很熟悉。`Href`支持任何协议，例如`http https ftpmailto`等。



一个SysLink控件中可以有多个超链接。ID为可选属性，它在一个SysLink控件中必须是唯一的。当用户单击超链接时，系统会发送包含NM_CLICK通知码的WM_NOTIFY消息。要区分是哪一个超链接，可以使用其位置索引，索引从0开始。





:::details `LM_S/GETITEM 消息`



普通文本“我喜欢”的颜色是黑色，超链接文本的颜色是蓝色，SysLink控件的背景是灰色的。

超链接的状态和属性可以通过发送`LM_SETITEM`消息来进行设置。wParam参数没有用到。`IParam`参数是一个指向LITEM结构的指针，该结构包含超链接所需的新状态和属性，也用于`LM_GETITEM`消息中获取超链接的状态和属性。LITEM结构定义如下︰

```c
typedef struct tagLITEM
{
    UINT mask; //标志，要设置或获取哪些项目
    int iLink; //超链接的索引
    UINT state; //超链接的状态，和stateMask设置为相同的值
    UINT stateMask; //超链接的状态掩码
    WCHAR szID[MAX_LINKID_TEXT];  //ID，最大字符数MAX_LINKID_TEXT(48)
    WCHAR szUrl[L_MAX_URL_LENGTH]; //URL，最大字符数 
}LITEM,*PLITEM;
```

- mask字段指定要设置或获取哪些项目，可以是下表所示的一个或多个标志的组合。

| 宏              | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| `LIF_ITEMINDEX` | 超链接的索引，因为通常都是通过索引来确定`SysLink`控件中的一个超链接，所以不管是设置还是获取，都需要指定该标志，并为`iLink`字段设置一个值。 |
| `LIF_ITEMID`    | 超链接的ID，对应`szID`字段                                   |
| `LIF_URL`       | 超链接的URL，对应`szUrl`字段                                 |
| `LIF_STATE`     | 超链接的状态，对应`stateMask`字段                            |

- `state`和`stateMask`字段使用相同的值，可用的值如下表所示。

|       宏       |                             含义                             |
| :------------: | :----------------------------------------------------------: |
| `LIS_ENABLED`  | 默认值，该链接可以响应用户输入，除非创建控件的时候指定了WS_DISABLED样式 |
| `LIS_FOCUSED`  | 该链接具有键盘焦点，此时按Enter键会发送包含NM_CLICK通知码的WM_NOTIFY消息 |
| `LIS_VISITED`  |                     该链接已被用户访问过                     |
| `LIS_HOTTRACK` | 当鼠标悬停在控件上时，将以不同的颜色(COLOR_HIGHLIGHT为蓝色)突出显示 |

:::



:::details `WM_NOTIFY 消息`



当用户单击一个超链接时，系统会发送包含`NM_CLICK`通知码的`WM_NOTIFY`消息。

当超链接具有输入焦点时，按下Enter键会发送包含`NM_RETURN`通知码的`WM_NOTIFY`消息。



程序通常用同样的方法处理这两个消息，要区分是哪一个超链接，可以使用其位置索引，索引从0开始。这两个通知码的IParam参数是一个指向NMLINK结构的指针，该结构定义如下:

```c
typedef struct tagNMLINK
{
    NMHDR hdr;//NMHDR结构
    LITEM item; //LITEM结构，包含超链接的状态和属性信息
}NMLINK,*PNMLINK;
```

:::



:::details `示例`

```c
#include <Windows.h>
#include <tchar.h>
#include <strsafe.h>
#include <CommCtrl.h>

#pragma comment(lib, "Comctl32.lib")

#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

// 函数声明
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("SysLinkDemo");
    HWND hwnd;
    MSG msg;

    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);

    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HFONT hFont;
    static HWND hwndSysLink;

    LITEM li = { 0 };
    PNMLINK pnmLink;

    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        hwndSysLink = CreateWindowEx(0, TEXT("SysLink"),
          TEXT("我喜欢<a href=\"http://www.WindowsChs.com/\" ID=\"Windows\" >Windows程序设计</a>\n")
          TEXT("我喜欢<a href=\"http://www.TaoBao.com/\" ID=\"TaoBao\" >淘宝购物</a>\n")
          TEXT("我喜欢<a href=\"http://www.360Buy.com/\" ID=\"360Buy\" >京东商城</a>"),
          WS_CHILD | WS_VISIBLE | WS_TABSTOP | LWS_TRANSPARENT,
          10, 10, 200, 60, hwnd, (HMENU)(1001), hInstance, NULL);
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, DEFAULT_CHARSET, 0, 0, 0, 0, TEXT("微软雅黑"));
        SendMessage(hwndSysLink, WM_SETFONT, (WPARAM)hFont, FALSE);
        return 0;
    case WM_LBUTTONDBLCLK:
        li.mask = LIF_ITEMINDEX | LIF_URL;
        li.iLink = 0;
        StringCchCopy(li.szUrl, L_MAX_URL_LENGTH, TEXT("https://msdn.microsoft.com/"));
        SendMessage(hwndSysLink, LM_SETITEM, 0, (LPARAM)&li);
        return 0;
    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case NM_CLICK:
        case NM_RETURN:
            pnmLink = (PNMLINK)lParam;
            if (pnmLink->hdr.hwndFrom == hwndSysLink)
            {
                if (pnmLink->item.iLink == 0)
                    ShellExecute(NULL, TEXT("open"), pnmLink->item.szUrl, NULL, NULL, SW_SHOW);
                else if (pnmLink->item.iLink == 1)
                    ShellExecute(NULL, TEXT("open"), pnmLink->item.szUrl, NULL, NULL, SW_SHOW);
                else if (pnmLink->item.iLink == 2)
                    ShellExecute(NULL, TEXT("open"), pnmLink->item.szUrl, NULL, NULL, SW_SHOW);
            }
            break;
        }
        return 0;
    case WM_DESTROY:
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240626224553793.png)

在创建SysLink控件时，指定`LWS_TRANSPARENT`透明样式。

在客户区中双击时，程序发送一个`LM_SETITEM`消息，设置第1个超链接的URL为
https://msdn.microsoft.com/。

在`WM_NOTIFY`消息中处理`NM_CLICK`和`NM_RETURN`通知码，根据超链接的索引分别进行处理，`ShellExecute`函数用于打开一个文件或URL。

:::



## 全局热键与特定线程热键



热键，也叫快捷键。当用户在热键控件中输入用于热键的组合键时，组合键的名称会显示在热键控件中，如，组合键包括`修饰键(Ctrl Alt Shift)`和伴随键（数字字母键、方向键、功能键F1～F12)。



用户输入组合键以后，程序可以获取热键控件中的组合键，以设置全局热键或特定于线程的热键。





:::details `HKM_GETHOTKEY 消息`



发送`HKM_GETHOTKEY`消息可以获取热键控件中的修饰键和伴随键，消息的`wParam`和`lParam`参数都没有用到。



该消息返回一个包含修饰键标志和伴随键的虚拟键码的`DWORD`值。

- `LOBYTE(LOWORD(返回值))` 表示热键的伴随键的虚拟键码

- `HIBYTE(LOWORD(返回值))` 表示热键的修饰键标志。



修饰键标志可以是下表所示值的组合。



- `HOTKEYF_SHIFT1` Shift键
- `HOTKEYF_CONTROL2` Ctrl键
- `HOTKEYF_ALT4` Alt键



:::





:::details `HKM_SETHOTKEY 消息`



发送`HKM_SETHOTKEY`消息可以设置热键控件中的修饰键和伴随键。

- `LOBYTE(LOWORD (wParam))`表示热键的伴随键的虚拟键码。
- `HIBYTE(LOWORD (wParam))`表示热键的修饰键标志，`IParam`参数没有用到，该消息始终返回0。





**全局热键与指定的窗口相关联**，不管该窗口是否处于活动状态，按下全局热键以后，系统都会通知该窗口。可以通过发送`WM_SETHOTKEY`消息设置全局热键。



每当用户按下全局热键时，如果发送`WM_SETHOTKEY`消息设置全局热键的窗口处于活动状态，那么将收到`WM_SYSCOMMAND`消息(`wParam等于SC_HOTKEY,lParam等于窗口的句柄`)。如果该窗口没有处于活动状态，那么系统会激活该窗口到前台显示，在调用`WM_SETHOTKEY`消息设置全局热键的应用程序退出之前，热键一直有效。

:::



:::details `WM_SETHOTKEY 消息`



`WM_SETHOTKEY`消息的`LOWORD(wParam)`指定热键的伴随键的虚拟键码。

`HIWORD(wParam)`指定热键的修饰键标志，



因此`LOWORD(HKM_GETHOTKEY)`消息的返回值可以用作`WM_SETHOTKEY`消息的`wParam`参数。`wParam`参数设置为NULL表示删除与窗口关联的全局热键;



`IParam`参数没有用到。



具有`WS_CHILD`窗口样式的窗口不能设置全局热键。该消息的返回值包括



- -1 热键无效(例如VK_ESCAPE-VK_SPACE和VK_TAB等都是无效的热键)
- 0  窗口无效
- 1 成功，没有其他窗口具有相同的热键
- 2 成功，但另一个窗口已具有相同的热键





一个窗口只能关联一个全局热键，如果窗口已经有一个与之关联的全局热键，则新设置的全局热键将替换旧的全局热键。



如果多个窗口具有相同的全局热键，则由全局热键激活的窗口是随机的。



:::tip

发送`WM_SETHOTKEY`消息可以设置一个与指定窗口相关联的全局热键。按下全局热键以后，如果该窗口没有处于活动状态，则系统会激活该窗口。

如果该窗口处于活动状态，则会收到`WM_SYSCOMMAND`消息 (`wParam`等于`SC_HOTKEY`，`IParam`等于窗口的句柄)，所以该消息主要用于将程序窗口调到前台。全局热键也称为**窗口激活热键**。

:::

:::









如果需要在用户按下热键以后执行某种操作，例如QQ程序不管是处于最小化还是活动状态，按下Ctrl + Alt +A组合键都可以打开QQ截图程序，这可以通过调用`RegisterHotKey`函数设置特定于线程的系统范围的热键来实现。



在用户按下`RegisterHotKey`函数指定的热键以后，系统会发送`WM_HOTKEY`消息到线程的消息队列，该热键不会把程序窗口调到前台。程序执行以后会创建一个主线程。如果需要，程序可以通过调用`CreateThread`函数创建其他线程。



:::details `RegisterHotKey 函数说明`

```c
/// <summary>
/// 注册线程级别热键
/// </summary>
/// <param name="hWnd">窗口句柄，将接收由热键生成的WM_HOTKEY消息</param>
/// <param name="id">热键的ID</param>
/// <param name="fsModifiers">修饰键标志</param>
/// <param name="vk">伴随键的虚拟键码</param>
/// <returns>如果函数执行成功，则返回值为非0值﹔如果函数执行失败，则返回值为0。要获取错误信息,请调用GetLastError</returns>
BOOL RegisterHotKey(HWND hWnd, int id,UINT fsModifiers,UINT vk );
```

- hWnd参数指定窗口句柄，该窗口将接收由热键生成的`WM_HOTKEY`消息，热键与`hWnd`指定的窗口相关联。如果设置为NULL，则`WM_HOTKEY`消息将发送到调用该函数的线程的消息队列中，即在这种情况下热键与调用该函数的线程相关联。程序可以在消
  息循环中处理该消息以决定发送给哪个窗口，如同计时器的其他方式的消息循环中的处理代码。
- id参数指定热键的ID，因为一个程序可以通过调用`RegisterHotKey`函数设置多个热键，在`WM_HOTKEY`消息中可以通过id来确定是哪个热键。程序可以指定`O×0000～OxBFFF`范围内的id值，如果是动态链接库，则必须指定`OxCo00～OxFFFF`范围内的id值(一个程序可以同时加载多个动态链接库，为避免与其他动态链接库定义的热键id冲突，动态链接库应使用`GlobalAddAtom`函数来分配一个热键id)。
- fsModifiers参数指定修饰键标志。
  - MOD_ALT1 Alt
  - MOD_CONTROL2 Ctrl
  - MOD_SHIFT4 Shift
    MOD_WIN8 Windows键



特定于线程的系统范围的热键表示在系统中是唯一的。如果系统中其他程序已经注册过相同的热键组合键，则`RegisterHotKey`函数调用
会失败。如果使用相同的`Hwnd`和`id`又创建了一个或多个组合键不同的特定线程热键，则旧热键与新热键都可以工作。

:::



:::details `UnregisterHotKey 函数说明`



如果需要取消注册热键，可以调用UnregisterHotKey函数∶

```c
BOOL WINAPI UnregisterHotKey(_In_opt_HWND hWnd, _In_int id);
```

`WM_HOTKEY`消息的wParam参数是生成消息的热键的id，

- LOWORD(IParam)是以MOD_开头的修饰键标志。
- HIWORD(IParam)是伴随键的虚拟键码。

:::







:::details `示例:`

```c
#include <Windows.h>
#include <CommCtrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("HotKeyDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 290, 150, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HINSTANCE hInstance;
    static HWND hwndHotKeyHwnd, hwndBtnSetHwnd;     // 与窗口激活热键相关的热键控件和按钮句柄
    static HWND hwndHotKeyThread, hwndBtnSetThread; // 与特定线程热键相关的热键控件和按钮句柄
    static HFONT hFont;
    DWORD dwHotKey;         // 发送HKM_GETHOTKEY消息获取热键控件的修饰键和伴随键的返回值
    DWORD dwRet;            // 发送WM_SETHOTKEY消息设置窗口激活热键的返回值
    UINT fsModifiers = 0;   // RegisterHotKey函数的fsModifiers参数，修饰键标志

    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        // 2个热键控件
        hwndHotKeyHwnd = CreateWindowEx(0, TEXT("msctls_hotkey32"), NULL,
            WS_CHILD | WS_VISIBLE,
            10, 10, 120, 22, hwnd, (HMENU)IDC_HOTKEYHWND, hInstance, NULL);
        hwndHotKeyThread = CreateWindowEx(0, TEXT("msctls_hotkey32"), NULL,
            WS_CHILD | WS_VISIBLE,
            140, 10, 120, 22, hwnd, (HMENU)IDC_HOTKEYTHREAD, hInstance, NULL);

        // 2个按钮
        hwndBtnSetHwnd = CreateWindowEx(0, TEXT("Button"), TEXT("设置窗口激活热键"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            10, 40, 120, 25, hwnd, (HMENU)IDC_BTNSETHWND, hInstance, NULL);
        hwndBtnSetThread = CreateWindowEx(0, TEXT("Button"), TEXT("注册特定线程热键"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            140, 40, 120, 25, hwnd, (HMENU)IDC_BTNSETTHREAD, hInstance, NULL);

        // 设置字体
        hFont = CreateFont(18, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("微软雅黑"));
        SendMessage(hwndHotKeyHwnd, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndHotKeyThread, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndBtnSetHwnd, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndBtnSetThread, WM_SETFONT, (WPARAM)hFont, FALSE);
        return 0;

    case WM_SETFOCUS:
        SetFocus(hwndHotKeyHwnd);
        return 0;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_BTNSETHWND:
            dwHotKey = SendMessage(hwndHotKeyHwnd, HKM_GETHOTKEY, 0, 0);
            if (!HIBYTE(LOWORD(dwHotKey)) || !LOBYTE(LOWORD(dwHotKey)))
            {
                MessageBox(hwnd, TEXT("设置窗口激活热键需要修饰键和伴随键"), TEXT("错误"), MB_OK);
                return 0;
            }
            // 设置窗口激活热键
            dwRet = SendMessage(hwnd, WM_SETHOTKEY, LOWORD(dwHotKey), 0);
            if (dwRet <= 0)
                MessageBox(hwnd, TEXT("窗口激活热键设置失败"), TEXT("错误"), MB_OK);
            else if (dwRet == 1)
                MessageBox(hwnd, TEXT("成功，没有其他窗口具有"), TEXT("成功"), MB_OK);
            else if (dwRet == 2)
                MessageBox(hwnd, TEXT("成功，但另一个窗口已具有"), TEXT("警告"), MB_OK);
            break;

        case  IDC_BTNSETTHREAD:
            dwHotKey = SendMessage(hwndHotKeyThread, HKM_GETHOTKEY, 0, 0);
            if (HIBYTE(LOWORD(dwHotKey)) & HOTKEYF_SHIFT)
                fsModifiers |= MOD_SHIFT;
            if (HIBYTE(LOWORD(dwHotKey)) & HOTKEYF_CONTROL)
                fsModifiers |= MOD_CONTROL;
            if (HIBYTE(LOWORD(dwHotKey)) & HOTKEYF_ALT)
                fsModifiers |= MOD_ALT;
            if (!fsModifiers || !LOBYTE(LOWORD(dwHotKey)))
            {
                MessageBox(hwnd, TEXT("注册特定线程热键需要修饰键和伴随键"), TEXT("错误"), MB_OK);
                return 0;
            }
            // 注册特定线程热键
            if (RegisterHotKey(hwnd, 1, fsModifiers, LOBYTE(LOWORD(dwHotKey))))
                MessageBox(hwnd, TEXT("注册特定线程热键成功"), TEXT("注册成功"), MB_OK);
            else
                MessageBox(hwnd, TEXT("注册特定线程热键失败"), TEXT("注册失败"), MB_OK);
            break;
        }
        return 0;

    case WM_SYSCOMMAND:
        // 如果该窗口处于活动状态则会收到WM_SYSCOMMAND消息
        // 实际编程中很少处理SC_HOTKEY的WM_SYSCOMMAND消息
        if ((wParam & 0xFFF0) == SC_HOTKEY)
        {
            MessageBox(hwnd, TEXT("窗口激活热键消息"), TEXT("消息"), MB_OK);
            return 0;
        }
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    case WM_HOTKEY:
        // 处理特定线程热键消息
        if (wParam == 1)
            MessageBox(hwnd, TEXT("特定线程热键消息"), TEXT("消息"), MB_OK);
        return 0;
    case WM_DESTROY:
        UnregisterHotKey(hwnd, 1);
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240626225700074.png)

:::



## IP地址控件

目前应用最广泛的IP地址是基于IPv4的，一个IP地址的长度为32位，即4字节(DWORD)数据。IP地址中的每字节使用一个十进制数字来表示，每字节的数值范围是0～255，数字之间使用小数点分隔。lPv4的IP地址格式为XXX.XXX.XXX.XXX，这种IP地址表示法称为点分十进制表示法。IP地址控件允许用户以点分十进制表示法输入IP地址。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240626232255359.png)





4个数字是4个域，实际上每个域都是一个编辑控件。当IP地址控件获得、失去键盘焦点时会收到`EN_SETFOCUS`   ` EN_KILLFOCUS`通知码。当IP地址控件中的任何域更改时，都会收到`EN_CHANGE`通知码(通过`WM_COMMAND`消息的形式)，这些通知码通常都不需要处理。



## 图像列表`ImageList_Create`函数





图像列表是具有相同大小的多个图像的集合，每个图像都可以通过其索引来引用，图像列表用于有效管理大量图标或位图。图像列表并不是一个窗口，因此没有窗口类名。



可以通过调用`ImageList_Create`函数创建一个图像列表，函数返回HIMAGELIST图像列表句柄。




:::details `ImageList_Create 函数说明`

```c

/// <summary>
/// 创建图像列表
/// </summary>
/// <param name="cx">每个图像的宽度，以像素为单位</param>
/// <param name="cy"><每个图像的高度，以像素为单位/param>
/// <param name="flags">要创建的图像列表类型标志，设置为0表示默认</param>
/// <param name="clnitial">图像列表最初包含的图像个数</param>
/// <param name="cGrow">当图像列表中的图像个数超过cInitial时，可以动态增长的图像个数，可以设置为0</param>
/// <returns></returns>
HIMAGELIST ImageList_Create(int cx, int cy,UINT flags,int clnitial,int cGrow);
```

- flags参数指定要创建的图像列表的类型 ，可以是下表的组合。

|         宏          |                             含义                             |
| :-----------------: | :----------------------------------------------------------: |
|     `ILC_COLOR`     |              默认情况，使用ILC_COLOR4(4位色DIB)              |
|    `ILC_COLOR24`    |                          24位色DIB                           |
|    `ILC_COLOR32`    |                          32位色DIB                           |
|   `ILC_COLORDDB`    |                     使用设备相关位图DDB                      |
|     `ILC_MASK`      | 使用掩码，包含两个位图，其中一个是用作掩码的单色位图。如果没有指定该标志，则仅包含一个位图。图标或光标通常需要指定该类型，因为图标或光标内含掩码数据 |
| `ILC_CORIGINALSIZE` |                使用所添加的图像的原始实际大小                |
|                     |                                                              |

:::





:::details `ImageList_Destroy 函数说明` 

当不再需要图像列表的时候，可以通过调用`ImageList_Destroy`函数将其销毁︰

```c
/// <summary>
/// 销毁图像列表
/// </summary>
/// <param name="himl"></param>
/// <returns></returns>
BOOL ImageList_Destroy(HIMAGELIST himl)
```

:::
