# 	子窗口控件



调用`CreateWindow()` / `CreateWindowEx()`函数创建窗口的时候，将窗口样式指定为`WS_CHILD`或`WS_CHILDWINDOW`就可以创建一个子窗口。子窗口的位置可以在父窗口客户区的任何地方，这样的子窗口需要程序注册窗口类并提供窗口过程。程序也可以通过系统预定义的窗口类和窗口过程来创建标准子窗口控件，程序中常见的标准子窗口挫件有按钮、单选按钮、复选按钮、编辑框、组合框、列表框、滚动条控件等，像资源管理器窗口就包含多个子窗口控件，例如工具栏、树视图控件、滚动条控件等。标准子窗口控件也称为通用控件(Common Control) 。





程序可以把窗口类名指定为系统预定义的`相关子窗口控件类名`来调用`CreateWindow()`/ `CreateWindowEx()`函数创建一个子窗口控件(对应形参的`lpClassName`)，子窗口控件和父窗口之间可以互相发送消息来进行通信。子窗口控件在对话框程序中用得更普遍，不需要调用`CreateWindow()`/ `CreateWindowEx()`函数，直接在资源脚本文件中定义子窗口控件即可，也可以通过资源编辑器从工具箱中拖曳子窗口控件到对话框程序界面的合适位置。

​	

**系统预定义的窗口类名字符串含义**

- Button按钮（普通按钮、单选按钮、复选按钮、分组框)
- Edit编辑框
- ListBox列表框
- ComboBox组合框ScrollBar滚动条Static静态控件
- MDIClientMDl 客户窗口



另外，有一些类名是系统内部使用的，例如`ComboLBox (多一个L)`表示组合框内的列表框的类名，`#32770`表示对话框类名等。





## 按钮类

按钮(Button)类有许多样式属性，基于Button类指定不同的样式可以创建普通按钮、单选按钮、复选按钮和分组框等。Button类可以指定的按钮样式如表所示，BS_前缀表示Button Style.



:::details `不同类型的按钮`



|              宏               |                             含义                             |
| :---------------------------: | :----------------------------------------------------------: |
|        `BS_PUSHBUTTON`        |                           普通按钮                           |
|      `BS_DEFPUSHBUTTON`       | 默认按钮，和普通按钮一样，但是有一个较深的轮廓。如果是在对话框程序中，当其他按钮没有键盘焦点时，用户可以通过按下Enter键选择该按钮 |
|      ``BS_RADIOBUTTON``       |                 单选按钮，可以选中、取消选中                 |
|       `BS_AUTOCHECKBOX`       |                         自动单选按钮                         |
|       `BS_RADIOBUTTON`        |                          自动复选框                          |
|     `BS_AUTORADIOBUTTON`      |                 单选按钮，可以选中、取消选中                 |
|         `BS_CHECKBOX`         |                 复选框，可以选中，取消选中。                 |
|       `BS_ATUOCHECKBOX`       |                          自动复选框                          |
|        `BS_ATUO3TATE`         |                        自动三态复选框                        |
| `BS_LEFTTEXT或BS_RIGHTBUTTON` | 对于单选按钮﹑复选框或三态复选框，文本默认显示在按钮右侧，该样式表示显示在按钮左侧 |
|           `BS_TEXT`           |                      按钮矩形内显示文本                      |
|           `BS_LEFT`           |                    左对齐按钮矩形内的文本                    |
|          `BS_RIGHT`           |                    右对齐按钮矩形内的文本                    |
|         `BS_CENTTER`          |                   文本在按钮矩形内水平居中                   |
|           `BS_TOP`            |                     文本在按钮矩形的顶部                     |
|          `BS_BOTTOM`          |                     文本在按钮矩形的底部                     |
|         `BS_VCENTER`          |                   文本在按钮矩形内垂直居中                   |
|           `BS_FLAT`           |        按钮默认具有三维样式,该样式表示按钮是二维样式         |
|         `BS_PUSHLIKE`         |        使单选按钮、复选框或三态复选框看起来像按钮—样         |
|        `BS_OWNERDRAW`         | 自绘按钮，当按钮需要重绘时父窗口会收到WM_DRAWITEM消息，不能将该样式与任何其他按钮样式—起使用 |
|           `BS_ICON`           |                           图标按钮                           |
|          `BS_BITMAP`          |                           位图按钮                           |
|         `BS_GROUPBOX`         | 分组框,用于对其他控件进行分组，由一个矩形和显示在矩形左上角的文本组成 |
|          `BS_NOTIFY`          | 系统可以发送包含`BN_KTLLFOCUS`和`BS_SETFOCUS`通知码的WM_COMMAND消息到其父窗口 |
|       `BS_SPLITBUTTON`        | 拆分按钮。拆分按钮分为两部分，左侧是主要部分，类似于普通或默认按纽﹔右刻有一个向下的小箭头，单击箭头时可以弹出一个菜单。拆分按扭是通用控件版本6中引A的一种出钮，如图所示:![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240114215850442.png) |
|      `BS_DEFSPLITBUTTON`      | 默认拆分按钮，有一个较深的轮廓。如果是在对话框程序中，当其他按钮没有键盘焦点时，用户可以通过按下Eater键选择该按钮 |
|       `BS_COMMANDLTNK`        | 命令链接按钮，左侧有一个篮色箭头指向按钮文本(Windows 7系统中为绿色箭头〉。命令链接按钮是通用控件版本6中引入的一种按钮，如图所示:![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240114215850442.png) |
|      `BS_DEFCOMMANDLINK`      | 默认命令链接按钮，有一个较深的轮廓。如果是在对话框程序中，当其他按钮没有键盘焦点时，用户可以通过按下Enter键选择该按钮 |

以三态复选框与自动三态复选框为例，用户单击三态复选框以后不会自动选中或变灭，程序需要响应单击事件设置选中或变灰状态﹔而如果是自动三态复选框，则单击一次就会自动选中，再单击一次则复选框显示为灰色，第三次单击则会取消选中，如此循环，程序在需要的时候只需要获取其状态即可。

:::







普通按钮、默认按钮、单选按钮和复选框都可以同时指定BS_ICON或BS BITMAP样式，例如`BS_PUSHBUTTON|BS_BITMAP`，或`BS_AUTORADIOBUTTON| BS_BITMAP`，表示在普通按钮上显示一副位图，或单选按钮旁边显示一副位图。





`BS_ICON`或`BS_BITMAP`样式也可以单独使用，表示在普通按钮上显示一个图标或一副位图。指定`BS_ICON`或`BS_BITMAP`样式以后，需要发送`BM_SETIMAGE`消息为其设置图标或位图，后面再详细解释这个消息。





`BS_`前缀的样式是按钮专用样式。除了这些按钮专用样式，因为子窗口控件也是一个窗口，所以大部分用于普通窗口的API函数和窗口样式适用于子窗口控件。例如下表的窗口样式可以用于按钮。



:::details `可用于子窗口的窗口样式`

|               宏                |                             含义                             |
| :-----------------------------: | :----------------------------------------------------------: |
|  `WS_CHILD`或`WS_CHILDWINDOW`   |                         窗口是子窗口                         |
|          `WS_VISIBLE`           | `WS_VISABLE`窗口最初可见，可以通过调用`ShowWindow()`或`SetWindowPos()`函数显示和隐藏窗口 |
|           `WS_GROUP`            | `WS_GROUP`该窗口是一组控件的第一个控件，该组由第一个具有WS_GROUP样式的控件和在其后定义的所有控件组成，直到下一个具有`WS_GROUP`样式的控件(不包括该控件)出现。如果是在对话框程序中，用户可以使用方向键将键盘焦点从组中的一个控件移动到下一个控件。另外，每个组中的第一个控件通常具有`WS_TABSTOP`样式，如果是在对话框程序中，按下Tab键可以将键盘焦点移动到下一个具有`WS_TABSTOP`样式的按件。 |
|          `WS_TABSTOP`           | 该窗口是一个控件，当用户按下Tab键时，该控件可以接收键盘焦点，如果是在对话框程序中，按下Tab键可以将键盘焦点移动到下一个具有`WS_TABSTOP`样式的控件上 |
|           `WS_BORDER`           |                      窗口有一个细线边框                      |
|          `WS_DLGFRAME`          |                   窗口具有对话框样式的边框                   |
| `WS_SIZEBOX` 或 `WS_THICKFRAME` |                     窗口具有大小调整边框                     |
|          `WS_DISABLED`          | 窗口最初被禁用，禁用的窗口无法接收用户的输入,要想启用可以调用`EnableWindow()`函数 |

其中，`WS_CHILD`和`WS_VISIBLE`是必须指定的，`WS_CHILD`表示该窗口是一个子窗口。如果不指定`WS_VISIBLE`样式，则子窗口控件不会显示。
另外，一些扩展窗口样式也可以用于子窗口控件，例如`WS_EX_ACCEPTFILES`表示该子窗口控件可以接受拖放文件。

:::



## 按钮与父窗口通信

按钮可以向其父窗口发送消息，父窗口也可以向按钮发送消息。父窗口可以通过调用`SendMessage()`或`SendDlgltemMessage()`函数发送消息到子窗口控件



:::details `SendMessage 函数说明`

```c
LRESULT	SendMessage(HWND hWnd, UINT Msg,WPARAM wParam,LPARAM lParam);

LRESULT SendDIgItemMessage(HWND hDIg, int nIDDIgltem, UINT Msg, WPARAM	wParam,LPARAM lParam);
```

- `SendDlgltemMessage()`函数的`hDlg`指的是Dialog对话框，该函数通常用于在对话框程序中向子窗口控件发送消息 `hDlg`参数指定父窗口句柄，
- `nIDDIgltem`参数指定子窗口控件ID，每个子窗口控件都有一个ID。调用`CreateWindow/CreateWindowEx`函数创建子窗口控件的时候，第10个参数`hMenu`不再指定为菜单句柄，而是指定为**子窗口控件ID**。

:::



:::tip

对于`BS_ICON`或`BS_BITMAP`样式的按钮。`BM_SETIMAGE`消息用于为按钮设置图标或位图。

- 其中`wParam`参数指定图像类型，可以是IMAGE_ICON(图标)或IMAGE_BITMAP(位图)，
- `lParam`参数可以指定为图像的句柄(HICON或HBITMAP),
- `返回值`是先前与按钮关联的图像的句柄(如果有的话)，否则返回值是NULL

:::



:::tip 



`BM_GETIMAGE`消息用于获取与按钮关联的图标或位图的句柄.

- 其中`wParam`参数指定图像类型，可以是IMAGE_ICON(图标)或IMAGE_BITMAP(位图)
- `lParam`参数没有用到，指定为0即可。
- `返回值`是与按钮关联的图像的句柄（如果有的话),否则返回值是NULL。

:::



:::tip

`BM_SETSTYLE`消息用于设置按钮的样式

- 其中`wParam`参数可以指定为按钮新样式的组合
- `lParam`参数可以指定为TRUE(重绘按钮)或FALSE(不重绘按钮)。当然,通过调用`SetWindowLongPtr()`函数也可以达到同样的目的。

:::

:::tip 

`BM_SETCHECK`消息用于设置单选按钮、复选框或三态复选框的选中状态.

- 其中`wParam`参数可以指定为BST_CHECKED (选中)、BST_UNCHECKED (取消选中)或BST_INDETERMINATE（灰色,表示不确定状态，用于三态复选框)
- `lParam`参数没有用到，指定为0即可。

:::



:::tip

`BM_GETCHECK`消息用于获取单选按钮、复选框或三态复选框的选中状态.

- `wParam`和`lParam`参数没有用到，都指定为0即可
- `返回值`可以是BST_CHECKED (已选中)、BST_UNCHECKED (未选中）或BST_INDETERMINATE(灰色，表示不确定状态，用于三态复选框)。

:::

:::tip

`BM_SETSTATE`消息用于设置普通按钮是否按下的状态.

- `wParam`参数可以指定为TRUE(突出显示，按下状态)或FALSE(取消突出显示，非按下状态)
- `lParam`参数没有用到,指定为0即可。

:::



:::tip

`BM_GETSTATE`消息用于获取普通按钮、单选按钮、复选框或三态复选框的当前状态(选中状态，是否按下和是否具有键盘焦点等)

- `wParam`和`lParam` 参数没有用到，都指定为0即可.
- 返回值可以是BST_CHECKED (已选中)、BST_UNCHECKED(未选中)、BST_INDETERMINATE(灰色，表示不确定状态，用于三态复选框)、BST_PUSHED(普通按钮处于按下状态)、BST_FOCUS(按钮具有键盘焦点)、
  BST_HOT(鼠标悬停在按钮上)、BST_DROPDOWNPUSHED(按钮处于下拉状态，并且仅当按钮具有BTNS_DROPDOWN样式时用于工具栏按钮)。

:::



:::tip

`BM_CLICK`消息可以模拟用户单击按钮

- `lParam`参数都没有用到。该消息会导致系统向按钮的父窗口发送包含BN_CLICKED通知码的WM_COMMAND消息。

:::







调用`CheckDlgButton()`或`CheckRadioButton()`函数等同于发送BM_SETCHECK消息

调用`IsDlgButtonChecked()`函数等同于发送BM_GETCHECK消息



:::details `CheckDlgButton 函数说明`

一组复选按钮中通常可以同时选中多个，而一组单选按钮中通常只能选中一个。`CheckDlgButton()`函数通常用于设置复选框的选中状态。

```c
/// <summary>
/// 设置复选按钮被选中
/// </summary>
/// <param name="hDIg">父窗口句柄</param>
/// <param name="nIDButton">子窗口控件ID</param>
/// <param name="uCheck">/设置选中状态，BST_CHECKED BST_UNCHECKED或BST_INDETERMINATE</param>
/// <returns></returns>
BOOL CheckDlgButton(HWND hDIg,int nIDButton,UINT uCheck);
```

:::



:::details `CheckRadioButton 函数说明` 



`CheckDlgButton()`函数也可以用于设置单选按钮，但是如果在一组单选按钮中选中一个，还需要多次调用`CheckDlgButton()`取消选中其他的，所以设置单选按钮的状态通常使用`CheckRadioButton()`函数，指定一组单选按钮的第一个和最后一个以及需要选中哪一个，函数会自动完成任务。

```c
/// <summary>
/// 设置单选按钮被选中
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDFirstButton">组中第一个单选按钮的ID</param>
/// <param name="nlDLastButton">组中最后一个单选按钮的ID</param>
/// <param name="nlDCheckButton">要设置选中的单选按钮的ID</param>
/// <returns></returns>
BOOL CheckRadioButton(HWND hDlg,int nlDFirstButton,int nlDLastButton,int nlDCheckButton);
```

::: 



:::details `IsDlgButtonChecked 函数说明`

```c
/// <summary>
/// 判断对话框按钮是否被选中
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDButton">子窗口控件ID</param>
/// <returns>函数返回值可以是BST_CHECKED BST_UNCHECKED或BST_INDETERMINATE</returns>
UINT IsDlgButtonChecked(HWND hDlg,int nlDButton);
```

建议使用自动单选按钮，同组的单选按钮会随着用户选中一个而自动取消选中其他单选按钮。在程序中只需要在初始化的时候设置选中哪一个，并在需要查用户选择了哪一个的时候调用`lsDlgButtonChecked()`函数检查每一个单选按钮项的选中状态即可。



同样，复选按钮也不会因为用户的单击而自动变为选中或取消选中等，因此建议使用自动复选按钮，在初始化的时候设置选中哪些，并在需要的时候调用`lsDlgButtonChecked()`函数检查每一个的状态即可。



:::





:::details `用户点击按钮产生的消息 WM_COMAND`

当用户单击按钮时，它会接收键盘焦点，系统会向按钮的父窗口发送包含`BN_CLICKED`通知码的`WM_COMMAND`消息。不过对于自动单选按钮、自动复选框或自动三态复选框通常不需要处理该消息，因为这些按钮可以自动设置其状态。如果是普通按钮，则可能需要处理该消息。



`WM_COMMAND`消息的`wParam`和`IParam`参数的含义。



|                  `HIWORD (wParam) `                   |                      `LOWORD (wParam)`                       | ` HWND(lParam)` |
| :---------------------------------------------------: | :----------------------------------------------------------: | :-------------: |
|            `菜单命今ID`  比如说，`ID_MEUN`            | 菜单项ID，比如说，记事本程序的打开菜单项ID`IDM_FILE_OPEN`,保存菜单项`IDM_FILE_SAVE` |        0        |
|                    加速键(快捷键)                     |                        菜单项ID，同上                        |        0        |
| 子窗口控件**通知码**,比如说`BN_CLICKED`按钮比点击了。 |             控件ID,比如说按钮控件的ID`ID_BUTTON`             |    控件句柄     |

> 通知码，可以类比QT中的发出的信号。
>
> ```c
>    // 为按钮绑定事件 connect(信号的发送者,发送的信号,信号的接受者,处理的函数(槽函数))
>  connect(btn, &QPushButton::clicked, this, &QWidget::close);
> ```
>
> 



`BN_SETFOCUS`: 按钮获得了键盘焦点



`BN_KILLFOCUS`:按钮失去了键盘焦点



`BN_DBLCLK`或`BN_DOUBLECLICKED` :双击按钮





获得键盘焦点的按钮周围会显示一圈虚线，此时按下空格键就相当于单击了按钮。只有具有`BS_NOTIFY`样式的按钮会发送`BN_SETFOCUS`  `BN_KILLFOCUS`和`BN_DBLCLK`通知码，但是无论如何设置按钮样式，单击按钮都会发送`BN_CLICKED`通知码。





:::



:::warning



`BS_GROUPBOX`样式表示分组框，用于对其他控件进行分组，由一个矩形和显示在矩形左上角的文本组成。分组框不会获得键盘焦点，既不处理鼠标或键盘输入，也不会导致系统发送`WM_COMMAND`消息到父窗口。

:::







:::details `对于按钮类的自绘消息WM_DRAWITEM`

对于自绘按钮、组合框和列表框等，程序只需要在必要的时候负责绘制它们的外观即可，系统会正常处理用户和这些控件的交互，例如用户单击控件，系统会向父窗口发送`WM_COMMAND`消息。在介绍自绘菜单的时候说过，`WM_DRAWITEM`消息既用于菜单项，**也用于其他些子窗口控件的自绘**，当菜单项或子窗口控件需要自绘的时候,窗口过程会收到`WM_DRAWITEM`消息。





如果WM_DRAWITEM消息是由子窗口控件发送的，则`wParam`参数是子窗口控件的ID

如果是由菜单项发送的，则`wParam`参数为0。`lParam`参数是一个指向`DRAWITEMSTRUCT`结构的指针

```c
typedef struct tagDRAWITEMSTRUCT
{
	UINT	ctlType;//控件类型，如果是ODT_MENU，表示菜单项
	UINT	CtlID;//该字段不用于菜单项
	UINT	itemID;//菜单项ID
	UINT	itemAction; //所需的绘制操作
	UINT	itemState;//新的状态
	HWND	hwndItem;//菜单句柄
	HDC	hDC;//设备环境句柄
	RECT	rcItem;//绘制区域
	ULONG_PTR	itemData;//程序自定义数据，最初由MENUITEMINFO结构的dwltemData指定的
}DRAWITEMSTRUCT,NEAR *PDRAWITEMSTRUCT，FAR *LPDRAWITEMSTRUCT;
```

:::



:::details `按钮类示例:`



接下来实现一个例子，Buttons程序在窗口客户区中使用系统预定义的Button类调用`CreateWindowEx()`函数分别创建了普通按钮、图标按钮、位图按钮、自绘按钮、一组自动单选按钮、一组自动复选按钮、一组自动三态复选按钮、默认按钮。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6.gif)

:::





:::details `resource.h`

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 Buttons.rc 使用
//
#define IDB_KONGLONG                    101
#define IDI_SMILE                       102

#define IDC_PUSHBUTTON          1000
#define IDC_ICONBUTTON          1001
#define IDC_BITMAPBUTTON        1002
#define IDC_OWNERDRAWBUTTON     1003
#define IDC_GROUPBOX1           1004
#define IDC_AUTORADIOBUTTON1    1005
#define IDC_AUTORADIOBUTTON2    1006
#define IDC_AUTORADIOBUTTON3    1007
#define IDC_GROUPBOX2           1008
#define IDC_AUTOCHECKBOX1       1009
#define IDC_AUTOCHECKBOX2       1010
#define IDC_AUTOCHECKBOX3       1011
#define IDC_GROUPBOX3           1012
#define IDC_AUTO3STATE1         1013
#define IDC_AUTO3STATE2         1014
#define IDC_AUTO3STATE3         1015
#define IDC_DEFPUSHBUTTON       1016

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240114231846364-17052455277211-17052455358562.png)

:::



:::details `main.cpp`

```c
#include <Windows.h>
#include <tchar.h>
#include <strsafe.h>
#include "resource.h"


LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID OnDefPushButton(HWND hwnd);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("Buttons");  
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 300, 600, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
struct
{
    int     m_nStyle;
    PTSTR   m_pText;
}Buttons[] = {
    BS_PUSHBUTTON | BS_NOTIFY | WS_TABSTOP,                 TEXT("普通按钮"), // CtrlID 1000
    BS_ICON | BS_NOTIFY | WS_TABSTOP,                       TEXT("图标按钮"),
    BS_BITMAP | BS_NOTIFY | WS_TABSTOP,                     TEXT("位图按钮"),
    BS_OWNERDRAW,                                           TEXT("自绘按钮"),

    BS_GROUPBOX,                                            TEXT("政治面貌"), // CtrlID 1004
    BS_AUTORADIOBUTTON | BS_NOTIFY | WS_GROUP | WS_TABSTOP, TEXT("中共党员"),
    BS_AUTORADIOBUTTON | BS_NOTIFY,                         TEXT("共青团员"),
    BS_AUTORADIOBUTTON | BS_NOTIFY,                         TEXT("无党派人士"),

    BS_GROUPBOX,                                            TEXT("个人爱好"), // CtrlID 1008
    BS_AUTOCHECKBOX | BS_NOTIFY | WS_GROUP | WS_TABSTOP,    TEXT("看书"),
    BS_AUTOCHECKBOX | BS_NOTIFY,                            TEXT("唱歌"),
    BS_AUTOCHECKBOX | BS_NOTIFY,                            TEXT("听音乐"),

    BS_GROUPBOX,                                            TEXT("荣誉称号"), // CtrlID 1012
    BS_AUTO3STATE | BS_NOTIFY | WS_GROUP | WS_TABSTOP,      TEXT("团队核心"),
    BS_AUTO3STATE | BS_NOTIFY,                              TEXT("技术能手"),
    BS_AUTO3STATE | BS_NOTIFY,                              TEXT("先进个人"),

    BS_DEFPUSHBUTTON | BS_NOTIFY | WS_TABSTOP,              TEXT("默认按钮"), // CtrlID 1016
};
#define NUM (sizeof(Buttons) / sizeof(Buttons[0]))
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND hwndButton[NUM];                // 子窗口控件句柄数组
    int arrPos[NUM] = { 10, 40, 70, 100,         // 每个子窗口控件的起始Y坐标
        130, 150, 180, 210,
        250, 270, 300, 330,
        370, 390, 420, 450,
        490 };
    LPDRAWITEMSTRUCT lpDIS;
    if (WM_CREATE == uMsg)
    {
        // 创建17个子窗口控件
        for (int i = 0; i < NUM; i++)
        {
            hwndButton[i] = ::CreateWindowEx(
                0,
                TEXT("Button"),
                Buttons[i].m_pText,
                WS_CHILD | WS_VISIBLE | Buttons[i].m_nStyle,
                20, arrPos[i],
                150, 25,
                hwnd,
                (HMENU)(1000 + i),
                ((LPCREATESTRUCT)lParam)->hInstance, NULL);
        }
        // 移动3个分组框的位置
        ::MoveWindow(hwndButton[4], 10, arrPos[4], 170, 115, TRUE);
        ::MoveWindow(hwndButton[8], 10, arrPos[8], 170, 115, TRUE);
        ::MoveWindow(hwndButton[12], 10, arrPos[12], 170, 115, TRUE);

        // 为图标按钮、位图按钮设置图标、位图
        HANDLE hImage = ::LoadImage(((LPCREATESTRUCT)lParam)->hInstance, MAKEINTRESOURCE(IDI_SMILE), IMAGE_ICON, 20, 20, LR_DEFAULTCOLOR); //根据resourceID 查图片句柄
        ::SendDlgItemMessage(hwnd, IDC_ICONBUTTON, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hImage); //给按钮设置图标

        HBITMAP hBitMap = ::LoadBitmap(((LPCREATESTRUCT)lParam)->hInstance, MAKEINTRESOURCE(IDB_KONGLONG));// 根据resourceID 查位图句柄
        ::SendDlgItemMessage(hwnd, IDC_BITMAPBUTTON, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitMap);  //给按钮设置位图
        ::SetDlgItemText(hwnd, IDC_DEFPUSHBUTTON, TEXT("获取单选复选状态"));        // 设置默认按钮的文本

        // 单选按钮组、复选按钮组、三态复选按钮组，默认情况下分别选中一项
        ::CheckRadioButton(hwnd, IDC_AUTORADIOBUTTON1, IDC_AUTORADIOBUTTON3, IDC_AUTORADIOBUTTON2);
        ::CheckDlgButton(hwnd, IDC_AUTOCHECKBOX3, BST_CHECKED);
        ::CheckDlgButton(hwnd, IDC_AUTO3STATE2, BST_INDETERMINATE);

        return 0;

    }
    else if (WM_COMMAND == uMsg)
    {

        if (HIWORD(wParam) == BN_CLICKED)
        {
            // 子窗口控件ID常量定义请参见resource.h，可以根据需要在此处理每个控件的点击事件
            if (LOWORD(wParam) == IDC_PUSHBUTTON)
            {
            }
            else if (LOWORD(wParam) == IDC_ICONBUTTON)
            {
            }
            else if (LOWORD(wParam) == IDC_BITMAPBUTTON)
            {
            }
            else if (LOWORD(wParam) == IDC_OWNERDRAWBUTTON)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTORADIOBUTTON1)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTORADIOBUTTON2)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTORADIOBUTTON3)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTOCHECKBOX1)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTOCHECKBOX2)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTOCHECKBOX3)
            {

            }
            else if (LOWORD(wParam) == IDC_AUTO3STATE1)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTO3STATE2)
            {
            }
            else if (LOWORD(wParam) == IDC_AUTO3STATE3)
            {
            }
            else if (LOWORD(wParam) == IDC_DEFPUSHBUTTON)
            {
                OnDefPushButton(hwnd);
            }
        }
        return 0;
    }
    else if (WM_DRAWITEM == uMsg)
    {
        //按钮重绘
        lpDIS = (LPDRAWITEMSTRUCT)lParam;

        // 先把按钮矩形填充为和窗口背景一致的白色，然后画一个黑色圆角矩形
        ::SelectObject(lpDIS->hDC, GetStockObject(NULL_PEN));
        ::SelectObject(lpDIS->hDC, GetStockObject(WHITE_BRUSH));

        ::Rectangle(lpDIS->hDC, 0, 0, lpDIS->rcItem.right + 1, lpDIS->rcItem.bottom + 1);
        ::SelectObject(lpDIS->hDC, GetStockObject(BLACK_BRUSH));
        ::RoundRect(lpDIS->hDC, 0, 0, lpDIS->rcItem.right + 1, lpDIS->rcItem.bottom + 1, 20, 20);

        // 当用户点击按钮的时候，绘制COLOR_HIGHLIGHT颜色的圆角矩形
        if (lpDIS->itemState & ODS_SELECTED)
        {
            SelectObject(lpDIS->hDC, GetSysColorBrush(COLOR_HIGHLIGHT));
            RoundRect(lpDIS->hDC, 0, 0, lpDIS->rcItem.right + 1, lpDIS->rcItem.bottom + 1, 20, 20);
        }
        if (lpDIS->itemState & ODS_FOCUS)
        {
            ::InflateRect(&lpDIS->rcItem, -2, -2);
            ::DrawFocusRect(lpDIS->hDC, &lpDIS->rcItem);
        }
        // 自绘按钮的文本，透明背景的白色文字
        ::SetBkMode(lpDIS->hDC, TRANSPARENT);
        ::SetTextColor(lpDIS->hDC, RGB(255, 255, 255));
        ::DrawText(lpDIS->hDC, TEXT("自绘按钮"), _tcslen(TEXT("自绘按钮")), &lpDIS->rcItem, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        // 恢复设备环境
        ::SelectObject(lpDIS->hDC, GetStockObject(BLACK_PEN));
        ::SelectObject(lpDIS->hDC, GetStockObject(WHITE_BRUSH));
    }
    else if (WM_DESTROY == uMsg)
    {
        PostQuitMessage(0);
        return 0;
    }
    return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

VOID OnDefPushButton(HWND hwnd)
{
    TCHAR szBuf[128] = { 0 };

    //查自动单选按钮 哪一项被选中了
    if (::IsDlgButtonChecked(hwnd, IDC_AUTORADIOBUTTON1) & BST_CHECKED)
    {
        ::StringCchCopy(szBuf, _countof(szBuf), TEXT("政治面貌：中共党员\n"));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTORADIOBUTTON2) & BST_CHECKED)
    {
        ::StringCchCopy(szBuf, _countof(szBuf), TEXT("政治面貌：共青团员\n"));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTORADIOBUTTON3) & BST_CHECKED)
    {
        ::StringCchCopy(szBuf, _countof(szBuf), TEXT("政治面貌：无党派人士\n"));
    }
    //查自动复选按钮中 哪一个自动复选按钮项被选中了
    ::StringCchCat(szBuf, _countof(szBuf), TEXT("个人爱好："));
    if (::IsDlgButtonChecked(hwnd, IDC_AUTOCHECKBOX1) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("看书 "));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTOCHECKBOX2) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("唱歌 "));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTOCHECKBOX3) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("听音乐"));
    }
    ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n"));
    ::StringCchCat(szBuf, _countof(szBuf), TEXT("荣誉称号："));
    //查 自动三态复选按钮 哪一个自动三态复选按钮被选中了
    if (::IsDlgButtonChecked(hwnd, IDC_AUTO3STATE1) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("团队核心 "));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTO3STATE2) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("技术能手 "));
    }
    if (::IsDlgButtonChecked(hwnd, IDC_AUTO3STATE3) & BST_CHECKED)
    {
        ::StringCchCat(szBuf, _countof(szBuf), TEXT("先进个人"));
    }
    ::StringCchCat(szBuf, _countof(szBuf), TEXT("\n"));
    ::MessageBox(hwnd, szBuf, TEXT("个人简介汇总"), MB_OK);
}
```

在`WM_CREATE`消息中，程序使用系统预定义的Button类调用`CreateWindowEx`函数分别创建了17个子窗口控件，`lpWindowName`参数对于普通重叠窗口或弹出窗口来说是窗口标题，对于按钮来说是显示在按钮上的文本;窗口位置参数x和y指定子窗口左上角的位置，相对于父窗口客户区左上角;宽
度和高度参数nWidth和nHeight指定每个子窗口的宽度和高度;因为创建的是子窗口，所以父窗口参数hWndParent指定为hwnd;对于普通重叠窗口或弹出窗口来说，hMenu参数指定菜单句柄，对于子窗口来说，则用于指定其ID，每个子窗口的ID应该是唯一的，在
`WM_COMMAND`消息中通过子窗口ID来确定是从哪个子窗口发送过来的消息。



然后调用MoveWindow函数改变3个分组框的位置和大小，让每个分组框可以包围相应的组。分组框没有什么实际意义，仅仅提供一种视觉上的分组效果。一个组的界定依靠的是`WS_GROUP`样式，一个组由第一个具有`WS_GROUP`样式的控件和在其后定义的所有控件组成，直到下一个具有`WS_GROUP`样式的控件出现。



然后程序调用`SendDlgltemMessage`函数向图标按钮和位图按钮分别发送`BM_SETIMAGE`消息设置其图像。资源脚本文件中的图标大小是32 32，而按钮大小为150 25，因此加载图标用的是`Loadlmage`函数，该函数可以指定图标的宽度和高度。资源脚本文件中的恐龙位图大小正好是150 25，所以使用`LoadBitmap`函数直接加载即可。最后一个子窗口控件是默认按钮，程序调用`SetDlgltemText`函数改变按钮文本为"获取单选复选状态"。



:::





:::details `SetWindowsText 函数说明`



`SetWindowText`函数可以设置指定程序窗口的窗口标题，也可以设置子窗口控件的文本

```c
/// <summary>
/// 设置指定程序窗口的窗口标题
/// </summary>
/// <param name="hWnd">程序窗口或控件的句柄，其文本将被更改</param>
/// <param name="lpString">新窗口标题或控件文本</param>
/// <returns></returns>
BOOL WINAPI SetWindowText(HWND hWnd,LPCTSTR lpString); 
```

也可以通过发送`WM_SETTEXT`消息达到同样的目的。但如果是设置其他程序中的窗口标题或控件文本，则需要发送`WM_SETTEXT`消息，而不能调用`SetWindowText` 

:::





:::details `GETWindowsText 函数说明`

`GetWindowText`函数用于获取指定程序窗口的窗口标题或子窗口控件的文本

```c

/// <summary>
/// 获取指定窗口的文本标题
/// </summary>
/// <param name="hWnd">程序窗口或控件的句柄</param>
/// <param name="lpString">接收文本的缓冲区</param>
/// <param name="nMaxCount">缓冲区的大小，以字符为单位</param>
/// <returns></returns>
int WINAPI GetWindowText(HWND hWnd,LPTSTR lpString,int nMaxCount);
```

也可以通过发送`WM_GETTEXT`消息达到同样的目的。但如果是获取其他程序中的窗口标题或控件文本，则需要发送`WM_GETTEXT`消息，而不能调用`GetWindowText`



在获取指定程序窗口的窗口标题或子窗口控件的文本前，可以先调用`GetWindowTextLength`函数获取其文本的长度。

```c
int WINAPI GetWindowTextLength(HWND hWnd);
```

也可以通过发送`WM_GETTEXTLENGTH`消息达到同样的目的。但如果是获取其他程序中的窗口标题或控件文本长度，则需要发送`WM_GETTEXTLENGTH`消息，而不能调用`GetWindowTextLength`.

:::





:::details `GetDlgItem 函数说明`

对于子窗口控件，`SetWindowText`和`GetWindowText`函数需要提供子窗口控件句柄，这可能需要先调用`GetDlgltem`函数获取子窗口控件句柄︰

```c
/// <summary>
/// 获取子窗口控件句柄
/// </summary>
/// <param name="hDIg">父窗口句柄</param>
/// <param name="nlDDIgltem">子窗口控件ID</param>
/// <returns></returns>
HWND WINAPI GetDlgItem(HWND hDIg,int nlDDIgltem)
```

:::



:::details `函数说明GetDlgCtrlID 函数说明`

如果已经知道了子窗口控件句柄，可以通过调用`GetDlgCtrlID`函数获取其ID∶

```c
/// <summary>
/// 获取子窗口控件ID
/// </summary>
/// <param name="hwndCtl">子窗口控件句柄</param>
/// <returns></returns>
int WINAPI GetDlgCtrlID(HWND hwndCtl);
```

当然，要获取子窗口控件ID，还可以通过指定GWLP_ID索引调用`GetWindowLongPtr`函数获取。

:::



:::details `G/SetDlgItemText 函数说明`

要获取子窗口控件文本，还有一个更简单的函数︰

```c
/// <summary>
/// 获取对话框文本内容
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDDlgltem">子窗口控件ID</param>
/// <param name="lpString">接收文本的缓冲区</param>
/// <param name="nMaxCount">缓冲区的长度，以字符为单位</param>
/// <returns></returns>
UINT  GetDlgItemText(HWND hDlg,int nlDDlgltem,LPTSTR lpString, int nMaxCount); 
```

要设置子窗口控件文本可以使用SetDlgltemText函数

```c
/// <summary>
/// 设置子窗口控件文本
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nIDDlgltem">子窗口控件ID</param>
/// <param name="lpString">字符串指针</param>
/// <returns></returns>
BOOL WINAPI SetDlgltemText(HWND hDlg, int nIDDlgltem,LPCTSTR lpString); 
```

上面这两个函数实际上也是通过发送`WM_GETTEXT`和`WM_SETTEXT`消息实现的。

:::



再介绍两个函数。要接收鼠标和键盘输入，子窗口必须是可见（显示）并且启用的。如果一个子窗口是可见的，但是没有启用，那么子窗口中的文本是灰色的。如果在创建子窗口的时候没有指定`WS_VISIBLE`样式，则子窗口将不会显示，程序可以通过调用ShowWindow函数来显示∶

```c
ShowWindow(hwndChild,SW_SHOW);
```

程序可以通过调用以下语句来隐藏一个子窗口∶

```c
ShowWindow(hwndChild,SW_HIDE);
```

可以通过调用`IsWindowVisible`函数来判断一个窗口是否可见:

```c
lsWindowVisible(hwnd);
```

可以通过调用EnableWindow函数后用或禁用指定的窗口或子窗口控件。窗口禁用以后无法接收鼠标和键盘输入:

```c
/// <summary>
/// 是否启用窗口
/// </summary>
/// <param name="hWnd">窗口或子窗口控件句柄</param>
/// <param name="bEnable">TRUE表示后用，FALSE表示禁用</param>
/// <returns></returns>
BOOL  EnableWindow(HWND hWnd,BOOL bEnable);
```

可以通过调用lsWindowEnabled函数来判断一个窗口或子窗口控件是否处于启用状态∶

```c
BOOL WINAPI lsWindowEnabled(_ln_ HWND hWnd);
```

## 系统颜色

Windows提供了几十种系统预定义的颜色，用于显示窗口、菜单栏、工具栏、滚动条、按钮等不同的部分。程序可以通过调用`GetSysColor`函数获取这些颜色值，也可以通过调用`SetSysColors`函数改变系统预定义的颜色值，但是这会影响其他程序。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/SysColors.png)



## 控件的子类化与超类化



:::details `G/SetParent 函数说明`



GetParent函数用于获取指定窗口的父窗口句柄︰

```c
HWND  GetParent(HWND hWnd);
```

与之对应的，还有一个`SetParent`函数用于设置一个窗口的父窗口∶

```c
/// <summary>
/// 指定一个窗口为自己的父窗口
/// </summary>
/// <param name="hWndChild">子窗口句柄</param>
/// <param name="hWndNewParent">新父窗口句柄</param>
/// <returns></returns>
HWND WINAPI SetParent(HWND hWndChild,HWND hWndNewParent); 
```

如果函数执行成功，则返回值是前一个父窗口的句柄。如果函数执行失败，则返回值为NULL。

:::





:::details `CallWindowsProc 函数说明`

CallWindowProc函数用于把新窗口过程未处理的消息传递给原窗口过程∶

```c

/// <summary>
/// 用于新窗口过程未处理的消息传递给原窗口过程
/// </summary>
/// <param name="lpPrevWndFunc">原窗口过程</param>
/// <param name="hWnd"></param>
/// <param name="Msg"></param>
/// <param name="wParam"></param>
/// <param name="lParam"></param>
/// <returns></returns>
LRESULT  CallWindowProc(WNDPROC lpPrevWndFunc, HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);
```

:::





重叠窗口中子窗口控件的默认窗口过程无法满足我们的要求，为此调用SetWindowLongPtr函数为子窗口控件设置一个新的窗口过程。拦截控件的部分消息进行处理，这就是**控件的子类化**。





:::details `S/Get/RemoveWindowSubclass 函数说明`

`SetWindowSubclass`函数为需要子类化的窗口设置新的窗口过程

```c
/// <summary>
/// 设置子窗口控件的窗口过程
/// </summary>
/// <param name="hWnd">要子类化的窗口句柄</param>
/// <param name="pfnSubclass">指向新子类窗口过程的指针</param>
/// <param name="uldSubclass">子类ID，该参数与pfnSubclass参数一起唯一标识一个子类</param>
/// <param name="dwRefData">用户自定义数据，传递给新子类窗口过程的dwRefData参数</param>
/// <returns></returns>
BOOL SetWindowSubClass(HWND hWnd, SUBCLASSPROC pfnSubclass,UINT_PTR uldSubclass, DWORD_PTR dwRefData); 
```

`SetWindowSubclass`函数需要引入头文件`CommCtrl.h`，还需要使用导入库`Comctl32.lib`。在引入相关头文件以后，添加以下预编译指令。

```c
#include <Commctrl.h>
#pragma comment(lib, "Comctl32.lib")
```

要获取子类窗口的自定义数据，可以调用`GetWindowSubclass`函数∶

```c
/// <summary>
/// 获取子类窗口的自定义数据
/// </summary>
/// <param name="hWnd"子类窗口句柄></param>
/// <param name="pfnSubclass">子类窗口过程</param>
/// <param name="uldSubclass">子类ID</param>
/// <param name="pdwRefData">在这里返回自定义数据的指针</param>
/// <returns></returns>
BOOL GetWindowSubclass(HWND hWnd,SUBCLASSPROC pfnSubclass, UINT_PTR uldSubclass,DWORD_PTR* pdwRefData);
```

:::





:::details `RemoveWindowSubclass 函数说明`

`RemoveWindowSubclass`函数用于删除一个子类

```c

/// <summary>
/// 删除一个子类
/// </summary>
/// <param name="hWnd">窗口句柄</param>
/// <param name="pfnSubclass"> 子类ID</param>
/// <param name="uldSubclass">子类窗口过程</param>
/// <returns></returns>
BOOL RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass,UINT_PTR uldSubclass); 
```

:::



## 命令链接按钮与拆分按钮



:::tip 命令链接按钮

命今链接按钮是通用控件版本6中引入的一种按钮。指定`BS_COMMANDLINK`样式可以创建一个命今链接按钮，左侧有一个蓝色箭头指向按钮文本，按钮文本下面可以显示一些说明文字作为按钮文本的补充。要设置按钮文本，可以通过调用`SetWindowText/SetDlgltemText`函数或发送`WM_SETTEXT`消息来进行。要设置说明文字，可以通过发送`BCM_SETNOTE`消息来进行，该消息的`wParam`参数没有用到，将`IParam`参数指定为字符串指针。

:::





:::tip 

拆分按钮也是通用控件版本6中引入的一种按钮。指定`BS_SPLITBUTTON`样式可以创建一个拆分按钮。拆分按钮分为两部分，左侧是主要部分，类似于普通或默认按钮﹔右侧有一个下拉箭头，单击箭头通常会弹出一个菜单。单击下拉箭头，系统会发送包含`BCN_DROPDOWN`通知码的`WM_NOTIFY`消息。和其他按钮一样，单击命合链接按钮和拆分按钮的左侧会发送包含`BN_CLICKED`通知码的`WM_COMMAND`消息。

:::



:::details `拆分按钮的WM_NOTIFY消息`



`WM_NOTIFY`消息的`wParam`参数是控件的ID，不过通常不使用这个参数，而是使用`IParam`参数。`lParam`参数通常是一个指向`NMHDR`结构的指针，该结构包含通知码和一些附加信息。



对于其他通知码，`lParam参`数可能是指向一个更大结构的指针，但是这些结构的第一个字段总是NMHDR结构，所以把`lParam`参数强制转换为指向NMHDR结构的指针总是正确的。NMHDR结构定义如下∶

```c
typedef struct tagNMHDR
{
	HWND hwndFrom;//控件的窗口句柄
	UINT_PTR idFrom; // 控件的ID
	UINT code; // 通知码
} NMHDR;
```



处理`WM_NOTIFY`消息的代码通常如下，先把`IParam`参数转换为指向`NMHDR`结构的指针，确定通知码的类型，然后才可以进一步确定`lParam`指向的是什么结构∶

```c
case WM_NOTIFY:
{ 
    switch ((LPNMHDR)IParam)->code)
    {
    case BCN_DROPDOWN:
        // BCN_DROPDOWN通知码的IParam参数是一个指向NMBCDROPDOWN结构的指针把lParam参数转换为指向NMBCDROPDOWN结构的指针，然后使用结构中的字段
            break;
    case 其他通知码:
       //对于其他通知码，lParam参数可能是指向其他数据结构的指针
            break;
}
return 0;
```

如果程序需要发送`WM_NOTIFY`消息，`SendMessage`函数的窗口句柄参数需指定为父窗口句柄，例如:

```c
NMHDR nmh;
nmh.hwndFrom = hwndCtrl;//控件窗口句柄
nmh.idFrom = GetDlgCtrlID(hwndCtrl); //控件ID
nmh.code = 通知码; //通知码
SendMessage(GetParent(hwndCtrl), WM_NOTIFY, nmh.idFrom, (LPARAM)&nmh);
```

`BCN_DROPDOWN`通知码的`IParam`参数是一个指向`NMBCDROPDOWN`结构的指针。

```c
typedef struct tagNMBCDROPDOWN
{
	NMHDR hdr;
	RECT rcButton;// 按钮的矩形区域，相对于自己的客户区左上角
}NMBCDROPDOWN,*LPNMBCDROPDOWN;
```

:::





:::details `示例:`

举一个例子，单击拆分按钮的下拉箭头，系统会发送一个包含
BCN_DROPDOWN通知码的WM_NOTIFY消息。程序处理该消息弹出一个菜单。

```c
#include <Windows.h>
#include <Commctrl.h>
#include "resource.h"
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker, "\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("CommandLinkAndSplitButton");    
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR));
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        if (!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HINSTANCE hInstance;
    NMBCDROPDOWN* pDropDown;
    switch (uMsg)
    {
    case WM_CREATE:
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;

        CreateWindowEx(0, TEXT("Button"), TEXT("命令链接按钮"),
            WS_CHILD | WS_VISIBLE | BS_COMMANDLINK, 10, 10, 200, 50, hwnd,
            (HMENU)IDC_COMMANDLINK, hInstance, NULL);
        SendDlgItemMessage(hwnd, 1000, BCM_SETNOTE, 0, (LPARAM)TEXT("这是一个命令链接按钮"));

        CreateWindowEx(0, TEXT("Button"), TEXT("拆分按钮"),
            WS_CHILD | WS_VISIBLE | BS_SPLITBUTTON, 10, 70, 200, 30, hwnd,
            (HMENU)IDC_SPLITBUTTON, hInstance, NULL);
        return 0;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case ID_EDIT_CUT:
            MessageBox(hwnd, TEXT("ID_EDIT_CUT"), TEXT("提示"), MB_OK);
            break;
        case ID_EDIT_COPY:
            MessageBox(hwnd, TEXT("ID_EDIT_COPY"), TEXT("提示"), MB_OK);
            break;
        case ID_EDIT_PASTE:
            MessageBox(hwnd, TEXT("ID_EDIT_PASTE"), TEXT("提示"), MB_OK);
            break;

        case IDC_COMMANDLINK:
            MessageBox(hwnd, TEXT("点击了命令链接按钮"), TEXT("提示"), MB_OK);
            break;
        case IDC_SPLITBUTTON:
            MessageBox(hwnd, TEXT("点击了拆分按钮"), TEXT("提示"), MB_OK);
            break;
        }
        return 0;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case BCN_DROPDOWN:
            pDropDown = (NMBCDROPDOWN*)lParam;
            if (pDropDown->hdr.hwndFrom = GetDlgItem(hwnd, IDC_SPLITBUTTON))
            {
                POINT pt;
                HMENU hMenu;
                pt.x = pDropDown->rcButton.left;
                pt.y = pDropDown->rcButton.bottom;
                // 拆分按钮的矩形客户区坐标转换为屏幕坐标
                ClientToScreen(pDropDown->hdr.hwndFrom, &pt);
                hMenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDR_MENU));
                TrackPopupMenu(GetSubMenu(hMenu, 0), TPM_LEFTALIGN | TPM_TOPALIGN, 
                    pt.x, pt.y, 0, hwnd, NULL);
            }
            break;
        }
        return 0;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240623170905457.png)

:::



## 编辑控件

编辑控件通常叫作编辑框或文本框，是一个矩形窗口，可以用于输入和编辑文本，编辑控件的应用比较广泛。



:::details `编辑控件样式表`

|       样式       |                             含义                             |
| :--------------: | :----------------------------------------------------------: |
|  `ES_MULTILINE`  | 编辑控件默认为单行编辑控件，指定ES_MULTILIE样式表示创建一个多行编辑控件 |
| `ES_AUTOHSCROLL` | 对于单行编辑控件。当用户输入文本时，如果文本字数填满了编辑控件，则无法维续输入。指定该样式以后。在必要时编辑控件会自动水平滚动。这样一来用户输入的文本字数就不受编辑控件的长度影响。对于多行编辑控件，如果没有指定然S_ATOHBSCDOL样式。当用户输入的文本多于可在单行上显示的字数时，文本将自动换行显示到下一行﹔如果指定了ES_AUTOHSCROLL样式，则当用户输入的文本多于可在单行上显示的字数时，控件将自动水平滚动，文字不会换行 |
| `ES_AUTOVSCROLL` | 仅适用于多行编辑控件。如果没有指定该样式。当用户输入的文本行数高于‘编辑控件的高度时，无法继续输入。在指定该样式后，在必要时的编辑控件会自动垂直滚动，这样一来用户输入的文本行数就不受编辑控件的高度影响 |
|    `ES_LEFT`     |                    文本在编辑控件中左对齐                    |
|    `ES_RIGHT`    |                    文本在编辑控件中右对齐                    |
|   `ES_CENTER`    | 文本在编辑控件中居中对齐.右对齐和居中对齐的多行编辑控件不能具有ES_AUTOHSCROLL样式，即不能自动水平滚动，超过一行限制以后会自动换行显示 |
|  `ES_LOWERCASE`  |                输入的所有大写字母都转换为小写                |
|  `ES_UPPERCASE`  |                输入的所有小写字母都转换为大写                |
|   `ES_NUMBER`    |                   只能在编辑控件中输入数字                   |
|  `ES_READONLY`   |        将编辑控件设置为只读模态,不允许编辑其中的文本         |
|  `ES_PASSWORD`   | 将单行编辑控件中的所有字符显示为星号，版本6中显示为黑圆圈〈如果需要显示为其他字符﹐可以通过发送`EM_SETPASSWORDCHAR`消息进行设置，该样式通常用于密码一类的敏感信息 |
|  `ES_NOHIDESEL`  | 默认情况下，当编辑控件失去输入焦点时，所选中的文本会失去突出显示。在指定该样式后，即使编辑控件失去输入焦点，所选中的文本也会突出显示 |
| `ES_WANTRETURN`  | 对于对话框程序中的多行编辑控件，如果没有指定ES_WANTRETURN样式，当用户按下`Enter`键时。不会换行，不过可以按`Ctrl +Enter`组合键进行换行。在指定该样式后，按下`Enter`键就可以换行。 |

默认情况下，编辑控件是没有边框的，可以指定WS_BORDER窗口样式为其添加一个边框。当然，`WS_CHILD |WS_VISIBLE`窗口样式是子窗口控件必不可少的。如果需要为编辑控件添加水平或垂直滚动条，可以指定`WS_HSCROLL`或`WS_VSCROLL`窗口样式。





系统在创建编辑控件时，会自动创建文本缓冲区，并设置其初始大小，默认情况下最大缓冲区大小约为32KB个字符，有时候可能需要限制用户输入。比如有一个用户名文本框，可能想限制用户最多可以输入20个字符，有时候可能需要比32KB更大的缓冲区，可以通过向编辑控件发送`EM_SETLIMITTEXT`(和`EM_LIMITTEXT`相同）消息来设置缓冲区大小，将`wParam`参数指定为最大字符数，没有用到`lParam`参数。



对于单行编辑控件，可以设置的最大字符数为Ox7FFFFFFE(约2G);

对于多行编辑控件，可以设置为系统支持的最大大小，如果`wParam`参数为0，则表示使用可用的最大大小。

:::





对于每个编辑控件，系统维护一个**只读标志**，指示控件的文本是可读可写(默认）或只读，可以通过向控件发送`EM_SETREADONLY`消息来设置文本的可读可写或只读标志，`wParam`参数为TRUE表示只读,FALSE表示可读可写，没有用到`lParam`参数。



确定编辑控件是否为只读，而没有名为`EM_GETREADONLY`的消息，可以使用
`GWL_STYLE`常量调用`GetWindowLongPtr`函数获取控件样式(`ES_READONLY`) 。





:::tip 设置编辑控件的文本



可以通过调用`SetWindowText/SetDlgltemText`函数或发送`WM_SETTEXT`消息来设置编辑控件的文本，这几个设置窗口文本的方法对于所有窗口几乎都适用。当然，还有` GetWindowText / GetDlgltemText`和`WM_GETTEXT`消息。



:::





有时候需要把一个数值型数据显示到编辑控件中，或者从编辑控件中获取一个字符串作为数值型使用，将文本转换为数值或将数值转换为文本需要额外的函数调用。为了简化操作，Windows提供了两个函数来处理这个问题。





:::details `SetDlgltemInt 函数说明`



`S/GetDlgltemInt`函数可以把一个数值型数据显示到编辑控件中

```c
/// <summary>
/// 把一个数值型数据显示到编辑控件中
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDDlgltem">编辑控件ID</param>
/// <param name="uValue">数值型数据</param>
/// <param name="bSigned">指示uValue参数是有符号还是无符号数</param>
/// <returns></returns>
BOOL  SetDlgItemInt(HWND hDlg, int nlDDlgltem,UINT uValue, BOOL bSigned);
```

- 参数`bSigned`指示uValue参数是有符号数还是无符号数。如果该参数为TRUE且uValue小于0，则在编辑控件中的第一个数字之前会添加-个减号﹔如果该参数为FALSE，则把uValue视为无符号数。

```c

/// <summary>
/// 获取一个字符串并返回数值型
/// </summary>
/// <param name="hDlg">父窗口句柄</param>
/// <param name="nlDDlgltem">编辑控件ID</param>
/// <param name="lpTranslated">函数执行成功还是失败，返回TRUE表示成功FALSE表示失败</param>
/// <param name="bSigned">是否检查编辑控件中的字符串开头有没有减号</param>
/// <returns></returns>
UINT  GetDlgltemInt(HWND hDlg, int nlDDlgltem, BOOL* lpTranslated,BOOL bSigned);
```

- 参数`bSigned`表示是否检查编辑控件中的字符串开头有没有减号。如果该参数为TRUE并且在字符串开头发现了减号，则返回有符号整数值，在这种情况下需要把返回值强制转换为int类型;否则返回无符号整数值。
- 因为函数返回值是从编辑控件中获取到的十进制数值，所以通过参数`lpTranslated`表示函数执行结果，返回TRUE表示成功，FALSE表示失败。如果不需要检查函数执行成功还是失败，可以将该参数设置为NULL

:::



除了上面介绍的消息，下表所示的消息也可以用于编辑控件，不过这些消息**通常用于多行编辑控件**。多行编辑控件可以用于实现一个简单的文本编辑器。





:::details `多行文本控件样式表`

|     消息类型      |                             含义                             |
| :---------------: | :----------------------------------------------------------: |
|     `EM_UNDO`     | 撤销最近—次的编辑操作，即除刚刚插入的文本或恢复刚刚已删除的文本，例如:`SendMessage (hwndEdit,EM_UNDO,0,0);` |
|   `EM_CANUNDO`    | 编辑控件的撤销队列是否不为空，即能不能撤销上次的扁辑操作，如果可以，返回TRUE，例如:`bResult = SendMessage(hwndEdit,EM_CANUNDo,0,0) ;` |
| `EM_GETLINECOUNT` | 获取多行编辑控件的总行数，例如:`nCount = SendMessage(hwndEdit，EM_GETLINECOUNT，0，0);` |
|  `EM_LINELENGTH`  | 对于单行编辑控件`wParam`和 `lParam`参数都没有用到，直接返回单行编辑控件中的字符个数，不包含终止空字符；                                                                           对于多行编辑控件。`wParam`指定为一个字符的字符索引（第1行第1个字符索引为0)，没有用到lParam参数，返回指定字符所在行的字符个数，比如说下面的多行编辑控件:![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240123222036685-17191526236041.png) |
|  `EM_LINELENGTH`  | ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240123222209532-17191526582182.png) |
|   `EM_GETLINE`    | 将单行编辑控件中的文本复制到指定的缓冲区并返回复制的字符数，不包含终止空字符; 对于多行编辑控件，则是复制指定行的文本并返回复制的字符数，不包含终止空字符。没有用到wParam参数，lParam参数指定为缓冲区指针;对于多行编辑控件，wParam参数指定为从0开始的行号，lParam参数指定为缓冲区指针。需要注意的是因为返回的文本不包括终止空字符，所以缓冲区应该清零，另外在发送消息前，缓冲区第一个字符必须设置为缓冲区的长度。例如 |
|  `EM_LINEINDEX`   | 获取多行编辑控件中指定行的第1个字符的字符索引，该消息与EM_LINEFROMCHAR消息相反，例如:![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240124190806537.png) |
| `EM_LTHEFEOMCHAR` | 用于多行编辑控件，返回指定字符索引的字符所在行的行索引。该消息与`EM_LINEINDEX`消息相反 |
|  `EM_GETMODIFY`   | 编辑控件的内容是否已经被修改，如果已修改返回TRUE，否则返回FAISE，例如:`bResult = SendMessage(hwndEdit,EM_GETMODIFY，0，0);` |
|    `EM_SETSEL`    | 通过指定一段字符的开始和结束位置〈字符索引〉﹐在编辑控件中选中一段文字，例如: ![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240124191504295-17060949052582-17191527733803.png) |
|    `EM_SETSEL`    | 即包括开始位置。但不包括结束位置。                                                                  如果开始位置为0且结束位置为-1，则选中编辑控件中的所有文本.                          如果开始位置为-1，则取消当前选中。                                                                        选中文本以后。控件会在结束位置显示闪烁的光标。如果开始和结束位置为相同的值，则会移动光标到此处，这是设置光标位置的一种方法。 |
|    `EM_GETSEL`    | 返回编辑控件中当前所选中文本的开始和结束位置，例如:`DWORD dwResult;DWORD dwStart, dwEnd;dwResult = SendMessage(hwndEdit，EM_GETSEL，(WPARAM) &dwStart,(LPARAM)dwEnd);` 在dwStart和dwEnd中返回当前选中文本的开始和结束位置（字符索引），结束位置是选中的最后一个字符的索引加1，该消息的返回值是DWORD类型，LOWORD(dwResult) 等于开始位置，HIWORD(dwResult)等于结束位置，如果没有选中文本，则开始和结束位置都是光标的位置。 |
|  `EM_REPLACESEL`  | 将当前选中的文本替换为指定的的文本,例如：`SendMessage(hwndEidt,EM_REPLACESET,TRUE,(LPARAM)szStr)` wParam参教可以指定为TRUE或FALSE，表示是否可以撤销本次替换操作。如果指定为TRUE:则表示可以撤销操作﹔如果指定为FALSE，则表示无法撤销操作；lParam参数指定为要替换的字符串，如果没有选中的文本，则将lParam参数指定的字符串插入光标位置。 |
| `EM_SCROLLCARET`  | 在编辑控件中将光标滚动到可见视图中，在设置选中区域〈或改变了光标位置〉后，这个区域可能落在客户区的外面，用户看不到它。如果希望控件能够滚动已将新位置的内容落在客户区中，可以发送`EM_SCROLLCREAT` 消息，例如:`SendMessage(hwndEdit,EM_SCROLLCREAT,0,0)` |
|     `WM_COPY`     | 复制当前选中的内容到剪贴板(如果样式为ES_PASSWORD，则不支持该消息)，例如:`SendMessage(hwndEdit,WM_COPY,0,0)` |
|     `WM_CUT`      | 删除编辑控件中当前选中的内容，并把当前选中的内容以CF_TEXT格式复制到剪贴板，例如:`SendMessage(hwndEdit,WM_CUT,0,0)` |
|    `WM_PASTE`     | 把剪贴板中CF_TEXT格式的内容插入编辑控件的光标位置,例如:`SendMessage(hWndEdit,WM_PAUSE,0,0)` |
|    `WM_CLEAR`     | 删除编辑控件中当前选中的内容，如果当前没有选中文本，则删除光标右侧的字符，例如:`SendMessage(hwndEdit,WM_CLEAR,0,0)` |
|     `WM_UNDO`     | 撤销最近—次的编辑操作，即删除刚刚插入的任何文本或恢复刚刚已删除的文本，例如:`SendMessage(hwndEdit,WM_UNDO,0,0)` |

> 编辑控件的通知码以WM_COMMAND消息的形式发送给父窗口，常见的通知码如下表所示：



**通知码含义**

- EN_SETFOCUS 编辑控件获得了输入焦点
- EN_KILLFOCUS 编辑控件失去了输入焦点
- EN_UPDATE 编辑控件的内容将变化
- EN_CHANGE 编辑控件的内容已变化。

如果是多行编辑控件，并且是通过程序代码（例如SetWindowText SetDlgltemTextSetDlgltemInt等)改变了多行编辑控件的内容，则不会收到EN_CHANGE和EN_UPDATE这两个通知码。

- EN_ERRSPACE 编辑控件的缓冲区已满
- EN _MAXTEXT  编辑控件已经没有空间完成文本插入
- EN_HSCROLL   编辑控件的水平滚动条被单击
- EN_VSCROLL   编辑控件的垂直滚动条被单击



系统自带的记事本程序实际上用的就是Edit多行编辑控件。如果需要实现一个文本编辑器，那么建议学习功能更加强大的RichEdit富文本控件。本节的知识点几乎能适用于RichEdit控件，RichEdit控件提供了更多的功能。

:::





:::details `单行文本控件示例效果:`

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/WIN32UI%E6%8E%A7%E4%BB%B6%E7%BC%96%E8%BE%91%E6%A1%86.gif)

:::



:::details  `resource.h`

```c
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 EditDemo.rc 使用
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

:::



:::details `main.cpp`

```c
#include <Windows.h>
#include <Commctrl.h>
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker, "\"/manifestdependency:type='win32' \
    name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
    processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    WNDCLASSEX wndclass;
    TCHAR szAppName[] = TEXT("EditDemo");
    HWND hwnd;
    MSG msg;
    wndclass.cbSize = sizeof(WNDCLASSEX);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = NULL;
    RegisterClassEx(&wndclass);
    hwnd = CreateWindowEx(0, szAppName, szAppName, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    while (GetMessage(&msg, NULL, 0, 0) != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HINSTANCE hInstance;
    static HWND hwndUserName, hwndPassword, hwndAge, hwndRegister;
    static HWND hwndStatic[4];
    static HFONT hFont;
    int cx, cy;
    RECT rect;
    if (WM_CREATE == uMsg)
    {
        hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        hFont = CreateFont(12, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET, 0, 0, 0, 0, TEXT("宋体"));
        //==========================构建UI布局============================================
        hwndStatic[0] = CreateWindowEx(
            0, TEXT("Static"),
            TEXT("会员注册"), WS_CHILD | WS_VISIBLE | SS_CENTER,
            130, 20, 80, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        // 用户名
        hwndStatic[1] = CreateWindowEx(
            0, TEXT("Static"), TEXT("用户名："),
            WS_CHILD | WS_VISIBLE, 20, 50, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndUserName = CreateWindowEx(
            0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL,
            80, 50, 220, 20, hwnd, (HMENU)(1000), hInstance, NULL);
        // 密码
        hwndStatic[2] = CreateWindowEx(
            0, TEXT("Static"),
            TEXT("密  码："),
            WS_CHILD | WS_VISIBLE, 20, 75, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndPassword = CreateWindowEx(0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_PASSWORD,
            80, 75, 180, 20, hwnd, (HMENU)(1001), hInstance, NULL);
        // 年龄
        hwndStatic[3] = CreateWindowEx(
            0, TEXT("Static"), TEXT("年  龄："),
            WS_CHILD | WS_VISIBLE, 20, 100, 60, 20, hwnd, (HMENU)(-1), hInstance, NULL);
        hwndAge = CreateWindowEx(
            0, TEXT("Edit"), NULL,
            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL | ES_NUMBER,
            80, 100, 180, 20, hwnd, (HMENU)(1002), hInstance, NULL);
        // 注册按钮
        hwndRegister = CreateWindowEx(
            0, TEXT("Button"), TEXT("注册"),
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_NOTIFY | WS_TABSTOP,
            85, 130, 150, 25, hwnd, (HMENU)(1003), hInstance, NULL);
        //==========================构建UI布局============================================



        // 设置所有控件的字体为宋体
        SendMessage(hwndUserName, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndPassword, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndAge, WM_SETFONT, (WPARAM)hFont, FALSE);
        SendMessage(hwndRegister, WM_SETFONT, (WPARAM)hFont, FALSE);
        for (int i = 0; i < _countof(hwndStatic); i++)
        {
            SendMessage(hwndStatic[i], WM_SETFONT, (WPARAM)hFont, FALSE);
        }
        // 用户名、密码、年龄分别限制输入20、12、3个字符
        SendMessage(hwndUserName, EM_SETLIMITTEXT, 20, 0);
        SendMessage(hwndPassword, EM_SETLIMITTEXT, 12, 0);
        SendMessage(hwndAge, EM_SETLIMITTEXT, 3, 0);
        // 设置程序窗口大小，客户区所需最小大小为320 * 175
        SetRect(&rect, 0, 0, 320, 175);
        AdjustWindowRectEx(&rect, GetWindowLongPtr(hwnd, GWL_STYLE), GetMenu(hwnd) != NULL, GetWindowLongPtr(hwnd, GWL_EXSTYLE));
        SetWindowPos(hwnd, NULL, 0, 0, rect.right - rect.left, rect.bottom - rect.top, SWP_NOZORDER | SWP_NOMOVE);
    }
    else if (uMsg == WM_SIZE)
    {
        //如果说当前窗口大小被拉大，则对应调整控件的位置
        if (LOWORD(lParam) > 320 && HIWORD(lParam) > 175)
        {
            cx = (LOWORD(lParam) - 320) / 2;
            cy = (HIWORD(lParam) - 175) / 2;
            SetWindowPos(hwndStatic[0], NULL, 130 + cx, 20 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndStatic[1], NULL, 20 + cx, 50 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndStatic[2], NULL, 20 + cx, 75 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndStatic[3], NULL, 20 + cx, 100 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndUserName, NULL, 80 + cx, 50 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndPassword, NULL, 80 + cx, 75 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndAge, NULL, 80 + cx, 100 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            SetWindowPos(hwndRegister, NULL, 85 + cx, 130 + cy, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
        }
        return 0;
    }
    else if (uMsg == WM_DESTROY)
    {
        DeleteObject(hFont);
        PostQuitMessage(0);
        return 0;
    }
    else if (uMsg == WM_CTLCOLORSTATIC)
    {
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);
    }
    else if (uMsg == WM_COMMAND)
    {
        if (HIWORD(wParam) == BN_CLICKED)
        {
            if (LOWORD(wParam) == 1003)
            {
                int nLen;
                LPTSTR lpUserName, lpPassword;
                TCHAR szBuf[64] = { 0 };

                //查用户输入用户名的字符个数 做校验
                nLen = SendMessage(hwndUserName, EM_LINELENGTH, 0, 0);
                if (nLen < 3)
                {
                    MessageBox(hwnd, TEXT("用户名至少需要3个字符"), TEXT("错误提示"), MB_OK);
                    return 0;
                }
                //根据字符长度，动态分配内存，并初始化。
                lpUserName = new TCHAR[nLen + 1];
                ZeroMemory(lpUserName, (nLen + 1) * sizeof(TCHAR));
                lpUserName[0] = nLen + 1;
                //存用户名编辑框的输入
                SendMessage(hwndUserName, EM_GETLINE, 0, (LPARAM)lpUserName);
               //查用户输入的密码字符个数 做校验
                nLen = SendMessage(hwndPassword, EM_LINELENGTH, 0, 0);
                if (nLen < 3)
                {
                    MessageBox(hwnd, TEXT("密码至少需要3个字符"), TEXT("错误提示"), MB_OK);
                    return 0;
                }
                //同理，存密码编辑框的输入
                lpPassword = new TCHAR[nLen + 1];
                ZeroMemory(lpPassword, (nLen + 1) * sizeof(TCHAR));
                lpPassword[0] = nLen + 1;
                SendMessage(hwndPassword, EM_GETLINE, 0, (LPARAM)lpPassword);
                //进行一个信息输出，年龄直接用更上层的函数也行，底层也是走SendMessage...再string=> int
                wsprintf(szBuf, TEXT("用户名：%s\n密  码：%s\n年  龄：%d"),
                    lpUserName, lpPassword,
                    GetDlgItemInt(hwnd, 1002, NULL, FALSE));
                MessageBox(hwnd, szBuf, TEXT("注册信息"), MB_OK);
                delete[] lpUserName;
                delete[] lpPassword;
            }
        }
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

“会员注册"“用户名""密码"和“年龄"这些文本用的都是Static类静态控件。静态控件后面再讲。因为用不到这些静态控件的ID，所以静态控件的ID我都设置为-1。至于静态控件、编辑控件和按钮控件摆放的位置，读者可以自己设计，这不是重点。在WM_CREATE消息中，创建所有控件以后，发送WM_SETFONT消息设置所有控件的字体;发送EM_SETLIMITTEXT消息设置用户名，且分别限制密码、年龄3个编辑控件输入20 12 3个字符。调用`AdjustWindowRectEx`函数设置程序窗口大小。
在`WM_COMMAND`消息中，要获取用户名和密码字符串，首先发`EM_LINELENGTH`消息确定字符串的长度，然后分配缓冲区，发送EM_GETLINE消息获取字符串，要获取年龄则直接调用`GetDlgItemInt`函数得到无符号数值型，然后通过`wsprintf`函数格式化。当然,使用`GetWindowText / GetDlgltemText或WM_GETTEXT`消息获取编辑控件的文本字符串也完全可以。



:::details WM_CTLCOLORSTATIC 消息

另外需要介绍的是`WM_CTLCOLORSTATIC`消息。默认情况下静态控件有一个灰色背景，而程序客户区的背景是白色，因此应该将静态控件的背景颜色设置为白色。在绘制静态控件以前，系统会发送WM_CTLCOLORSTATIC消息到静态控件的父窗口。该消息的wParam参数是静态控件窗口对应的DC句柄，IParam参数是静态控件的窗口句柄。程序可以调用SetTextColor函数设置文本颜色，调用SetBkColor函数设置文本的背景颜色等，最后返回一个画刷句柄，静态控件会使用这个画刷来擦除背景。本例对WM_CTLCOLORSTATIC消息的处理，仅仅是通过调用GetSysColorBrush函数返回一个白色画刷。



常用的类似消息如下表所示。



**消息类型针对的控件类型**

|          消息          |                          针对的控件                          |
| :--------------------: | :----------------------------------------------------------: |
|  `WM_CTLCOLORSTATIC`   | 静态控件和只读或禁用的编辑控件（正常状态的编辑控件不会收到该消息，而是收到WM_CTLCOLOREDIT消息) |
|   `WM_CTLCOLOREDIT`    |                    非只读或禁用的编辑控件                    |
|    `WM_CTLCOLORBTN`    |   自绘按钮(但是对于自绘按钮，通常处理的是WM_DRAWITEM消息)    |
|  `WM_CTLCOLORLISTBOX`  |                            列表框                            |
| `WM_CTLCOLORSCROLLBAR` |                          滚动条控件                          |
|    `WM_CTLCOLORDLG`    |                            对话框                            |

后面5个消息的wParam和lParam参数的含义和`WM_CTLCOLORSTATIC`消息完全相同

- wParam参数是控件对应的DC句柄，

- IParam参数是控件的窗口句柄。

  例如下面的代码

```c
    else if (uMsg == WM_CTLCOLOREDIT)
    {
        if ((HWND)lParam == hwndUserName)
        {
            //设置编辑框控件文本颜色为白色
            SetTextColor((HDC)wParam, RGB(255, 255, 255));

            //设置编辑框背景为黑色
            SetBkColor((HDC)wParam, RGB(0, 0, 0));
            HBRUSH hbrBkgnd = CreateSolidBrush(RGB(0, 0, 0));
            return (LRESULT)hbrBkgnd;
        }
    }
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%BE%91%E6%A1%86%E9%A2%9C%E8%89%B2-17060989253541.gif)





注意啊，`WM_CTLCOLOR***`消息中调用SetTextColor函数对于禁用编辑控件的设置文本颜色是无效的。

:::



## 列表框

列表框也是经常使用的子窗口控件，包含可供用户选择的项目列表，用户可以从中选择一个或多个项目。如果列表框不够大，显示不了所有列表项，则列表框可以显示一个滚动条。另外，每一个列表项都可以设置一个与之关联的32位数据，称为项目数据，可以设置为指向某些自定义数据的指针。普通的列表框效果如下图所示。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240623225338787.png)





:::details 列表框控件常用样式



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240623225515764.png)



:::





:::details `WM_COMMAND 消息`

当列表框中发生事件时，系统会以`WM_COMMAND`消息的形式向父窗口发送通知码，常见的通知码如下所示：

|       宏        |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
| `LBN_SETFOCUS`  |                     列表框获取了键盘焦点                     |
| `LBN_KILLFOCUS` |                     列表框失去了键盘焦点                     |
| `LBN_SELCHANGE` | 列表框中的选择已更改，通常是在用户单击一个列表项的时候发生，用户按下方向键改变选择或键盘焦点的时候也会发送该通知码。如果是通过发送LB_SETSEL LB_SETCURSEL LB_SELECTSTRING LB_SELITEMRANGE或 LB_SELITEMRANGEEX消息更改了选择，则不会发送该通知码，即如果是程序代码更改了选中项，就不会收到LBN_SELCHANGE通知码 |
|  `LBN_DBLCLK`   |                   双击列表框中的某个列表项                   |
| `LBN_SELCANCEL` | 取消选中列表框中的某个列表项LBN_ERRSPACE列表框无法分配足够的内存来完成请求 |

:::





列表项的添加、删除、查询等都是通过发送消息来实现的。列表项的位置索引是从0开始的，列表框中第1个列表项的索引为0，第2个列表项的索引为1，以此类推。





:::details `列表框消息`

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240623230115556.png)



总结一下，调用`CreateWindow / CreateWindowEx`函数创建列表框控件后，列表框中还没有列表项，需要发送`LB_ADDSTRING/ LB_INSERTSTRING`消息添加列表项。要删除一个

列表项可以发送`LB_DELETESTRING`消息，要清空列表框可以发送`LB_RESETCONTENT`消息，要获取一个列表项的文本可以发送`LB_GETTEXTLEN` `LB_GETTEXT`消息，可以发送`LB_SETITEMDATA`消息为每个列表项设置一个关联的项目数据，要获取与列表项关联的项目数据可以发送`LB_GETITEMDATA`消息，要获取一个列表项的选中
状态可以发送`LB_GETSEL`消息，根据字符串查找一个列表项可以发送`LB_FINDSTRING/ LB_FINDSTRINGEXACT`消息，获取列表框中的列表项总数可以发送`LB_GETCOUNT`消息。









对于单选列表框∶可以发送`LB_SETCURSEL`或`LB_GETCURSEL`消息来设置或获取当前选中项。另外，`LB_SELECTSTRING`消息也是针对单选列表框的。





对于多选列表框∶要选中或取消选中一个列表项可以发送`LB_SETSEL`消息，要选中或取消选中一片连续的列表项可以发送`LB_SELITEMRANGE`消息，要获取所有选中项的索引可以发送`LB_GETSELCOUNT` `LB_GETSELITEMS`消息。



:::



:::details `拖动列表框`

拖动列表框允许用户将列表项从一个位置拖动到另一个位置，以改变排列顺序。拖动列表框仅用于单选列表框。如果想让一个列表框可以拖动，在创建列表框控件以后，则需要调用`MakeDragList(hwndListBox);`函数将其更改为拖动列表框。



调用`MakeDragList`函数时系统会定义拖动列表消息。当发生拖动事件时，系统会向拖动列表框的父窗口发送拖动列表消息，父窗口必须处理拖动列表消息。拖动列表消息的ID值是多少呢?拖动列表消息的具体值还没有确定，程序可以通过注册消息的方式获取这个值，



调用`RegisterWindowMessage (DRAGLISTMSGSTRING)`;函数会返回一`0xC000`～`0xFFFF`范围内的消息ID，该消息ID在整个系统中是唯一的。`DRAGLISTMSGSTRING`是一个常量，在CommCtrl.h头文件中定义如下∶

```c
#define DRAGLISTMSGSTRING TEXT("commctrl_DragListMsg")
```

有了**拖动列表消息ID**，就可以在窗口过程中处理该消息。例如下面的代码∶

```c
        static UINT WM_DRAGLIST;
        // 更改为拖动列表框
        MakeDragList(hwndListBox);
        WM_DRAGLIST = RegisterWindowMessage(DRAGLISTMSGSTRING);
```

**拖动列表消息**的wParam参数是拖动列表框的控件ID，IParam参数是一个指向DRAGLISTINFO结构的指针，其中包含拖动事件的通知码和其他信息，拖动列表消息的返回值取决于具体的通知码。



`DRAGLISTINFO`结构在CommCtrl.h头文件中定义如下︰

```c
typedef struct tagDRAGLISTINFO
{
UINT uNotification;//通知码，指示拖动事件的类型
HWND hWnd;	//拖动列表框的窗口句柄
POINT ptCursor;//拖动事件发生时鼠标光标的X和Y坐标
}DRAGLISTINFO，*LPDRAGLISTINFO;
```

- `uNotification`字段表示通知码，指示拖动事件的类型，该字段可以是下表项之一。



:::



