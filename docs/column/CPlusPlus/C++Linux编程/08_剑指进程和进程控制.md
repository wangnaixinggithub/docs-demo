# 剑指进程和进程控制

## Linux的信号

### 信号的基本概念 

信号（signal）是软件中断，是进程之间相互传递消息的一种方法，用于通知进程发生了事件，但是不能给进程传递任何数据。

信号产生的原因有很多，比说在Shell中，可以用`kill`和`killall`命令来向进程发送信号：

:::details `如何使用Shell给进程发信号`

语法格式：

```shell
kill -信号的类型 进程编号
killall -信号的类型 进程名
```

- 写一个demo程序，执行一个死循环，不断向标准输出中打印执行了一次任务。

`demo.cpp`

```cpp
#include <unistd.h>
#include <iostream>
using namespace std;
int main()
{
    while (true)
    {
        cout << "执行了一次任务 \n";
        sleep(1);
    }
}
```

- 在窗口1编译 并运行demo程序

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
# 进程收到了15的信号，该进程会终止
[root@localhost my_learn_test]# ./demo 
执行了一次任务 
....
已终止
#进程又一次收到了15的信号，该进程会终止。
[root@localhost my_learn_test]# ./demo 
执行了一次任务 
...
已终止
# 进程收到了1的信号，该进程会从运行态 转为 挂起态
[root@localhost my_learn_test]# ./demo 
执行了一次任务 
... 
挂起
[root@localhost my_learn_test]# ./demo 
执行了一次任务 
...
浮点数例外(吐核)
```

```shell
[root@localhost my_learn_test]# killall demo
[root@localhost my_learn_test]# killall -15 demo
[root@localhost my_learn_test]# killall -1 demo
[root@localhost my_learn_test]# killall -8 demo
```

在另外一个窗口2执行`killall`命令，此刻观察窗口1可以看到进程被终止运行。实际上是我们通过信号来让程序退出的。



`-15` 是` killall` 命令的缺省参数。同样上述操作，也可以杀死进程。



当然我们还可以通过`killall` 来发送其他信号，比如说发送1的信号，进程收到信号后，会使得进程挂起。发送8的信号，进程收到信号后，会使得进程触发浮点异常，使得进程终止并进行内核映像转储·（core dump）





:::

### 信号的类型 

信号名和信号值这两个一个东西，你用值也行，用他的宏定义也ok.  





> 请注意，加粗重点关注。

| 信号名（宏定义） |  信号值  | 默认处理动作 |                    发出信号的原因                     |
| :--------------: | :------: | :----------: | :---------------------------------------------------: |
|      SIGHUP      |    1     |      A       |               终端挂起或者控制进程终止                |
|   **`SIGINT`**   | **`2`**  |   **`A`**    |                   `键盘中断Ctrl+c`                    |
|     SIGQUIT      |    3     |      C       |                  键盘的退出键被按下                   |
|      SIGILL      |    4     |      C       |                       非法指令                        |
|     SIGABRT      |    6     |      C       |               由abort(3)发出的退出指令                |
|      SIGFPE      |    8     |      C       |                       浮点异常                        |
|  **`SIGKILL`**   | **`9`**  |  **`AEF`**   |       **`采用 kill -9 进程编号 强制杀死进程`**        |
|  **`SIGSEGV`**   | **`11`** |  **`CEF`**   | **`无效的内存引用 （数组越界、操作空指针和野指针）`** |
|     SIGPIPE      |    13    |      A       |          管道破裂，写一个没有读端口的管道。           |
|  **`SIGALRM`**   |    14    |      A       |          **`由闹钟alarm()函数 发出的信号`**           |
|  **`SIGTERM`**   | **`15`** |     `A`      |  **`采用 kill 进程编号 或 killall 程序名 通知程序`**  |
|     SIGUSR1      |    10    |      A       |                    用户自定义信号1                    |
|     SIGUSR2      |    12    |      A       |                    用户自定义信号2                    |
|  **`SIGCHLD`**   | **`17`** |   **`B`**    |                 **`子进程结束信号`**                  |
|     SIGCONT      |    18    |              |              进程继续（曾被停止的进程）               |
|     SIGSTOP      |    19    |     DEF      |                       终止进程                        |
|     SIGTSTP      |    20    |      D       |              控制终端（tty）上按下停止键              |
|     SIGTTIN      |    21    |      D       |               后台进程企图从控制终端读                |
|     SIGTTOU      |    22    |      D       |               后台进程企图从控制终端写                |
|       其它       |   <=64   |      A       |                      自定义信号                       |

处理动作一项中的字母含义如下：

- A 缺省的动作是终止进程。
- B 缺省的动作是忽略此信号，将该信号丢弃，不做处理。
- C 缺省的动作是终止进程并进行内核映像转储（core dump）。
- D 缺省的动作是停止进程，进入停止状态的程序还能重新继续，一般是在调试的过程中。
- E 信号不能被捕获。
- F 信号不能被忽略。



:::details 验证 kill -9 信号 既不能被捕获、也不能被忽略

```c{14}
#include <unistd.h>
#include <iostream>
#include <signal.h>
using namespace std;
void func(int signum)
{
    cout << "收到了信号:" << signum << endl; 
}
int main()
{
     //对信号进行捕获
    signal(1,func);
    signal(15,func);
    signal(9,func);  //试图捕获9的信号
    while (true)
    {
        cout << "执行了一次任务 \n";
        sleep(1);
    }
}
```

在窗口1 编译源码，并运行程序。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
执行了一次任务 
...
执行了一次任务 
收到了信号:1
执行了一次任务 
...
执行了一次任务 
已杀死
```

在窗口2，给程序进程发送1的信号，可以看到终端打印可知  执行了1的信号处理函数。而给程序进程发送9的信号，发现并没有打印内容。可代码上已经做了9信号关联信号处理函数了，由此可知 **信号9，根本就不能被进程捕获处理。**

```shell
[root@localhost my_learn_test]# killall -1 demo
[root@localhost my_learn_test]# killall -9 demo
```

于是进一步验证，信号9 能否被忽略。

```c{17}
#include <unistd.h>
#include <iostream>
#include <signal.h>
using namespace std;
void func(int signum)
{
    cout << "收到了信号:" << signum << endl; 
}
int main()
{
    signal(1,func);
    signal(15,func);
    signal(9,func);  

    //对信号进行忽略
    signal(2,SIG_IGN);
    signal(9,SIG_IGN); //试图忽略9的信号
    while (true)
    {
        cout << "执行了一次任务 \n";
        sleep(1);
    } 
}
```

再次在窗口1编译源码，运行程序。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
执行了一次任务 
执行了一次任务 
...
执行了一次任务 
执行了一次任务 
已杀死
```

给程序进程发送2的信号，可见程序没有任何状态变更 依旧打印信息。继续给程序发送 9的 信号，可以看到程序被杀死了。可以得到结论 **9的信号，不能被进程设置忽略。**

```shell
[root@localhost my_learn_test]# killall -2 demo
[root@localhost my_learn_test]# killall -9 demo
```

:::



::: details 信号作为定时任务让进程运行指定逻辑



首先我们通过`alarm()` 来设置一个闹钟，让他5秒之后，向程序发送14的信号。通过查看信号的类型，可以知道14的信号带来的行为是终止进程。

```c
#include <unistd.h>
#include <iostream>
#include <signal.h>
using namespace std;
void func(int signum)
{
    cout << "收到了信号:" << signum << endl; 
}
int main()
{
    signal(1,func);
    signal(15,func);
    signal(9,func); 
    signal(2,SIG_IGN);
    signal(9,SIG_IGN); 
    alarm(5); //闹钟（定时器），5秒后将向本程序发送14的信号
    while (true)
    {
        cout << "执行了一次任务 \n";
        sleep(1);
    }
}
```

 在窗口1启动程序，可以看到过了5秒，闹钟响了，操作系统向进程发送了14的信号，由于程序没有对14的信号自定义消息处理，所以程序采用默认的信号处理函数，最终使得程序退出。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
执行了一次任务 
执行了一次任务 
执行了一次任务 
执行了一次任务 
执行了一次任务 
闹钟
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240410212829823.png)

在实际开发中，我们可以结合`alarm()函数`以及对14的信号进捕获处理，从而实现进程的定时任务。

```cpp{6-9}
#include <unistd.h>
#include <iostream>
#include <signal.h>
using namespace std;
void func(int signum)
{
    cout << "收到了信号:" << signum << endl; 
}
void func1(int signum)
{
    cout << "闹钟响了，执行定时任务.\n";
    alarm(5);
}
int main()
{
    signal(1,func);
    signal(15,func);
    signal(9,func); 
    signal(2,SIG_IGN);
    signal(9,SIG_IGN); 

    alarm(5); //闹钟（定时器），5秒后将向本程序发送14的信号
    signal(14,func1);//设置定时任务函数

    while (true)
    {
        cout << "执行了一次任务 \n";
        sleep(1);
    }
    
}
```

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
执行了一次任务 
执行了一次任务 
执行了一次任务 
执行了一次任务 
执行了一次任务 
闹钟响了，执行定时任务.
执行了一次任务 
执行了一次任务 
执行了一次任务 
执行了一次任务 
执行了一次任务 
闹钟响了，执行定时任务.
执行了一次任务 
执行了一次任务 
执行了一次任务 
执行了一次任务 
已杀死
[root@localhost my_learn_test]# 

```

```shell
[root@localhost my_learn_test]# killall -9 demo
```

可以看到闹钟，每5秒响一次，走定时任务处理函数。

```cpp
#include <unistd.h>
#include <iostream>
#include <signal.h>
using namespace std;

void func(int signum)
{
    cout << "收到了信号:" << signum << endl; 
}
void func1(int signum)
{
    cout << "闹钟响了，执行定时任务.\n";
    //alarm(5); 没有这行，则闹钟只响1次
}
int main()
{
   //对信号进行捕获
    signal(1,func);
    signal(15,func);
    signal(9,func);  //试图捕获9的信号

    //对信号进行忽略
    signal(2,SIG_IGN);
    signal(9,SIG_IGN); //试图忽略9的信号


    alarm(5); //闹钟（定时器），5秒后将向本程序发送14的信号
    signal(14,func1);//设置定时任务函数

    while (true)
    {

        cout << "执行了一次任务 \n";
        sleep(1);
    }
    
}
```

:::

### 信号的处理

进程对信号的处理方法有三种：

- 对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程。
- 设置信号的处理函数，收到信号后，由该函数来处理。
- 忽略某个信号，对该信号不做任何处理，就像未发生过一样。

signal()函数可以设置程序对信号的处理方式。

函数声明：

```c
sighandler_t signal(int signum, sighandler_t handler);
```

::: details signal 函数说明

参数signum表示信号的编号（信号的值）。

参数handler表示信号的处理方式，有三种情况：

- SIG_DFL：恢复参数signum信号的处理方法为默认行为。 
- 一个自定义的处理信号的回调函数，该回调函数的形参是信号的编号。
- SIG_IGN：忽略参数signum所指的信号。

:::



:::details 给信号注入指定处理

```c{12,13}
#include <unistd.h>
#include <iostream>
#include <signal.h>
using namespace std;
void func(int signum)
{
    cout << "收到了信号:" << signum << endl; 
}
int main()
{
    //进程收到1 Or 15的信号，即刻执行func回调
    signal(1,func);
    signal(15,func);
    while (true)
    {
        cout << "执行了一次任务 \n";
        sleep(1);
    }
}
```

编译源码并运行程序。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
执行了一次任务 
... 
收到了信号:15
执行了一次任务 
...
执行了一次任务 
收到了信号:1
执行了一次任务 
执行了一次任务 
...
[root@localhost my_learn_test]# 
```

可以看到，15，1信号，被我们自定义的信号处理函数处理了，成功的在shell界面打印出来`cout`的输出。

没用指定`signal`,则信号走默认的处理回调。大部分的信号的默认处理回调都是杀死进程。

```shell
[root@localhost my_learn_test]# killall -15 demo
[root@localhost my_learn_test]# killall -1 demo
[root@localhost my_learn_test]# killall -2 demo
```

:::



:::details SIG_IGN 忽略信号实例

```c{14}
#include <unistd.h>
#include <iostream>
#include <signal.h>
using namespace std;
void func(int signum)
{
    cout << "收到了信号:" << signum << endl; 
}
int main()
{
    signal(1,func);
    signal(15,func);
    //忽略2的信号，不做任何回应处理
    signal(2,SIG_IGN);
    while (true)
    {

        cout << "执行了一次任务 \n";
        sleep(1);
    }
}
```

编译源码并运行程序。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
执行了一次任务 
执行了一次任务 
... 
执行了一次任务 
执行了一次任务 
执行了一次任务 
执行了一次任务 
执行了一次任务 
退出(吐核)
[root@localhost my_learn_test]#  
```

我们先发送2的信号，由于我们对2信号进行了`SIG_IGN` 故进程忽略即其不受理2的信号了。之后再发送3的信号，可以3信号被进程捕获，执行了3信号的默认处理回调，所以进程退出。终止运行！

```shell
[root@localhost my_learn_test]# killall -2 demo
[root@localhost my_learn_test]# killall -3 demo
```

:::



:::details 信号回调函数可写恢复默认信号行为的操作

```c{9}
#include <unistd.h>
#include <iostream>
#include <signal.h>
using namespace std;
void func(int signum)
{
    cout << "收到了信号:" << signum << endl; 
    //恢复信号的处理回调函数 为系统默认，即走系统默认的处理逻辑
    signal(signum,SIG_DFL);
}
int main()
{
    signal(1,func);
    signal(15,func);
    signal(2,SIG_IGN);
    while (true)
    {
        cout << "执行了一次任务 \n";
        sleep(1);
    }  
}
```

编译源码，并运行程序。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
执行了一次任务 
.... 
执行了一次任务 
收到了信号:1
执行了一次任务 
... 
执行了一次任务 
挂起
[root@localhost my_learn_test]# 
```

第一次收到了1的信号，可见走我们的自定义信号回调`func`进行处理，在`fuc`内部将信号1的处理信号的方法恢复为默认行为后，再次发送一次1的信号，可以看到线程挂起了。即回到了信号1的默认处理方式，而不再采用`fuc` 定义的信号处理方式。

```shell
[root@localhost my_learn_test]# killall -1 demo
[root@localhost my_learn_test]# killall -1 demo
```

:::



### 信号有什么用

::: tip 信号有什么用?

服务程序运行在后台，如果想让中止它，杀掉不是个好办法，因为进程被杀的时候，是突然死亡，没有安排善后工作。



如果向服务程序发送一个信号，服务程序收到信号后，调用一个函数，在函数中编写善后的代码，程序就可以有计划的退出。 总之，我们希望我们的程序在被中止的时候，所有申请的资源均可以得到有效的释放。



:::



> 此外，如果向服务程序发送0的信号，可以检测程序是否存活。



:::details 可利用信号机制，在进程退出时，让进程资源得到有效释放！

```c{9,17-18,20-21}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
void EXIT(int sig)
{
  cout << "收到了信号：" << sig << endl;
  cout << "正在释放资源，程序将退出......\n";
  // 以下是释放资源的代码。

  cout << "程序退出。\n";
  exit(0);  // 进程退出。
}
int main(int argc,char *argv[])
{
  // 忽略全部的信号，防止程序被其他的信号异常中止。
  for (int ii=1;ii<=64;ii++) 
    signal(ii,SIG_IGN);
  // 如果收到2和15的信号（Ctrl+c和kill、killall），本程序将主动退出。
  signal(2,EXIT); 
  signal(15,EXIT);
  while (true)
  {
    cout << "执行了一次任务。\n";
    sleep(1);
  }
}
```

编译源码，并运行程序。通过`ctrl+c`快捷键操作，触发2的信号。则可以看到，进程的资源能得到有效释放。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
执行了一次任务。
执行了一次任务。
执行了一次任务。
执行了一次任务。
^C收到了信号：2
正在释放资源，程序将退出......
程序退出。
[root@localhost my_learn_test]# 
```

再次启动程序，进一步验证发送15的信号。同样的，可以看到进程现在所有占用的资源得到了一个有效的释放。

```shell
[root@localhost my_learn_test]# ./demo
执行了一次任务。
...
执行了一次任务。
收到了信号：15
正在释放资源，程序将退出......
程序退出。
[root@localhost my_learn_test]# 
```

可以看到，我们现在可以终止一个进程退出时，做一些资源释放的工作了。

```shell
[root@localhost my_learn_test]# killall -15  demo
```

如果这个时候你想知道这个进程是不是已经成功的被我们中止运行了，可以通过给进程发送0的信号，如果shell终端输出了 `demo: no process found` 的说明信息，则可证进程已经中止成功！如果进程启动正在运行，则啥也不返回。

```shell
[root@localhost my_learn_test]# killall -0 demo
demo: no process found
[root@localhost my_learn_test]# killall -0 demo
```

当然我们也可以通过`ps-ef|grep 进程名` 进行过滤查询进程表，如果查不到进程信息，也可证明进程已经中止成功。

```shell
[root@localhost my_learn_test]# ps -ef|grep demo
root      60744   5571  0 20:22 pts/3    00:00:00 grep --color=auto demo
```

:::

### 发送信号

Linux操作系统提供了`kill`和`killall`命令向进程发送信号，在程序中，可以用`kill()函数`向其它进程发送信号。



函数声明：

```cpp
int kill(pid_t pid, int sig);
```

:::details kill 函数说明

kill()函数将参数sig指定的信号给参数pid指定的进程。



参数 pid 有几种情况：

- pid>0 将信号传给进程号为pid 的进程。
- pid=0 将信号传给和当前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号。
- pid=-1 将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息。

sig：准备发送的信号代码，假如其值为0则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。



返回值说明： 成功执行时，返回0；失败返回-1，`errno`被设置。

:::

## 进程终止

有8种方式可以中止进程，其中5种为正常终止，它们是：

- 在main()函数用return返回；
- 在任意函数中调用`exit()函数`；
- 在任意函数中调用`_exit()`或`_Exit()`函数；
- 最后一个线程从其启动例程（线程主函数）用return返回；
- 在最后一个线程中调用`pthread_exit()函数`返回；

异常终止有3种方式，它们是：

- 调用`abort()函数`中止；
- 接收到一个信号；
- 最后一个线程对取消请求做出响应。

:::details  在任意函数中使用 `exit(0)` 令进程终止！ 

```c{8}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
void func2()
{
    cout << "调用了func2().\n";
    exit(0); 
}
void func1()
{
  cout << "调用了func1()。\n";
  func2();
  cout << "回到了func1()函数.\n";
}
int main(int argc,char *argv[])
{

  func1(); 
  cout << "回到了main函数。\n";
}
```

编译源码，并运行程序。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
调用了func1()。
调用了func2().
[root@localhost my_learn_test]# 
```

可见效果，使用`exit(0)`函数被运行，程序函数栈被销毁，即不会回到func1()和main()中了，直接令线程退出。

```c{9}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
void func2()
{
    cout << "调用了func2().\n";
    //exit(0);
    return; 
}
void func1()
{
  cout << "调用了func1()。\n";
  func2();
  cout << "回到了func1()函数.\n";
}

int main(int argc,char *argv[])
{

  func1(); 
  cout << "回到了main函数。\n";
}
```

将`exit(0)` 注释，尝试使用`return;` 看看效果，编译源码并运行程序。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
调用了func1()。
调用了func2().
回到了func1()函数.
回到了main函数。
[root@localhost my_learn_test]# 
```

可见，`return`，直接返回当前函数级，不会像exit()函数不管在哪一个函数内部都一样直接终止线程。

:::



### 进程终止的状态



在main()函数中，return的返回值即终止状态，如果没有return语句或调用exit()，那么该进程的终止状态是0。

在Shell中，查看进程终止的状态：echo $?



正常终止进程的3个函数：

`exit()`和`_Exit()`是由ISO C 声明

`_exit()`是由POSIX 声明

```c
void exit(int status);
void _exit(int status);
void _Exit(int status);
```

status也是进程终止的状态。

如果进程被异常终止，终止状态为非0。  



在实际开发中，进程终止状态获取会用在服务程序的调度、日志和监控。



:::details 查进程退出的状态

```c{7}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
int main(int argc,char *argv[])
{
  //main方法中没有任何代码
}
```

编译源码并运行程序，并通过`echo $?` 查看进程退出的状态，是0.

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
[root@localhost my_learn_test]# echo $?
0
```

修改demo程序,加入`return 1;`

```c{7}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
int main(int argc,char *argv[])
{
   return 1;
}
```

编译，再运行程序， 并通过`echo $?` 查看进程退出的状态，是1.

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
[root@localhost my_learn_test]# echo $?
1
```

如不使用`return;` 的方式进行终止进程，使用`exit(0)` 来终止，并查看进程终止的状态。

```c{7}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
int main(int argc,char *argv[])
{
    exit(0);
}
```

可以看到，此刻这种情况下，进程终止的状态是0

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
[root@localhost my_learn_test]# echo $?
0
```

将`exit(0);` 写成`exit(5)`

```c{7}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
int main(int argc,char *argv[])
{
    exit(5);
}
```

再通过shell终端，来查看进程终止的状态变成了5，所以我们可以自行指定进程的终止状态。

```shell

[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
[root@localhost my_learn_test]# echo $?
5
```

:::

### 资源释放的问题

`return` 表示函数返回，会调用局部对象的析构函数，main()函数中的return还会调用全局对象的析构函数。



**exit()表示终止进程，不会调用局部对象的析构函数，只调用全局对象的析构函数。**



`exit()`会执行清理工作，然后退出，`_exit()`和`_Exit()`直接退出，不会执行任何清理工作。



:::details 验证不同的进程终止方式对资源的释放粒度

```c{14,17,19}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
struct AA
{
   string name;
   AA(const string& str):name(str){}
   ~AA()
   {
    cout << name << "调用了析构函数.\n";
   }
};
AA a1("对象a1"); //用return终止进程，则会使得底层调用局部对象的析构，全局对象的析构
int main(int argc,char *argv[])
{
    AA a2("对象a2");
    
    return 0;
}
```

编译程序运行，可以看到全局对象，局部对象的资源均可以得到有效的释放。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
对象a2调用了析构函数.
对象a1调用了析构函数.
```

我们注释掉 `return 0` 而采用 `exit(0)` 

```c{14,17,19}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
struct AA
{
   string name;
   AA(const string& str):name(str){}
   ~AA()
   {
    cout << name << "调用了析构函数.\n";
   }
};
AA a1("对象a1");
int main(int argc,char *argv[])
{
    AA a2("对象a2"); //exit 只调用了全局对象的析构函数，没有调用局部对象的析构函数
    //return 0;
    exit(0);
}
```

编译程序运行，可以看到全局对象a2并没有被析构，即全局资源不能得到释放。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
对象a1调用了析构函数.
[root@localhost my_learn_test]# 
```

再去验证下`_exit(0)`的方式，对资源释放的把控粒度。

```c{20}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
struct AA
{
   string name;
   AA(const string& str):name(str){}
   ~AA()
   {
    cout << name << "调用了析构函数.\n";
   }
};
AA a1("对象a1");
int main(int argc,char *argv[])
{
    AA a2("对象a2"); 
    //return 0;
    //exit(0);
    _exit(0);
}
```

可以看到，该`_exit(0)` 函数即不会释放局部资源、也不会释放全局资源。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
[root@localhost my_learn_test]# 
```

:::

### 进程的终止函数

进程可以用`atexit()`函数注册终止函数（最多32个），这些函数将由`exit()函数`自动调用。

```cpp
int atexit(void (*function)(void));
```



:::details `atexit()` 弥补`exit()` 函数不能释放全局对象资源的缺陷



`exit()`调用终止函数的顺序与登记时相反。在进程终止前，会逐一终止函数， 从而开发可以在终止函数中完成对资源的释放工作。即终止函数是做进程退出前的收尾工作。

```c{15-17}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
void func1()
{
    cout << "调用了 func1()\n";
}
void func2()
{
    cout << "调用了 func2()\n";
}
int main(int argc,char *argv[])
{
    atexit(func1); //登记第一个进程终止函数
    atexit(func2); //登记第二个进程终止函数
    return 0;
}
```

编译源码，并运行程序，可以看到使用了在主函数中使用 `retrun 0`来终止进程，同样也可以触发注册好的进程终止函数。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
调用了 func2()
调用了 func1()
```

注释掉`return 0` 使用`exit(1)` 来终止进程。

```c{15-16,18}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
void func1()
{
    cout << "调用了 func1()\n";
}
void func2()
{
    cout << "调用了 func2()\n";
}
int main(int argc,char *argv[])
{
    atexit(func1); //登记第一个进程终止函数
    atexit(func2); //登记第二个进程终止函数
    //return 0;
    exit(1);
}
```

编译源码，并运行程序。可见同样会在进程退出前，执行进程终止函数。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
调用了 func2()
调用了 func1()
```

再实验`_exit(1);` 

```c{17-18,21}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;

void func1()
{
    cout << "调用了 func1()\n";
}
void func2()
{
    cout << "调用了 func2()\n";
}

int main(int argc,char *argv[])
{
    atexit(func1); //登记第一个进程终止函数
    atexit(func2); //登记第二个进程终止函数
    //return 0;
    //exit(1);
    _exit(1);
}
```

可以看到`_exit(1)` 依旧不能处理资源释放的问题。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
[root@localhost my_learn_test]# 
```

基于这样的认识，我们就可以弥补线程通过`exit()`函数退出时，没有完成对全局对象的资源释放这一个设计缺陷了，从而可有针对性的 对对象做释放资源的工作了。

:::

## 调用可执行程序

Linux提供了`system()`函数和`exec()`函数族，利用这些函数，可在C++程序中，去执行其它的程序（二进制文件、操作系统命令或Shell脚本）。



### system()函数

system()函数提供了一种简单的执行程序的方法，把需要执行的程序和参数用一个字符串传给system()函数就行了。



:::details `system()函数`的声明

```cpp
int system(const char * string);
```

system()函数的返回值比较麻烦。

- 如果执行的程序不存在，system()函数返回非0；
- 如果执行程序成功，并且被执行的程序终止状态是0，system()函数返回0；
- 如果执行程序成功，并且被执行的程序终止状态不是0，system()函数返回非0。

:::



::: details `system()` 运行操作系统命令

```c{7}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
int main(int argc,char *argv[])
{
    int ret = system("/bin/ls -l /tmp");
    cout << "ret = " << ret << endl;
    perror("system");
}
```

```shell
[root@localhost my_learn_test]# /bin/ls -l /tmp
总用量 440
drwxr-xr-x. 2 root        root             6 3月   2 02:02 aaa
drwxr-xr-x. 2 root        root             6 2月  23 16:48 appInsights-nodeAIF-d9b70cd4-b9f9-4d70-929b-a071c400b217
....
drwx------. 2 wangnaixing wangnaixing     24 3月   8 16:59 ssh-FsqpWRkssfVR
drwx------. 2 wangnaixing wangnaixing     25 3月   2 00:20 ssh-gov8lKswLXm4
drwx------. 3 root        root            17 3月   8 16:59 systemd-private-03-08.17-01.Hv04ex.yumtx
ret = 0
system: Success
[root@localhost my_learn_test]# 
```

:::



::: details `system() 运行进程`



`demo1.cpp`

```cpp
#include <iostream>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
    cout << "运行了 demo1.\n";
    return 0;
}
```

`demo.cpp`

```c{7-9}
#include <iostream>
#include <unistd.h>
#include <signal.h>
using namespace std;
int main(int argc,char *argv[])
{
    int ret = system("/root/project/demo/my_learn_test/demo1");
    cout << "ret = " << ret << endl;
    perror("system");
}
```

编译`demo.cpp`,`demo1.cpp`程序，并运行`demo` 程序，已实现在一个进程中调用另一个进程。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# g++ -o demo1 demo1.cpp
[root@localhost my_learn_test]# ./demo
运行了 demo1.
ret = 0
system: Success
```

可见，成功运行了demo1,我们修改`demo1.cpp`的源码，让其`return 5`

```c
#include <iostream>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
    cout << "运行了 demo1.\n";
   // return 0;
   return 5;
}
```

然后他的返回值出乎意料，竟然是1280,而非5.

```shell
[root@localhost my_learn_test]# g++ -o demo1 demo1.cpp
[root@localhost my_learn_test]# ./demo
运行了 demo1.
ret = 1280
system: Success
```

继续修改`demo1.cpp`的源码，让其`return 8`

```c
#include <iostream>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
    cout << "运行了 demo1.\n";
   // return 0;
    //return 5;
    return 8;
}
```

重复之前的操作，啊，返回值变成了2048，而非8.

```shell
[root@localhost my_learn_test]# g++ -o demo1 demo1.cpp
[root@localhost my_learn_test]# ./demo
运行了 demo1.
ret = 2048
system: Success
[root@localhost my_learn_test]# 

```

额呃呃，所以可以看到system()的返回值，额，不是这么友好！！在实际开发中我们使用`system()` 调用另一个进程时，不可通过该函数返回值来处理逻辑！

:::

### exec函数族

exec函数族提供了另一种在进程中调用程序（二进制文件或Shell脚本）的方法。

exec函数族的声明如下：

```cpp
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg,...,char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],char *const envp[]);
```

在实际开发中，重点使用：

```cpp
int execl(const char *path, const char *arg, ...);
int execv(const char *path, char *const argv[]);
```

::: tip 注意：

- 如果执行程序失败则直接返回-1，失败原因存于errno中。
- 新进程的进程编号与原进程相同，但是，新进程取代了原进程的代码段、数据段和堆栈。
- 如果执行成功则函数不会返回，当在主程序中成功调用exec后，被调用的程序将取代调用者程序，也就是说，exec函数之后的代码都不会被执行。
- 在实际开发中，最常用的是execl()和execv()，其它的极少使用。

:::



:::details `execl()` `execv()` 调用操作系统命令

```c{8,19}
#include <iostream>
#include <string.h>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
  //方式1：基于execl 调用
  int ret=execl("/bin/ls","/bin/ls","-lt","/tmp",0);  // 最后一个参数0不能省略。
  cout << "ret=" << ret << endl;
  perror("execl");

  /* 方式2：基于execv 调用
  char *args[10];
  args[0]="/bin/ls";
  args[1]="-lt";
  args[2]="/tmp";
  args[3]=0;     // 这行代码不能省略。

  int ret=execv("/bin/ls",args);
  cout << "ret=" << ret << endl;
  perror("execv");
  */
}
```

编译源码并运行程序，可以看到结果和我们在shell终端中输入的是一样的。

```shell
[root@localhost my_learn_test]# /bin/ls -lt /tmp
总用量 440
-rw-------. 1 root        root        224250 3月   8 17:01 yum_save_tx.2024-03-08.17-01.Hv04ex.yumtx
....
drwx------. 2 wangnaixing wangnaixing     25 3月   2 00:20 ssh-gov8lKswLXm4
drwxr-xr-x. 2 root        root             6 2月  23 16:48 appInsights-nodeAIF-d9b70cd4-b9f9-4d70-929b-a071c400b217

[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
总用量 440
-rw-------. 1 root        root        224250 3月   8 17:01 yum_save_tx.2024-03-08.17-01.Hv04ex.yumtx
....
drwx------. 2 wangnaixing wangnaixing     25 3月   2 00:20 ssh-gov8lKswLXm4
drwxr-xr-x. 2 root        root             6 2月  23 16:48 appInsights-nodeAIF-d9b70cd4-b9f9-4d70-929b-a071c400b217

```

忽略之后的报错信息情况：

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
demo.cpp: In function ‘int main(int, char**)’:
demo.cpp:11:11: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   args[0]="/bin/ls";
           ^~~~~~~~~
demo.cpp:12:11: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   args[1]="-lt";
           ^~~~~
demo.cpp:13:11: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   args[2]="/tmp";
```

:::



:::details `execl()函数` 与 `system()` 调用另一个进程的区别

`demo1.cpp`

```c
#include <iostream>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
    cout << "demo1 本进程的编号是: " << getpid() << endl;
    return 0;
}
```

编译`demo1.cpp` 源码文件，反复运行demo1程序。可以看到每一次运行进程，都会分配到一个不同的`pid` 进程编号。

```shell
[root@localhost my_learn_test]# g++ -o demo1 demo1.cpp
[root@localhost my_learn_test]# ./demo1
demo1 本进程的编号是: 88275
[root@localhost my_learn_test]# ./demo1
demo1 本进程的编号是: 88935
[root@localhost my_learn_test]# ./demo1
demo1 本进程的编号是: 89281
```

编译`demo.cpp` 源码文件，并运行该`demo` 程序。

`demo.cpp`

```cpp
#include <iostream>
#include <string.h>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
    //新进程的进程编号与原进程相同，但是，新进程取代了原进程的代码段、数据段和堆栈。
    cout << "demo1 本进程的编号是: " << getpid() << endl;
    int ret = execl("/root/project/demo/my_learn_test/demo1","/root/project/demo/my_learn_test/demo1",0);
}
```

可以看到，demo1进程被启动了，新的demo1进程使用了demo0调用进程的进程编号。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
demo1 本进程的编号是: 96227
demo1 本进程的编号是: 96227
```

修改`demo.cpp` 的源码，采用`system()` 函数来启动`demo1`进程。

```cpp
#include <iostream>
#include <string.h>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
    //新进程的进程编号与原进程相同，但是，新进程取代了原进程的代码段、数据段和堆栈。
    cout << "demo1 本进程的编号是: " << getpid() << endl;
   // int ret = execl("/root/project/demo/my_learn_test/demo1","/root/project/demo/my_learn_test/demo1",0);
   int ret = system("/root/project/demo/my_learn_test/demo1");
}
```

 可见，新的demo1进程，并没有使用demo0调用进程的进程编号，而时采用一个新的进程编号。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
demo1 本进程的编号是: 101285
demo1 本进程的编号是: 101286
```

除了进程编号的差异性之外，我们再验证。代码段的执行情况。修改 `demo.cpp`源码，在`system()`函数调用完毕之后，输出其返回值以及`system()` 执行失败的的错误信息。

```c
#include <iostream>
#include <string.h>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
    //新进程的进程编号与原进程相同，但是，新进程取代了原进程的代码段、数据段和堆栈。
    cout << "demo1 本进程的编号是: " << getpid() << endl;
   // int ret = execl("/root/project/demo/my_learn_test/demo1","/root/project/demo/my_learn_test/demo1",0);
   int ret = system("/root/project/demo/my_learn_test/demo1");
   cout << "ret=" << ret << endl;
   perror("system");
}
```

编译源码并运行程序，可以看到调用进程`demo0` 在启动`demo1`进程之后，还可以继续向下执行代码段。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
demo1 本进程的编号是: 105622
demo1 本进程的编号是: 105623
ret=0
system: Success
```

此刻，我们试验 `execl()` 的代码的执行情况

```c
#include <iostream>
#include <string.h>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{  
   cout << "demo1 本进程的编号是: " << getpid() << endl;
   int ret = execl("/root/project/demo/my_learn_test/demo1","/root/project/demo/my_learn_test/demo1",0);
  // int ret = system("/root/project/demo/my_learn_test/demo1");
  cout << "ret=" << ret << endl;
  perror("execl");
}
```

可以看到，并没有输出`execl()`函数返回值以及函数执行失败的错误信息。

```cpp
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
demo1 本进程的编号是: 108482
demo1 本进程的编号是: 108482
[root@localhost my_learn_test]# 
```

基于此认识，我们得到结论：exec 新进程的进程编号与原进程相同，但是，新进程取代了原进程的代码段、数据段和堆栈。而system() 不是，新进程拥有自己的进程编号和代码段、数据段、堆栈。该system()执行完后会继续继续走他后面的代码。

:::



## 创建进程

### Linux的0、1和2号进程

整个linux系统全部的进程是一个树形结构。

- 0号进程（系统进程）是所有进程的祖先，它创建了1号和2号进程。
- 1号进程（systemd）负责执行内核的初始化工作和进行系统配置。
- 2号进程（kthreadd）负责所有内核线程的调度和管理。



用`pstree`命令可以查看进程树（`yum -y install psmisc`）。



:::details pstree 命令的使用



语法：

```
pstree -p 进程编号
```

举例：查0好进程所有的孩子进程

```shell
[root@localhost my_learn_test]# pstree -p 0
    ...
```

:::

### 进程标识

每个进程都有一个非负整数表示的唯一的进程ID。虽然是唯一的，但是进程ID可以复用。当一个进程终止后，其进程ID就成了复用的候选者。Linux采用延迟复用算法，让新建进程的ID不同于最近终止的进程所使用的ID。这样防止了新进程被误认为是使用了同一ID的某个已终止的进程。



:::tip getpid 查当前进程、当前进程的父进程的进程标识

```cpp
pid_t getpid(void);     // 获取当前进程的ID。
pid_t getppid(void);    // 获取父进程的ID。
```

:::



### fork()函数

一个现有的进程可以调用fork()函数创建一个新的进程。

```cpp
pid_t fork(void);
```

由fork()创建的新进程被称为子进程。子进程是父进程的副本，父进程和子进程都从调用fork()之后的代码开始执行。



fork()函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是子进程的进程ID。



子进程获得了父进程数据空间、堆和栈的副本（**注意：子进程拥有的是副本，不是和父进程共享**）。



fork()之后，父进程和子进程的执行顺序是不确定的。



:::details  `fork()` 创建父进程的子进程



写一个正常不过的`demo.cpp` 程序。

```cpp
#include <iostream>
#include <string.h>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
  int bh = 8;
  string message = "我是一只傻傻鸟";
  cout << "亲爱的" << bh << "号：" << message << endl;
}
```

运行此demo程序。可以看到正常的输出。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
亲爱的8号：我是一只傻傻鸟
```

增加一行代码`fork()`

```c
#include <iostream>
#include <string.h>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
  int bh = 8;
  string message = "我是一只傻傻鸟";
  fork();//fork之后，父进程，子进程都是从fork函数后面继续执行。  
  cout << "亲爱的" << bh << "号：" << message << endl;
}
```

编译`demo.cpp` 并运行，可以看到 亲爱的8号：我是一只傻傻鸟 被输出了两次，证实了两个进程去执行了这个代码。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
亲爱的8号：我是一只傻傻鸟
[root@localhost my_learn_test]# 亲爱的8号：我是一只傻傻鸟
```

为了方便演示，我们再增加两行代码。来确定他们是父子进程关系，以及两个进程 是从fork() 之后继续执行代码的。

```c{9,11-12}
#include <iostream>
#include <string.h>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
  int bh = 8;
  string message = "我是一只傻傻鸟";
  fork();
  cout << "亲爱的" << bh << "号：" << message << endl;
  sleep(20);
  cout << "程序结束. \n";
}
```

在窗口1，编译`demo.cpp` 并运行`demo`程序。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
亲爱的8号：我是一只傻傻鸟
亲爱的8号：我是一只傻傻鸟
程序结束. 
程序结束. 
[root@localhost my_learn_test]# 
```

切换到窗口2，通过`ps -ef |grep demo` 指令查`demo` 进程的信息。清晰可见demo程序有两个，并且是父子进程的关系（`pstree -p 进程ID` 查某进程的父进程）

```cpp
[root@localhost my_learn_test]# ps -ef|grep demo
root      45930  43765  0 23:12 pts/5    00:00:00 ./demo
root      45931  45930  0 23:12 pts/5    00:00:00 ./demo
root      46173   5571  0 23:12 pts/3    00:00:00 grep --color=auto demo

[root@localhost my_learn_test]# pstree -p 45931
demo(45931)

[root@localhost my_learn_test]# pstree -p 45930
demo(45930)───demo(45931)
```

在实际开发中，我们往下执行的代码时需要区分是父进程还是进程的问题。方便对进程进行一个管理性的处理工作。这个时候我们可以通过fork() 函数的返回值，作为我们的判断区分条件。

```cpp
#include <iostream>
#include <string.h>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
  int bh = 8;
  string message = "我是一只傻傻鸟";
  pid_t pid =  fork();
  cout << "pid=" << pid << endl;
  cout << "亲爱的" << bh << "号：" << message << endl;
}
```

编译，并运行demo程序，可见如果是父进程返回，则pid=子进程编号，如果是子进程返回则pid=0.

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
pid=55324
亲爱的8号：我是一只傻傻鸟
[root@localhost my_learn_test]# pid=0
亲爱的8号：我是一只傻傻鸟
```

最终达成我们的一个区分父进程，子进程，从而控制其执行不同的代码逻辑。

```cpp
#include <iostream>
#include <string.h>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
   
  int bh = 8;
  string message = "我是一只傻傻鸟";
  pid_t pid =  fork();
  if(pid > 0)
  {
    //父进程将执行这段代码
    cout << "父：pid=" << pid << endl;
    cout << "父：亲爱的" << bh << "号：" << message << endl;
  }
  else
  {
    //子进程将执行这段代码
    cout << "子：pid=" << pid << endl;
    cout << "子：亲爱的" << bh << "号：" << message << endl;
  }
}
```

编译`demo.cpp` 并运行demo程序，输出结果如我们预期所想。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
父：pid=65251
父：亲爱的8号：我是一只傻傻鸟
[root@localhost my_learn_test]# 子：pid=0
子：亲爱的8号：我是一只傻傻鸟
```

之后，我们再验证，子进程使用的数据段是不是拷贝的副本。

```cpp
#include <iostream>
#include <string.h>
#include <unistd.h>
using namespace std;
int main(int argc,char *argv[])
{
  int bh = 8;
  string message = "我是一只傻傻鸟";
  pid_t pid =  fork();
  if(pid > 0)
  {
    //父进程将执行这段代码
    cout << "父：pid=" << pid << endl;
    cout << "父：亲爱的" << &bh << "号：" << &message << endl;
  }
  else
  {
    //子进程将执行这段代码
    cout << "子：pid=" << pid << endl;
    cout << "子：亲爱的" << &bh << "号：" << &message << endl;
  }
}
```

乍一看，好像不是复制副本，而是复制引用的样子。地址都一样？（个人猜测可能用到的类似Windows操作系统的虚拟内存机制）

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
子：pid=0
子：亲爱的0x7fff3b0cd5b4号：0x7fff3b0cd5a8
父：pid=79971
父：亲爱的0x7fff3b0cd5b4号：0x7fff3b0cd5a8
```

所以，我让父进程休息1秒钟，让子进程将`bh message`变量做一个修改。

```cpp
#include <iostream>
#include <string.h>
#include <unistd.h>
using namespace std;

int main(int argc,char *argv[])
{
   
  int bh = 8;
  string message = "我是一只傻傻鸟";
  pid_t pid =  fork();
  if(pid > 0)
  {
    //父进程将执行这段代码
    sleep(1);
    cout << "父：pid=" << pid << endl;
    cout << "父：亲爱的" << &bh << "号：" << &message << endl;
  }
  else
  {
    //子进程将执行这段代码
    bh = 3; message = "你是一只傻傻鸟";
    cout << "子：pid=" << pid << endl;
    cout << "子：亲爱的" << &bh << "号：" << &message << endl;
  }

}
```

可以看到，并没有影响到父进程的结果，所以可见fork出来的子进程，对于数据段的数据采用的是拷贝副本的方式进行的。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
子：pid=0
子：亲爱的3号：你是一只傻傻鸟
父：pid=82012
父：亲爱的8号：我是一只傻傻鸟
```

:::

### fork()的两种用法

- 第一个，父进程复制自己，然后，父进程和子进程分别执行不同的代码。这种用法在网络服务程序中很常见，父进程等待客户端的连接请求，当请求到达时，父进程调用fork()，让子进程处理些请求，而父进程则继续等待下一个连接请求。

- 第二个，进程要执行另一个程序。这种用法在Shell中很常见，子进程从fork()返回后立即调用exec。



第一个做法，我们后面还会进行讨论，这里示例下第二个用法

```cpp
#include <iostream>
#include <unistd.h>
using namespace std;
int main()
{
  if (fork()>0)
  { // 父进程将执行这段代码。
    while (true)
    {
      sleep(1);
      cout << "父进程运行中...\n";
    }
  }
  else
  {
     // 子进程将执行这段代码。
    sleep(10);
    cout << "子进程开始执行任务...\n";
      
    //execl 新的进程将取代子进程，因为他取代的是子进程，不会影响父进程。
    execl("/bin/ls","/bin/ls","-lt","/tmp",0);
    cout << "子进程执行任务结束，退出。\n";
  }
}
```

所以在实例落地开发的时候，我们要想调用别的进程，同样是fork一个子进程，由子进程做调用别的进程这个事情。这样父进程不受到任何干扰。

```shell
[root@localhost my_learn_test]# ps -ef|grep demo
root     127109  64140  0 23:34 pts/5    00:00:00 ./demo
root     127110 127109  0 23:34 pts/5    00:00:00 ./demo
root     127522   5571  0 23:34 pts/3    00:00:00 grep --color=auto demo

[root@localhost my_learn_test]# ps -ef|grep demo
root     127109  64140  0 23:34 pts/5    00:00:00 ./demo
root     129047   5571  0 23:34 pts/3    00:00:00 grep --color=auto demo
[root@localhost my_learn_test]# 
```

:::tip 为啥不用`system()` 函数呢？

我们可以CSDN查system函数的源码，实际上我们操作的是一样的。底层用的也是fork(),在子进程也还是调用exec函数。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240413115233881.png)



这种设计机制也是有实际的应用的，比如说shell程序,shell接收我们的标准输入之后，其内部也是fork一个子进程 进行处理此命令的。

:::





### 共享文件

fork()的一个特性是在父进程中打开的文件描述符都会被复制到子进程中，父进程和子进程共享同一个文件偏移量。文件偏移量就是文件指针。父进程你写完之后，子进程接着父进程的文件偏移量，继续写。



如果父进程和子进程写同一描述符指向的文件，但又没有任何形式的同步，那么它们的输出可能会相互混合。 解决方案：进程同步

```cpp
#include <iostream>
#include <unistd.h>
#include <fstream>
using namespace std;
int main()
{
  ofstream fout;
  //写入1千万行内容  
  fout.open("/tmp/tmp.txt");
  for (int ii = 0; ii < 100000000; ii++)
  {
    fout << "进程" << getpid() << "西施" << ii << "极漂亮" << "\n";
  }
  fout.close();
}
```

编译源码程序，然后写`tmp.sh` 脚本文件，该脚本文件会在后台启动两个demo进程。

```shell
[root@localhost project]# mkdir wnx
[root@localhost project]# cd wnx
[root@localhost wnx]# g++ -o demo demo.cpp
[root@localhost wnx]# vim tmp.sh
[root@localhost wnx]# sh tmp.sh
[root@localhost wnx]# ps -ef |grep demo
root       2843      1 39 04:18 pts/4    00:00:03 ./demo
root       2844      1 39 04:18 pts/4    00:00:03 ./demo
root       2866   1841  0 04:19 pts/4    00:00:00 grep --color=auto demo
...
root       2968   1841  0 04:19 pts/4    00:00:00 grep --color=auto demo
[root@localhost wnx]# ps -ef |grep demo
root       2990   1841  0 04:19 pts/4    00:00:00 grep --color=auto demo
[root@localhost wnx]# wc /tmp/tmp.txt
 100000000  100000000 3388888890 /tmp/tmp.txt
```

脚本内容如下，最后等待进程运行完毕，通过`wc` 指令查文件行数，发现是1千万行，而不是2千万行。

```shell
./demo &
./demo &
```

修改`demo.cpp` 增加一行代码`fork();`

```cpp
#include <iostream>
#include <unistd.h>
#include <fstream>
using namespace std;
int main()
{
  ofstream fout;
  fout.open("/tmp/tmp.txt");
  fork();
  //演示fork子进程之后，父进程和子进程一起给tmp.txt文件写入内容  
  for (int ii = 0; ii < 100000000; ii++)
  {
    fout << "进程" << getpid() << "西施" << ii << "极漂亮" << "\n";
  }
  fout.close();
}
```

最终我们查文件内容，会得到2千万行数据，说明父子进程他们拥有同一个文件偏移量。所以写入的行数据才没有少。如果是两个独立的进程，则后一个进程会覆盖前一个进程写入的行数据。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
[root@localhost my_learn_test]#  wc /tmp/tmp.txt
[root@localhost my_learn_test]#  wc /tmp/tmp.txt
 200000000  200000000 6977777780 /tmp/tmp.txt
[root@localhost my_learn_test]# 
```

### vfork()函数

vfork()函数的调用和返回值与fork()相同，但两者的语义不同。



vfork()函数用于创建一个新进程，而该新进程的目的是exec一个新程序，它不复制父进程的地址空间，因为子进程会立即调用exec，于是也就不会使用父进程的地址空间。如果子进程使用了父进程的地址空间，可能会带来未知的结果。



vfork()和fork()的另一个区别是：vfork()保证子进程先运行，在子进程调用exec或exit()之后父进程才恢复运行。



## 僵尸进程

如果父进程比子进程先退出，子进程将被1号进程托管（这也是一种让程序在后台运行的方法）。如果子进程比父进程先退出，而父进程没有处理子进程退出的信息，那么，子进程将成为僵尸进程。



僵尸进程有什么危害？内核为每个子进程保留了一个数据结构，包括进程编号、终止状态、使用CPU时间等。父进程如果处理了子进程退出的信息，内核就会释放这个数据结构，父进程如果没有处理子进程退出的信息，内核就不会释放这个数据结构，子进程的进程编号将一直被占用。系统可用的进程编号是有限的，如果产生了大量的僵尸进程，将因为没有可用的进程编号而导致系统不能产生新的进程。



僵尸进程的避免：

- 子进程退出的时候，内核会向父进程发送SIGCHLD信号，如果父进程用signal(SIGCHLD,SIG_IGN)通知[内核](https://baike.baidu.com/item/内核?fromModule=lemma_inlink)，表示自己对子进程的退出不感兴趣，那么子进程退出后会立即释放数据结构。
- 父进程通过`wait()/waitpid()`等函数等待子进程结束，在子进程退出之前，父进程将被阻塞待。

```cpp
pid_t wait(int *stat_loc);
pid_t waitpid(pid_t pid, int *stat_loc, int options);
pid_t wait3(int *status, int options, struct rusage *rusage);
pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage);
```

返回值是子进程的编号。



stat_loc是子进程终止的信息

- 如果是正常终止，宏WIFEXITED(stat_loc)返回真，宏WEXITSTATUS(stat_loc)可获取终止状态
- 如果是异常终止，宏WTERMSIG(stat_loc)可获取终止进程的信号。

如果父进程很忙，可以捕获SIGCHLD信号，在信号处理函数中调用`wait()/waitpid()`。



:::details 验证若父进程先退出，则子进程将被1号进程托管

```c++
#include <iostream>
#include <unistd.h>
#include <fstream>
#include<sys/wait.h>
using namespace std;
int main()
{
 if(fork() > 0)
 {
    //父进程的流程,运行20S就退出了
    sleep(20);
    cout << "父进程将退出" << endl;
 }
 else
 {
    //子进程的流程，子进程会运行100S
    for (int ii = 0; ii < 100; ii++)
    {
        cout << "子进程继续运行中。" << endl;
        sleep(1);
    }
 }
}
```

在窗口1中运行demo程序。可以看到子进程运行后输出了运行消息，等待20S之后，父进程退出了，子进程还可以运行80S，所以继续运行。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
子进程继续运行中。
子进程继续运行中。
...
子进程继续运行中。
父进程将退出
[root@localhost my_learn_test]# 子进程继续运行中。
```

在0-20S的运行时机，我们切换到窗口2，使用`ps -ef|grep demo`指令 查看demo 程序的进程信息。

可以看到此时子进程的父进程为进程ID=74790的进程，在20-100S的运行时段，可见ID=74790的进程已经终止了，而子进程的父进程为进程ID=1的进程进行托管。

```shell
[root@localhost tmp]# ps -ef |grep demo
root      74790  64140  0 23:56 pts/5    00:00:00 ./demo
root      74791  74790  0 23:56 pts/5    00:00:00 ./demo
root      75573   5571  0 23:56 pts/3    00:00:00 grep --color=auto demo
[root@localhost tmp]# ps -ef |grep demo
\root      74791      1  0 23:56 pts/5    00:00:00 ./demo
root      77156   5571  0 23:56 pts/3    00:00:00 grep --color=auto demo
[root@localhost tmp]# 

```

最终得到结论，父进程退出之后，他的子进程将由1号进程接管。

:::



:::details 开发持续运行在后台的程序



如果希望程序持续不断的运行在后台，有两种方法。第一种运行程序时加`&`

```c
#include <iostream>
#include <unistd.h>
#include <fstream>
#include<sys/wait.h>
using namespace std;
int main()
{
 while (true)
 {
    cout << "服务运行中。" << endl;
    sleep(1);
 }
}
```

编译源码文件，并以加上&结尾的方式运行demo程序，可以看到程序始终在后台运行。在界面中我们可以做其他的事情，虽然只是界面的显示 收到了干扰，但是shell 还是可以正常接收指令的。

```shell
[root@localhost my_learn_test]# ./demo &
[1] 89529
[root@localhost my_learn_test]# 服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
d服务运行中。                                                                                                                                                       服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
ls
demo  demo1  demo10.cpp  demo1.cpp  demo.cpp  tmp.sh
[root@localhost my_learn_test]# 服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
服务运行中。
killall -15 demo
demo: no process found
[1]+  已终止               ./demo
[root@localhost my_learn_test]# 
[root@localhost my_learn_test]# 

```

另一种方法，不管是什么程序，加上这行代码` if(fork()>0) return 0;`

```c
#include <iostream>
#include <unistd.h>
#include <fstream>
#include<sys/wait.h>
using namespace std;
int main()
{
  //父进程退出，子进程继续运行。
 if(fork()>0) return 0;
 while (true)
 {
    cout << "服务运行中。" << endl;
    sleep(1);
 }
}
```

编译源码，并运行demo程序。

```shell
[root@localhost my_learn_test]# ./demo
[root@localhost my_learn_test]# 服务运行中。
服务运行中。
ls服务运行中。
demo  demo1  demo10.cpp  demo1.cpp  demo.cpp  tmp.sh
[root@localhost my_learn_test]# 服务运行中。
服务运行中。
ki服务运行中。
ll服务运行中。
all服务运行中。
 demo服务运行中。
[root@localhost my_learn_test]# 
```

:::



:::details 一不留神开发出僵尸进程

如果子进程先退出，父进程继续运行且父进程没有清理掉子进程退出的信息。则这个子进程就会变成僵尸进程。

```cpp
#include <iostream>
#include <unistd.h>
#include <fstream>
#include<sys/wait.h>
using namespace std;
int main()
{
 //子进程退出，父进程继续运行
 if(fork() == 0) return 0;
 while (true)
 {
    cout << "服务运行中。" << endl;
    sleep(1);
 }
}
```

这个时候再启动一个窗口（运行demo程序的窗口由于主进程还在持续运行，占用标准输出，则无法接收指令。），输入`ps -ef|grep demo` 指令，查询demo 程序进程信息。可以发现`pid=105446` 是一个子进程，并且是`defunct` 失效的。

```shell
[root@localhost tmp]# ps -ef|grep demo
root     105445  64140  0 00:04 pts/5    00:00:00 ./demo
root     105446 105445  0 00:04 pts/5    00:00:00 [demo] <defunct>
root     106463   5571  0 00:04 pts/3    00:00:00 grep --color=auto demo
[root@localhost tmp]# top
```

这种失效的进程，也叫做僵尸进程。我们可以通过 `top` 指令，查看当前系统有多少僵尸进程。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240309160555289-17099715562521.png)

:::



::: details 避免僵尸进程



第一种方法，可以通过`signal(SIGCHLD,SIG_IGN);` 这行代码，表示自己对子进程的退出不感兴趣，那么子进程退出后 会立即释放数据结构。

```c{8}
#include <iostream>
#include <unistd.h>
#include <fstream>
#include<sys/wait.h>
using namespace std;
int main()
{
 signal(SIGCHLD,SIG_IGN); //忽略子进程退出的信号
 if(fork() == 0) return 0;
 while (true)
 {
    cout << "服务运行中。" << endl;
    sleep(1);
 }
}
```

在窗口1，编译源码，运行demo程序。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
服务运行中。
服务运行中。
服务运行中。
```

在另一个窗口,通过 `ps -ef|grep demo` 指令，查看demo程序进程信息。可以看到成功避免的僵尸进程的出现。

```shell
[root@localhost tmp]# ps -ef|grep demo
root     118359  64140  0 00:07 pts/5    00:00:00 ./demo
root     118911   5571  0 00:07 pts/3    00:00:00 grep --color=auto demo
[root@localhost tmp]# 
```

第二种方法，父进程通过`wait()/waitpid()` 等函数等待子进程的结束，在子进程退出之前，父进程将被阻塞。

```c
#include <iostream>
#include <unistd.h>
#include <fstream>
#include<sys/wait.h>
using namespace std;
int main()
{
if(fork() > 0)
{
    //父进程的流程
    int sts; //定义子进程退出的信息
    pid_t pid = wait(&sts); //等待子进程退出
    cout << "已终止的子进程编号是: " << pid << endl;
    
    //将子进程退出的信息传给 WIFEXITED 这个宏，如果是正常退出的成功IF会成立。
    if(WIFEXITED(sts))
        cout << "子进程是正常退出的，退出状态是： " << WEXITSTATUS(sts) << endl;
    else
        //何为正常退出？请查看进程终止的那8种方式。
 		cout << "子进程是异常退出的，终止它的信号是：" << WTERMSIG(sts) << endl;
}
else
{
    //子进程的流程
    sleep(5); //子进程睡5秒种后，调用exit(0) 进行进程的正常退出。
    exit(0);
}
}
```

编译源码，并运行demo程序，5秒之后，可以看到标准输出，说明子进程是正常退出的。

```shell
[root@localhost my_learn_test]# ./demo
已终止的子进程编号是: 14506
子进程是正常退出的，退出状态是： 0
```

将进程退出状态改为`exit(1)`

```c{25}
#include <iostream>
#include <unistd.h>
#include <fstream>
#include<sys/wait.h>
using namespace std;

int main()
{
 
if(fork() > 0)
{
    //父进程的流程
    int sts;
    pid_t pid = wait(&sts);
    cout << "已终止的子进程编号是: " << pid << endl;
    if(WIFEXITED(sts))
        cout << "子进程是正常退出的，退出状态是： " << WEXITSTATUS(sts) << endl;
    else
        cout << "子进程是异常退出的，终止它的信号是：" << WTERMSIG(sts) << endl;
}
else
{
    //子进程的流程
   sleep(5);
   exit(1);
}
}
```

编译源码文件，并运行demo程序，5秒可以看到如下结果，退出状态更新为了1,使用`return;` 的效果也是一样的，这里不在演示了。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
已终止的子进程编号是: 19435
子进程是正常退出的，退出状态是： 1
```

修改`demo.cpp `将sleep 由5秒变成100秒。

```c
#include <iostream>
#include <unistd.h>
#include <fstream>
#include<sys/wait.h>
using namespace std;

int main()
{
 
if(fork() > 0)
{
    //父进程的流程
    int sts;
    pid_t pid = wait(&sts);
    cout << "已终止的子进程编号是: " << pid << endl;
    if(WIFEXITED(sts))
        cout << "子进程是正常退出的，退出状态是： " << WEXITSTATUS(sts) << endl;
    else
        cout << "子进程是异常退出的，终止它的信号是：" << WTERMSIG(sts) << endl;
}
else
{
    //子进程的流程
   sleep(100);
   exit(1);
}
}
```

在窗口1，编译源码文件，并运行demo程序。程序父进程由于子进程没有执行完毕，会在`wait()` 中进行阻塞。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
已终止的子进程编号是: 29123
子进程是异常退出的，终止它的信号是：15
```

在窗口2，通过`ps -ef|grep demo` 指令查demo进程，并给子进程`pid=29123` 发送15的信号，意图中止子进程。可以看到窗口1，子进程被中止了，并且同样没有僵尸进程。

```shell
[root@localhost tmp]# ps -ef|grep demo
root      29122  64140  0 00:18 pts/5    00:00:00 ./demo
root      29123  29122  0 00:18 pts/5    00:00:00 ./demo
root      29275   5571  0 00:18 pts/3    00:00:00 grep --color=auto demo
[root@localhost tmp]# kill 29123
```

在窗口1，继续运行程序，验证子进程在异常情况下被终止的情况。

```shell
[root@localhost my_learn_test]# ./demo
已终止的子进程编号是: 33097
子进程是异常退出的，终止它的信号是：9
```

在窗口2，重复之前的操作，查到子进程ID之后，给子进程发送 9的信号，强制杀死子进程。

```shell
[root@localhost tmp]# ps -ef|grep demo
root      33096  64140  0 00:19 pts/5    00:00:00 ./demo
root      33097  33096  0 00:19 pts/5    00:00:00 ./demo
root      33294   5571  0 00:19 pts/3    00:00:00 grep --color=auto demo
[root@localhost tmp]# kill -9 33097
```

可以看到窗口1，子进程被终止的消息打印。

```cpp
#include <iostream>
#include <unistd.h>
#include <fstream>
#include<sys/wait.h>
using namespace std;

int main()
{
 
if(fork() > 0)
{
    //父进程的流程
    int sts;
    pid_t pid = wait(&sts);
    cout << "已终止的子进程编号是: " << pid << endl;

    if(WIFEXITED(sts))
        cout << "子进程是正常退出的，退出状态是： " << WEXITSTATUS(sts) << endl;
    else
        cout << "子进程是异常退出的，终止它的信号是：" << WTERMSIG(sts) << endl;
}
else
{	//子进程流程
    //定义空指针，并操作空指针。会产生内存泄漏。
    int* p = 0;
    *p = 100; 
    exit(1);
}
}
```

重新编译`demo.cpp`运行demo程序，可以看到子进程异常退出了，终止他的信号为11.

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
已终止的子进程编号是: 38958
子进程是异常退出的，终止它的信号是：11
[root@localhost my_learn_test]# 
```

第三种方法，如果父进程很忙，可以捕获`SIGCHLD`信号，并在信号处理函数中调用 `wait()/waitpid()` 来处理子进程退出。

```c{10}
#include <iostream>
#include <unistd.h>
#include <fstream>
#include<sys/wait.h>
using namespace std;
//子进程退出的信号处理函数
void func(int sig)
{
    int sts;
    pid_t pid = wait(&sts);
    cout << "已终止的子进程编号是：" << pid << endl;
    if(WIFEXITED(sts))
        cout << "子进程是正常退出的，退出状态是: " << WEXITSTATUS(sts) << endl;
    else
        cout << "子进程是异常退出的，终止他的信号是： " << WTERMSIG(sts) << endl;
}

int main()
{
     signal(SIGCHLD,func);      //捕获子进程退出的信号
     if(fork() > 0)
     {
        //父进程的流程，用一个死循环来模拟这个父进程很忙。
        while (true)
        {
            cout << "父进程忙着执行任务.\n";
            sleep(1);
        }
     }else
     {
        //子进程的流程
        sleep(5);
        int *p = 0;*p = 10; //Sleep 5秒之后，内存泄漏挂掉
        exit(1);
     }   
}
```

在窗口1，编译源码，并运行demo程序，可以看到父进程一直忙着执行任务，5秒之后，子进程挂掉，子进程成功退出。父进程继续执行他的任务。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
父进程忙着执行任务.
父进程忙着执行任务.
父进程忙着执行任务.
父进程忙着执行任务.
父进程忙着执行任务.
父进程忙着执行任务.
已终止的子进程编号是：66980
子进程是异常退出的，终止他的信号是： 11
父进程忙着执行任务.
父进程忙着执行任务.
```

在窗口2，查看demo 进程的信息，可以看到没有留下僵尸进程。

```shell
[root@localhost tmp]# ps -ef|grep demo
root      69439  64140  0 00:29 pts/5    00:00:00 ./demo
root      69440  69439  0 00:29 pts/5    00:00:00 ./demo
root      69702   5571  0 00:29 pts/3    00:00:00 grep --color=auto demo
[root@localhost tmp]# ps -ef|grep demo
root      69439  64140  0 00:29 pts/5    00:00:00 ./demo
root      70313   5571  0 00:29 pts/3    00:00:00 grep --color=auto demo
[root@localhost tmp]# 

```

:::

## 多进程与信号

:::tip 父进程和子进程退出处理

在多进程的服务程序中，如果子进程收到退出信号，子进程自行退出如果父进程收到退出信号，则应该先向全部的子进程发送退出信号，然后自己再退出。

:::



::: details 多进程退出逻辑架构

```cpp
#include <iostream>
#include <unistd.h>
#include <signal.h>
using  namespace std;
void FathEXIT(int sig);  // 父进程的信号处理函数。
void ChldEXIT(int sig);  // 子进程的信号处理函数。
int main()
{
  // 忽略全部的信号，不希望被打扰。
  for (int ii=1;ii<=64;ii++) signal(ii,SIG_IGN);
  // 设置信号,在shell状态下可用 "kill 进程号" 或 "Ctrl+c" 正常终止进程
  // 但请不要用 "kill -9 +进程号" 强行终止
  signal(SIGTERM,FathEXIT); // SIGTERM 15
  signal(SIGINT,FathEXIT);  // SIGINT 2
  while (true)
  {
    if (fork()>0) // 父进程的流程。
    {
      sleep(5); continue;         //每5秒创建一个子进程
    }
    else          // 子进程的流程。
    {
      // 子进程需要重新设置信号。
      signal(SIGTERM,ChldEXIT);   // 子进程的退出函数与父进程不一样。
      signal(SIGINT ,SIG_IGN);   // 子进程不需要捕获SIGINT信号。不支持子进程Ctrl+C中断
      //子进程持续不断运行是每3秒中，打印输出。
      while (true)
      {
        cout << "子进程" << getpid() << "正在运行中。\n"; sleep(3); continue;
      }
    }
  }
}

// 父进程的信号处理函数。
void FathEXIT(int sig)
{
  // 以下代码是为了防止信号处理函数在执行的过程中再次被信号中断。
  signal(SIGINT,SIG_IGN); signal(SIGTERM,SIG_IGN);
  cout << "父进程退出，sig=" << sig << endl;
  kill(0,SIGTERM);     // 向全部的子进程发送15的信号，通知它们退出。

  // 在实际开发中,在这里增加释放资源的代码（全局的资源）。
  exit(0);
}

// 子进程的信号处理函数。
void ChldEXIT(int sig)
{
  // 以下代码是为了防止信号处理函数在执行的过程中再次被信号中断。
  signal(SIGINT,SIG_IGN); signal(SIGTERM,SIG_IGN);

  cout << "子进程" << getpid() << "退出，sig=" << sig << endl;

  // 在这里增加释放资源的代码（只释放子进程的资源）。
  exit(0);
}
```

在窗口1，编译源码并运行demo程序，可以看到每5秒父进程就会不断创建子进程进行工作。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
子进程113602正在运行中。
子进程113602正在运行中。
...
子进程114543正在运行中。
子进程115458正在运行中。
子进程115132正在运行中。
子进程114200正在运行中。
子进程113883退出，sig=15
....
子进程115804正在运行中。
子进程116737正在运行中。
父进程退出，sig=15
子进程117326退出，sig=15
子进程117020退出，sig=15
子进程116737退出，sig=15
子进程116391退出，sig=15
子进程116085退出，sig=15
子进程115804退出，sig=15
子进程115458退出，sig=15
子进程115132退出，sig=15
子进程114871退出，sig=15
子进程114543退出，sig=15
子进程114200退出，sig=15
子进程113602退出，sig=15
[root@localhost my_learn_test]# 
```

在窗口2，我们可以通过kill 杀死两个子进程看看。可以看到子进程工程退出了。我们再去杀死父进程，可以看到所以的子进程都有次序的终止退出了。

```shell
[root@localhost tmp]# ps -ef|grep demo
root     113601  64140  0 00:40 pts/5    00:00:00 ./demo
root     113602 113601  0 00:40 pts/5    00:00:00 ./demo
root     113883 113601  0 00:40 pts/5    00:00:00 ./demo
root     114200 113601  0 00:40 pts/5    00:00:00 ./demo
root     114543 113601  0 00:40 pts/5    00:00:00 ./demo
root     114545   5571  0 00:40 pts/3    00:00:00 grep --color=auto demo
[root@localhost tmp]# kill 113883
[root@localhost tmp]# ps -ef|grep demo
root     113601  64140  0 00:40 pts/5    00:00:00 ./demo
root     113602 113601  0 00:40 pts/5    00:00:00 ./demo
root     114200 113601  0 00:40 pts/5    00:00:00 ./demo
root     114543 113601  0 00:40 pts/5    00:00:00 ./demo
root     114871 113601  0 00:40 pts/5    00:00:00 ./demo
root     115132 113601  0 00:40 pts/5    00:00:00 ./demo
root     115458 113601  0 00:41 pts/5    00:00:00 ./demo
root     115804 113601  0 00:41 pts/5    00:00:00 ./demo
root     116085 113601  0 00:41 pts/5    00:00:00 ./demo
root     116391 113601  0 00:41 pts/5    00:00:00 ./demo
root     116737 113601  0 00:41 pts/5    00:00:00 ./demo
root     116739   5571  0 00:41 pts/3    00:00:00 grep --color=auto demo
[root@localhost tmp]# kill 113601
[root@localhost tmp]# 

```



:::

## 共享内存

多线程共享进程的地址空间，如果多个线程需要访问同一块内存，用全局变量就可以了。



在多进程中，每个进程的地址空间是独立的，不共享的，如果多个进程需要访问同一块内存，不能用全局变量，只能用共享内存。





共享内存（Shared Memory）允许多个进程（不要求进程之间有血缘关系）访问同一块内存空间，是多个进程之间共享和传递数据最高效的方式。进程可以将共享内存连接到它们自己的地址空间中，如果某个进程修改了共享内存中的数据，其它的进程读到的数据也会改变。



共享内存没有提供锁机制，也就是说，在某一个进程对共享内存进行读/写的时候，不会阻止其它进程对它的读/写。这个时候我们就要考虑临界资源竞争的问题了，如果要对共享内存的读/写加锁，可以使用信号量。



Linux中提供了一组函数用于操作共享内存。

### shmget函数

:::details `shmget()` 函数说明

该函数用于创建/获取共享内存。

```cpp
int shmget(key_t key, size_t size, int shmflg);
```



`key`	 共享内存的键值，是一个整数（typedef unsigned int key_t），一般采用十六进制，例如0x5005，不同共享内存的key不能相同。



`size` 共享内存的大小，以字节为单位。



`shmflg`	共享内存的访问权限，与文件的权限一样，例如0666|IPC_CREAT，0666表示全部用户对它可读写，IPC_CREAT表示如果共享内存不存在，就创建它。



`返回值:` 成功返回共享内存的id（一个非负的整数），失败返回-1（系统内存不足、没有权限）

:::



:::details shmget() 创建/获取共享内存

```c
#include <iostream>
#include <unistd.h>
#include <signal.h>
#include <sys/ipc.h>
#include <sys/shm.h>
using  namespace std;
struct stgirl //超女结构体
{
  int no; //编号。
  char name[51]; //姓名，注意，不能用string
};
int main(int argc,char* argv[])
{
  //第一步，创建/获取共享内存，键值key为0x5005,也可以用其他的值
  int shmid = shmget(0x5005,sizeof(stgirl),0640|IPC_CREAT);
  if ( shmid ==-1 )
    cout << "shmget(0x5005) failed.\n"; return -1;
  cout << "shmid=" << shmid << endl;
}
```

编译源码，并运行demo程序。可以看到共享内存`shmid=22`.  我们还可以用`ipcs -m`可以查看系统的共享内存。展示的信息包括：键值（key），共享内存id（shmid），拥有者（owner），权限（perms），大小（bytes）。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ./demo
shmid=22
[root@localhost my_learn_test]# ipcs -m
------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态      
0x00000000 9          wangnaixin 777        16384      1          目标       ...       
0x00005005 22         root       640        56         0                       
```

我们可以使用`ipcrm -m `  基于共享内存id 进行手工删除共享内存。如下演示了手工删除操作。

```shell
[root@localhost my_learn_test]# ipcs -m
------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态      
0x00000000 9          wangnaixin 777        16384      1          目标       ...    
0x00005005 22         root       640        56         0                   
[root@localhost my_learn_test]# ipcrm -m 22
[root@localhost my_learn_test]# ipcs -m

------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态      
0x00000000 9          wangnaixin 777        16384      1          目标       ...
[root@localhost my_learn_test]# 

```

:::

### shmat函数

:::details  `shmat()` 函数说明

该函数用于把共享内存连接到当前进程的地址空间。

```cpp
void *shmat(int shmid, const void *shmaddr, int shmflg);
```

`shmid`		由shmget()函数返回的共享内存标识。

`shmaddr` 指定共享内存连接到当前进程中的地址位置，通常填0，表示让系统来选择共享内存的地址。

`shmflg`		标志位，通常填0。

`返回值:` 调用成功时返回共享内存起始地址，失败返回(void*)-1。

:::



:::details  shmat() 把共享内存连接到当前进程的地址空间

```cpp
#include <iostream>
#include <unistd.h>
#include <signal.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <cstring>
using  namespace std;
struct stgirl //超女结构体
{
  int no; //编号。
  char name[51]; //姓名，注意，不能用string
};
int main(int argc,char* argv[])
{
  if (argc!=3) { cout << "Using:./demo no name\n"; return -1; }
    
  //第一步，创建/获取共享内存，键值key为0x5005,也可以用其他的值
  int shmid = shmget(0x5005,sizeof(stgirl),0640|IPC_CREAT);
  if ( shmid ==-1 )
    cout << "shmget(0x5005) failed.\n"; return -1;
  cout << "shmid=" << shmid << endl;

  // 第2步：把共享内存连接到当前进程的地址空间。
  stgirl *ptr=(stgirl *)shmat(shmid,0,0);
  if ( ptr==(void *)-1 )
  {
    cout << "shmat() failed\n"; return -1;
  }
   // 第3步：使用共享内存，对共享内存进行读/写。
   cout << "原值：no=" << ptr->no << ",name=" << ptr->name << endl;  // 显示共享内存中的原值。
    ptr->no=atoi(argv[1]);        // 对超女结构体的no成员赋值。
    strcpy(ptr->name,argv[2]);    // 对超女结构体的name成员赋值。
    cout << "新值：no=" << ptr->no << ",name=" << ptr->name << endl;  // 显示共享内存中的当前值。

  // 第4步：把共享内存从当前进程中分离。
  shmdt(ptr);
}
```

编译源码程序并运行。可以看到我们成功对共享内存存的结构体指针指向的数据进行了查询和修改。

```shell
[root@localhost my_learn_test]# g++ -o demo demo.cpp
[root@localhost my_learn_test]# ls
demo  demo1  demo10.cpp  demo1.cpp  demo.cpp  tmp.sh
[root@localhost my_learn_test]# ./demo 3 西施
shmid=23
原值：no=0,name=
新值：no=3,name=西施
[root@localhost my_learn_test]# ./demo 8 冰冰
shmid=23
原值：no=3,name=西施
新值：no=8,name=冰冰
```

:::

### shmdt函数

::: details shmdt() 函数说明

该函数用于将共享内存从当前进程中分离，相当于shmat()函数的反操作。

```cpp
int shmdt(const void *shmaddr);
```

shmaddr	shmat()函数返回的地址。

调用成功时返回0，失败时返回-1。

:::

### shmctl函数

:::details shmctl 函数说明

该函数用于操作共享内存，最常用的操作是删除共享内存。

```cpp
int shmctl(int shmid, int command, struct shmid_ds *buf);
```

shmid		shmget()函数返回的共享内存id。

command	操作共享内存的指令，如果要删除共享内存，填IPC_RMID。

buf			操作共享内存的数据结构的地址，如果要删除共享内存，填0。

调用成功时返回0，失败时返回-1。

:::



:::warning 注意



**用root创建的共享内存，不管创建的权限是什么，普通用户无法删除。**



**结构体中表示字符串不能用stl容器，只能用c的风格的东西，数组啊，char*啊。别用string (经验)**

::: 

## 循环队列

共享内存不能自动扩展，只能采用C++内置的数据类型，

共享内存不能采用STL容器，也不能使用移动语义。

如果要实现多进程的生产/消费者模型，只能采用循环队列



假设这是一块共享内存，大小是固定的，可以存放7个元素。用数组表示。现在队列中已经存放了4个元素。还有3个位置是空的，内部维护队头指针，队尾指针。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240413211017836.png)



如果有新的元素要入队，入队之后，则队尾指针往后移动。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240317090417049-17106374580141.png)



队列中的元素往队头出队，出队之后，然后队头指针往后移动。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240413211322841.png)

现在队尾指针已经指向最后一个位置了，如果这个时候还有元素要入队怎么办？把数组的第一个元素利用起来，进行入队，然后队尾指针指向第一个元素。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240413211500215.png)

总之，循环队列就是把固定大小的空间循环利用起来。





:::details 测试自封装的循环队列

`demo1.cpp`

```cpp
#include "_public.h"
int main()
{
  using ElemType=int;
  squeue<ElemType,5> QQ;
  ElemType ee;      // 创建一个数据元素。

  cout << "元素（1、2、3）入队。\n";
  ee=1;  QQ.push(ee);
  ee=2;  QQ.push(ee);
  ee=3;  QQ.push(ee);
  cout << "队列的长度是" << QQ.size() << endl;
  QQ.printqueue();

  ee=QQ.front(); QQ.pop(); cout << "出队的元素值为" << ee << endl;
  ee=QQ.front(); QQ.pop(); cout << "出队的元素值为" << ee << endl;
  cout << "队列的长度是" << QQ.size() << endl;
  QQ.printqueue();

  cout << "元素（11、12、13、14、15）入队。\n";
  ee=11;  QQ.push(ee);
  ee=12;  QQ.push(ee);
  ee=13;  QQ.push(ee);
  ee=14;  QQ.push(ee);
  ee=15;  QQ.push(ee);
  cout << "队列的长度是" << QQ.size() << endl;
  QQ.printqueue();
}
```

编译源码，并运行demo1 程序。可以看到这个循环队列处理元素符合我们需要预期。

```shell
[root@localhost my_learn_test]# make
g++ -g -o demo1 demo1.cpp _public.cpp
g++ -g -o demo2 demo2.cpp _public.cpp
g++ -g -o demo3 demo3.cpp _public.cpp
g++ -g -o incache incache.cpp _public.cpp
g++ -g -o outcache outcache.cpp _public.cpp
[root@localhost my_learn_test]# ./demo1
元素（1、2、3）入队。
队列的长度是3
m_data[0],value=1
m_data[1],value=2
m_data[2],value=3
[root@localhost my_learn_test]# make
g++ -g -o demo1 demo1.cpp _public.cpp
[root@localhost my_learn_test]# ./demo1
元素（1、2、3）入队。
队列的长度是3
m_data[0],value=1
m_data[1],value=2
m_data[2],value=3
出队的元素值为1
出队的元素值为2
队列的长度是1
m_data[2],value=3
元素（11、12、13、14、15）入队。
循环队列已满，入队失败。
队列的长度是5
m_data[2],value=3
m_data[3],value=11
m_data[4],value=12
m_data[0],value=13
m_data[1],value=14
[root@localhost my_learn_test]# 
```

:::



:::details 基于共享内存的循环队列的整合

```cpp
// demo2.cpp，本程序演示基于共享内存的循环队列。
#include "_public.h"

int main()
{
  using ElemType=int;

  // 初始化共享内存。
  int shmid=shmget(0x5005, sizeof(squeue<ElemType,5>), 0640|IPC_CREAT);
  if ( shmid ==-1 )
    cout << "shmget(0x5005) failed.\n"; return -1;

  // 把共享内存连接到当前进程的地址空间。
  squeue<ElemType,5> *QQ=(squeue<ElemType,5> *)shmat(shmid,0,0);
  if (QQ==(void *)-1 )
    cout << "shmat() failed\n"; return -1;
    
  QQ->init();       // 初始化循环队列。
  //进程的共享内存只是一块内存，我们把他转为循环队列的指针之后，他本质还是内存，所以必须进行初始化。
  
  //循环队列 元素入队情况
  ElemType ee;    
  cout << "元素（1、2、3）入队。\n";
  ee=1;  QQ->push(ee);
  ee=2;  QQ->push(ee);
  ee=3;  QQ->push(ee);
  cout << "队列的长度是" << QQ->size() << endl;
  QQ->printqueue();
  //循环队列 元素出队情况
  ee=QQ->front(); QQ->pop(); cout << "出队的元素值为" << ee << endl;
  ee=QQ->front(); QQ->pop(); cout << "出队的元素值为" << ee << endl;
  cout << "队列的长度是" << QQ->size() << endl;
  QQ->printqueue();
  //循环队列队满入队情况
  cout << "元素（11、12、13、14、15）入队。\n";
  ee=11;  QQ->push(ee);
  ee=12;  QQ->push(ee);
  ee=13;  QQ->push(ee);
  ee=14;  QQ->push(ee);
  ee=15;  QQ->push(ee);

  cout << "队列的长度是" << QQ->size() << endl;  
  QQ->printqueue();

  shmdt(QQ);  // 把共享内存从当前进程中分离。
}
```

编译源码文件，并运行 demo2程序，验证基于共享内存的循环队列。

```shell
[root@localhost my_learn_test]# ./demo2
元素（1、2、3）入队。
循环队列已满，入队失败。
循环队列已满，入队失败。
循环队列已满，入队失败。
队列的长度是5
m_data[2],value=3
m_data[3],value=11
m_data[4],value=12
m_data[0],value=13
m_data[1],value=14
出队的元素值为3
出队的元素值为11
队列的长度是3
m_data[4],value=12
m_data[0],value=13
m_data[1],value=14
元素（11、12、13、14、15）入队。
循环队列已满，入队失败。
循环队列已满，入队失败。
循环队列已满，入队失败。
队列的长度是5
m_data[4],value=12
m_data[0],value=13
m_data[1],value=14
m_data[2],value=11
m_data[3],value=12
```

:::





:::details 循环队列实现

```c
#ifndef __PUBLIC_HH
#define __PUBLIC_HH 1
#include "_cmpublic.h"    // C/C++、Linux编程常用的头文件，新的头文件请在_cmpublic.h中添加。

// 循环队列。
template <class TT, int MaxLength>
class squeue
{
private:
    bool m_inited;              // 队列被初始化标志，true-已初始化；false-未初始化。
    TT   m_data[MaxLength];     // 用数组存储循环队列中的元素。
    int  m_head;                // 队列的头指针。
    int  m_tail;                // 队列的尾指针，指向队尾元素。
    int  m_length;              // 队列的实际长度。    
    squeue(const squeue &) = delete;             // 禁用拷贝构造函数。
    squeue &operator=(const squeue &) = delete;  // 禁用赋值函数。
public:
    squeue() { init(); }  // 构造函数。

    // 循环队列的初始化操作。
    // 注意：如果用于共享内存的队列，不会调用构造函数，必须调用此函数初始化。
    void init()  
    { 
        if (m_inited!=true)               // 循环队列的初始化只能执行一次。
        { 
            m_head=0;                      // 头指针。
            m_tail=MaxLength-1;     // 为了方便写代码，初始化时，尾指针指向队列的最后一个位置。
            m_length=0;                   // 队列的实际长度。
            memset(m_data,0,sizeof(m_data));  // 数组元素清零。
            m_inited=true; 
        }
    }

    // 元素入队，返回值：false-失败；true-成功。
    bool push(const TT &ee)
    {
        if (full() == true)
        {
            cout << "循环队列已满，入队失败。\n"; return false;
        }

        // 先移动队尾指针，然后再拷贝数据。
        m_tail=(m_tail+1)%MaxLength;  // 队尾指针后移。
        m_data[m_tail]=ee;
        m_length++;    

      return true;
    }

    // 求循环队列的长度，返回值：>=0-队列中元素的个数。
    int  size()                   
    {
        return m_length;    
    }

    // 判断循环队列是否为空，返回值：true-空，false-非空。
    bool empty()                    
    {
      if (m_length == 0) return true;    

      return false;
    }

    // 判断循环队列是否已满，返回值：true-已满，false-未满。
    bool full()
    {
        if (m_length == MaxLength) return true;    

      return false;
    }

    // 查看队头元素的值，元素不出队。
    TT& front()
    {
        return m_data[m_head];
    }

    // 元素出队，返回值：false-失败；true-成功。
    bool pop()
    {
        if (empty() == true) return false;

        m_head=(m_head+1)%MaxLength;  // 队列头指针后移。
        m_length--;    

        return true;
    }

    // 显示循环队列中全部的元素。
    // 这是一个临时的用于调试的函数，队列中元素的数据类型支持cout输出才可用。
    void printqueue()                    
    {
        for (int ii = 0; ii < size(); ii++)
        {
            cout << "m_data[" << (m_head+ii)%MaxLength << "],value=" \
                 << m_data[(m_head+ii)%MaxLength] << endl;
        }
    }
};
#endif
```

>  计算入队时，元素插入索引设计细节

 假设当前循环队列是如下的情况，尾指针是2，则进入计算索引逻辑 2+1=3，3%7=3。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240413212423590.png)

因为计算出来的尾指针为3，将尾指针从位置2移动到3的位置，再把数据拷贝进去。最后把队列长度+1.

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240413212748354.png)



假设队列又是这种情况，尾指针是6，则进入计算索引逻辑，6+1=7，7%7=0。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240413212837106.png)



因为计算出来的尾指针为0，最终得到的结果也是符合预期的。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240413213019948.png)

:::



## 信号量

**信号量的基本概念**

- 信号量本质上是一个非负数(≥0)的计数器。
- 用于给共享资源建立一个标志，表示该共享资源被占用情况。



**信号量的两种操作**

- P操作(wait)将信号量的值减1，如果信号量的值为0，将阻塞等待，直到信号量的值大于0。
  
- V操作(post)将信号量的值加1，任何时候都不会阻塞。



**信号量的应用场景**

- 如果约定信号量的取值只是0和1 (O-资源不可用;1-资源可用),可以实现互斥锁。
- 如果约定信号量的取值表示可用资源的数量，可以实现生产/消费者模型。



:::details 自实现信号量`csemp` 声明

```c
// 信号量。
class csemp
{
private:
    union semun  // 用于信号量操作的共同体。
    {
      int val;
      struct semid_ds *buf;
      unsigned short  *arry;
    };

    int   m_semid;         // 信号量id（描述符）。
    // 如果把sem_flg设置为SEM_UNDO，操作系统将跟踪进程对信号量的修改情况，
    // 在全部修改过信号量的进程（正常或异常）终止后，操作系统将把信号量恢复为初始值。
    // 如果信号量用于互斥锁，设置为SEM_UNDO。
    // 如果信号量用于生产消费者模型，设置为0。
    short m_sem_flg;

    

public:
    //m_semid为-1表示信号量没有被初始化，如果被初始化了应该大于等于0
    csemp():m_semid(-1){}
    csemp(const csemp &) = delete;   // 禁用拷贝构造函数。
    csemp &operator=(const csemp &) = delete;  // 禁用赋值函数。
	
    
public:    
    //初始化信号量
    // key 表示一个信号量，和共享内存差不多
    // 底层会判读如果信号量已存在，获取信号量；如果信号量不存在，则创建它并初始化为value。
    // 如果用于互斥锁，第二个参数value填1，第三个参数sem_flg填SEM_UNDO。
    // 如果用于生产消费者模型，第二个参数value填0，第三个参数sem_flg填0。
    bool init(key_t key,unsigned short value=1,short sem_flg=SEM_UNDO);
    
    
    //信号量的P操作
    //如果信号量的值是0，将阻塞等待，直到信号量的值大于0。
    //如果信号量的值大于0，将立即返回。
    bool wait(short value=-1);   
   
    // 信号量的V操作。
    //缺省形参，默认将信号量的值加1
    bool post(short value=1);    
    
    //获取信号量的值，成功返回信号量的值，失败返回-1。
    int  getvalue();                 
    
    //销毁信号量。
    bool destroy();                      
    
    ~csemp();
};

```

:::



:::details  `csemp`信号量实现

```c
#include "_public.h"

// 如果信号量已存在，获取信号量；如果信号量不存在，则创建它并初始化为value。
// 如果用于互斥锁，value填1，sem_flg填SEM_UNDO。
// 如果用于生产消费者模型，value填0，sem_flg填0。
bool csemp::init(key_t key,unsigned short value,short sem_flg)
{
  if (m_semid!=-1) return false; // 如果已经初始化了，不必再次初始化。

  m_sem_flg=sem_flg;

  // 信号量的初始化不能直接用semget(key,1,0666|IPC_CREAT)
  // 因为信号量创建后，初始值是0，如果用于互斥锁，需要把它的初始值设置为1，
  // 而获取信号量则不需要设置初始值，所以，创建信号量和获取信号量的流程不同。

  // 信号量的初始化分三个步骤：
  // 1）获取信号量，如果成功，函数返回。
  // 2）如果失败，则创建信号量。
  // 3) 设置信号量的初始值。

  // 获取信号量。
  if ( (m_semid=semget(key,1,0666)) == -1)
  {
    // 如果信号量不存在，创建它。
    if (errno==ENOENT)
    {
      // 用IPC_EXCL标志确保只有一个进程创建并初始化信号量，其它进程只能获取。
      if ( (m_semid=semget(key,1,0666|IPC_CREAT|IPC_EXCL)) == -1)
      {
        if (errno==EEXIST) // 如果错误代码是信号量已存在，则再次获取信号量。
        {
          if ( (m_semid=semget(key,1,0666)) == -1)
          { 
            perror("init 1 semget()"); return false; 
          }
          return true;
        }
        else  // 如果是其它错误，返回失败。
        {
          perror("init 2 semget()"); return false;
        }
      }

      // 信号量创建成功后，还需要把它初始化成value。
      union semun sem_union;
      sem_union.val = value;   // 设置信号量的初始值。
      if (semctl(m_semid,0,SETVAL,sem_union) <  0) 
      { 
        perror("init semctl()"); return false; 
      }
    }
    else
    { perror("init 3 semget()"); return false; }
  }

  return true;
}

// 信号量的P操作（把信号量的值减value），如果信号量的值是0，将阻塞等待，直到信号量的值大于0。
bool csemp::wait(short value)
{
  if (m_semid==-1) return false;

  struct sembuf sem_b;
  sem_b.sem_num = 0;      // 信号量编号，0代表第一个信号量。
  sem_b.sem_op = value;   // P操作的value必须小于0。
  sem_b.sem_flg = m_sem_flg;
  if (semop(m_semid,&sem_b,1) == -1) { perror("p semop()"); return false; }

  return true;
}

// 信号量的V操作（把信号量的值减value）。
bool csemp::post(short value)
{
  if (m_semid==-1) return false;

  struct sembuf sem_b;
  sem_b.sem_num = 0;     // 信号量编号，0代表第一个信号量。
  sem_b.sem_op = value;  // V操作的value必须大于0。
  sem_b.sem_flg = m_sem_flg;
  if (semop(m_semid,&sem_b,1) == -1) { perror("V semop()"); return false; }

  return true;
}

// 获取信号量的值，成功返回信号量的值，失败返回-1。
int csemp::getvalue()
{
  return semctl(m_semid,0,GETVAL);
}

// 销毁信号量。
bool csemp::destroy()
{
  if (m_semid==-1) return false;

  if (semctl(m_semid,0,IPC_RMID) == -1) { perror("destroy semctl()"); return false; }

  return true;
}

csemp::~csemp()
{
}
```

:::



:::details 演示用信号量给共享内存加锁

```cpp
// demo3.cpp，本程序演示用信号量给共享内存加锁。
#include "_public.h"
struct stgirl     // 超女结构体。
{
  int  no;        // 编号。
  char name[51];  // 姓名，注意，不能用string。
};

int main(int argc,char *argv[])
{
  if (argc!=3) { cout << "Using:./demo no name\n"; return -1; }

  // 第1步：创建/获取共享内存，键值key为0x5005，也可以用其它的值。
  int shmid=shmget(0x5005, sizeof(stgirl), 0640|IPC_CREAT);
  if ( shmid ==-1 )
    cout << "shmget(0x5005) failed.\n"; return -1; 
  cout << "shmid=" << shmid << endl;

  // 第2步：把共享内存连接到当前进程的地址空间。
  stgirl *ptr=(stgirl *)shmat(shmid,0,0);
  if ( ptr==(void *)-1 )
    cout << "shmat() failed\n"; return -1; 

  // 创建、初始化二元信号量。
  csemp mutex;
  if (mutex.init(0x5005)==false)
    cout << "mutex.init(0x5005) failed.\n"; return -1;

  cout << "申请加锁...\n";
  mutex.wait(); // 申请加锁。
  cout << "申请加锁成功。\n";

  // 第3步：使用共享内存，对共享内存进行读/写。
  cout << "原值：no=" << ptr->no << ",name=" << ptr->name << endl;  // 显示共享内存中的原值。
  ptr->no=atoi(argv[1]);        // 对超女结构体的no成员赋值。
  strcpy(ptr->name,argv[2]);    // 对超女结构体的name成员赋值。
  cout << "新值：no=" << ptr->no << ",name=" << ptr->name << endl;  // 显示共享内存中的当前值。
  
 sleep(10);

    
  mutex.post(); // 解锁。
  cout << "解锁。\n";

  // 查看信号量  ：ipcs -s    // 删除信号量  ：ipcrm sem 信号量id
  // 查看共享内存：ipcs -m    // 删除共享内存：ipcrm -m  共享内存id

  // 第4步：把共享内存从当前进程中分离。
  shmdt(ptr);

  // 第5步：删除共享内存。
  //if (shmctl(shmid,IPC_RMID,0)==-1)
  //{ 
   // cout << "shmctl failed\n"; return -1; 
  //}
}
```

在窗口1，编译`demo3.cpp`源码 并运行`demo3`程序。可以看到获取到信号量后，对共享内存进行了操作（查询并修改）。直到10秒之后，才对信号量进行解锁。

```shell
[root@localhost my_learn_test]# ./demo3 8 西施
shmid=25
申请加锁...
申请加锁成功。
原值：no=3,name=冰冰
新值：no=8,name=西施
解锁。
```

窗口1，再次重复上述流程。

```shell
[root@localhost my_learn_test]# ./demo3 8 西施
shmid=25
申请加锁...
申请加锁成功。
原值：no=0,name=
新值：no=3,name=冰冰
解锁。
[root@localhost my_learn_test]# 

```

此刻窗口2，在锁被占用的10秒内，又运行`demo3` 可以看到，在申请加锁 信号量P操作，这一步阻塞住了。直到窗口2解锁，过去了10S，窗口的才可以继续操作共享内存。

```shell
[root@localhost my_learn_test]# ./demo3 3 冰冰
shmid=25
申请加锁...
...10S之后
申请加锁成功。
原值：no=8,name=西施
新值：no=3,name=冰冰
解锁。
[root@localhost my_learn_test]# 
```

:::



:::details  `ipcrm 管理信号量的指令` 

我们可以先通过 `ipcs -s` 指向，查询Linux操作中所有运行的信号量，该命令会返回信号量键、`semid` 等等信息。



依据`semid` 可以通过`ipcrm sem 信号量ID`   去删除一个存在的信号量。

```shell
[root@localhost my_learn_test]# ipcs sem

--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息      
...
--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems     
0x00005005 0          root       666        1         

[root@localhost my_learn_test]# ipcs -s

--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems     
0x00005005 0          root       666        1         

[root@localhost my_learn_test]# ipcrm sem 0
resource(s) deleted
[root@localhost my_learn_test]# ipcs -s

--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems     
```

:::



## 生产/消费者模型

:::details `生产者程序 incache`

```cpp
//incache.cpp
// 多进程的生产消费者模型的生产者程序
#include "_public.h"
int main()
{
  struct stgirl  // 循环队列的数据元素是超女结构体。
  {
    int no;
    char name[51];
  };
  using ElemType=stgirl;
  // 初始化共享内存。
  int shmid=shmget(0x5005, sizeof(squeue<ElemType,5>), 0640|IPC_CREAT);
  if ( shmid ==-1 )
  {
    cout << "shmget(0x5005) failed.\n"; return -1;
  }
  // 把共享内存连接到当前进程的地址空间。
  squeue<ElemType,5> *QQ=(squeue<ElemType,5> *)shmat(shmid,0,0);
  if ( QQ==(void *)-1 )
  {
    cout << "shmat() failed\n"; return -1;
  }

  QQ->init();       // 初始化循环队列。

  ElemType ee;      // 创建一个数据元素。

  csemp mutex; mutex.init(0x5001);     // 用于给共享内存加锁。
  csemp cond;  cond.init(0x5002,0,0);  // 信号量的值用于表示队列中数据元素的个数。

  mutex.wait();  // 加锁。
  // 生产3个数据。
  ee.no=3; strcpy(ee.name,"西施"); QQ->push(ee);
  ee.no=7; strcpy(ee.name,"冰冰"); QQ->push(ee);
  ee.no=8; strcpy(ee.name,"幂幂"); QQ->push(ee);
  mutex.post();  // 解锁。
  cond.post(3);  // 实参是3，表示生产了3个数据。

  shmdt(QQ);  // 把共享内存从当前进程中分离。
}
```

:::



:::details `消费者程序 outcache.cpp`

```cpp
//outcache.cpp
// 多进程的生产消费者模型的消费者程序
#include "_public.h"

int main()
{
  struct stgirl  // 循环队列的数据元素是超女结构体。
  {
    int no;
    char name[51];
  };

  using ElemType=stgirl;

  // 初始化共享内存。
  int shmid=shmget(0x5005, sizeof(squeue<ElemType,5>), 0640|IPC_CREAT);
  if ( shmid ==-1 )
  {
    cout << "shmget(0x5005) failed.\n"; return -1;
  }

  // 把共享内存连接到当前进程的地址空间。
  squeue<ElemType,5> *QQ=(squeue<ElemType,5> *)shmat(shmid,0,0);
  if ( QQ==(void *)-1 )
  {
    cout << "shmat() failed\n"; return -1;
  }

  QQ->init();       // 初始化循环队列。

  ElemType ee;      // 创建一个数据元素。

  csemp mutex; mutex.init(0x5001);     // 用于给共享内存加锁。
  csemp cond;  cond.init(0x5002,0,0);  // 信号量的值用于表示队列中数据元素的个数。

  while (true)
  {
    mutex.wait();  // 加锁。

    while (QQ->empty())    // 如果队列空，进入循环，否则直接处理数据。必须用循环，不能用if
    {
      mutex.post();   // 解锁。
      cond.wait();    // 等待生产者的唤醒信号。
      mutex.wait();   // 加锁。
    }

    // 数据元素出队。
    ee = QQ->front();  QQ->pop();
    mutex.post(); // 解锁。

    // 处理出队的数据（把数据消费掉）。
    cout << "no=" << ee.no << ",name=" << ee.name << endl;
    usleep(100);    // 假设处理数据需要时间，方便演示。
  }

  shmdt(QQ);
}
```

:::





::: details `makefile` 做整合编译

```makefile
incache:incache.cpp _public.h _public.cpp
	g++ -g -o incache incache.cpp _public.cpp

outcache:outcache.cpp _public.h _public.cpp
	g++ -g -o outcache outcache.cpp _public.cpp

clean:
	rm -f demo1 demo2 demo3 incache outcache
```

:::



在窗口1，运行生产者程序`incache`，在窗口2运行消费者程序`outcache` ,可以看到三条数据都被消费者消费完了。

```shell
[root@localhost my_learn_test]# ./incache
[root@localhost my_learn_test]# ./incache 
[root@localhost my_learn_test]# ./incache 
```

这个时候，在窗口1运行生产者程序，在窗口2，窗口3，窗口4依次运行消费者程序，可以看到程序依然被三个进程有序消费了。

```shell
[root@localhost my_learn_test]# ./outcache 
no=3,name=西施
no=7,name=冰冰
no=8,name=幂幂
no=3,name=西施
no=7,name=冰冰
no=8,name=幂幂
no=3,name=西施
```

```shell
[root@localhost my_learn_test]# ./outcache 
no=7,name=冰冰
```

```shell
[root@localhost my_learn_test]# ./outcache 
no=8,name=幂幂
```

则说明我们进程版本的 生产者/消费者模型 搭建完成。

## UNIX环境高级编程

经典书籍《UNIX环境高级编程(APUE) 》，第三版。

UNIX环境高级编程博大精深，现阶段暂时不要深入研究。

最常用:目录、文件、时间、进程、进程通讯、线程、线程同步。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240317094155053-17106397169362.png)





先满足工作和面试的要求。



其它的内容，如果工作中真的用到了，再研究。



时间比较充裕的时候把这本书过一遍。

