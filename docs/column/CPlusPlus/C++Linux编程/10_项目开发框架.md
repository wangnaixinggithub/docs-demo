# 项目开发框架

什么是开发框架？

- 开发框架可以简单的理解为已封装好的函数和类，是工具的集合。
- 拥有合适的开发框架，可以极大的提升开发效率。
- 在实际项目开发中，程序员都会使用开发框架。

- 在项目开始之前，熟悉开发框架（士兵-武器装备)。

- 重点是掌握开发框架的功能和使用方法，能写出源代码更棒。

- 不完全理解开发框架的功能没有关系，项目开发时将融汇贯通





# 开发框架介绍

![image-20240324113844474](10_项目开发框架.assets/image-20240324113844474-17112515258981.png)



有统一的开发框架吗？

- boost、POCO是底层框架，不能满足应用开发的需求。
- 不同的行业、公司、大佬有不同的开发框架，一人一风格。
- 开发框架是各家的秘笈，不外传，百度不到。





# 字符串操作

## 删除替换字符、正则匹配

```c++
namespace idc
{
    // C++风格字符串操作的若干函数。
    // 删除字符串左边指定的字符。
    // str：待处理的字符串。
    // cc：需要删除的字符，缺省删除空格。
    char*     deletelchr(char* str, const int cc=' ');
    string& deletelchr(string &str, const int cc=' ');

    // 删除字符串右边指定的字符。
    // str：待处理的字符串。
    // cc：需要删除的字符，缺省删除空格。
    char*     deleterchr(char *str,const int cc=' ');
    string& deleterchr(string &str,const int cc=' ');

    // 删除字符串左右两边指定的字符。
    // str：待处理的字符串。
    // chr：需要删除的字符，缺省删除空格。
    char*     deletelrchr(char *str,const int cc=' ');
    string& deletelrchr(string &str,const int cc=' ');
    
    
        // 把字符串中的小写字母转换成大写，忽略不是字母的字符。
    // str：待转换的字符串。
    char*     toupper(char *str);
    string& toupper(string &str);

    // 把字符串中的大写字母转换成小写，忽略不是字母的字符。
    // str：待转换的字符串。
    char*     tolower(char *str);
    string& tolower(string &str);
    

    // 字符串替换函数。
    // 在字符串str中，如果存在字符串str1，就替换为字符串str2。
    // str：待处理的字符串。
    // str1：旧的内容。
    // str2：新的内容。
    // bloop：是否循环执行替换。
    // 注意：
    // 1、如果str2比str1要长，替换后str会变长，所以必须保证str有足够的空间，否则内存会溢出（C++风格字符串不存在这个问题）。
    // 2、如果str2中包含了str1的内容，且bloop为true，这种做法存在逻辑错误，replacestr将什么也不做。
    // 3、如果str2为空，表示删除str中str1的内容。
    bool replacestr(char *str   ,const string &str1,const string &str2,const bool bloop=false);
    bool replacestr(string &str,const string &str1,const string &str2,const bool bloop=false);
    
    
    
    
    
// 从一个字符串中提取出数字、符号和小数点，存放到另一个字符串中。
// src：原字符串。
// dest：目标字符串。
// bsigned：是否提取符号（+和-），true-包括；false-不包括。
// bdot：是否提取小数点（.），true-包括；false-不包括。
// 注意：src和dest可以是同一个变量。
char*     picknumber(const string &src,char *dest,const bool bsigned=false,const bool bdot=false);
string& picknumber(const string &src,string &dest,const bool bsigned=false,const bool bdot=false);
string    picknumber(const string &src,const bool bsigned=false,const bool bdot=false);
    
    
    
    // 正则表达式，判断一个字符串是否匹配另一个字符串。
// str：需要判断的字符串，是精确表示的，如文件名"_public.cpp"。
// rules：匹配规则的表达式，用星号"*"代表任意字符，多个表达式之间用半角的逗号分隔，如"*.h,*.cpp"。
// 注意：1）str参数不需要支持"*"，rules参数支持"*"；2）函数在判断str是否匹配rules的时候，会忽略字母的大小写。
bool matchstr(const string &str,const string &rules);

}
```

```c
/*
 *  程序名：demo10.cpp，此程序演示开发框架中删除字符串左、右、两边指定字符的使用方法。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    char str1[31];        // C风格的字符串。
    string str2;            // C++风格的字符串。

    strcpy(str1,"  西施  ");
    deletelchr(str1,' ');                // 删除str1左边的空格
    printf("str1=%s=\n",str1);    // 出输结果是str1=西施  =

    str2="  西施  ";
    deletelchr(str2,' ');
    cout << "str2=" << str2 << "=\n";

    strcpy(str1,"  西施  ");
    deleterchr(str1,' ');                // 删除str1左边的空格
    printf("str1=%s=\n",str1);    // 出输结果是str1=西施  =

    str2="  西施  ";
    deleterchr(str2,' ');
    cout << "str2=" << str2 << "=\n";

    strcpy(str1,"  西施  ");
    deletelrchr(str1,' ');               // 删除str1两边的空格
    printf("str1=%s=\n",str1);    // 出输结果是str1=西施=

    str2="  西施  ";
    deletelrchr(str2,' ');
    cout << "str2=" << str2 << "=\n";
}

```

```shell
[root@localhost demo]# g++ -o demo10 demo10.cpp ../_public.cpp  
[root@localhost demo]# ./demo10
str1=西施  =
str2=西施  =
str1=  西施=
str2=  西施=
str1=西施=
str2=西施=
[root@localhost demo]# 
```

```cpp
/*
 *  程序名：demo14.cpp，此程序演示开发框架中字符串替换replacestr函数的使用。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    char str1[301];

    strcpy(str1,"name:messi,no:10,job:striker.");
    replacestr(str1,":","=");         // 把冒号替换成等号。
    printf("str1=%s=\n",str1);    // 出输结果是str1=name=messi,no=10,job=striker.=

    strcpy(str1,"name:messi,no:10,job:striker.");
    replacestr(str1,"name:","");    // 把"name:"替换成""，相当于删除内容"name:"。
    printf("str1=%s=\n",str1);      // 出输结果是str1=messi,no:10,job:striker.=

    strcpy(str1,"messi----10----striker");  
    replacestr(str1,"--","-",false);    // 把两个"--"替换成一个"-"，bloop参数为false。
    printf("str1=%s=\n",str1);         // 出输结果是str1=messi--10--striker=

    strcpy(str1,"messi----10----striker");  
    replacestr(str1,"--","-",true);    // 把两个"--"替换成一个"-"，bloop参数为true。
    printf("str1=%s=\n",str1);        // 出输结果是str1=messi-10-striker=

    strcpy(str1,"messi-10-striker");  
    replacestr(str1,"-","--",false);    // 把一个"-"替换成两个"--"，bLoop参数为false。
    printf("str1=%s=\n",str1);         // 出输结果是str1=messi--10--striker=

    // 以下代码把"-"替换成"--"，bloop参数为true，存在逻辑错误，replacestr将不执行替换。
    strcpy(str1,"messi-10-striker");  
    replacestr(str1,"-","--",true);    // 把一个"-"替换成两个"--"，bloop参数为true。
    printf("str1=%s=\n",str1);        // 出输结果是str1=messi-10-striker=

    // ////////////////////////////////////
    string str2;
    str2="name:messi,no:10,job:striker.";
    replacestr(str2,":","=");                        // 把冒号替换成等号。
    cout << "str2=" << str2 << "=\n";    // 出输结果是str2=name=messi,no=10,job=striker.=

    str2="name:messi,no:10,job:striker.";
    replacestr(str2,"name:","");                  // 把"name:"替换成""，相当于删除内容"name:"。
    cout << "str2=" << str2 << "=\n";     // 出输结果是str2=messi,no:10,job:striker.=

    str2="messi----10----striker";  
    replacestr(str2,"--","-",false);               // 把两个"--"替换成一个"-"，bLoop参数为false。
    cout << "str2=" << str2 << "=\n";     // 出输结果是str2=messi--10--striker=

    str2="messi----10----striker";  
    replacestr(str2,"--","-",true);                // 把两个"--"替换成一个"-"，bLoop参数为true。
    cout << "str2=" << str2 << "=\n";     // 出输结果是str2=messi-10-striker=

    str2="messi-10-striker";  
    replacestr(str2,"-","--",false);               // 把一个"-"替换成两个"--"，bLoop参数为false。
    cout << "str2=" << str2 << "=\n";     // 出输结果是str2=messi--10--striker=

    // 以下代码把"-"替换成"--"，bloop参数为true，存在逻辑错误，updatestr将不执行替换。
    str2="messi-10-striker";  
    replacestr(str2,"-","--",true);                // 把一个"-"替换成两个"--"，bloop参数为true。
    cout << "str2=" << str2 << "=\n";     // 出输结果是str2=messi-10-striker=
}


```

## 解析出字符串的数字

```cpp
/*
 *  程序名：demo16.cpp，此程序演示开发框架中picknumber函数的使用。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    char str1[30];   
    string str2;

    strcpy(str1,"iab+12.3xy");
    picknumber(str1,str1,false,false);
    printf("str1=%s=\n",str1);    // 出输结果是str1=123=

    str2="iab+12.3xy";
    picknumber(str2,str2,false,false);
    cout << "str2=" << str2 << "=\n";  // 出输结果是str2=123=

    strcpy(str1,"iab+12.3xy");
    picknumber(str1,str1,true,false);
    printf("str1=%s=\n",str1);         // 出输结果是str1=+123=

    str2="iab+12.3xy";
    picknumber(str2,str2,true,false);
    cout << "str2=" << str2 << "=\n";  // 出输结果是str2=+123=

    strcpy(str1,"iab+12.3xy");
    picknumber(str1,str1,true,true);
    printf("str1=%s=\n",str1);         // 出输结果是str1=+12.3=

    str2="iab+12.3xy";
    picknumber(str2,str2,true,true);
    cout << "str2=" << str2 << "=\n";  // 出输结果是str2=+12.3=
}


```

```cpp
/*
 *  程序名：demo18.cpp，此程序演示开发框架正则表达示MatchStr函数的使用。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    // 以下代码将输出yes。
    if (matchstr("_public.h","*.h,*.cpp")==true) printf("yes\n");
    else printf("no\n");

    // 以下代码将输出yes。
    if (matchstr("_public.h","*.H")==true) printf("yes\n");
    else printf("no\n");

    // 以下代码将输出no。
    if (matchstr("_public.h","*p*k*.h")==true) printf("yes\n");
    else printf("no\n");
}
```

提升代码能力

- 用demo程序测试函数的功能，掌握使用方法。
- 除了matchstr函数，把其它的函数写出来。
- 如果这些函数的代码写不出来，代码能力达不到实战要求。



## 字符串转数组

```c
/*
 *  程序名：demo20.cpp，此程序演示开发框架拆分字符串ccmdstr类的使用。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

// 用于存放足球运动员资料的结构体。
struct st_player
{
    char name[51];    // 姓名
    char no[6];           // 球衣号码
    bool striker;         // 场上位置是否是前锋，true-是；false-不是。
    int  age;               // 年龄
    double weight;    // 体重，kg。
    long sal;              // 年薪，欧元。
    char club[51];      // 效力的俱乐部
}stplayer;

int main()
{
    memset(&stplayer,0,sizeof(struct st_player));

    string buffer="messi~!~10~!~true~!~a30~!~68.5~!~2100000~!~Barc,elona";    // 梅西的资料。

    //ccmdstr cmdstr;                               // 定义拆分字符串的对象。
    //cmdstr.splittocmd(buffer,"~!~");           // 拆分buffer。
    ccmdstr cmdstr(buffer,"~!~");                 // 定义拆分字符串的对象并拆分字符串。

    // 像访问数组一样访问拆分后的元素。
    for (int ii=0;ii<cmdstr.size();ii++)
    {
        cout << "cmdstr["<<ii<<"]=" << cmdstr[ii] << endl;
    }

    // 输出拆分后的元素，一般用于调试。
    cout << cmdstr;

    // 获取拆分后元素的内容。
    cmdstr.getvalue(0, stplayer.name,50);     // 获取姓名
    cmdstr.getvalue(1, stplayer.no,5);            // 获取球衣号码
    cmdstr.getvalue(2, stplayer.striker);         // 场上位置
    cmdstr.getvalue(3, stplayer.age);             // 获取年龄
    cmdstr.getvalue(4, stplayer.weight);        // 获取体重
    cmdstr.getvalue(5, stplayer.sal);               // 获取年薪，欧元。
    cmdstr.getvalue(6, stplayer.club,50);        // 获取效力的俱乐部
  
    printf("name=%s,no=%s,striker=%d,age=%d,weight=%.1f,sal=%ld,club=%s\n",\
               stplayer.name,stplayer.no,stplayer.striker,stplayer.age,\
               stplayer.weight,stplayer.sal,stplayer.club);
    // 输出结果:name=messi,no=10,striker=1,age=30,weight=68.5,sal=21000000,club=Barcelona
}

```

```cpp
///////////////////////////////////// /////////////////////////////////////
// ccmdstr类用于拆分有分隔符的字符串。
// 字符串的格式为：字段内容1+分隔符+字段内容2+分隔符+字段内容3+分隔符+...+字段内容n。
// 例如："messi,10,striker,30,1.72,68.5,Barcelona"，这是足球运动员梅西的资料。
// 包括：姓名、球衣号码、场上位置、年龄、身高、体重和效力的俱乐部，字段之间用半角的逗号分隔。
class ccmdstr
{
private:
    vector<string> m_cmdstr;  // 存放拆分后的字段内容。

    ccmdstr(const ccmdstr &) = delete;                      // 禁用拷贝构造函数。
    ccmdstr &operator=(const ccmdstr &) = delete;  // 禁用赋值函数。
public:
    ccmdstr()  { } // 构造函数。
    ccmdstr(const string &buffer,const string &sepstr,const bool bdelspace=false);

    const string& operator[](int ii) const     // 重载[]运算符，可以像访问数组一样访问m_cmdstr成员。
    {
        return m_cmdstr[ii];
    }

    // 把字符串拆分到m_cmdstr容器中。
    // buffer：待拆分的字符串。
    // sepstr：buffer中采用的分隔符，注意，sepstr参数的数据类型不是字符，是字符串，如","、" "、"|"、"~!~"。
    // bdelspace：拆分后是否删除字段内容前后的空格，true-删除；false-不删除，缺省不删除。
    void splittocmd(const string &buffer,const string &sepstr,const bool bdelspace=false);

    // 获取拆分后字段的个数，即m_cmdstr容器的大小。
    int size() const { return m_cmdstr.size(); }
    int cmdcount() const { return m_cmdstr.size(); }      // 兼容以前的项目。

    // 从m_cmdstr容器获取字段内容。
    // ii：字段的顺序号，类似数组的下标，从0开始。
    // value：传入变量的地址，用于存放字段内容。
    // 返回值：true-成功；如果ii的取值超出了m_cmdstr容器的大小，返回失败。
    bool getvalue(const int ii,string &value,const int ilen=0) const;      // C++风格字符串。视频中没有第三个参数，加上第三个参数更好。
    bool getvalue(const int ii,char *value,const int ilen=0) const;          // C风格字符串，ilen缺省值为0-全部长度。 
    bool getvalue(const int ii,int  &value) const;                                    // int整数。
    bool getvalue(const int ii,unsigned int &value) const;                     // unsigned int整数。
    bool getvalue(const int ii,long &value) const;                                  // long整数。
    bool getvalue(const int ii,unsigned long &value) const;                  // unsigned long整数。
    bool getvalue(const int ii,double &value) const;                              // 双精度double。
    bool getvalue(const int ii,float &value) const;                                  // 单精度float。
    bool getvalue(const int ii,bool &value) const;                                  // bool型。

    ~ccmdstr(); // 析构函数。
};

// 重载<<运算符，输出ccmdstr::m_cmdstr中的内容，方便调试。
ostream& operator<<(ostream& out, const ccmdstr& cc);
```

## 解析XML

```c
///////////////////////////////////// /////////////////////////////////////
// 解析xml格式字符串的函数族。
// xml格式的字符串的内容如下：
// <filename>/tmp/_public.h</filename><mtime>2020-01-01 12:20:35</mtime><size>18348</size>
// <filename>/tmp/_public.cpp</filename><mtime>2020-01-01 10:10:15</mtime><size>50945</size>
// xmlbuffer：待解析的xml格式字符串。
// fieldname：字段的标签名。
// value：传入变量的地址，用于存放字段内容，支持bool、int、insigned int、long、
//       unsigned long、double和char[]。
// 注意：当value参数的数据类型为char []时，必须保证value数组的内存足够，否则可能发生内存溢出的问题，
//           也可以用ilen参数限定获取字段内容的长度，ilen的缺省值为0，表示不限长度。
// 返回值：true-成功；如果fieldname参数指定的标签名不存在，返回失败。
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,string &value,const int ilen=0);    // 视频中没有第三个参数，加上第三个参数更好。
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,char *value,const int ilen=0);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,bool &value);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,int  &value);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,unsigned int &value);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,long &value);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,unsigned long &value);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,double &value);
bool getxmlbuffer(const string &xmlbuffer,const string &fieldname,float &value);
///////////////////////////////////// /////////////////////////////////////
```

```c
/*
 *  程序名：demo22.cpp，此程序演示调用开发框架的getxmlbuffer函数解析xml字符串。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    // 球员梅西的资料存放在xml中。
    string buffer="<name>梅西</name><no>10</no><striker>true</striker><age>30</age><weight>68.5</weight><sal>21000000</sal><club>Barcelona</club>";

    // 用于存放足球运动员资料的结构体。
    struct st_player
    {
        string name;      // 姓名
        char no[6];       // 球衣号码
        bool striker;     // 场上位置是否是前锋，true-是；false-不是。
        int  age;         // 年龄
        double weight;    // 体重，kg。
        long sal;         // 年薪，欧元。
        char club[51];    // 效力的俱乐部
    }stplayer;

    getxmlbuffer(buffer,"name",stplayer.name);
    cout << "name=" << stplayer.name << endl;

    getxmlbuffer(buffer,"no",stplayer.no,5);
    cout << "no=" << stplayer.no << endl;

    getxmlbuffer(buffer,"striker",stplayer.striker);
    cout << "striker=" << stplayer.striker << endl;

    getxmlbuffer(buffer,"age",stplayer.age);
    cout << "age=" << stplayer.age << endl;

    getxmlbuffer(buffer,"weight",stplayer.weight);
    cout << "weight=" << stplayer.weight << endl;

    getxmlbuffer(buffer,"sal",stplayer.sal);
    cout << "sal=" << stplayer.sal << endl;

    getxmlbuffer(buffer,"club",stplayer.club,50);
    cout << "club=" << stplayer.club << endl;
}


```

```c
[root@localhost demo]# ./demo22
name=梅西
no=10
striker=1
age=30
weight=68.5
sal=21000000
club=Barcelona
```

## 格式输出C++字符串

```c++
// C++格式化输出函数模板。
template< typename... Args >
bool sformat(string &str,const char* fmt, Args... args ) 
{
    int len = snprintf( nullptr, 0, fmt, args... );      // 得到格式化输出后字符串的总长度。
    if (len < 0) return false;                                  // 如果调用snprintf失败，返回-1。
    if (len == 0) { str.clear(); return true; }            // 如果调用snprintf返回0，表示格式化输出的内容为空。

    str.resize(len);                                                 // 为string分配内存。
    snprintf(&str[0], len + 1, fmt, args... );           // linux平台第二个参数是len+1，windows平台是len。
    return true;
}
template< typename... Args >
string sformat(const char* fmt, Args... args ) 
```

```c
/*
 *  程序名：demo23.cpp，此程序演示调用开发框架的格式化输出sformat函数。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    int bh=1;
    char name[31]; strcpy(name,"西施");
    double weight=48.2;
    string yz="漂亮";

    char s1[100];
    int len=snprintf(s1,100,"编号=%02d,姓名=%s,体重=%.2f,颜值=%s",bh,name,weight,yz.c_str());
    cout << "s1=" << s1 << endl;
    printf("len=%d\n",len);
    printf("strlen(s1)=%d\n",strlen(s1));

    string s2;
    s2="编号="+to_string(bh)+",姓名="+name+",体重="+to_string(weight)+",颜值="+yz;
    cout << "s2=" << s2 << endl;

    s2=sformat("编号=%02d,姓名=%s,体重=%.2f,颜值=%s",bh,name,weight,yz.c_str());
    cout << "s2=" << s2 << endl;

    sformat(s2,"编号=%02d,姓名=%s,体重=%.2f,颜值=%s",bh,name,weight,yz.c_str());
    cout << "s2=" << s2 << endl;
}


```

```shell
[root@localhost demo]# ./demo23
s1=编号=01,姓名=西施,体重=48.20,颜值=漂亮
len=50
strlen(s1)=50
s2=编号=1,姓名=西施,体重=48.200000,颜值=漂亮
s2=编号=01,姓名=西施,体重=48.20,颜值=漂亮
s2=编号=01,姓名=西施,体重=48.20,颜值=漂亮
[root@localhost demo]# 
```



# 时间操作



- C++11提供了chrono模版库，实现了时间相关的操作。

- chrono模版库不够方便，不能满足开发的需求，还需要封装。

- 对原生的时间操作函数进行了封装。

```c
///////////////////////////////////// /////////////////////////////////////
// 时间操作的若干函数。
/*
  取操作系统的时间（用字符串表示）。
  strtime：用于存放获取到的时间。
  timetvl：时间的偏移量，单位：秒，0是缺省值，表示当前时间，30表示当前时间30秒之后的时间点，-30表示当前时间30秒之前的时间点。
  fmt：输出时间的格式，fmt每部分的含义：yyyy-年份；mm-月份；dd-日期；hh24-小时；mi-分钟；ss-秒，
  缺省是"yyyy-mm-dd hh24:mi:ss"，目前支持以下格式：
  "yyyy-mm-dd hh24:mi:ss"
  "yyyymmddhh24miss"
  "yyyy-mm-dd"
  "yyyymmdd"
  "hh24:mi:ss"
  "hh24miss"
  "hh24:mi"
  "hh24mi"
  "hh24"
  "mi"
  注意：
    1）小时的表示方法是hh24，不是hh，这么做的目的是为了保持与数据库的时间表示方法一致；
    2）以上列出了常用的时间格式，如果不能满足你应用开发的需求，请修改源代码timetostr()函数增加更多的格式支持；
    3）调用函数的时候，如果fmt与上述格式都匹配，strtime的内容将为空。
    4）时间的年份是四位，其它的可能是一位和两位，如果不足两位，在前面补0。
*/
string& ltime(string &strtime,const string &fmt="",const int timetvl=0);
char *    ltime(char *strtime   ,const string &fmt="",const int timetvl=0);
// 为了避免重载的岐义，增加ltime1()函数。
string    ltime1(const string &fmt="",const int timetvl=0);



// 把整数表示的时间转换为字符串表示的时间。
// ttime：整数表示的时间。
// strtime：字符串表示的时间。
// fmt：输出字符串时间strtime的格式，与ltime()函数的fmt参数相同，如果fmt的格式不正确，strtime将为空。
string& timetostr(const time_t ttime,string &strtime,const string &fmt="");
char*     timetostr(const time_t ttime,char *strtime   ,const string &fmt="");
// 为了避免重载的岐义，增加timetostr1()函数。
string    timetostr1(const time_t ttime,const string &fmt="");

// 把字符串表示的时间转换为整数表示的时间。
// strtime：字符串表示的时间，格式不限，但一定要包括yyyymmddhh24miss，一个都不能少，顺序也不能变。
// 返回值：整数表示的时间，如果strtime的格式不正确，返回-1。
time_t strtotime(const string &strtime);


///////////////////////////////////// /////////////////////////////////////
```



```c
/*
 *  程序名：demo24.cpp，此程序演示开发框架中ltime时间函数的使用（获取操作系统时间）。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    // C风格的字符串。
    char strtime1[20];     // 存放系统时间。
    memset(strtime1,0,sizeof(strtime1));

    ltime(strtime1,"yyyy-mm-dd hh24:mi:ss");        // 获取当前时间。
    printf("strtime1=%s\n",strtime1);

    ltime(strtime1,"yyyy-mm-dd hh24:mi:ss",-30);  // 获取30秒前的时间。
    printf("strtime1=%s\n",strtime1);

    ltime(strtime1,"yyyy-mm-dd hh24:mi:ss",30);    // 获取30秒后的时间。
    printf("strtime1=%s\n",strtime1);

    // C++风格的字符串。
    string strtime2;

    ltime(strtime2,"yyyy-mm-dd hh24:mi:ss");        // 获取当前时间。
    cout << "strtime2=" << strtime2 << "\n";

    ltime(strtime2,"yyyy-mm-dd hh24:mi:ss",-30);  // 获取30秒前的时间。
    cout << "strtime2=" << strtime2 << "\n";

    ltime(strtime2,"yyyy-mm-dd hh24:mi:ss",30);    // 获取30秒后的时间。
    cout << "strtime2=" << strtime2 << "\n";
}


```

```cpp
// 把字符串表示的时间加上一个偏移的秒数后得到一个新的字符串表示的时间。
// in_stime：输入的字符串格式的时间，格式不限，但一定要包括yyyymmddhh24miss，一个都不能少，顺序也不能变。
// out_stime：输出的字符串格式的时间。
// timetvl：需要偏移的秒数，正数往后偏移，负数往前偏移。
// fmt：输出字符串时间out_stime的格式，与ltime()函数的fmt参数相同。
// 注意：in_stime和out_stime参数可以是同一个变量的地址，如果调用失败，out_stime的内容会清空。
// 返回值：true-成功，false-失败，如果返回失败，可以认为是in_stime的格式不正确。
bool addtime(const string &in_stime,char *out_stime    ,const int timetvl,const string &fmt="");
bool addtime(const string &in_stime,string &out_stime,const int timetvl,const string &fmt="");
```

```cpp
/*
 *  程序名：demo28.cpp，此程序演示开发框架中采用addtime函数进行时间的运算。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    char strtime[20];

    memset(strtime,0,sizeof(strtime));
    strcpy(strtime,"2020-01-20 12:35:22");

    char s1[20];         // C风格的字符串。
    addtime(strtime,s1,0-1*24*60*60);        // 减一天。
    printf("s1=%s\n",s1);                              // 输出s1=2020-01-19 12:35:22
  
    string s2;            // C++风格的字符串。
    addtime(strtime,s2,2*24*60*60);           // 加两天。  172800
    cout << "s2=" << s2 << endl;              // 输出s2=2020-01-22 12:35:22
}


```

```cpp
///////////////////////////////////// /////////////////////////////////////
// 这是一个精确到微秒的计时器。
class ctimer
{
private:
    struct timeval m_start;    // 计时开始的时间点。
    struct timeval m_end;     // 计时结束的时间点。
public:
    ctimer();          // 构造函数中会调用start方法。

    void start();     // 开始计时。

    // 计算已逝去的时间，单位：秒，小数点后面是微秒。
    // 每调用一次本方法之后，自动调用start方法重新开始计时。
    double elapsed();
};
///////////////////////////////////////////////////////////////////////////////////////////////////
```

```cpp
/*
 *  程序名：demo29.cpp，此程序演示开发框架中的ctimer类（计时器）的用法。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    ctimer timer;

    printf("elapsed=%lf\n",timer.elapsed());
    sleep(1);
    printf("elapsed=%lf\n",timer.elapsed());
    sleep(1);
    printf("elapsed=%lf\n",timer.elapsed());
    usleep(1000);
    printf("elapsed=%lf\n",timer.elapsed());
    usleep(100);
    printf("elapsed=%lf\n",timer.elapsed());
    sleep(10);
    printf("elapsed=%lf\n",timer.elapsed());
}


```

# 目录和文件操作

```cpp
// 根据绝对路径的文件名或目录名逐级的创建目录。
// pathorfilename：绝对路径的文件名或目录名。
// bisfilename：指定pathorfilename的类型，true-pathorfilename是文件名，否则是目录名，缺省值为true。
// 返回值：true-成功，false-失败，如果返回失败，原因有大概有三种情况：
// 1）权限不足；2）pathorfilename参数不是合法的文件名或目录名；3）磁盘空间不足。
bool newdir(const string &pathorfilename,bool bisfilename=true);

```

```cpp
/*
 *  程序名：demo30.cpp，此程序演示开发框架中采用newdir函数根据绝对路径的文件名或目录名逐级的创建目录。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    // /tmp/aaa/bbb/ccc/ddd    /tmp    /tmp/aaa    /tmp/aaa/bbb    /tmp/aaa/bbb/ccc   /tmp/aaa/bbb/ccc/ddd
    newdir("/tmp/aaa/bbb/ccc/ddd",false);   // 创建"/tmp/aaa/bbb/ccc/ddd"目录。

    newdir("/tmp/111/222/333/444/data.xml",true);   // 创建"/tmp/111/222/333/444"目录。
}


```

```cpp
// 重命名文件，类似Linux系统的mv命令。
// srcfilename：原文件名，建议采用绝对路径的文件名。
// dstfilename：目标文件名，建议采用绝对路径的文件名。
// 返回值：true-成功；false-失败，失败的主要原因是权限不足或磁盘空间不够，如果原文件和目标文件不在同一个磁盘分区，重命名也可能失败。
// 注意，在重命名文件之前，会自动创建dstfilename参数中包含的目录。
// 在应用开发中，可以用renamefile()函数代替rename()库函数。
bool renamefile(const string &srcfilename,const string &dstfilename);
```

```cpp
// 复制文件，类似Linux系统的cp命令。
// srcfilename：原文件名，建议采用绝对路径的文件名。
// dstfilename：目标文件名，建议采用绝对路径的文件名。
// 返回值：true-成功；false-失败，失败的主要原因是权限不足或磁盘空间不够。
// 注意：
// 1）在复制文件之前，会自动创建dstfilename参数中的目录名。
// 2）复制文件的过程中，采用临时文件命名的方法，复制完成后再改名为dstfilename，避免中间状态的文件被读取。
// 3）复制后的文件的时间与原文件相同，这一点与Linux系统cp命令不同。
bool copyfile(const string &srcfilename,const string &dstfilename);
```

```cpp
// 获取文件的大小。
// filename：待获取的文件名，建议采用绝对路径的文件名。
// 返回值：如果文件不存在或没有访问权限，返回-1，成功返回文件的大小，单位是字节。
int filesize(const string &filename);
```

```cpp
// 获取文件的时间。
// filename：待获取的文件名，建议采用绝对路径的文件名。
// mtime：用于存放文件的时间，即stat结构体的st_mtime。
// fmt：设置时间的输出格式，与ltime()函数相同，但缺省是"yyyymmddhh24miss"。
// 返回值：如果文件不存在或没有访问权限，返回false，成功返回true。
bool filemtime(const string &filename,char *mtime    ,const string &fmt="yyyymmddhh24miss");
bool filemtime(const string &filename,string &mtime,const string &fmt="yyyymmddhh24miss");

// 重置文件的修改时间属性。
// filename：待重置的文件名，建议采用绝对路径的文件名。
// mtime：字符串表示的时间，格式不限，但一定要包括yyyymmddhh24miss，一个都不能少，顺序也不能变。
// 返回值：true-成功；false-失败，失败的原因保存在errno中。
bool setmtime(const string &filename,const string &mtime);
```

```cpp
/*
 *  程序名：demo32.cpp，此程序演示开发框架的文件操作函数的用法
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    // 重命名文件。
    if (renamefile("/project/public/lib_public.so","/tmp/aaa/bbb/ccc/lib_public.so")==false)
    {
        printf("renamefile(/project/public/lib_public.so) %d:%s\n",errno,strerror(errno));
    }

    // 复制文件。
    if (copyfile("/project/public/libftp.a","/tmp/aaa/ddd/ccc/libftp.a")==false)
    {
        printf("copyfile(/project/public/libftp.a) %d:%s\n",errno,strerror(errno));
    }

    // 获取文件的大小。
    printf("size=%d\n",filesize("/project/public/_public.h"));

    // 重置文件的时间。
    setmtime("/project/public/_public.h","2020-01-05 13:37:29");

    // 获取文件的时间。
    string mtime;
    filemtime("/project/public/_public.h",mtime,"yyyy-mm-dd hh24:mi:ss");
    cout << "mtime=" << mtime << endl;   // 输出mtime=2020-01-05 13:37:29
    filemtime("/project/public/_public.h",mtime);
    cout << "mtime=" << mtime << endl;   // 输出mtime=20200105133729
}
```

```c
///////////////////////////////////// /////////////////////////////////////
// 获取某目录及其子目录中的文件列表的类。
class cdir
{
private:
    vector<string> m_filelist;  // 存放文件列表的容器（绝对路径的文件名）。
    int m_pos;                          // 从文件列表m_filelist中已读取文件的位置。
    string m_fmt;                     // 文件时间格式，缺省"yyyymmddhh24miss"。

    cdir(const cdir &) = delete;                      // 禁用拷贝构造函数。
    cdir &operator=(const cdir &) = delete;  // 禁用赋值函数。
public:
    // /project/public/_public.h
    string m_dirname;        // 目录名，例如：/project/public
    string m_filename;       // 文件名，不包括目录名，例如：_public.h
    string m_ffilename;      // 绝对路径的文件，例如：/project/public/_public.h
    int      m_filesize;          // 文件的大小，单位：字节。
    string m_mtime;           // 文件最后一次被修改的时间，即stat结构体的st_mtime成员。
    string m_ctime;            // 文件生成的时间，即stat结构体的st_ctime成员。
    string m_atime;            // 文件最后一次被访问的时间，即stat结构体的st_atime成员。

    cdir():m_pos(0),m_fmt("yyyymmddhh24miss") {}  // 构造函数。

    // 设置文件时间的格式，支持"yyyy-mm-dd hh24:mi:ss"和"yyyymmddhh24miss"两种，缺省是后者。
    void setfmt(const string &fmt);

    // 打开目录，获取目录中文件的列表，存放在m_filelist容器中。
    // dirname，目录名，采用绝对路径，如/tmp/root。
    // rules，文件名的匹配规则，不匹配的文件将被忽略。
    // maxfiles，本次获取文件的最大数量，缺省值为10000个，如果文件太多，可能消耗太多的内存。
    // bandchild，是否打开各级子目录，缺省值为false-不打开子目录。
    // bsort，是否按文件名排序，缺省值为false-不排序。
    // 返回值：true-成功，false-失败。
    bool opendir(const string &dirname,const string &rules,const int maxfiles=10000,const bool bandchild=false,bool bsort=false);

private:
    // 这是一个递归函数，被opendir()的调用，在cdir类的外部不需要调用它。
    bool _opendir(const string &dirname,const string &rules,const int maxfiles,const bool bandchild);

public:
    // 从m_filelist容器中获取一条记录（文件名），同时获取该文件的大小、修改时间等信息。
    // 调用opendir方法时，m_filelist容器被清空，m_pos归零，每调用一次readdir方法m_pos加1。
    // 当m_pos小于m_filelist.size()，返回true，否则返回false。
    bool readdir();

    unsigned int size() { return m_filelist.size(); }

    ~cdir();  // 析构函数。
};
///////////////////////////////////// /////////////////////////////////////
```

```cpp
/*
 *  程序名：demo34.cpp，此程序演示开发框架中采用cdir类获取某目录及其子目录中的文件列表信息。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main(int argc,char *argv[])
{
    if (argc != 3) 
    { 
        printf("Using:./demo34 pathname matchstr\n");
        printf("Sample:./demo34 /project \"*.h,*.cpp\"\n");
        return -1;
    }

    cdir dir;       // 创建读取目录的对象。

    if (dir.opendir(argv[1],argv[2],100,false,true)==false)             // 打开目录，获取目录中文件的列表。
    {   
        printf("dir.opendir(%s) failed.\n",argv[1]); return -1; 
    }

    while(dir.readdir()==true)        // 遍历文件列表。
    {
        cout << "filename=" << dir.m_ffilename << ",mtime=" << dir.m_mtime << ",size=" << dir.m_filesize << endl;
    }
}

```



# 写文件和读文件

C＋+提供了ofstream类，实现了文件的读和写。

不支持格式化输出。

还有其它的小细节需要处理。





向文件中写数据的步骤（初工的想法）

- 打开文件。
- 向文件中写入数据。
- 关闭文件。

![image-20240324143306576](10_项目开发框架.assets/image-20240324143306576.png)

文件操作没有锁机制，生成文件需要时间，如果在进程A生成文件的过程中，进程B就读到了文件，那么，进程B读到的内容可能是不完整的。



向文件中写数据的步骤-优化 （中工的做法）

- 打开临时文件。
- 向临时文件中写入数据。
- 关闭临时文件。
- 把临时文件名改名为正式的文件名。

```c
/*
 *  程序名：demo36.cpp，此程序演示开发框架中采用cofile类向文件中写入文本数据。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;  

int main()
{
    cofile ofile;      

    // 创建文件，实际创建的是临时文件，例如/tmp/data/girl.xml.tmp。
    if (ofile.open("/tmp/data/girl.xml")==false)
    {
        printf("ofile.open(/tmp/data/girl.xml) failed.\n"); return -1;
    }

    // 用<<输出到文件，与cout的用法相同。
    ofile << "<data>" << "\n";         // 换行只能用\n，不能用endl。

    // 格式化输出到文件。
    ofile.writeline("<name>%s</name><age>%d</age><sc>%s</sc><yz>%s</yz><memo>%s</memo><endl/>\n",\
                           "妲已",28,"火辣","漂亮","商要亡，关我什么事。");
    ofile.writeline("<name>%s</name><age>25</age><sc>火辣</sc><yz>漂亮</yz><memo>1、中国排名第一的美女；\n"\
         "2、男朋友是范蠡；\n"\
         "3、老公是夫差，被勾践弄死了。</memo><endl/>\n","西施");

    ofile << "</data>\n";                 // 换行只能用\n，不能用endl。

    // sleep(10);   // 用ls /tmp/data/*.tmp可以看到生成的临时文件。

    // 关闭文件，并把临时文件名改为正式的文件名。
    ofile.closeandrename();
}


```

```c
///////////////////////////////////////////////////////////////////////////////////////////////////
// 写文件的类。
class cofile  // class out file
{
private:
    ofstream fout;                  // 写入文件的对象。
    string   m_filename;         // 文件名，建议采用绝对路径。
    string   m_filenametmp;  // 临时文件名，在m_filename后面加".tmp"。
public:
    cofile() {}
    bool isopen() const { return fout.is_open(); }     // 文件是否已打开。

    // 打开文件。
    // filename，待打开的文件名。
    // btmp，是否采用临时文件的方案。
    // mode，打开文件的模式。
    // benbuffer，是否启用文件缓冲区。
     bool open(const string &filename,const bool btmp=true,const ios::openmode mode=ios::out,const bool benbuffer=true);

    // 把数据以文本的方式格式化输出到文件。
    template< typename... Args >
    bool writeline(const char* fmt, Args... args) 
    {
        if (fout.is_open()==false) return false;

        fout << sformat(fmt,args...);

        return fout.good();
    }

    // 重载<<运算符，把数据以文本的方式输出到文件。
    // 注意：换行只能用\n，不能用endl。
    template<typename T>
    cofile& operator<<(const T &value)
    {
        fout << value; return *this;
    }

    // 把二进制数据写入文件。
    bool write(void *buf,int bufsize);

    // 关闭文件，并且把临时文件名改为正式文件名。
    bool closeandrename();

    // 关闭文件，如果有临时文件，则删除它。
    void close();

    ~cofile() { close(); };
};
///////////////////////////////////////////////////////////////////////////////////////////////////
```

```cpp
/*
 *  程序名：demo37.cpp，此程序演示开发框架中采用cifile类从文本文件中读取数据。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    cifile ifile;

    // 打开文件。
    if (ifile.open("/tmp/data/girl.xml")==false)
    {
        printf("ofile.open(/tmp/data/girl.xml) failed.\n"); return -1;
    }

    string strline;   // 存放从文本文件中读取的一行。

    while (true)
    {
        // 从文件中读取一行。
        if (ifile.readline(strline,"<endl/>")==false) break;

        cout << "=" << strline << "=\n";
    }

    // ifile.closeandremove();     // 关闭并删除文件。
    ifile.close();                       // 关闭文件。
}
```

```cpp
///////////////////////////////////////////////////////////////////////////////////////////////////
// 读取文件的类。
class cifile    // class in file
{
private:
    ifstream fin;                     // 读取文件的对象。
    string   m_filename;         // 文件名，建议采用绝对路径。
public:
    cifile() {}

    // 判断文件是否已打开。
    bool isopen() const { return fin.is_open(); }

    // 打开文件。
    // filename，待打开的文件名。
    // mode，打开文件的模式。
    bool open(const string &filename,const ios::openmode mode=ios::in);

    // 以行的方式读取文本文件，endbz指定行的结尾标志，缺省为空，没有结尾标志。
    bool readline(string &buf,const string& endbz="");

    // 读取二进制文件，返回实际读取到的字节数。
    int read(void *buf,const int bufsize);

    // 关闭并删除文件。
    bool closeandremove();

    // 只关闭文件。
    void close();

    ~cifile() { close(); }
};
///////////////////////////////////////////////////////////////////////////////////////////////////
```

```c
/*
 *  程序名：demo38.cpp，此程序演示开发框架中采用cofile类向文件中写入二进制数据。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    cofile ofile;

    // 创建文件，实际创建的是临时文件，例如/tmp/data/girl.dat.tmp。
    if (ofile.open("/tmp/data/girl.dat",true,ios::binary)==false)
    {
        printf("ofile.open(/tmp/data/girl.dat) failed.\n"); return -1;
    }

    struct st_girl
    {
        int bh;
        char name[21];
    }girl;

    memset(&girl,0,sizeof(girl));
    girl.bh=8;
    strcpy(girl.name,"西施");
    ofile.write(&girl,sizeof(girl));

    // sleep(30);   // 用ls /tmp/data/*.tmp可以看到生成的临时文件。

    // 关闭文件，并把临时文件名改为正式的文件名。
    ofile.closeandrename();
}


```



# 日志文件操作

简单的小程序，把东西显示在屏幕上就可以了。

服务程序运行在后台，无人守值，不会在屏幕上显示东西。

日志文件的内容:程序运行的状态、处理数据的情况........



```c
/*
 *  程序名：demo42.cpp，此程序演示采用开发框架的clogfile类记录程序的运行日志。
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main()
{
    clogfile logfile;      // 创建日志对象。

    // 打开日志文件。
    if (logfile.open("/tmp/log/demo42.log",ios::out,false)==false)
    {
        printf("logfile.open(/tmp/log/demo42.log) failed.\n");  return -1;
    }

    logfile.write("程序开始运行。\n");

    for (int ii=0;ii<5000000;ii++)
    {
        logfile.write("这是第%d个%s...ok.\n",ii,"超级女生");
        //logfile.write("第%d个超女开始表演...",ii);     // 表演前，写一行日志，...表示正在表演中。
        //sleep(2);                                                          // 超女在表演中。
        //logfile << "ok.\n";                                          // 表演完成后，写入ok。
    }

    logfile.write("程序运行结束。\n");
}
```

```cpp
///////////////////////////////////// /////////////////////////////////////
// 日志文件。
class clogfile
{
    ofstream fout;                       // 日志文件对象。
    string   m_filename;              // 日志文件名，建议采用绝对路径。
    ios::openmode m_mode;      // 日志文件的打开模式。
    bool     m_backup;                // 是否自动切换日志。
    int        m_maxsize;               // 当日志文件的大小超过本参数时，自动切换日志。
    bool     m_enbuffer;              // 是否启用文件缓冲区。
    spinlock_mutex m_splock;    // 自旋锁，用于多线程程序中给写日志的操作加锁。

public:
    // 构造函数，日志文件的大小缺省100M。
    clogfile(int maxsize=100):m_maxsize(maxsize){}

    // 打开日志文件。
    // filename：日志文件名，建议采用绝对路径，如果文件名中的目录不存在，就先创建目录。
    // openmode：日志文件的打开模式，缺省值是ios::app。
    // bbackup：是否自动切换（备份），true-切换，false-不切换，在多进程的服务程序中，如果多个进程共用一个日志文件，bbackup必须为false。
    // benbuffer：是否启用文件缓冲机制，true-启用，false-不启用，如果启用缓冲区，那么写进日志文件中的内容不会立即写入文件，缺省是不启用。
    // 注意，在多进程的程序中，多个进程往同一日志文件写入大量的日志时，可能会出现小混乱，但是，多线程不会。
    // 1）多个进程往同一日志文件写入大量的日志时，可能会出现小混乱，这个问题并不严重，可以容忍；
    // 2）只有同时写大量日志时才会出现混乱，在实际开发中，这种情况不多见。
    // 3）如果业务无法容忍，可以用信号量加锁。
    bool open(const string &filename,const ios::openmode mode=ios::app,const bool bbackup=true,const bool benbuffer=false);

    // 把日志内容以文本的方式格式化输出到日志文件，并且，在日志内容前面写入时间。
    template< typename... Args >
    bool write(const char* fmt, Args... args) 
    {
        if (fout.is_open()==false) return false;

        backup();                   // 判断是否需要切换日志文件。

        m_splock.lock();        // 加锁。
        fout << ltime1() << " " << sformat(fmt,args...);      // 把当前时间和日志内容写入日志文件。
        m_splock.unlock();    // 解锁。

        return fout.good();
    }

    // 重载<<运算符，把日志内容以文本的方式输出到日志文件，不会在日志内容前面写时间。
    // 注意：内容换行用\n，不能用endl。
    template<typename T>
    clogfile& operator<<(const T &value)
    {
        m_splock.lock();
        fout << value; 
        m_splock.unlock();

        return *this;
    }
  
private:
    // 如果日志文件的大小超过m_maxsize的值，就把当前的日志文件名改为历史日志文件名，再创建新的当前日志文件。
    // 备份后的文件会在日志文件名后加上日期时间，如/tmp/log/filetodb.log.20200101123025。
    // 注意，在多进程的程序中，日志文件不可切换，多线的程序中，日志文件可以切换。
    bool backup();
public:
    void close() { fout.close(); }

    ~clogfile() { close(); };
};
///////////////////////////////////////////////////////////////////////////////////////////////////
```



# 网络通信

```cpp
/*
 *  程序名：demo44.cpp，此程序演示采用开发框架的ctcpclient类传输文本数据（网络通讯的客户端） 
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main(int argc,char *argv[])
{
    if (argc!=3)
    {
        printf("Using:./demo44 ip port\n");
        printf("Sample:./demo44 192.168.150.128 5005\n");
        return -1;
    }

    ctcpclient tcpclient;
    if (tcpclient.connect(argv[1],atoi(argv[2]))==false)     // 向服务端发起连接请求。
    {
        printf("tcpclient.connect(%s,%s) failed.\n",argv[1],argv[2]); return -1;
    }

    string sendbuf,recvbuf;

    for (int ii=0;ii<10;ii++)
    {
        sendbuf=sformat("这是第%d个超级女生。",ii);

        if (tcpclient.write(sendbuf)==false)        // 向服务端发送请求报文。
        {
            printf("tcpclient.write() failed.\n"); break;
        }
        cout << "发送：" << sendbuf << endl;

        sleep(1);

        if (tcpclient.read(recvbuf)==false)         // 接收服务端的回应报文。
        {
            printf("tcpclient.read() failed.\n"); break;
        }
        cout << "接收：" << recvbuf << endl;
    }
}
```

```cpp
/*
 *  程序名：demo45.cpp，此程序演示采用开发框架的ctcpserver类传输文本数据。（网络通讯的服务端） 
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main(int argc,char *argv[])
{
    if (argc!=2)
    {
        printf("Using:./demo45 port\n");
        printf("Sample:./demo45 5005\n");
        return -1;
    }

    ctcpserver tcpserver;
    if (tcpserver.initserver(atoi(argv[1]))==false)        // 服务端初始化。
    {
        printf("tcpserver.initserver(%s) failed.\n",argv[1]); return -1;
    }

    if (tcpserver.accept()==false)                                // 等待客户端的连接。
    {
        printf("accept() failed.\n"); return -1;
    }
    cout << "客户端已连接(" << tcpserver.getip() << ")。\n";

    string sendbuf,recvbuf;

    while (true)
    {
        if (tcpserver.read(recvbuf)==false)          // 接收客户端的请求报文。
        {
            printf("tcpserver.read() failed.\n"); break;
        }
        cout << "接收：" << recvbuf << endl;

        sendbuf="ok";
        if (tcpserver.write(sendbuf)==false)        // 向客户端发送回应报文。
        {
            printf("tcpserver.write() failed.\n"); break;
        }
        cout << "发送：" << sendbuf << endl;
    }
}
```

```cpp
/*
 *  程序名：demo46.cpp，此程序演示采用开发框架的ctcpclient类传输二进制数据（网络通讯的客户端） 
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main(int argc,char *argv[])
{
    if (argc!=3)
    {
        printf("Using:./demo46 ip port\n");
        printf("Sample./demo46 192.168.150.128 5005\n");
        return -1;
    }

    ctcpclient tcpclient;
    if (tcpclient.connect(argv[1],atoi(argv[2]))==false)     // 向服务端发起连接请求。
    {
        printf("tcpclient.connect(%s,%s) failed.\n",argv[1],argv[2]); return -1;
    }

    struct st_girl   // 超女结构体。
    {
        int bh;
        char name[31];
    }stgirl;

    string recvbuf;

    for (int ii=0;ii<10;ii++)
    {
        memset(&stgirl,0,sizeof(stgirl));
        stgirl.bh=ii;
        sprintf(stgirl.name,"西施%d",ii);

        if (tcpclient.write(&stgirl,sizeof(stgirl))==false)        // 向服务端发送请求数据。
        {
            printf("tcpclient.write() failed.\n"); break;
        }
        cout << sformat("发送：bh=%d,name=%s\n",stgirl.bh,stgirl.name);

        sleep(1);

        if (tcpclient.read(recvbuf)==false)         // 接收服务端的回应报文。
        {
            printf("tcpclient.read() failed.\n"); break;
        }
        cout << "接收：" << recvbuf << endl;
    }
}
```

```cpp
/*
 *  程序名：demo47.cpp，此程序演示采用开发框架的ctcpserver类传输二进制数据。（网络通讯的服务端）
 *  作者：吴从周
*/
#include "../_public.h"
using namespace std;
using namespace idc;

int main(int argc,char *argv[])
{
    if (argc!=2)
    {
        printf("Using:./demo47 port\n");
        printf("Sample:./demo47 5005\n");
        return -1;
    }

    ctcpserver tcpserver;
    if (tcpserver.initserver(atoi(argv[1]))==false)        // 服务端初始化。
    {
        printf("tcpserver.initserver(%s) failed.\n",argv[1]); return -1;
    }

    if (tcpserver.accept()==false)                                // 等待客户端的连接。
    {
        printf("accept() failed.\n"); return -1;
    }
    cout << "客户端已连接(" << tcpserver.getip() << ")。\n";

    struct st_girl
    {
        int bh;
        char name[31];
    }stgirl;

    string sendbuf;

    while (true)
    {
        if (tcpserver.read(&stgirl,sizeof(stgirl))==false)          // 接收客户端的请求数据。
        {
            printf("tcpserver.read() failed.\n"); break;
        }
        cout << sformat("接收：bh=%d,name=%s\n",stgirl.bh,stgirl.name);

        sendbuf="ok";
        if (tcpserver.write("ok")==false)        // 向客户端发送回应报文。
        {
            printf("tcpserver.write() failed.\n"); break;
        }
        cout << "发送：" << sendbuf << endl;
    }
}
```

```cpp
///////////////////////////////////////////////////////////////////////////////////////////////////
// 以下是socket通讯的函数和类

// socket通讯的客户端类
class ctcpclient
{
private:
    int  m_connfd;    // 客户端的socket.
    string m_ip;        // 服务端的ip地址。
    int  m_port;        // 服务端通讯的端口。
public:
    ctcpclient(): m_connfd(-1),m_port(0) { }  // 构造函数。

    // 向服务端发起连接请求。
    // ip：服务端的ip地址。
    // port：服务端通讯的端口。
    // 返回值：true-成功；false-失败。
    bool connect(const string &ip,const int port);

    // 接收对端发送过来的数据。
    // buffer：存放接收数据缓冲区。
    // ibuflen: 打算接收数据的大小。
    // itimeout：等待数据的超时时间（秒）：-1-不等待；0-无限等待；>0-等待的秒数。
    // 返回值：true-成功；false-失败，失败有两种情况：1）等待超时；2）socket连接已不可用。
    bool read(string &buffer,const int itimeout=0);                           // 接收文本数据。
    bool read(void *buffer,const int ibuflen,const int itimeout=0);   // 接收二进制数据。

    // 向对端发送数据。
    // buffer：待发送数据缓冲区。
    // ibuflen：待发送数据的大小。
    // 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。
    bool write(const string &buffer);                          // 发送文本数据。
    bool write(const void *buffer,const int ibuflen);   // 发送二进制数据。

    // 断开与服务端的连接
    void close();

    ~ctcpclient();  // 析构函数自动关闭socket，释放资源。
};

// socket通讯的服务端类
class ctcpserver
{
private:
    int m_socklen;                                // 结构体struct sockaddr_in的大小。
    struct sockaddr_in m_clientaddr;   // 客户端的地址信息。
    struct sockaddr_in m_servaddr;     // 服务端的地址信息。
    int  m_listenfd;                               // 服务端用于监听的socket。
    int  m_connfd;                                // 客户端连接上来的socket。
public:
    ctcpserver():m_listenfd(-1),m_connfd(-1) {}  // 构造函数。

    // 服务端初始化。
    // port：指定服务端用于监听的端口。
    // 返回值：true-成功；false-失败，一般情况下，只要port设置正确，没有被占用，初始化都会成功。
    bool initserver(const unsigned int port,const int backlog=5); 

    // 从已连接队列中获取一个客户端连接，如果已连接队列为空，将阻塞等待。
    // 返回值：true-成功的获取了一个客户端连接，false-失败，如果accept失败，可以重新accept。
    bool accept();

    // 获取客户端的ip地址。
    // 返回值：客户端的ip地址，如"192.168.1.100"。
    char *getip();

    // 接收对端发送过来的数据。
    // buffer：存放接收数据的缓冲区。
    // ibuflen: 打算接收数据的大小。
    // itimeout：等待数据的超时时间（秒）：-1-不等待；0-无限等待；>0-等待的秒数。
    // 返回值：true-成功；false-失败，失败有两种情况：1）等待超时；2）socket连接已不可用。
    bool read(string &buffer,const int itimeout=0);                           // 接收文本数据。
    bool read(void *buffer,const int ibuflen,const int itimeout=0);   // 接收二进制数据。

    // 向对端发送数据。
    // buffer：待发送数据缓冲区。
    // ibuflen：待发送数据的大小。
    // 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。
    bool write(const string &buffer);                          // 发送文本数据。
    bool write(const void *buffer,const int ibuflen);   // 发送二进制数据。

    // 关闭监听的socket，即m_listenfd，常用于多进程服务程序的子进程代码中。
    void closelisten();

    // 关闭客户端的socket，即m_connfd，常用于多进程服务程序的父进程代码中。
    void closeclient();

    ~ctcpserver();  // 析构函数自动关闭socket，释放资源。
};

// 接收socket的对端发送过来的数据。
// sockfd：可用的socket连接。
// buffer：接收数据缓冲区的地址。
// ibuflen：本次成功接收数据的字节数。
// itimeout：读取数据超时的时间，单位：秒，-1-不等待；0-无限等待；>0-等待的秒数。
// 返回值：true-成功；false-失败，失败有两种情况：1）等待超时；2）socket连接已不可用。
bool tcpread(const int sockfd,string &buffer,const int itimeout=0);                            // 读取文本数据。
bool tcpread(const int sockfd,void *buffer,const int ibuflen,const int itimeout=0);     // 读取二进制数据。

// 向socket的对端发送数据。
// sockfd：可用的socket连接。
// buffer：待发送数据缓冲区的地址。
// ibuflen：待发送数据的字节数。
// 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。
bool tcpwrite(const int sockfd,const string &buffer);                             // 写入文本数据。
bool tcpwrite(const int sockfd,const void *buffer,const int ibuflen);      // 写入二进制数据。

// 从已经准备好的socket中读取数据。
// sockfd：已经准备好的socket连接。
// buffer：存放数据的地址。
// n：本次打算读取数据的字节数。
// 返回值：成功接收到n字节的数据后返回true，socket连接不可用返回false。
bool readn(const int sockfd,char *buffer,const size_t n);

// 向已经准备好的socket中写入数据。
// sockfd：已经准备好的socket连接。
// buffer：待写入数据的地址。
// n：待写入数据的字节数。
// 返回值：成功写入完n字节的数据后返回true，socket连接不可用返回false。
bool writen(const int sockfd,const char *buffer,const size_t n);

// 以上是socket通讯的函数和类
///////////////////////////////////// /////////////////////////////////////
```

tcp的发送和接收

- 发送:把数据放入tcp的发送缓冲区。

- 接收:从tcp的接收缓冲区中取数据。



分包和粘包



分包: tcp报文的大小缺省是1460字节，如果发送缓冲区中的数据超过1460字节，tcp将拆分成多个包发送，如果接收方及时的从接收缓冲区中取走了数据，看上去像就接收到了多个报文。



粘包: tcp接收到数据之后，有序放在接收缓冲区中，数据之间不存在分隔符的说法，如果接收方没有及时的从缓冲区中取走数据看上去就象粘在了一起。



如何区分报文

报文长度(4字节的整数）+报文内容



发送报文的方法

- 先发送报文长度，再发送报文内容。
- 例如:Hello world，先发送11，再发送Hello world。



该封装的`tcpwrite()` `tcpread()` 可以解决分包和粘包的问题。



send函数

- send函数的功能是把待发送的数据拷贝到发送缓冲区。
- 返回值是已拷贝的字节数，正常情况下，与待发送数据的字节数相同。
- 如果发送缓冲区的空间不足，则返回本次已拷贝的字节数。

- 为了保证全部的数据被发送，应该循环调用send函数，直到全部的数据被发送完成。

# 学习要求

- 用demo程序测试开发框架中函数和类的功能，掌握使用方法。
- 除了matchstr函数，把其它函数和类的代码写出来。
- 如果有些写不出来，不要强求。

![image-20240324145658342](10_项目开发框架.assets/image-20240324145658342-17112634198342.png)



