# 菜单

## 菜单命令响应函数

这里我们先需学习，如何新增菜单项，并且该菜单项被点击的事件进行处理。



首先，通过点击菜单资源，可以进行配置菜单的菜单项。我们新增一个菜单项为Test,指定他的ID为`IDM_TEST`



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401212850973-17119781324801.png)

然后，在`MainFrm.h` 中添加消息处理函数`onTest()`的声明。

并在`MainFrm.cpp` 添加其实现逻辑，这里是去进行弹窗。

接着，把`OnTest()` 函数和`ON_COMMAND`消息进行一个消息绑定。

```c{42}

// MainFrm.h: CMainFrame 类的接口
//

#pragma once

class CMainFrame : public CFrameWnd
{
	
protected: // 仅从序列化创建
	CMainFrame() noexcept;
	DECLARE_DYNCREATE(CMainFrame)

// 特性
public:

// 操作
public:

// 重写
public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// 实现
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // 控件条嵌入成员
	CToolBar          m_wndToolBar;
	CStatusBar        m_wndStatusBar;

// 生成的消息映射函数
protected:
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	DECLARE_MESSAGE_MAP()

public:
	//1、声明一个消息处理函数，afx_msg 代表他是一个消息处理函数。
	afx_msg void OnTest();
private:
	CBitmap m_bitmap;
public:
	afx_msg void OnUpdateEditCut(CCmdUI *pCmdUI);
	afx_msg void OnUpdateFileNew(CCmdUI *pCmdUI);
	afx_msg void OnShow();
};



```

```c{21,123,124,125,126}

// MainFrm.cpp: CMainFrame 类的实现
//

#include "stdafx.h"
#include "Menu.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#include "Resource.h"
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	ON_WM_CREATE()
//2、消息处理函数和要处理的消息进行消息映射	
ON_COMMAND(IDM_TEST, &CMainFrame::OnTest)
ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, &CMainFrame::OnUpdateEditCut)
ON_UPDATE_COMMAND_UI(ID_FILE_NEW, &CMainFrame::OnUpdateFileNew)
//ON_COMMAND(IDM_SHOW, &CMainFrame::OnShow)
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // 状态行指示器
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

// CMainFrame 构造/析构

CMainFrame::CMainFrame() noexcept
{
	//m_bAutoMenuEnable = FALSE;
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	/*
	//GetMenu()->GetSubMenu(0)->CheckMenuItem(0, MF_BYPOSITION | MF_CHECKED);
	GetMenu()->GetSubMenu(0)->CheckMenuItem(ID_FILE_NEW, MF_BYCOMMAND | MF_CHECKED);
	GetMenu()->GetSubMenu(0)->SetDefaultItem(1, TRUE);
	GetMenu()->GetSubMenu(0)->SetDefaultItem(5, TRUE);

	CString str;
	str.Format(L"x=%d, y=%d", GetSystemMetrics(SM_CXMENUCHECK), GetSystemMetrics(SM_CYMENUCHECK));
	MessageBox(str);

	m_bitmap.LoadBitmap(IDB_BITMAP1);
	GetMenu()->GetSubMenu(0)->SetMenuItemBitmaps(0, MF_BYPOSITION, &m_bitmap, &m_bitmap);
	*/

	GetMenu()->GetSubMenu(0)->EnableMenuItem(1, MF_BYPOSITION | MF_DISABLED);
	SetMenu(NULL);
	CMenu menu;
	menu.LoadMenu(IDR_MAINFRAME);
	SetMenu(&menu);
	menu.Detach();

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	// TODO: 在此处通过修改
	//  CREATESTRUCT cs 来修改窗口类或样式

	return TRUE;
}

// CMainFrame 诊断

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}
#endif //_DEBUG


// CMainFrame 消息处理程序


//3、由我们对这个菜单项被点击的消息，来写处理逻辑，这里是弹窗。
void CMainFrame::OnTest()
{
	MessageBox(L"MainFrame Clicked");
}


void CMainFrame::OnUpdateEditCut(CCmdUI *pCmdUI)
{
	if (2 == pCmdUI->m_nIndex)
		pCmdUI->Enable();
}


void CMainFrame::OnUpdateFileNew(CCmdUI *pCmdUI)
{
	if (ID_FILE_NEW == pCmdUI->m_nID)
		pCmdUI->Enable(FALSE);

}


void CMainFrame::OnShow()
{
	MessageBox(L"Main show");
}

```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401214739296-17119792609001.png)



可以看到，当我们点击了Test菜单项时，成功触发了我们的处理逻辑，弹框。





## 菜单命令的路由

### 程序类对菜单命令的响应顺序

如果一个菜单项被点击的消息处理函数，被写在多个程序类中，比如说主框架类`CMainFrame`  视图类 `CMenuView ` 文档类 `CMenuDoc` 。理论上，他们都会处理这个Test菜单项，被点击的消息，那么三者之间，必然存在一个优先级。即响应顺序，下面我们实验一下，他们之间的优先级（响应顺序） 是什么样的。

```c{44}

// MenuView.h: CMenuView 类的接口
//

#pragma once


class CMenuView : public CView
{
protected: // 仅从序列化创建
	CMenuView() noexcept;
	DECLARE_DYNCREATE(CMenuView)

// 特性
public:
	CMenuDoc* GetDocument() const;

// 操作
public:

// 重写
public:
	virtual void OnDraw(CDC* pDC);  // 重写以绘制该视图
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

// 实现
public:
	virtual ~CMenuView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// 生成的消息映射函数
protected:
	DECLARE_MESSAGE_MAP()
public:
	//1、视图类同样添加消息处理函数 OnTest() 方法
	afx_msg void OnTest();
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
//	afx_msg void OnShow();
};

#ifndef _DEBUG  // MenuView.cpp 中的调试版本
inline CMenuDoc* CMenuView::GetDocument() const
   { return reinterpret_cast<CMenuDoc*>(m_pDocument); }
#endif


```

```c{29,109,110,111,112,113}

// MenuView.cpp: CMenuView 类的实现
//

#include "stdafx.h"
// SHARED_HANDLERS 可以在实现预览、缩略图和搜索筛选器句柄的
// ATL 项目中进行定义，并允许与该项目共享文档代码。
#ifndef SHARED_HANDLERS
#include "Menu.h"
#endif

#include "MenuDoc.h"
#include "MenuView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CMenuView

IMPLEMENT_DYNCREATE(CMenuView, CView)

BEGIN_MESSAGE_MAP(CMenuView, CView)
	// 标准打印命令
	ON_COMMAND(ID_FILE_PRINT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, &CView::OnFilePrintPreview)
	//2、让视图类也处理IDM_TEST菜单项被点击的事件
	ON_COMMAND(IDM_TEST, &CMenuView::OnTest)
	ON_WM_RBUTTONDOWN()
//	ON_COMMAND(IDM_SHOW, &CMenuView::OnShow)
END_MESSAGE_MAP()

// CMenuView 构造/析构

CMenuView::CMenuView() noexcept
{
	// TODO: 在此处添加构造代码

}

CMenuView::~CMenuView()
{
}

BOOL CMenuView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: 在此处通过修改
	//  CREATESTRUCT cs 来修改窗口类或样式

	return CView::PreCreateWindow(cs);
}

// CMenuView 绘图

void CMenuView::OnDraw(CDC* /*pDC*/)
{
	CMenuDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	if (!pDoc)
		return;

	// TODO: 在此处为本机数据添加绘制代码
}


// CMenuView 打印

BOOL CMenuView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// 默认准备
	return DoPreparePrinting(pInfo);
}

void CMenuView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: 添加额外的打印前进行的初始化过程
}

void CMenuView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: 添加打印后进行的清理过程
}


// CMenuView 诊断

#ifdef _DEBUG
void CMenuView::AssertValid() const
{
	CView::AssertValid();
}

void CMenuView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CMenuDoc* CMenuView::GetDocument() const // 非调试版本是内联的
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMenuDoc)));
	return (CMenuDoc*)m_pDocument;
}
#endif //_DEBUG


// CMenuView 消息处理程序
//3、处理的逻辑为 弹窗一句话  View show
void CMenuView::OnTest()
{
	// TODO: 在此添加命令处理程序代码
	MessageBox(L"View show");
}


void CMenuView::OnRButtonDown(UINT nFlags, CPoint point)
{
	CMenu menu;
	menu.LoadMenu(IDR_MENU1);
	CMenu* pPopup = menu.GetSubMenu(0);

	ClientToScreen(&point);

	//pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
	pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, GetParent());

	CView::OnRButtonDown(nFlags, point);


	CView::OnRButtonDown(nFlags, point);
}


//void CMenuView::OnShow()
//{
//	MessageBox(L"View show");
//}

```

```c{49}

// MenuDoc.h: CMenuDoc 类的接口
//


#pragma once


class CMenuDoc : public CDocument
{
protected: // 仅从序列化创建
	CMenuDoc() noexcept;
	DECLARE_DYNCREATE(CMenuDoc)

// 特性
public:

// 操作
public:

// 重写
public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
#ifdef SHARED_HANDLERS
	virtual void InitializeSearchContent();
	virtual void OnDrawThumbnail(CDC& dc, LPRECT lprcBounds);
#endif // SHARED_HANDLERS

// 实现
public:
	virtual ~CMenuDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// 生成的消息映射函数
protected:
	DECLARE_MESSAGE_MAP()

#ifdef SHARED_HANDLERS
	// 用于为搜索处理程序设置搜索内容的 Helper 函数
	void SetSearchContent(const CString& value);
#endif // SHARED_HANDLERS
public:
	//1、新增CMenuDoc 的消息处理函数 OnTest
  afx_msg void OnTest();
};

```

```c{142-147,25}

// MenuDoc.cpp: CMenuDoc 类的实现
//

#include "stdafx.h"
// SHARED_HANDLERS 可以在实现预览、缩略图和搜索筛选器句柄的
// ATL 项目中进行定义，并允许与该项目共享文档代码。
#ifndef SHARED_HANDLERS
#include "Menu.h"
#endif

#include "MenuDoc.h"

#include <propkey.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

// CMenuDoc

IMPLEMENT_DYNCREATE(CMenuDoc, CDocument)

BEGIN_MESSAGE_MAP(CMenuDoc, CDocument)
	//2、为消息处理函数绑定消息为 IDM_TEST 菜单命令被点击的消息
ON_COMMAND(IDM_TEST, &CMenuDoc::OnTest)
END_MESSAGE_MAP()


// CMenuDoc 构造/析构

CMenuDoc::CMenuDoc() noexcept
{
	// TODO: 在此添加一次性构造代码

}

CMenuDoc::~CMenuDoc()
{
}

BOOL CMenuDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: 在此添加重新初始化代码
	// (SDI 文档将重用该文档)

	return TRUE;
}




// CMenuDoc 序列化

void CMenuDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: 在此添加存储代码
	}
	else
	{
		// TODO: 在此添加加载代码
	}
}

#ifdef SHARED_HANDLERS

// 缩略图的支持
void CMenuDoc::OnDrawThumbnail(CDC& dc, LPRECT lprcBounds)
{
	// 修改此代码以绘制文档数据
	dc.FillSolidRect(lprcBounds, RGB(255, 255, 255));

	CString strText = _T("TODO: implement thumbnail drawing here");
	LOGFONT lf;

	CFont* pDefaultGUIFont = CFont::FromHandle((HFONT) GetStockObject(DEFAULT_GUI_FONT));
	pDefaultGUIFont->GetLogFont(&lf);
	lf.lfHeight = 36;

	CFont fontDraw;
	fontDraw.CreateFontIndirect(&lf);

	CFont* pOldFont = dc.SelectObject(&fontDraw);
	dc.DrawText(strText, lprcBounds, DT_CENTER | DT_WORDBREAK);
	dc.SelectObject(pOldFont);
}

// 搜索处理程序的支持
void CMenuDoc::InitializeSearchContent()
{
	CString strSearchContent;
	// 从文档数据设置搜索内容。
	// 内容部分应由“;”分隔

	// 例如:     strSearchContent = _T("point;rectangle;circle;ole object;")；
	SetSearchContent(strSearchContent);
}

void CMenuDoc::SetSearchContent(const CString& value)
{
	if (value.IsEmpty())
	{
		RemoveChunk(PKEY_Search_Contents.fmtid, PKEY_Search_Contents.pid);
	}
	else
	{
		CMFCFilterChunkValueImpl *pChunk = nullptr;
		ATLTRY(pChunk = new CMFCFilterChunkValueImpl);
		if (pChunk != nullptr)
		{
			pChunk->SetTextValue(PKEY_Search_Contents, value, CHUNK_TEXT);
			SetChunkValue(pChunk);
		}
	}
}

#endif // SHARED_HANDLERS

// CMenuDoc 诊断

#ifdef _DEBUG
void CMenuDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CMenuDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG


// CMenuDoc 命令


//3、实现OnTest消息的处理逻辑，当菜单项IDM_TEST 被点击时触发响应。
void CMenuDoc::OnTest()
{
	AfxMessageBox(L"Doc Clicked!");
}

```

如果三者都有处理，则只执行视图类的消息处理逻辑。

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401220822716-17119805039912.png)

如果视图类没有写处理逻辑，则只剩下文档类和框架类。则最终运行文档类的消息处理逻辑。





![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401220945735-17119805873723.png)

根据上述试验，可以得知，响应【Test】菜单项命令的顺序依次是:视类、文档类、框架类，最后才是应用程序类。





![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401222157273.png)



- 如果是命令消息，它就会交由OnCommand这个函数来处理，在这个函数将完成命令消息的路由;

- 如果是通告消息，那么它将交由OnNotify这个函数来处理，该丙数将完成通告消息的路由。

- 二者最后都会调用OnCmdMsg 函数。





 **总结**

下面，我们以Menu这个程序为例，来看看菜单命令消息路由的具体过程:当点击某个菜单项时，最先接收到这个菜单命令消息的是框架类。框架类将把接收到的这个消息交给它的子窗口，即视类，由视类首先进行处理。视类首先根据命令消息映射机制查找自身是否对此消息进行了响应，如果响应了，就调用相应响应函数对这个消息进行处理，消息路由过程结束;如果视类没有对此命令消息做出响应，就交由文档类，文档类同样查找自身是否对这个菜单命令进行了响应，如果响应了，就由文档类的命令消息响应函数进行处理，路由过程结束。如果文档类也未做出响应，就把这个命令消息交还给视类，后者又把该消息交还给框架类。框架类查看自己是否对这个命令消息进行了响应，如果它也没有做出响应，就把这个菜单命令消息交给应用程序类，由后者来进行处理。这就是菜单命令的路由过程。

### Windows消息的分类

- 标准消息

除`WM_COMMAND`之外，所有以WM_开头的消息都是标准消息。从CWnd派生的类，都可以接收到这类消息。

- 命令消息

来自菜单、加速键或工具栏按钮的消息。这类消息都以WM_COMMAND形式呈现。在MFC中，通过菜单项的标识(ID）来区分不同的命令消息:在SDK中，通过消息的wParam参数识别。从 CCmdTarget派生的类，都可以接收到这类消息。

- 通告消息



### 基本菜单操作

菜单可以和房间楼层进行类比。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401222536695-17119815380694.png)

房间也可以通过位置索引来访问，例如三楼第一个房间。同样，对于菜单来说，如果要访问某个菜单项，既可以通过该菜单项的标识ID，也可以通过其位置索引来实现访问。



但对于子菜单来说，只能通过索引号进行访问，因为子菜单是没有标识号的。





#### 标记菜单

带有一个对号(√)(如下图所示)，我们称这种类型的菜单为标记菜单。



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401222613475-17119815746795.png)

```c{25-33}
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
	
	//获取到框架类 指向菜单栏A的指针
	CMenu* menuA =  GetMenu();
	//获取菜单栏A的第一个子菜单B
	CMenu* menuB = menuA->GetSubMenu(0);

	//设置 第0号索引位置的菜单项为 标记菜单
	menuB->CheckMenuItem(0, MF_BYPOSITION | MF_CHECKED);
	//设置 菜单项ID为ID_FILE_OPEN为标记菜单 
	menuB->CheckMenuItem(ID_FILE_OPEN, MF_BYCOMMAND|MF_CHECKED);


	return 0;
}

```



![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401223939400-17119823816916.png)

#### 默认菜单项

有些应用程序的子菜单下有一个菜单项是以粗体形式显示的，以这种形式显示的就是该子菜单的默认菜单项。

```c{34}
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("未能创建工具栏\n");
		return -1;      // 未能创建
	}

	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("未能创建状态栏\n");
		return -1;      // 未能创建
	}
	m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

	// TODO: 如果不需要可停靠工具栏，则删除这三行
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
	
	
	//设置默认菜单项，黑体加粗显示。
	//1、分割线也会占用菜单项索引
	//2、不支持设置多个默认菜单项，默认菜单项有且只有一个。取代码最后一次SetDefaultItem的时候指定的菜单项
	GetMenu()->GetSubMenu(0)->SetDefaultItem(1,TRUE);
	GetMenu()->GetSubMenu(0)->SetDefaultItem(5, TRUE);


	return 0;
}
```

![](https://blogwnx-bucket.oss-cn-beijing.aliyuncs.com/img/image-20240401224802914.png)
